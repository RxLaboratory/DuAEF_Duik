/**
 * Duik Rigging Tools
 * @author Nicolas Dufresne, Kevin Masson and contributors
 * @copyright 2017,2018 Nicolas Dufresne, Rainbox Productions<br />
 * {@link https://rainboxprod.coop}
 * @namespace
 * @memberof DuAEF.Duik
 * @license GPL-3.0 <br />
 * DuAEF is free software: you can redistribute it and/or modify<br />
 * it under the terms of the GNU General Public License as published by<br />
 * the Free Software Foundation, either version 3 of the License, or<br />
 * (at your option) any later version.<br />
 *<br />
 * DuAEF is distributed in the hope that it will be useful,<br />
 * but WITHOUT ANY WARRANTY; without even the implied warranty of<br />
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<br />
 * GNU General Public License for more details.<br />
 *<br />
 * You should have received a copy of the GNU General Public License<br />
 * along with DuAEF. If not, see {@link http://www.gnu.org/licenses/}.
 */
DuAEF.Duik.Rigging = {};

/**
 * Chain Rig types
 * @enum {int}
 * @readonly
 */
DuAEF.Duik.Rigging.chainTypes = {
    IK: 0,
    FK: 1,
    BEZIER: 2
}

/**
 * Separates the dimensions of the properties into an effect.<br />
 * Works with 2D, 3D, and colors
 * @param {Property|PropertyInfo} prop - The property
 */
DuAEF.Duik.Rigging.separateDimensions = function( prop )
{
    var propInfo = new PropertyInfo( prop );
    prop = propInfo.getProperty();

    var layer = propInfo.layer;
    var dim = propInfo.dimensions;

    if ( dim < 2 || dim > 4 ) return;

    if ( dim == 2 )
    {
        var pseudo;
        if ( propInfo.isScale ) pseudo = DuAEF.Duik.PseudoEffects.TWO_DIMENSIONS_SCALE;
        else if ( propInfo.isAngle ) pseudo = DuAEF.Duik.PseudoEffects.TWO_DIMENSIONS_ANGLE;
        else pseudo = DuAEF.Duik.PseudoEffects.TWO_DIMENSIONS;

        var effect = pseudo.apply( layer, propInfo.name + " XY" );

        prop = propInfo.getProperty();

        //copy values
        if ( prop.numKeys == 0 )
        {
            effect( pseudo.xSlider ).setValue( prop.value[ 0 ] );
            effect( pseudo.ySlider ).setValue( prop.value[ 1 ] );
        }
        else
        {
            for ( var k = 1, num = prop.numKeys; k <= num; k++ )
            {
                var time = prop.keyTime( k );
                var value = prop.keyValue( k );
                effect( pseudo.xSlider ).setValueAtTime( time, value[ 0 ] );
                effect( pseudo.ySlider ).setValueAtTime( time, value[ 1 ] );
            }
        }

        //add expression
        prop.expression = '//Duik.separateDimensions\n' +
            'var fx = thisLayer.effect("' + effect.name + '");\n' +
            '[fx(' + pseudo.xSlider + ').value,fx(' + pseudo.ySlider + ').value];';
    }
    else if ( dim == 3 )
    {
        var pseudo;
        if ( propInfo.isScale ) pseudo = DuAEF.Duik.PseudoEffects.THREE_DIMENSIONS_SCALE;
        else if ( propInfo.isAngle ) pseudo = DuAEF.Duik.PseudoEffects.THREE_DIMENSIONS_ANGLE;
        else pseudo = DuAEF.Duik.PseudoEffects.THREE_DIMENSIONS;

        var effect = pseudo.apply( layer, propInfo.name + " XYZ" );

        prop = propInfo.getProperty();

        //copy values
        if ( prop.numKeys == 0 )
        {
            effect( pseudo.xSlider ).setValue( prop.value[ 0 ] );
            effect( pseudo.ySlider ).setValue( prop.value[ 1 ] );
            effect( pseudo.zSlider ).setValue( prop.value[ 2 ] );
        }
        else
        {
            for ( var k = 1, num = prop.numKeys; k <= num; k++ )
            {
                var time = prop.keyTime( k );
                var value = prop.keyValue( k );
                effect( pseudo.xSlider ).setValueAtTime( time, value[ 0 ] );
                effect( pseudo.ySlider ).setValueAtTime( time, value[ 1 ] );
                effect( pseudo.zSlider ).setValueAtTime( time, value[ 2 ] );
            }
        }

        //add expression
        prop.expression = '//Duik.separateDimensions\n' +
            'var fx = thisLayer.effect("' + effect.name + '");\n' +
            '[fx(' + pseudo.xSlider + ').value,fx(' + pseudo.ySlider + ').value, fx(' + pseudo.zSlider + ').value];';
    }
    else if ( dim == 4 )
    {
        var pseudo = DuAEF.Duik.PseudoEffects.COLOR;
        var effect = pseudo.apply( layer, propInfo.name + " RGB/HSL" );
        effect( pseudo.channelsPopup ).setValue( 2 );
        prop = propInfo.getProperty();

        //copy values
        if ( prop.numKeys == 0 )
        {
            var color = prop.value;
            color = DuAEF.DuJS.Color.rgbToHsl( color );
            effect( pseudo.xSlider ).setValue( color[ 0 ] );
            effect( pseudo.ySlider ).setValue( color[ 1 ] );
            effect( pseudo.zSlider ).setValue( color[ 2 ] );
        }
        else
        {
            for ( var k = 1, num = prop.numKeys; k <= num; k++ )
            {
                var time = prop.keyTime( k );
                var value = prop.keyValue( k );
                value = DuAEF.DuJS.Color.rgbToHsl( value );
                effect( pseudo.xSlider ).setValueAtTime( time, value[ 0 ] );
                effect( pseudo.ySlider ).setValueAtTime( time, value[ 1 ] );
                effect( pseudo.zSlider ).setValueAtTime( time, value[ 2 ] );
            }
        }

        //add expression
        prop.expression = '//Duik.separateDimensions\n' +
            'var fx = thisLayer.effect("' + effect.name + '");\n' +
            'var color = [fx(' + pseudo.xSlider + ').value,fx(' + pseudo.ySlider + ').value, fx(' + pseudo.zSlider + ').value, 1];\n' +
            'if (fx(' + pseudo.channelsPopup + ').value == 2) hslToRgb(color);\n' +
            'else color;\n';
    }
}

/**
 * Adds a zero to a layer
 * @param {Layer} layer - The layer
 * @return {AVLayer} The zero, a null
 */
DuAEF.Duik.Rigging.addZero = function( layer )
{
    //create null object
    var zero = layer.containingComp.layers.addNull();
    DuAEF.Dugr.addLayerToGroup( zero, "Zeros" );
    var layerparent = layer.parent;
    layer.parent = null;
    zero.position.setValue( layer.position.value );
    zero.rotation.setValue( layer.rotation.value );
    zero.name = "Zero | " + layer.name.slice( -24 );
    layer.parent = zero;
    zero.scale.setValue( layer.scale.value );
    layer.scale.setValue( [ 100, 100, 100 ] );

    DuAEF.Duik.setDuikMarker( zero, "Zero", DuAEF.Duik.LayerTypes.ZERO );

    //parent
    zero.parent = layerparent;

    //lock and hide
    zero.moveToEnd();
    zero.guideLayer = true;
    zero.shy = true;
    zero.enabled = false;
    zero.selected = false;
    zero.locked = true;
    return zero;
}

/**
 * Adds a locator to a layer
 * @param {Layer|CompItem} [layerOrComp=DuAEF.DuAE.Project.getActiveComp()] - The layer or the containing comp, to add a standalone locator.
 * @return {AVLayer} The locator, a null object
 */
DuAEF.Duik.Rigging.addLocator = function( layerOrComp )
{
    var layer = null;
    var comp = null;
    if ( typeof layerOrComp === 'undefined' ) comp = DuAEF.DuAE.Project.getActiveComp();
    else if ( layerOrComp instanceof CompItem ) comp = layerOrComp;
    else
    {
        layer = layerOrComp;
        comp = layer.containingComp;
    }
    if ( !comp ) return;

    //create null object
    var loc = comp.layers.addNull();
    var name = 'LOC';
    if ( layer ) name = DuAEF.Duik.generateName( 'LOC', layer.name );
    loc.name = DuAEF.DuAE.Comp.newUniqueLayerName( name, comp );
    DuAEF.Dugr.addLayerToGroup( loc, "Locators" );

    //add layer control
    var layerfx = loc.property( 'ADBE Effect Parade' ).addProperty( 'ADBE Layer Control' );
    layerfx.name = "Locator";
    if ( layer ) layerfx( 1 ).setValue( layer.index );

    //add expressions
    loc.transform.rotation.expression = 'var result = 0;\n' +
        'var l = null;\n' +
        'try{ l = effect("' + layerfx.name + '")(1) } catch(e) { }\n' +
        'if (l)\n' +
        '{\n' +
        'result = l.rotation;\n' +
        'while(l.hasParent)\n' +
        '{\n' +
        'l = l.parent;\n' +
        'result += l.rotation;\n' +
        '}\n' +
        '}\n' +
        'if (hasParent)\n' +
        '{\n' +
        'var p =thisLayer;\n' +
        'while (p.hasParent)\n' +
        '{\n' +
        'p = p.parent;\n' +
        'result -= p.rotation;\n' +
        '}\n' +
        '}\n' +
        'result;';

    loc.transform.position.expression = 'var result = [thisComp.width/2,thisComp.height/2];\n' +
        'var l = null;\n' +
        'try{ l = effect("' + layerfx.name + '")(1) } catch(e) { }\n' +
        'if (l)\n' +
        '{\n' +
        'result = l.toWorld(l.anchorPoint);\n' +
        '}\n' +
        'if (hasParent)\n' +
        '{\n' +
        'result = parent.fromWorld(result);\n' +
        '}\n' +
        'result;';

    loc.transform.anchorPoint.expression = 'var result = value;\n' +
        'var l = null;\n' +
        'try{ l = effect("' + layerfx.name + '")(1) } catch(e) { }\n' +
        'if (l)\n' +
        '{\n' +
        'result =l.anchorPoint.value;\n' +
        '}\n' +
        'result;';

    DuAEF.Duik.setDuikMarker( loc, "Locator", DuAEF.Duik.LayerTypes.LOCATOR );


    return loc;
}

/**
 * Extracts locators from a precomposition
 * @param {AVLayer} [preCompLayer] - The precomposition layer
 * @return {AVLayer[]} The extracted locators
 */
DuAEF.Duik.Rigging.extractLocators = function( preCompLayer )
{
    var preComp = preCompLayer.source;
    if ( !preComp instanceof CompItem ) return;

    //get locators in precomp
    var preCompLocs = DuAEF.Duik.getLayers( DuAEF.Duik.LayerTypes.LOCATOR, false, preComp );

    var locs = [];

    var it = new Iterator( preCompLocs );
    it.do( function( preCompLoc )
    {
        locs.push( DuAEF.Duik.Rigging.extractLocator( preCompLoc, preCompLayer ) );
    } );

    return locs;
}

/**
 * Extracts one locator from a precomposition
 * @param {AVLayer} [preCompLayer] - The precomposition layer
 * @param {AVLayer} [locator] - The locator to extract
 * @return {AVLayer} The extracted locator
 */
DuAEF.Duik.Rigging.extractLocator = function( locator, preCompLayer )
{
    var comp = preCompLayer.containingComp;
    //comp names
    DuAEF.DuAE.Comp.setUniqueCompName( comp );
    DuAEF.DuAE.Comp.setUniqueCompName( locator.containingComp );
    //create a null in the comp
    var loc = comp.layers.addNull();
    loc.name = DuAEF.DuAE.Comp.newUniqueLayerName( locator.name, comp );
    loc.parent = preCompLayer;
    DuAEF.Dugr.addLayerToGroup( loc, "Locators" );
    DuAEF.Duik.setDuikMarker( loc, "Locator", DuAEF.Duik.LayerTypes.LOCATOR );
    DuAEF.DuAE.Property.linkProperties( loc.transform, locator.transform );
    return loc;
}

/**
 * Parents two layers even if the parent is in the parent comp or a precomp.
 * @param {Layer[]} children - The child layer(s)
 * @param {Layer} parent - The parent layer
 */
DuAEF.Duik.Rigging.parent = function( children, parent )
{
    if ( typeof children === 'undefined' ) throw "You must provide children to parent.";
    if ( typeof children.length === 'undefined' ) children = [ children ];

    var parentComp = parent.containingComp;

    //create the parent locator
    var locator = DuAEF.Duik.Rigging.addLocator( parent );
    //the children locators
    var childLocators = [];

    new Iterator( children ).do( function( child )
    {
        var childComp = child.containingComp;

        //check if there already is a child locator
        var childLocator = null;
        for ( var i = 0, num = childLocators.length; i < num; i++ )
        {
            if ( childLocators[ i ].containingComp.id == childComp.id )
            {
                childLocator = childLocators[ i ];
                break;
            }
        }

        //if precomp
        var precomps = DuAEF.DuAE.Comp.getPrecomps( childComp );

        if ( DuAEF.DuJS.Array.indexOf( precomps, parentComp ) >= 0 )
        {
            //select the first precomp layer
            var precompLayer;
            for ( var i = 1, num = childComp.numLayers; i <= num; i++ )
            {
                var l = childComp.layer( i );
                if ( l.source )
                {
                    if ( l.source.id == parentComp.id )
                    {
                        precompLayer = l;
                        break;
                    }
                }
            }

            //create the child Locator
            if ( !childLocator )
            {
                //create a locator and extract it
                var childLocator = DuAEF.Duik.Rigging.extractLocator( locator, precompLayer );
                childLocator.selected = false;
                childLocator.enabled = false;
                childLocator.shy = true;
                childLocator.locked = true;
                childLocators.push( childLocator );
            }

            child.parent = childLocator;
            child.selected = true;
            return;
        }

        //if parent comp
        var parentComps = DuAEF.DuAE.Comp.getParentComps( childComp );
        if ( DuAEF.DuJS.Array.indexOf( parentComps, parentComp ) >= 0 )
        {
            //select the first precomp layer
            var precompLayer;
            for ( var i = 1, num = parentComp.numLayers; i <= num; i++ )
            {
                var l = parentComp.layer( i );
                if ( l.source == childComp )
                {
                    precompLayer = l;
                    break;
                }
            }

            //create a locator and extract it
            locator.parent = precompLayer;

            //create the child Locator
            if ( !childLocator )
            {
                //create a null in the comp
                var childLocator = childComp.layers.addNull();
                childLocator.name = DuAEF.DuAE.Comp.newUniqueLayerName( locator.name, childComp );
                DuAEF.Duik.setDuikMarker( childLocator, "Locator", DuAEF.Duik.LayerTypes.LOCATOR );
                DuAEF.DuAE.Property.linkProperties( childLocator.transform, locator.transform );
                //lock and hide
                childLocator.selected = false;
                childLocator.enabled = false;
                childLocator.shy = true;
                childLocator.locked = true;
                childLocators.push( childLocator );
            }

            child.parent = childLocator;
            child.selected = true;

            return;
        }

    } );

    //lock and hide
    locator.selected = false;
    locator.enabled = false;
    locator.locked = true;
    locator.shy = true;
    parent.selected = true;

}

/**
 * Adds an orientation constraint to a layer
 * @param {Layer} layer - The layer
 */
DuAEF.Duik.Rigging.orientationConstraint = function( layer )
{
    var effect = DuAEF.DuAE.Layer.addPseudoEffect( layer, DuAEF.Duik.PseudoEffects.ORIENTATION, DuAEF.Duik.PseudoEffectsMatchNames.ORIENTATION, 'Orientation constraint' );

    layer.rotation.expression = '//Duik.orientationConstraint\n' +
        'function o(l)\n' +
        '{\n' +
        'var r = 0;\n' +
        'r += l.rotation;\n' +
        'while(l.hasParent)\n' +
        '{\n' +
        'l = l.parent;\n' +
        'r += l.rotation;\n' +
        '}\n' +
        'return r;\n' +
        '}\n' +
        'var result = value;\n' +
        'var p = thisLayer;\n' +
        'while(p.hasParent)\n' +
        '{\n' +
        'p = p.parent;\n' +
        'result -= p.rotation.value;\n' +
        '}\n' +
        'for (var i = 1 ; i <= thisLayer("Effects").numProperties ; i++)\n' +
        '{\n' +
        'var fx = effect(i) ;\n' +
        'if (fx.name.indexOf("Orientation constraint") == 0)\n' +
        '{\n' +
        'var l = null;\n' +
        'try { l = fx(1); } catch (e){}\n' +
        'if (l) result += o(l)*(fx(2).value/100);\n' +
        '}\n' +
        '}\n' +
        'result;';

}

/**
 * Adds a position constraint to a layer
 * @param {Layer} layer - The layer
 */
DuAEF.Duik.Rigging.positionConstraint = function( layer )
{
    var effect = DuAEF.Duik.PseudoEffects.POSITION.apply( layer );
    effect( DuAEF.Duik.PseudoEffects.POSITION.weightSlider ).setValue( 0 );

    layer.position.expression = '//Duik.positionConstraint\n' +
        'var result = value;\n' +
        'for (var i = 1 ; i <= thisLayer("Effects").numProperties ; i++)\n' +
        '{\n' +
        'var fx = effect(i) ;\n' +
        'if (fx.name.indexOf("' + effect.name + '") == 0)\n' +
        '{\n' +
        'var l = null;\n' +
        'try { l = fx(1); } catch (e){}\n' +
        'if (l)\n' +
        '{\n' +
        'var cp = l.toWorld(l.anchorPoint);\n' +
        'if (thisLayer.hasParent) cp = thisLayer.parent.fromWorld(cp);\n' +
        'cp0 = l.toWorld(l.anchorPoint,0);\n' +
        'if (thisLayer.hasParent) cp0 = thisLayer.parent.fromWorld(cp0);\n' +
        'cp -= cp0;\n' +
        'result += cp*(fx(2).value/100);\n' +
        '}\n' +
        '}\n' +
        '}\n' +
        'result;';
}

/**
 * Adds a path constraint to a layer
 * @param {Layer} layer - The layer
 * @param {Property|PropertyInfo} path - The path property
 */
DuAEF.Duik.Rigging.pathConstraint = function( layer, path )
{
    if ( path instanceof PropertyInfo ) path = path.getProperty();

    var effect = DuAEF.Duik.PseudoEffects.PATH.apply( layer );

    var l = DuAEF.DuAE.Property.getLayer( path );
    var pathExpr = DuAEF.DuAE.Property.getExpressionLink( path, true );

    var expr = ['//Duik.pathConstraint',
        'var fx = effect("' + effect.name + '");',
        'var l = thisComp.layer("' + l.name + '");',
        'var p = ' + pathExpr + ';',
        'var percent = fx(' + DuAEF.Duik.PseudoEffects.PATH.index['Percent along pathSlider'] + ').value % 100 / 100;',
        'if (percent == 0) percent = 0.0001;',
        'var pathOffset = fx(' + DuAEF.Duik.PseudoEffects.PATH.index['Path OffsetSlider']  + ');',
        'var result = value;',
        '//path value',
        'result += p.pointOnPath(percent, time);',
        '//offset',
        'result += p.normalOnPath(percent, time)*pathOffset;',
        '//layer position',
        'result += l.position;'
	].join('\n');

    DuAEF.DuAE.Property.setExpression( layer.position, expr );

    var expr = '//Duik.pathConstraint\n' +
        'var fx = effect("' + effect.name + '");\n' +
        'var autoOrient = fx(' + DuAEF.Duik.PseudoEffects.PATH.index['OrientationCheckbox'] + ').value;\n' +
        'var result = value;\n' +
        'if (autoOrient)\n' +
        '{\n' +
        'var p = ' + pathExpr + ';\n' +
        'var percent = fx(' + DuAEF.Duik.PseudoEffects.PATH.index['Percent along pathSlider'] + ').value % 100 / 100;\n' +
        'var C = p.tangentOnPath(percent, time);\n' +
        'var angle = Math.atan2(C[1], C[0]);\n' +
        'angle = radiansToDegrees(angle);\n' +
        'angle = angle;\n' +
        'result += angle;\n' +
        '}\n' +
        'result;';

    DuAEF.DuAE.Property.setExpression( layer.rotation, expr );
}

/**
 * Adds a parent constraint to a layer
 * @param {Layer} layer - The layer
 */
DuAEF.Duik.Rigging.parentConstraint = function( layer )
{
	var effect = DuAEF.Duik.PseudoEffects.PARENT.apply(layer);
    var index = DuAEF.Duik.PseudoEffects.PARENT.index;

	var posExpr = '//Duik.parent\n' +
		'function getParentTransform(l,origin,sF,eF)\n' +
		'{\n' +
		'var sT = framesToTime(sF);\n' +
		'var eT = framesToTime(eF);\n' +
		'try { var pos = l.fromWorld( origin , sT ) ; }\n' +
		'catch (e) { var pos = [0,0]; }\n' +
		'var prevPos = l.toWorld( pos , sT );\n' +
		'var newPos =  l.toWorld( pos , eT );\n' +
		'return newPos - prevPos;\n' +
		'}\n' +
		'var result = thisLayer.position.valueAtTime(0);\n' +
		'var cF = 1;\n' +
		'while (cF <= timeToFrames())\n' +
		'{\n' +
		'for (var i = 1 ; i <= thisLayer("Effects").numProperties ; i++)\n' +
		'{\n' +
		'var fx = effect(i);\n' +
		'if (fx.name.indexOf("Parent constraint") != 0) continue;\n' +
		'if (!fx(' + index['InheritancePositionCheckbox'] + ').value) continue;\n' +
		'var parentLayer = null;\n' + 
		'try { parentLayer = fx(' + index['LayerLayer'] + '); } catch (e){ continue; }\n' +
		'if (!parentLayer) continue;\n' + 
		'if (parentLayer.index == index) continue;\n' +
		'var weight = fx(' + index['WeightSlider'] + ').valueAtTime( framesToTime(cF) ) / 100;\n' +
		'if (weight == 0) continue;\n' +
		'result += getParentTransform( parentLayer , result , cF-1 , cF )*weight;\n' +
		'}\n' +
		'result += valueAtTime(framesToTime(cF)) - valueAtTime(framesToTime(cF-1));\n' +
		'cF++;\n' +
		'}\n' +
		'result;';

	if (layer.position.dimensionsSeparated)
	{
		layer.transform.xPosition.expression = posExpr + '\nresult[0];';

		layer.transform.yPosition.expression = posExpr + '\nresult[1];';
	}
	else
	{
		layer.position.expression = posExpr;
	}

	layer.rotation.expression = '//Duik.parent\n' +
						'function o(l,t)\n' +
						'{\n' +
						'if (t == undefined) t = time;\n' +
						'var r = 0;\n' +
						'r += l.rotation.valueAtTime(t);\n' +
						'while(l.hasParent)\n' +
						'{\n' +
						'l = l.parent;\n' +
						'r += l.rotation.valueAtTime(t);\n' +
						'}\n' +
						'return r;\n' +
						'}\n' +
						'var result = value;\n' +
						'for (var i = 1 ; i <= thisLayer("Effects").numProperties ; i++)\n' +
						'{\n' +
						'var fx = effect(i) ;\n' +
						'if (fx.name.indexOf("Parent constraint") != 0) continue;\n' +
						'if (!fx(' + index['InheritanceRotationCheckbox'] + ').value) continue;\n' +
						'var l = null;\n' + 
						'try { l = fx(' + index['LayerLayer'] + '); } catch (e){ continue; }\n' +
						'if (!l) continue;\n' + 
						'if (l.index == index) continue;\n' +
						'if ( fx(' + index['WeightSlider']  + ').numKeys < 2 )\n' +
						'{\n' +
						'var w = fx(' + index['WeightSlider']  + ').value/100;\n' +
						'if (w == 0) continue;\n' +
						'var P = o(l);\n' +
						'var oP = o(l,0);\n' +
						'result += (P - oP)*w;\n' +
						'}\n' +
						'else\n' +
						'{\n' +
						'var frame = timeToFrames(time);\n' +
						'for (var j = frame;j>=0;j--)\n' +
						'{\n' +
						'var t = framesToTime(j);\n' +
						'var prevT = framesToTime(j-1);\n' +
						'var w = fx(' + index['WeightSlider']  + ').valueAtTime(t)/100;\n' +
						'var P = o(l,t);\n' +
						'var oP = o(l,prevT);\n' +
						'result += (P - oP)*w;\n' +
						'}\n' +
						'}\n' +
						'}\n' +
						'result;';

	if (layer.parent != null)
	{
		var comp = layer.containingComp;
		var time = comp.time;
		comp.time = 0;
		var parent = layer.parent;
		layer.parent = null;
		effect(1).setValue(parent.index);
		comp.time = time;
	}
}

/**
 * Checks if the property can be used as parent with the connector
 * @param {Property|PropertyInfo} prop - The property
 * @return {int} 0 if the prop can not be used as parent, or the number of the dimensions of the property (4 = color)
 */
DuAEF.Duik.Rigging.connectorCheckParent = function( prop )
{
    if ( !( prop instanceof PropertyInfo ) ) prop = new PropertyInfo( prop );
    if ( prop.getProperty().propertyType != PropertyType.PROPERTY ) return 0;

    //check dimensions
    var dim = DuAEF.DuAE.Property.getDimensions( prop );
    return dim;
}

/**
 * Applies connector to the property
 * @param {Property|PropertyInfo} childProp - The child property
 * @param {Property|PropertyInfo} parentProp - The parent property
 * @param {PropertyGroup|PropertyInfo|null} [parentEffect] - The effect of an already existing connector
 * @param {float} [minValue=0] - The minimum value
 * @param {float} [maxValue=100] - The maximum value
 * @param {DuAEF.DuAE.Axis} [axis=DuAEF.DuAE.Axis.X] - The axis or channel to connect
 * @param {DuAEF.DuAE.Types} [axis=DuAEF.DuAE.Types.VALUE] - The type
 * @return {PropertyGroup} The controlling effect created
 */
DuAEF.Duik.Rigging.connector = function( childProp, parentProp, parentEffect, minValue, maxValue, axis, type )
{
    if ( typeof minValue === 'undefined' ) minValue = null;
    if ( typeof maxValue === 'undefined' ) maxValue = null;
    if ( typeof axis === 'undefined' ) axis = DuAEF.DuAE.Axis.X;
    if ( typeof type === 'undefined' ) axis = DuAEF.DuAE.Types.VALUE;
    if ( typeof parentEffect === 'undefined' ) parentEffect = null;


    childProp = new PropertyInfo( childProp );
    var parentProp = new PropertyInfo( parentProp );

    DuAEF.DuAE.Comp.setUniqueCompName( parentProp.comp );
    DuAEF.DuAE.Comp.setUniqueCompName( childProp.comp );

    if ( !childProp.riggable ) return null;

    var dim = DuAEF.Duik.Rigging.connectorCheckParent( parentProp );
    if ( dim == 0 ) return null;

    var parentLayer = DuAEF.DuAE.Property.getLayer( parentProp );

    //Adjust minimum value
    if ( !isNaN( minValue ) )
    {
        if ( dim == 4 )
        {
            if ( app.project.bitsPerChannel == 8 ) minValue = minValue / 255;
            if ( app.project.bitsPerChannel == 16 ) minValue = minValue / 32768;
            if ( app.project.bitsPerChannel == 32 && minValue < 0 ) minValue = 0;
            if ( app.project.bitsPerChannel == 32 && minValue > 1 ) minValue = 1;
        }
    }
    else minValue = 0;

    //adjust maximum value
    if ( !isNaN( maxValue ) )
    {
        if ( dim == 4 )
        {
            if ( app.project.bitsPerChannel == 8 ) maxValue = maxValue / 255;
            if ( app.project.bitsPerChannel == 16 ) maxValue = maxValue / 32768;
            if ( app.project.bitsPerChannel == 32 && maxValue < 0 ) maxValue = 0;
            if ( app.project.bitsPerChannel == 32 && maxValue > 1 ) maxValue = 1;
        }
    }
    else maxValue = 100;

    //adjust type
    if ( type == DuAEF.DuAE.Types.VELOCITY ) type = 2;
    else type = 1;

    //adjust axis
    if ( axis == DuAEF.DuAE.Axis.Y ) axis = 2;
    else if ( axis == DuAEF.DuAE.Axis.Z ) axis = 3;
    else if ( axis == DuAEF.DuAE.Axis.RED ) axis = 1;
    else if ( axis == DuAEF.DuAE.Axis.GREEN ) axis = 2;
    else if ( axis == DuAEF.DuAE.Axis.BLUE ) axis = 3;
    else if ( axis == DuAEF.DuAE.Axis.ALPHA ) axis = 4;
    else if ( axis == DuAEF.DuAE.Axis.HUE ) axis = 5;
    else if ( axis == DuAEF.DuAE.Axis.SATURATION ) axis = 6;
    else if ( axis == DuAEF.DuAE.Axis.VALUE ) axis = 7;

	var connectorLayer = DuAEF.Duik.Rigging.getConnectorLayer( parentProp.comp );

    //try to find an existing effect
    if ( !parentEffect )
    {
        var connectorEffects = connectorLayer.property( 'ADBE Effect Parade' );
        var matchName = DuAEF.Duik.PseudoEffects.ONED_CONNECTOR.matchName;
        if ( dim == 2 ) matchName = DuAEF.Duik.PseudoEffects.TWOD_CONNECTOR.matchName;
        else if ( dim == 3 ) matchName = DuAEF.Duik.PseudoEffects.THREED_CONNECTOR.matchName;
        else if ( dim == 4 ) matchName = DuAEF.Duik.PseudoEffects.COLOR_CONNECTOR.matchName;

        var effects = DuAEF.DuAE.Property.getProps( connectorEffects, matchName, true );

        //check if there is one with the same params
        for ( var i = 0, num = effects.length; i < num; i++ )
        {
            var effect = effects[ i ].getProperty();
            if ( effect.property( DuAEF.Duik.PseudoEffects.ONED_CONNECTOR.minimumSlider ).value != minValue ) continue;
            if ( effect.property( DuAEF.Duik.PseudoEffects.ONED_CONNECTOR.maximumSlider ).value != maxValue ) continue;
            if ( effect.property( DuAEF.Duik.PseudoEffects.ONED_CONNECTOR.connexionModePopup ).value != type ) continue;
            if ( dim > 1 )
                if ( effect.property( DuAEF.Duik.PseudoEffects.TWOD_CONNECTOR.axisPopup ).value != axis ) continue;

            //if all tests passed, this is the one!
            parentEffect = effect;
            break;
        }
    }

    //if not found, create
    if ( !parentEffect )
    {
        if ( dim == 1 ) parentEffect = DuAEF.Duik.PseudoEffects.ONED_CONNECTOR.apply( connectorLayer, parentProp.layer.name + ' # ' + parentProp.getProperty().name );
        else if ( dim == 2 ) parentEffect = DuAEF.Duik.PseudoEffects.TWOD_CONNECTOR.apply( connectorLayer, parentProp.layer.name + ' # ' + parentProp.getProperty().name );
        else if ( dim == 3 ) parentEffect = DuAEF.Duik.PseudoEffects.THREED_CONNECTOR.apply( connectorLayer, parentProp.layer.name + ' # ' + parentProp.getProperty().name );
        else if ( dim == 4 ) parentEffect = DuAEF.Duik.PseudoEffects.COLOR_CONNECTOR.apply( connectorLayer, parentProp.layer.name + ' # ' + parentProp.getProperty().name );

        if ( dim != 4 ) parentEffect( DuAEF.Duik.PseudoEffects.ONED_CONNECTOR.maximumSlider ).setValue( 100 );
        else parentEffect( DuAEF.Duik.PseudoEffects.COLOR_CONNECTOR.maximumSlider ).setValue( 1 );
    }

    parentEffect( DuAEF.Duik.PseudoEffects.ONED_CONNECTOR.minimumSlider ).setValue( minValue );
    parentEffect( DuAEF.Duik.PseudoEffects.ONED_CONNECTOR.maximumSlider ).setValue( maxValue );
    parentEffect( DuAEF.Duik.PseudoEffects.ONED_CONNECTOR.connexionModePopup ).setValue( type );
    if ( dim > 1 ) parentEffect( DuAEF.Duik.PseudoEffects.TWOD_CONNECTOR.axisPopup ).setValue( axis );

    // the expression

    // check if the current comp is the same than the comp containing the masterProperty
    var parentComp = parentLayer.containingComp;
    var childComp = DuAEF.DuAE.Property.getComp( childProp );
    var comp = 'thisComp.';
    if ( parentComp !== childComp ) comp = 'comp("' + parentComp.name + '").';

    var expr = '//Duik.connector\n' +
        'var ctrlLayer = ' + comp + 'layer("' + parentLayer.name + '");\n' +
        'var connectorLayer = ' + comp + 'layer("' + connectorLayer.name + '");\n' +
        'var ctrlValue = ctrlLayer' + DuAEF.DuAE.Property.getExpressionLink( parentProp.getProperty(), false, false ) + ';\n' +
        'var ctrlEffect = connectorLayer.effect("' + parentEffect.name + '");\n' +
        'var ctrlMin = ctrlEffect(2).value;\n' +
        'var ctrlMax = ctrlEffect(3).value;\n' +
        'var result = value;\n' +
        'if (numKeys >= 2 && ctrlEffect.enabled)\n' +
        '{\n' +
        'var useVelocity = ctrlEffect(1).value == 2;\n' +
        'if (useVelocity) ctrlValue = ctrlValue.velocity;\n' +
        'else ctrlValue = ctrlValue.value;\n';
    if ( parentProp.isAngle )
    {
        expr += 'if (!useVelocity) ctrlValue = ctrlValue % 360;\n';
    }
    else if ( dim == 2 || dim == 3 )
    {
        expr += 'var axis = ctrlEffect(4).value-1;\n' +
            'ctrlValue = ctrlValue[axis];\n';
    }
    else if ( dim == 4 )
    {
        expr += 'var axis = ctrlEffect(4).value;\n' +
            'if (axis == 1) ctrlValue = ctrlValue[0];\n' +
            'else if (axis == 2) ctrlValue = ctrlValue[1];\n' +
            'else if (axis == 3) ctrlValue = ctrlValue[2];\n' +
            'else if (axis == 4) ctrlValue = ctrlValue[3];\n' +
            'else \n' +
            '{\n' +
            'ctrlValue = rgbToHsl(ctrlValue);\n' +
            'if (axis == 5) ctrlValue = ctrlValue[0];\n' +
            'else if (axis == 6) ctrlValue = ctrlValue[1];\n' +
            'else if (axis == 7) ctrlValue = ctrlValue[2];\n' +
            '}';
    }
    expr += 'var t = 0;\n' +
        'var beginTime = key(1).time;\n' +
        'var endTime = key(numKeys).time;\n' +
        'if (ctrlMin > ctrlMax)\n' +
        '{\n' +
        't = linear(ctrlValue, ctrlMin, ctrlMax, endTime, beginTime);\n' +
        '}\n' +
        'else\n' +
        '{\n' +
        't = linear(ctrlValue, ctrlMin, ctrlMax, beginTime, endTime);\n' +
        '}\n' +
        'result = valueAtTime(t);\n' +
        '}\n' +
        'result;';

    
    var prop = childProp.getProperty();
    prop.expression = expr;
    if ( prop.matchName == "ADBE Opacity" ) childProp.layer.enabled = true;

    return parentEffect;
}

/**
 * Gets (or create) the controller layer for the connectors of the comp
 * @param {CompItem} [comp] - The comp. The active composition by default.
 * @return {AVLayer} The connector layer
 */
DuAEF.Duik.Rigging.getConnectorLayer = function( comp )
{
	if (typeof comp === 'undefined') comp = DuAEF.DuAE.Project.getActiveComp();
	if (!comp) throw "DuAEF.Duik.Rigging.getConnectorLayer()\nneeds a composition to get the connector layer";

	var connectorLayer = DuAEF.Duik.getLayer(DuAEF.Duik.LayerTypes.CONNECTOR, false, comp);
	//create
	if ( connectorLayer == null )
	{
		var connectorCtrl = DuAEF.Duik.Controller.create( comp, DuAEF.Duik.Controller.Types.CONNECTOR );
		connectorLayer = connectorCtrl.layer;
		DuAEF.Duik.setDuikMarker(connectorLayer,"Connector",DuAEF.Duik.LayerTypes.CONNECTOR);
	}

	return connectorLayer;
}

/**
 * Applies connector to the property, creating a controller layer (or using any existing one) with a slider in the effects
 * @param {Property[]|PropertyInfo[]} childProps - The child property
 */
DuAEF.Duik.Rigging.quickConnector = function( childProps )
{
    var childProp = childProps[ childProps.length - 1 ];
    if ( !( childProp instanceof PropertyInfo ) ) childProp = new PropertyInfo( childProp );
    //look for the connector layer in this comp, or create one
    var connectorLayer = null;
    var comp = childProp.comp;
    var ctrls = DuAEF.Duik.Controller.getControllers( comp );
    for ( var i = 0, num = ctrls.length; i < num; i++ )
    {
        var ctrl = ctrls[ i ].layer;
        if ( ctrl.property( 'ADBE Effect Parade' ).property( DuAEF.Duik.PseudoEffects.QUICK_CONNECTOR.matchName ) )
        {
            connectorLayer = ctrl;
            break;
        }
    }
    //create if needed
    if ( connectorLayer == null )
    {
        var connectorCtrl = DuAEF.Duik.Controller.create( comp, DuAEF.Duik.Controller.Types.CONNECTOR );
        connectorLayer = connectorCtrl.layer;
    }
    //create effect
    var prop = childProp.getProperty();
    var childLayer = childProp.layer;
    var connectorEffect = DuAEF.Duik.PseudoEffects.QUICK_CONNECTOR.apply( connectorLayer, childLayer.name + ' | ' + prop.parentProperty.name );

    var expr = '//Duik.connector\n' +
        'var ctrlLayer = thisComp.layer("' + connectorLayer.name + '");\n' +
        'var ctrlEffect = ctrlLayer.effect("' + connectorEffect.name + '");\n' +
        'var ctrlValue = ctrlEffect(' + DuAEF.Duik.PseudoEffects.QUICK_CONNECTOR.connectorSlider + ');\n' +
        'var ctrlMin = 0;\n' +
        'var ctrlMax = 100;\n' +
        'var result = value;\n' +
        'if (numKeys >= 2 && ctrlEffect.enabled)\n' +
        '{\n' +
        'ctrlValue = ctrlValue.value;\n' +
        'var t = 0;\n' +
        'var beginTime = key(1).time;\n' +
        'var endTime = key(numKeys).time;\n' +
        'if (ctrlMin > ctrlMax)\n' +
        '{\n' +
        't = linear(ctrlValue, ctrlMin, ctrlMax, endTime, beginTime);\n' +
        '}\n' +
        'else\n' +
        '{\n' +
        't = linear(ctrlValue, ctrlMin, ctrlMax, beginTime, endTime);\n' +
        '}\n' +
        'result = valueAtTime(t);\n' +
        '}\n' +
        'result;';


    var it = new Iterator( childProps );
    it.do( function( childProp )
    {
        if ( !( childProp instanceof PropertyInfo ) ) childProp = new PropertyInfo( childProp );
        if ( !childProp.riggable ) return;

        childProp.getProperty().expression = expr;
    } );
}

/**
 * Creates an IK and its controller on the layers/the structure.
 * @param {Layer[]|Structure} layers - The layers, already parented or ordered from goal (at index 0) to root (including the goal)
 * @param {Layer|Controller|null} [controller] - An already existing controller.
 * @param {boolean} [forceBezier=false] - force the use of a bezier IK even with two or three layers
 * @param {boolean} [threeAsOneAndTwo=true] - when rigging three layers, true to rig using a one-layer IK followed by a two-layer IK instead of a three-mayer IK
 * @return {Controller[]} The controller(s) of the IK.
 */
DuAEF.Duik.Rigging.ik = function( layers, controller, forceBezier, threeAsOneAndTwo )
{
    if ( layers instanceof Structure ) layers = layers.elements;
    if ( typeof forceBezier === 'undefined' ) forceBezier = false;
    if ( typeof threeAsOneAndTwo === 'undefined' ) threeAsOneAndTwo = true;
    if ( layers.length < 1 ) return [];


    //check if there is a controller in the selection
    if ( typeof controller === 'undefined' )
    {
        if ( layers.length < 2 ) return [];
        for ( var i = 0; i < layers.length; i++ )
        {
            var l = layers[ i ];
            if ( DuAEF.Duik.isLayerType( l, DuAEF.Duik.LayerTypes.CONTROLLER ) )
            {
                controller = l;
                layers.splice( i, 1 );
                break;
            }
        }
    }

    //sort layers and parent them
    layers = DuAEF.DuAE.Layer.sortByParent( layers );
    //reset rotation and scale if structures
    var it = new Iterator( layers );
    it.do( DuAEF.Duik.Structure.resetTransform );
    DuAEF.DuAE.Layer.parentChain( layers );

    //check if the last one is a goal
    var withGoal = true;
    if ( typeof controller !== 'undefined' )
    {
        var l = layers[ layers.length - 1 ];
        //check position
        var cL = controller;
        if ( controller instanceof Controller ) cL = controller.layer;
        else controller = new Controller( controller );
        var distance = DuAEF.DuAE.Layer.getDistance( cL, l );
        if ( distance > 10 ) withGoal = false;
    }
    var goal = null;
    if ( withGoal ) goal = layers.pop();

    if ( layers.length == 1 && !forceBezier ) controller = [ DuAEF.Duik.Rigging.oneLayerIK( layers[ 0 ], goal, controller ) ];
    else if ( layers.length == 2 && !forceBezier ) controller = [ DuAEF.Duik.Rigging.twoLayerIK( layers[ 0 ], layers[ 1 ], goal, controller ) ];
    else if ( layers.length == 3 && !forceBezier )
    {
        if ( threeAsOneAndTwo )
        {
            controller = DuAEF.Duik.Rigging.twoLayerIK( layers[ 1 ], layers[ 2 ], goal, controller );
            DuAEF.Duik.Rigging.oneLayerIK( layers[ 0 ], goal, controller );
            controller.layer.effect( DuAEF.Duik.PseudoEffects.ONELAYER_IK.matchName )( DuAEF.Duik.PseudoEffects.ONELAYER_IK.weightSlider ).setValue( 50 );
            controller = [ controller ];
        }
        else controller = [ DuAEF.Duik.Rigging.threeLayerIK( layers[ 0 ], layers[ 1 ], layers[ 2 ], goal, controller ) ];
    }
    else controller = DuAEF.Duik.Rigging.bezierIK( layers, goal, controller );

    return controller;
}

/**
 * Creates a one-layer-ik on the layer
 * @param {Layer} layer - The layer
 * @param {Layer|null} [goal] - The goal layer, at the end of the IK
 * @param {Layer|Controller|null} [controller] - The layer to use as a controller, can be automatically created.<br />
 * Must be provided if goal is undefined
 * @return {Controller} The controller created
 */
DuAEF.Duik.Rigging.oneLayerIK = function( layer, goal, controller )
{
    if ( goal == undefined ) goal = null;
    if ( controller == undefined ) controller = null;
    if ( controller == null && goal == null ) throw "You must provide either a goal layer or a controller";
    var comp = layer.containingComp;

    var drawGuides = true;

    //Create controller
    if ( controller == null )
    {
        var ctrlType = DuAEF.Duik.Controller.Types.TRANSFORM;
        if ( DuAEF.Duik.Controller.defaultType == DuAEF.Duik.Controller.Types.NULL ) ctrlType = DuAEF.Duik.Controller.Types.NULL;
        controller = DuAEF.Duik.Controller.create( comp, ctrlType, goal );
    }
    if ( !( controller instanceof Controller ) )
    {
        drawGuides = false;
        controller = new Controller( controller );
    }

    //is right ?
    var ctrlPos = DuAEF.DuAE.Layer.getWorldPos( controller.layer );
    var layerPos = DuAEF.DuAE.Layer.getWorldPos( layer );

    var right = ( ctrlPos[ 0 ] - layerPos[ 0 ] ) < 0;

    //Add Effect
    var name = layer.name;
    if ( goal != null ) name = goal.name;
    var ikEffect = DuAEF.Duik.PseudoEffects.ONELAYER_IK.apply( controller.layer, DuAEF.Duik.generateName( 'IK', name ) );
    if ( right ) ikEffect( 6 ).setValue( 1 );
    ikEffect( 9 ).setValue( layer.index );

    if ( DuAEF.DuAE.App.version >= 15 && controller.layer instanceof ShapeLayer && drawGuides )
    {
        var lineGroup = controller.layer( "ADBE Root Vectors Group" ).property( 'IK Line' );
        if ( !lineGroup )
        {
            lineGroup = controller.layer( "ADBE Root Vectors Group" ).addProperty( "ADBE Vector Group" );
            lineGroup.name = 'IK Line';
        }
        var lineContent = lineGroup.property( "ADBE Vectors Group" );
        var shape = lineContent.addProperty( "ADBE Vector Shape - Group" );
        shape( 'ADBE Vector Shape' ).expression = 'if (active){\n' +
            'var fx = effect("' + ikEffect.name + '");\n' +
            'var layer1 = null;\n' +
            'var result = [[0,0]];\n' +
            'if (fx(1).value && fx(12).value)\n' +
            '{\n' +
            'try{layer1 = fx(9);}catch(e){}\n' +
            'if (layer1!=null)\n' +
            '{\n' +
            'var l = layer1.toWorld(layer1.anchorPoint);\n' +
            'l = fromWorld(l);\n' +
            'result = [l,[0,0]];\n' +
            '}\n' +
            '}\n' +
            'createPath(result,[],[],false);\n' +
            '} else value;';
        var stroke = lineContent.property( "ADBE Vector Graphic - Stroke" );
        if ( !stroke ) stroke = lineContent.addProperty( "ADBE Vector Graphic - Stroke" );
        stroke( "ADBE Vector Stroke Color" ).expression = 'effect("Controller")(2)-[0.2,0.2,0.2,0]';
        stroke( "ADBE Vector Stroke Width" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Line Cap" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
        stroke( "ADBE Vector Stroke Dashes" )( "ADBE Vector Stroke Dash 1" ).setValue( 5 );
    }

    //Add Data
    var layerData = DuAEF.DuAE.Layer.addPseudoEffect( layer, DuAEF.Duik.PseudoEffects.IK, DuAEF.Duik.PseudoEffectsMatchNames.IK, "IK" );
    layerData( 1 ).setValue( controller.layer.index );
    //Expression
    var expr = '//Duik.oneLayerIK\n' +
        'var ctrl = null;\n' +
        'var result = value;\n' +
        'try { ctrl = effect("' + layerData.name + '")(1); } catch (e){ value };\n' +
        'if (ctrl != null)\n' +
        '{\n' +
        'var C = ctrl.toWorld( ctrl.anchorPoint );\n' +
        'var O =  thisLayer.toWorld( thisLayer.anchorPoint );\n' +
        'var fx = ctrl.effect("' + ikEffect.name + '");\n' +
        'W = fx(2).value/100;\n' +
        'FK = fx(3).value;\n' +
        'R = fx(6).value;\n' +
        'var useIK = fx(1).value;\n' +
        'var parentRot = fx(5).value;\n' +
        'result = value+FK;\n' +
        'if (useIK)\n' +
        '{\n' +
        'var vec = R == 1 ? O-C : C-O;\n' +
        'var layer = thisLayer;\n' +
        'if (layer.hasParent && parentRot) result += layer.parent.rotation.value;\n' +
        'while (layer.hasParent)\n' +
        '{\n' +
        'layer = layer.parent;\n' +
        'result = result - layer.rotation;\n' +
        '}\n' +
        'var angle = Math.atan2(vec[1], vec[0]);\n' +
        'angle = radiansToDegrees(angle);\n' +
        'angle = angle*W;\n' +
        'result += angle;\n' +
        '}\n' +
        '}\n' +
        'result;\n';

    DuAEF.DuAE.Property.setExpression( layer.transform.rotation, expr );

    if ( goal != null )
    {
        var goalData = DuAEF.DuAE.Layer.addPseudoEffect( goal, DuAEF.Duik.PseudoEffects.IK, DuAEF.Duik.PseudoEffectsMatchNames.IK, "IK" );
        goalData( 1 ).setValue( controller.layer.index );
        expr = '//Duik.oneLayerIK.goal\n' +
            'var ctrl = null;\n' +
            'var result = value;\n' +
            'try { ctrl = effect("' + goalData.name + '")(1); } catch (e){ value };\n' +
            'if (ctrl != null)\n' +
            '{\n' +
            'var goal = ctrl.effect("' + ikEffect.name + '")(1).value;\n' +
            'result += ctrl.rotation.value;\n' +
            'if (goal)\n' +
            '{\n' +
            'var layer = thisLayer;\n' +
            'while (layer.hasParent)\n' +
            '{\n' +
            'layer = layer.parent;\n' +
            'result = result - layer.rotation;\n' +
            '}\n' +
            '}\n' +
            '}\n' +
            'result;';
        DuAEF.DuAE.Property.setExpression( goal.transform.rotation, expr );
    }

    return controller;
}

/**
 * Creates a two-layer-ik on the layer
 * @param {Layer} layer1 - The root layer
 * @param {Layer} layer2 - The end layer
 * @param {Layer|null} [goal] - The goal layer, at the end of the IK
 * @param {Layer|Controller|null} [controller] - The layer to use as a controller, can be automatically created.<br />
 * Must be provided if goal is undefined
 * @return {Controller} The controller created
 */
DuAEF.Duik.Rigging.twoLayerIK = function( layer1, layer2, goal, controller )
{
    if ( goal == undefined ) goal = null;
    if ( controller == undefined ) controller = null;
    if ( controller == null && goal == null ) throw "You must provide either a goal layer or a controller";

    var comp = layer1.containingComp;

    var drawGuides = true;

    //Create controller
    if ( controller == null )
    {
        var ctrlType = DuAEF.Duik.Controller.Types.TRANSFORM;
        if ( DuAEF.Duik.Controller.defaultType == DuAEF.Duik.Controller.Types.NULL ) ctrlType = DuAEF.Duik.Controller.Types.NULL;
        controller = DuAEF.Duik.Controller.create( comp, ctrlType, goal );
        goal.parent = null;
        controller.layer.transform.rotation.setValue( goal.transform.rotation.value );
        goal.parent = layer2;
    }
    if ( !( controller instanceof Controller ) )
    {
        drawGuides = false;
        controller = new Controller( controller );
    }

    //Check if clockwise and lengths

    //unparent
    var rootParent = layer1.parent;
    layer1.parent = null;
    var middleParent = layer2.parent;
    layer2.parent = null;
    var endParent = controller.layer.parent;
    controller.layer.parent = null;

    var clockwise = false;

    var upperLength = DuAEF.DuJS.Math.getLength( layer1.transform.position.value, layer2.transform.position.value );
    var lowerLength = DuAEF.DuJS.Math.getLength( layer2.transform.position.value, controller.layer.transform.position.value );
    var endPos = controller.layer.transform.position.value - layer1.transform.position.value;
    var middlePos = layer2.transform.position.value - layer1.transform.position.value;
    if ( endPos[ 0 ] == 0 && endPos[ 1 ] > 0 && middlePos[ 0 ] > 0 ) clockwise = true;
    else if ( endPos[ 0 ] == 0 && endPos[ 1 ] < 0 && middlePos[ 0 ] < 0 ) clockwise = true;
    else
    {
        var coef = endPos[ 1 ] / endPos[ 0 ];
        if ( middlePos[ 1 ] < middlePos[ 0 ] * coef && endPos[ 0 ] > 0 ) clockwise = true;
        if ( middlePos[ 1 ] > middlePos[ 0 ] * coef && endPos[ 0 ] < 0 ) clockwise = true;
    }

    //reparent
    layer1.parent = rootParent;
    layer2.parent = middleParent;
    controller.layer.parent = endParent;


    //add effect
    var name = layer2.name;
    if ( goal != undefined ) name = goal.name;
    var ikEffect = DuAEF.Duik.PseudoEffects.TWOLAYER_IK.apply( controller.layer, DuAEF.Duik.generateName( 'IK', name ) );
    if ( clockwise ) ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.reverseCheckbox ).setValue( 1 );

    //set layers
    ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLayer ).setValue( layer1.index );
    ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLayer ).setValue( layer2.index );
    if ( goal != undefined ) ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalLayer ).setValue( goal.index );

    //set lengths
    ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLengthSlider ).setValue( upperLength );
    ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLengthSlider ).setValue( lowerLength );

    //rotation limit
    ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.fullRotationLimitAngle ).setValue( -180 );

    //inherit parent rotation
    ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.parentRotationCheckbox ).setValue( 1 );

    //get some useful coordinates
    var goalPos = [ 0, 0 ];
    if ( goal != null )
    {
        goalPos = goal.transform.position.value;
    }
    else
    {
        ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalPositionPoint ).expression = "thisComp.layer(" + layer2.index + ").fromWorld( thisComp.layer(" + controller.layer.index + ").position)";
        goalPos = ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalPositionPoint ).value;
        ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalPositionPoint ).expression = "";
    }
    DuAEF.DuAE.Property.setValue( ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalPositionPoint ), goalPos );
    var rootAp = layer1.transform.anchorPoint.value.toSource();
    var middleAp = layer2.transform.anchorPoint.value.toSource();
    var middlePos = layer2.transform.position.value.toSource();

    //add expressions
    ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperStretchSlider ).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
        'var layer1 = null;\n' +
        'var layer2 = null;\n' +
        'var result = 0;\n' +
        'try{layer1 = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLayer + ');layer2=fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLayer + ');}catch(e){}\n' +
        'if (layer1!=null)\n' +
        '{\n' +
        'newLength = length(layer1.toWorld(layer1.anchorPoint),layer2.toWorld(layer2.anchorPoint));\n' +
        'result = newLength - fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLengthSlider + ').value;\n' +
        '}\n' +
        'result;';

    ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperScaleSlider ).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
        'if (fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLengthSlider + ').value > 0)(fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperStretchSlider + ').value+fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLengthSlider + ').value)/fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLengthSlider + ').value*100; else 100;';

    ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerStretchSlider ).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
        'var layer2 = null;\n' +
        'var result = 0;\n' +
        'try{layer2=fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLayer + ');}catch(e){}\n' +
        'if (layer2!=null)\n' +
        '{\n' +
        'newLength = length(layer2.toWorld(fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalPositionPoint + ').value),layer2.toWorld(layer2.anchorPoint));\n' +
        'result = newLength - fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLengthSlider + ').value;\n' +
        '}\n' +
        'result;';

    ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerScaleSlider ).expression = 'var fx = effect("' + ikEffect.name + '"); if (fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLengthSlider + ').value > 0)(fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerStretchSlider + ').value+fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLengthSlider + ').value)/fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLengthSlider + ').value*100; else 100;';

    ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalPositionPoint ).expression = 'var result = value;\n' +
        'fx = effect("' + ikEffect.name + '");\n' +
        'layer1 = null;\n' +
        'try{layer1=fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLayer + ')}catch(e){}\n' +
        'if (layer1 != null)\n' +
        '{\n' +
        'stretch = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.stretchSlider + ');\n' +
        'auto = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.autoStretchCheckbox + ').value;\n' +
        'IK = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.ikCheckbox + ').value;\n' +
        'shrinkVal = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.autoShrinkSlider + ').value/100;\n' +
        'function getWorldPos(L){\n' +
        'return L.toWorld(L.anchorPoint);\n' +
        '}\n' +
        'dist1 = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLengthSlider + ').value;\n' +
        'dist2 = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLengthSlider + ').value;\n' +
        'IKLength = dist1+dist2;\n' +
        'IKStretched = IKLength+stretch;\n' +
        'boneStretch = 0;\n' +
        'proportion = dist2/(IKLength);\n' +
        'posC = toWorld(anchorPoint);\n' +
        'posR = getWorldPos(layer1);\n' +
        'distC = length(posC,posR);\n' +
        'shrinkMax = IKLength*shrinkVal;\n' +
        'shrink = 0;\n' +
        'if (distC < IKStretched && IK) shrink = 1-distC/IKStretched;\n' +
        'boneStretch -= easeOut(shrink,0,shrinkMax)*proportion;\n' +
        'if (distC > IKStretched && auto && IK) boneStretch += (distC-IKLength)*proportion;\n' +
        'else boneStretch += stretch*proportion;\n' +
        'coef = 1;\n' +
        'dist2 != 0 ? coef = (dist2+boneStretch)/dist2 : coef = 1;\n' +
        'result = (' + goalPos.toSource() + ' -' + middleAp + ')*coef+' + middleAp + ';\n' +
        '}\n' +
        'result;';

    ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalWorldPositionPoint ).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
        'var layer2 = null;\n' +
        'var result = [0,0];\n' +
        'try{layer2=fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLayer + ')}catch(e){}\n' +
        'if (layer2!=null)\n' +
        '{\n' +
        'result = layer2.toWorld(fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalPositionPoint + ').value);\n' +
        '}\n' +
        'result;';

    ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.ikLengthSlider ).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
        'var result = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLengthSlider + ').value + fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLengthSlider + ').value;\n' +
        'var goalPos = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalWorldPositionPoint + ').value;\n' +
        'var layer1 = null;\n' +
        'try{ layer1 = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLayer + '); } catch(e){}\n' +
        'if (layer1 != null)\n' +
        '{\n' +
        'result = length(layer1.toWorld(layer1.anchorPoint), goalPos);\n' +
        '}\n' +
        'result;';

    ikEffect( DuAEF.Duik.PseudoEffects.TWOLAYER_IK.straightCheckbox ).expression = 'fx = effect("' + ikEffect.name + '");\n' +
        'var layer1 = null;\n' +
        'var layer2 = null;\n' +
        'var result = false;\n' +
        'try{layer1 = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLayer + ');layer2=fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLayer + ');}catch(e){}\n' +
        'if (layer1!=null)\n' +
        '{\n' +
        'var a = layer1.toWorld(layer1.anchorPoint);\n' +
        'var b = layer2.toWorld(layer2.anchorPoint);\n' +
        'var c = layer2.toWorld(fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalPositionPoint + ').value);\n' +
        'result = Math.abs(a[0] * (b[1] - c[1]) + b[0] * (c[1] - a[1]) + c[0] * (a[1] - b[1])) < 1000;\n' +
        '}\n' +
        'result;';

    //add controller visual feedback
    if ( ( controller.layer instanceof ShapeLayer ) && drawGuides )
    {
        var ikGroup = controller.layer( "ADBE Root Vectors Group" ).addProperty( "ADBE Vector Group" );
        ikGroup.name = 'IK';
        var ikContent = ikGroup.property( "ADBE Vectors Group" );
        var shape = ikContent.addProperty( "ADBE Vector Shape - Group" );
        var ikShape = new Shape();
        ikShape.vertices = [
            [ -8, 16 ],
            [ 8, 16 ]
        ];
        ikShape.inTangents = [
            [ 0, 0 ],
            [ 0, 0 ]
        ];
        ikShape.outTangents = [
            [ 0, 0 ],
            [ 0, 0 ]
        ];
        ikShape.closed = false;
        shape( 'ADBE Vector Shape' ).setValue( ikShape );
        var stroke = ikContent.addProperty( "ADBE Vector Graphic - Stroke" );
        stroke( "ADBE Vector Stroke Color" ).expression = 'effect("Controller")(2)-[0.2,0.2,0.2,0]';
        stroke( "ADBE Vector Stroke Width" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Line Cap" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Opacity" ).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
            'if (fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.drawGuidesCheckbox + ').value) fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.straightCheckbox + ').value*100; else 0;';

        ikGroup.transform.scale.expression = '[effect("Controller")(4)*2,effect("Controller")(4)*2]';
        ikGroup.transform.position.expression = 'effect("Controller")(3)';
        ikGroup.transform.opacity.expression = 'effect("Controller")(6)';

        if ( DuAEF.DuAE.App.version >= 15 )
        {
            var lineGroup = controller.layer( "ADBE Root Vectors Group" ).property( 'IK Line' );
            if ( !lineGroup )
            {
                lineGroup = controller.layer( "ADBE Root Vectors Group" ).addProperty( "ADBE Vector Group" );
                lineGroup.name = 'IK Line';
            }
            var lineContent = lineGroup.property( "ADBE Vectors Group" );
            var shape = lineContent.addProperty( "ADBE Vector Shape - Group" );
            shape( 'ADBE Vector Shape' ).expression = 'if (active){\n' +
                'var fx = effect("' + ikEffect.name + '");\n' +
                'var layer1 = null;\n' +
                'var result = [[0,0]];\n' +
                'if (fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.ikCheckbox + ').value && fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.drawGuidesCheckbox + ').value)\n' +
                '{\n' +
                'try{layer1 = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLayer + ');}catch(e){}\n' +
                'if (layer1!=null)\n' +
                '{\n' +
                'var l = layer1.toWorld(layer1.anchorPoint);\n' +
                'l = fromWorld(l);\n' +
                'result = [l,[0,0]];\n' +
                '}\n' +
                '}\n' +
                'createPath(result,[],[],false);\n' +
                '} else value;';
            var stroke = lineContent.property( "ADBE Vector Graphic - Stroke" );
            if ( !stroke ) stroke = lineContent.addProperty( "ADBE Vector Graphic - Stroke" );
            stroke( "ADBE Vector Stroke Color" ).expression = 'effect("Controller")(2)-[0.2,0.2,0.2,0]';
            stroke( "ADBE Vector Stroke Width" ).setValue( 2 );
            stroke( "ADBE Vector Stroke Line Cap" ).setValue( 2 );
            stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
            stroke( "ADBE Vector Stroke Dashes" )( "ADBE Vector Stroke Dash 1" ).setValue( 5 );
        }
    }


    //setup layers
    var layer1Data = DuAEF.DuAE.Layer.addPseudoEffect( layer1, DuAEF.Duik.PseudoEffects.IK, DuAEF.Duik.PseudoEffectsMatchNames.IK, "IK" );
    layer1Data( 1 ).setValue( controller.layer.index );

    layer1.transform.rotation.expression = '//Duik.twoLayerIK\n' +
        'var controller = null;\n' +
        'var result = value;\n' +
        'try{controller=effect("' + layer1Data.name + '")(1)}catch(e){}\n' +
        'if (controller !=null)\n' +
        '{\n' +
        'var fx = controller.effect("' + ikEffect.name + '");\n' +
        'IKFK = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.ikCheckbox + ').value;\n' +
        'function ik() \n' +
        '{\n' +
        'layer1 = thisLayer;\n' +
        'layer2 = null;\n' +
        'try{ layer2 = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLayer + '); }  catch (e){return value;}\n' +
        'if (layer2 != null)\n' +
        '{\n' +
        'endPos = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalPositionPoint + ').value;\n' +
        'limit = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.fullRotationLimitAngle + ').value;\n' +
        'cw = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.reverseCheckbox + ').value;\n' +
        'function getWorldPos(L){\n' +
        'return L.toWorld(L.anchorPoint);\n' +
        '}\n' +
        'A = getWorldPos(layer1);\n' +
        'C = layer2.toWorld(endPos);\n' +
        'B = getWorldPos(layer2);\n' +
        'E = getWorldPos(controller);\n' +
        'a = length(B,C);\n' +
        'b = length(E,A);\n' +
        'c = length(A,B);\n' +
        'x = (b*b + c*c - a*a )/(2*b);\n' +
        'alpha = Math.acos(clamp(x/c,-1,1));\n' +
        'D = E - A;\n' +
        'delta = Math.atan2(D[1],D[0]);\n' +
        'result = radiansToDegrees(delta - (cw ? 1 : -1)*alpha);\n' +
        'V = B - A;\n' +
        'adj1 = radiansToDegrees(Math.atan2(V[1],V[0]));\n' +
        'IK = result - adj1 + value;\n' +
        'if (IK < limit) IK+=360;\n' +
        'return IK;\n' +
        '}\n' +
        '}\n' +
        'function fk() {\n' +
        'var follow = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.parentRotationCheckbox + ').value;\n' +
        'var FK = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperAngle + ').value + fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.fkAngle + ').value;\n' +
        'var p = thisLayer;\n' +
        'if (!follow)\n' +
        '{\n' +
        'while(p.hasParent)\n' +
        '{\n' +
        'p = p.parent;\n' +
        'FK -= p.rotation.value;\n' +
        '}\n' +
        '}\n' +
        'return FK;\n' +
        '}\n' +
        'result = IKFK ? ik() : fk();\n' +
        '}\n' +
        'result;';


    var layer2Data = DuAEF.DuAE.Layer.addPseudoEffect( layer2, DuAEF.Duik.PseudoEffects.IK, DuAEF.Duik.PseudoEffectsMatchNames.IK, "IK" );
    layer2Data( 1 ).setValue( controller.layer.index );


    layer2.transform.rotation.expression = '//Duik.twoLayerIK\n' +
        'var controller = null;\n' +
        'var result = value;\n' +
        'try{controller=effect("' + layer2Data.name + '")(1)}catch(e){}\n' +
        'if (controller !=null)\n' +
        '{\n' +
        'var fx = controller.effect("' + ikEffect.name + '");\n' +
        'IKFK = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.ikCheckbox + ').value;\n' +
        'layer1 = null;\n' +
        'layer2 = thisLayer;\n' +
        'try{ layer1 = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLayer + '); }  catch (e){}\n' +
        'if (layer1 != null)\n' +
        '{\n' +
        'function ik()\n' +
        '{\n' +
        'endPos = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalPositionPoint + ').value;\n' +
        'cw = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.reverseCheckbox + ').value;\n' +
        'function getWorldPos(L)\n' +
        '{\n' +
        '	return L.toWorld(L.anchorPoint);\n' +
        '}\n' +
        'A = getWorldPos(layer1);\n' +
        'B = getWorldPos(layer2);\n' +
        'C = layer2.toWorld(endPos);\n' +
        'E = getWorldPos(controller);\n' +
        'a = length(B,C);\n' +
        'b = length(E,A);\n' +
        'c = length(A,B);\n' +
        'x = (b*b + c*c - a*a )/(2*b);\n' +
        'alpha = Math.acos(clamp(x/c,-1,1));\n' +
        'y = b - x;\n' +
        'gamma = Math.acos(clamp(y/a,-1,1));\n' +
        'result = (cw ? 1 : -1)*radiansToDegrees(gamma + alpha);  V1 = B - A;\n' +
        'adj1 = radiansToDegrees(Math.atan2(V1[1],V1[0]));\n' +
        'V2 = C - B;\n' +
        'adj2 = radiansToDegrees(Math.atan2(V2[1],V2[0]));\n' +
        'IK = result +  adj1 - adj2 + value;\n' +
        'return IK % 360;\n' +
        '}\n' +
        'function fk()\n' +
        '{\n' +
        'var ctrlRot = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.fkAngle + ');\n' +
        'var delay = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.resistanceSlider + ').value ;\n' +
        'var amp = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.flexibilitySlider + ').value ;\n' +
        'var follow = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.parentRotationCheckbox + ').value;\n' +
        'var ftEnabled = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.followThroughCheckbox + ').value;\n' +
        'if (!ftEnabled)\n' +
        '{\n' +
        'amp = 0;\n' +
        'delay = 0;\n' +
        '}\n' +
        'else\n' +
        '{\n' +
        'delay = delay / 100;\n' +
        'amp = amp / 100 ;\n' +
        '}\n' +
        'FK = ctrlRot.valueAtTime(time-delay);\n' +
        'if (follow && hasParent)\n' +
        '{\n' +
        'var cP = layer1;\n' +
        'while(cP.hasParent)\n' +
        '{\n' +
        'cP = cP.parent;\n' +
        'FK -= cP.rotation.value - cP.rotation.valueAtTime(time-delay);\n' +
        '}\n' +
        '}\n' +
        'FK = FK - ctrlRot.value ;\n' +
        'FK = FK * amp;\n' +
        'FK = FK - ctrlRot.velocity*(delay/5);\n' +
        'FK += fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerAngle + ').value;\n' +
        'return FK;\n' +
        '}\n' +
        'result = IKFK ? ik() : fk();\n' +
        '}\n' +
        '}\n' +
        'result;';

    layer2.transform.position.expression = '//Duik.twoLayerIK.stretch\n' +
        'var ctrl = null;\n' +
        'var result = value;\n' +
        'try { ctrl = effect("' + layer2Data.name + '")(1); } catch (e){ value };\n' +
        'if (ctrl != null)\n' +
        '{\n' +
        'fx = ctrl.effect("' + ikEffect.name + '");\n' +
        'layer1 = null;\n' +
        'result = [211, 25];\n' +
        'try{layer1=fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLayer + ')}catch(e){}\n' +
        'if (layer1 != null)\n' +
        '{\n' +
        'stretch = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.stretchSlider + ').value;\n' +
        'auto = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.autoStretchCheckbox + ').value;\n' +
        'IK = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.ikCheckbox + ').value;\n' +
        'shrinkVal = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.autoShrinkSlider + ').value/100;\n' +
        'function getWorldPos(L){\n' +
        'return L.toWorld(L.anchorPoint);\n' +
        '}\n' +
        'dist1 = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLengthSlider + ').value;\n' +
        'dist2 = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLengthSlider + ').value;\n' +
        'IKLength = dist1+dist2;\n' +
        'IKStretched = IKLength+stretch;\n' +
        'boneStretch = 0;\n' +
        'proportion = dist1/(IKLength);\n' +
        'posC = getWorldPos(ctrl);\n' +
        'posR = getWorldPos(layer1);\n' +
        'distC = length(posC,posR);\n' +
        'shrinkMax = IKLength*shrinkVal;\n' +
        'shrink = 0;\n' +
        'if (distC < IKStretched && IK) shrink = 1-distC/IKStretched;\n' +
        'boneStretch -= easeOut(shrink,0,shrinkMax)*proportion;\n' +
        'if (distC > IKStretched && auto && IK) boneStretch += (distC-IKLength)*proportion;\n' +
        'else boneStretch += stretch*proportion;\n' +
        'coef = 1;\n' +
        'dist1 != 0 ? coef = (dist1+boneStretch)/dist1 : coef = 1;\n' +
        'result = (' + middlePos + ' -' + rootAp + ')*coef+' + rootAp + ';\n' +
        '}\n' +
        '}\n' +
        'result;';

    if ( goal != null )
    {
        var goalData = DuAEF.DuAE.Layer.addPseudoEffect( goal, DuAEF.Duik.PseudoEffects.IK, DuAEF.Duik.PseudoEffectsMatchNames.IK, "IK" );
        goalData( 1 ).setValue( controller.layer.index );

        var rotExpr = '//Duik.goal\n' +
            'var ctrl = null;\n' +
            'try { ctrl = effect("' + goalData.name + '")(1); } catch (e){};\n' +
            'if (ctrl != null)\n' +
            '{\n' +
            'var fx = ctrl.effect("' + ikEffect.name + '");\n' +
            'var ikfk = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.ikCheckbox + ').value;\n' +
            'function ik()\n' +
            '{\n' +
            'var IK = ctrl.rotation.value;\n' +
            'var layer = thisLayer;\n' +
            'while (layer.hasParent)\n' +
            '{\n' +
            'layer = layer.parent;\n' +
            'IK = IK - layer.rotation;\n' +
            '}\n' +
            'return IK;\n' +
            '}\n' +
            'function fk()\n' +
            '{\n' +
            'var FK = value;\n' +
            'var parentRot = parent.transform.rotation ;\n' +
            'var delay = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.resistanceSlider + ').value ;\n' +
            'var amp = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.flexibilitySlider + ').value ;\n' +
            'var ftEnabled = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.followThroughCheckbox + ').value;\n' +
            'if (!ftEnabled)\n' +
            '{\n' +
            'amp = 0;\n' +
            'delay = 0;\n' +
            '}\n' +
            'else\n' +
            '{\n' +
            'delay = delay / 100;\n' +
            'amp = amp / 100 ;\n' +
            '}\n' +
            'FK = parentRot.valueAtTime(time-delay);\n' +
            'FK = FK * amp;\n' +
            'FK = FK + value + fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalAngle + ') - parentRot.valueAtTime(0);\n' +
            'return FK;\n' +
            '}\n' +
            'ikfk ? ik() : fk();\n' +
            '}\n' +
            'else value;\n';


        DuAEF.DuAE.Property.setExpression( goal.transform.rotation, rotExpr );

        goal.transform.position.expression = 'var ctrl = null;\n' +
            'var result = value;\n' +
            'try { ctrl = effect("' + goalData.name + '")(1); } catch (e){ value };\n' +
            'if (ctrl != null)\n' +
            '{\n' +
            'result = ctrl.effect("' + ikEffect.name + '")(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalPositionPoint + ').value;\n' +
            '}\n' +
            'result;';
    }

    return controller;
}

/**
 * Creates a three-layer-ik on the layer
 * @param {Layer} layer1 - The root layer
 * @param {Layer} layer2 - The middle layer
 * @param {Layer} layer3 - The end layer
 * @param {Layer|null} [goal] - The goal layer, at the end of the IK
 * @param {Layer|Controller|null} [controller] - The layer to use as a controller, can be automatically created.<br />
 * Must be provided if goal is undefined
 * @return {Controller} The controller created
 */
DuAEF.Duik.Rigging.threeLayerIK = function( layer1, layer2, layer3, goal, controller )
{
    if ( goal == undefined ) goal = null;
    if ( controller == undefined ) controller = null;
    if ( controller == null && goal == null ) throw "You must provide either a goal layer or a controller";

    var comp = layer1.containingComp;

    //Create controller
    if ( controller == null )
    {
        var ctrlType = DuAEF.Duik.Controller.Types.TRANSFORM;
        if ( DuAEF.Duik.Controller.defaultType == DuAEF.Duik.Controller.Types.NULL ) ctrlType = DuAEF.Duik.Controller.Types.NULL;
        controller = DuAEF.Duik.Controller.create( comp, ctrlType, goal );
        goal.parent = null;
        controller.layer.transform.rotation.setValue( goal.transform.rotation.value );
        goal.parent = layer3;
    }
    if ( !( controller instanceof Controller ) ) controller = new Controller( controller );

    //Check if clockwise and lengths

    //unparent
    var rootParent = layer1.parent;
    layer1.parent = null;
    var middleParent = layer2.parent;
    layer2.parent = null;
    var endParent = controller.layer.parent;
    controller.layer.parent = null;

    var upperLength = DuAEF.DuJS.Math.getLength( layer1.transform.position.value, layer2.transform.position.value );
    var lowerLength = DuAEF.DuAE.Layer.getDistance( layer3, controller.layer );
    var middleLength = DuAEF.DuAE.Layer.getDistance( layer3, layer2 );
    var endPos = controller.layer.transform.position.value - layer1.transform.position.value;
    var middlePos = layer2.transform.position.value - layer1.transform.position.value;
    var coef = endPos[ 1 ] / endPos[ 0 ];

    var clockwise = false;
    if ( middlePos[ 1 ] < middlePos[ 0 ] * coef && endPos[ 0 ] > 0 ) clockwise = true;
    if ( middlePos[ 1 ] > middlePos[ 0 ] * coef && endPos[ 0 ] < 0 ) clockwise = true;

    //reparent
    layer1.parent = rootParent;
    layer2.parent = middleParent;
    controller.layer.parent = endParent;


    //add effect
    var name = layer3.name;
    if ( goal != undefined ) name = goal.name;
    var ikEffect = DuAEF.Duik.PseudoEffects.THREELAYER_IK.apply( controller.layer, DuAEF.Duik.generateName( 'IK', name ) );
    if ( clockwise ) ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.reverseCheckbox ).setValue( 1 );

    //set layers
    ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLayer ).setValue( layer1.index );
    ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLayer ).setValue( layer2.index );
    ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLayer ).setValue( layer3.index );
    if ( goal != undefined ) ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalLayer ).setValue( goal.index );

    //set lengths
    ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLengthSlider ).setValue( upperLength );
    ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLengthSlider ).setValue( middleLength );
    ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLengthSlider ).setValue( lowerLength );

    //rotation limit
    ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.fullRotationLimitAngle ).setValue( -180 );

    //get some useful coordinates
    var goalPos = [ 0, 0 ];
    if ( goal != null )
    {
        goalPos = goal.transform.position.value;
    }
    else
    {
        ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalPositionPoint ).expression = "thisComp.layer(" + layer3.index + ").fromWorld( thisComp.layer(" + controller.layer.index + ").position)";
        goalPos = ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalPositionPoint ).value;
        ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalPositionPoint ).expression = "";
    }
    DuAEF.DuAE.Property.setValue( ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalPositionPoint ), goalPos );
    var rootAp = layer1.transform.anchorPoint.value.toSource();
    var middleAp = layer2.transform.anchorPoint.value.toSource();
    var lowerAp = layer3.transform.anchorPoint.value.toSource();
    var middlePos = layer2.transform.position.value.toSource();
    var lowerPos = layer3.transform.position.value.toSource();

    //add expressions
    ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperStretchSlider ).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
        'var layer1 = null;\n' +
        'var layer2 = null;\n' +
        'var result = 0;\n' +
        'try{layer1 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLayer + ');layer2=fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLayer + ');}catch(e){}\n' +
        'if (layer1!=null)\n' +
        '{\n' +
        'newLength = length(layer1.toWorld(layer1.anchorPoint),layer2.toWorld(layer2.anchorPoint));\n' +
        'result = newLength - fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLengthSlider + ').value;\n' +
        '}\n' +
        'result;';

    ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleStretchSlider ).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
        'var layer2 = null;\n' +
        'var layer3 = null;\n' +
        'var result = 0;\n' +
        'try{layer3 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLayer + ');layer2=fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLayer + ');}catch(e){}\n' +
        'if (layer3!=null)\n' +
        '{\n' +
        'newLength = length(layer2.toWorld(layer2.anchorPoint),layer3.toWorld(layer3.anchorPoint));\n' +
        'result = newLength - fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLengthSlider + ').value;\n' +
        '}\n' +
        'result;';

    ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerStretchSlider ).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
        'var layer3 = null;\n' +
        'var result = 0;\n' +
        'try{layer3=fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLayer + ');}catch(e){}\n' +
        'if (layer3!=null)\n' +
        '{\n' +
        'newLength = length( fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalWorldPositionPoint + ').value , layer3.toWorld(layer3.anchorPoint));\n' +
        'result = newLength - fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLengthSlider + ').value;\n' +
        '}\n' +
        'result;';

    ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.stretchScaleSlider ).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
        'result = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperStretchSlider + ').value + fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleStretchSlider + ').value + fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerStretchSlider + ').value;\n' +
        'var o = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLengthSlider + ').value + fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLengthSlider + ').value + fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLengthSlider + ').value;\n' +
        'result += o;\n' +
        'result = result / o * 100;';

    ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalPositionPoint ).expression = 'var result = value;\n' +
        'fx = effect("' + ikEffect.name + '");\n' +
        'layer1 = null;\n' +
        'try{layer1=fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLayer + ')}catch(e){}\n' +
        'if (layer1 != null)\n' +
        '{\n' +
        'stretch = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.stretchSlider + ').value;\n' +
        'auto = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.autoStretchCheckbox + ').value;\n' +
        'IK = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.ikCheckbox + ').value;\n' +
        'shrinkVal = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.autoShrinkSlider + ').value/100;\n' +
        'function getWorldPos(L){\n' +
        'return L.toWorld(L.anchorPoint);\n' +
        '}\n' +
        'var upperAP = ' + rootAp + ';\n' +
        'var middlePos = ' + middlePos + ';\n' +
        'var middleAP = ' + middleAp + ';\n' +
        'var lowerPos = ' + lowerPos + ';\n' +
        'var lowerAP = ' + lowerAp + ';\n' +
        'var zeroPos = ' + goalPos.toSource() + ';\n' +
        'dist1 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLengthSlider + ');\n' +
        'dist2 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLengthSlider + ');\n' +
        'dist3 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLengthSlider + ');\n' +
        'IKLength = dist1+dist2+dist3;\n' +
        'IKStretched = IKLength+stretch;\n' +
        'boneStretch = 0;\n' +
        'proportion = dist3/(IKLength);\n' +
        'posC = toWorld(anchorPoint);\n' +
        'posR = getWorldPos(layer1);\n' +
        'distC = length(posC,posR);\n' +
        'shrinkMax = IKLength*shrinkVal;\n' +
        'shrink = 0;\n' +
        'if (distC < IKStretched && IK) shrink = 1-distC/IKStretched;\n' +
        'boneStretch -= easeOut(shrink,0,shrinkMax)*proportion;\n' +
        'if (distC > IKStretched && auto && IK) boneStretch += (distC-IKLength)*proportion;\n' +
        'else boneStretch += stretch*proportion;\n' +
        'coef = 1;\n' +
        'dist3 != 0 ? coef = (dist3+boneStretch)/dist3 : coef = 1;\n' +
        'result = (middlePos-upperAP)*coef+upperAP;\n' +
        '}\n' +
        'result;';

    ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalWorldPositionPoint ).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
        'var layer3 = null;\n' +
        'var result = [0,0];\n' +
        'try{layer3=fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLayer + ')}catch(e){}\n' +
        'if (layer3!=null)\n' +
        '{\n' +
        'result = layer3.toWorld(fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalPositionPoint + ').value);\n' +
        '}\n' +
        'result;';

    ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.ikLengthSlider ).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
        'var result = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLengthSlider + ').value + fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLengthSlider + ').value + fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLengthSlider + ').value;\n' +
        'var goalPos = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalWorldPositionPoint + ').value;\n' +
        'var layer1 = null;\n' +
        'try{ layer1 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLayer + '); } catch(e){}\n' +
        'if (layer1 != null)\n' +
        '{\n' +
        'result = length(layer1.toWorld(layer1.anchorPoint), goalPos);\n' +
        '}\n' +
        'result;';

    ikEffect( DuAEF.Duik.PseudoEffects.THREELAYER_IK.straightCheckbox ).expression = 'fx = effect("' + ikEffect.name + '");\n' +
        'var layer1 = null;\n' +
        'var layer2 = null;\n' +
        'var layer3 = null;\n' +
        'var result = false;\n' +
        'try{layer1 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLayer + ');layer2=fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLayer + ');layer3=fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLayer + ');}catch(e){}\n' +
        'if (layer1!=null)\n' +
        '{\n' +
        'var a = layer1.toWorld(layer1.anchorPoint);\n' +
        'var b = layer2.toWorld(layer2.anchorPoint);\n' +
        'var c = layer3.toWorld(layer3.anchorPoint);\n' +
        'result = Math.abs(a[0] * (b[1] - c[1]) + b[0] * (c[1] - a[1]) + c[0] * (a[1] - b[1])) < 10 ;\n' +
        '}\n' +
        'result;';

    //add controller visual feedback
    if ( controller.layer instanceof ShapeLayer )
    {
        var ikGroup = controller.layer( "ADBE Root Vectors Group" ).addProperty( "ADBE Vector Group" );
        ikGroup.name = 'IK';
        var ikContent = ikGroup.property( "ADBE Vectors Group" );
        var shape = ikContent.addProperty( "ADBE Vector Shape - Group" );
        var ikShape = new Shape();
        ikShape.vertices = [
            [ -8, 16 ],
            [ 8, 16 ]
        ];
        ikShape.inTangents = [
            [ 0, 0 ],
            [ 0, 0 ]
        ];
        ikShape.outTangents = [
            [ 0, 0 ],
            [ 0, 0 ]
        ];
        ikShape.closed = false;
        shape( 'ADBE Vector Shape' ).setValue( ikShape );
        var stroke = ikContent.addProperty( "ADBE Vector Graphic - Stroke" );
        stroke( "ADBE Vector Stroke Color" ).expression = 'effect("Controller")(2)-[0.2,0.2,0.2,0]';
        stroke( "ADBE Vector Stroke Width" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Line Cap" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Opacity" ).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
            'if (fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.drawGuidesCheckbox + ').value) fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.straightCheckbox + ').value*100; else 0;';

        ikGroup.transform.scale.expression = '[effect("Controller")(4)*2,effect("Controller")(4)*2]';
        ikGroup.transform.position.expression = 'effect("Controller")(3)';
        ikGroup.transform.opacity.expression = 'effect("Controller")(6)';

        if ( DuAEF.DuAE.App.version >= 15 )
        {
            var lineGroup = controller.layer( "ADBE Root Vectors Group" ).property( 'IK Line' );
            if ( !lineGroup )
            {
                lineGroup = controller.layer( "ADBE Root Vectors Group" ).addProperty( "ADBE Vector Group" );
                lineGroup.name = 'IK Line';
            }
            var lineContent = lineGroup.property( "ADBE Vectors Group" );
            var shape = lineContent.addProperty( "ADBE Vector Shape - Group" );
            shape( 'ADBE Vector Shape' ).expression = 'if (active){\n' +
                'var fx = effect("' + ikEffect.name + '");\n' +
                'var layer1 = null;\n' +
                'var result = [[0,0]];\n' +
                'if (fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.ikCheckbox + ').value && fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.drawGuidesCheckbox + ').value)\n' +
                '{\n' +
                'try{layer1 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLayer + ');}catch(e){}\n' +
                'if (layer1!=null)\n' +
                '{\n' +
                'var l = layer1.toWorld(layer1.anchorPoint);\n' +
                'l = fromWorld(l);\n' +
                'result = [l,[0,0]];\n' +
                '}\n' +
                '}\n' +
                'createPath(result,[],[],false);\n' +
                '} else value;';
            var stroke = lineContent.property( "ADBE Vector Graphic - Stroke" );
            if ( !stroke ) stroke = lineContent.addProperty( "ADBE Vector Graphic - Stroke" );
            stroke( "ADBE Vector Stroke Color" ).expression = 'effect("Controller")(2)-[0.2,0.2,0.2,0]';
            stroke( "ADBE Vector Stroke Width" ).setValue( 2 );
            stroke( "ADBE Vector Stroke Line Cap" ).setValue( 2 );
            stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
            stroke( "ADBE Vector Stroke Dashes" )( "ADBE Vector Stroke Dash 1" ).setValue( 5 );
        }
    }

    //setup layers
    var layer1Data = DuAEF.DuAE.Layer.addPseudoEffect( layer1, DuAEF.Duik.PseudoEffects.IK, DuAEF.Duik.PseudoEffectsMatchNames.IK, "IK" );
    layer1Data( 1 ).setValue( controller.layer.index );

    layer1.transform.rotation.expression = '//Duik.threeLayerIK\n' +
        'var controller = null;\n' +
        'var result = value;\n' +
        'try{controller=effect("' + layer1Data.name + '")(1)}catch(e){}\n' +
        'if (controller !=null)\n' +
        '{\n' +
        'var fx = controller.effect("' + ikEffect.name + '");\n' +
        'IKFK = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.ikCheckbox + ').value;\n' +
        'layer1 = thisLayer;\n' +
        'layer2 = null;\n' +
        'layer3 = null;\n' +
        'try{ layer2 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLayer + '); layer3 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLayer + '); }  catch (e){}\n' +
        'if (layer1 != null)\n' +
        '{\n' +
        'function ik()\n' +
        '{\n' +
        'endPos = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalPositionPoint + ').value;\n' +
        'cw = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.reverseCheckbox + ').value;\n' +
        'limit = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.fullRotationLimitAngle + ').value;\n' +
        'function getWorldPos(layer)\n' +
        '{\n' +
        'return layer.toWorld(layer.anchorPoint);\n' +
        '}\n' +
        'function sq(result)\n' +
        '{\n' +
        'return result*result;\n' +
        '}\n' +
        'function getAngle(p1,p2)\n' +
        '{\n' +
        'var dist = p2-p1;\n' +
        'var angle = Math.atan2(dist[1],dist[0]);\n' +
        'return radiansToDegrees(angle);\n' +
        '}\n' +
        'var uPos = getWorldPos(layer1);\n' +
        'var mPos = getWorldPos(layer2);\n' +
        'var cPos = getWorldPos(controller);\n' +
        'var uLength = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLengthSlider + ').value\n' +
        'var mLength = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLengthSlider + ').value;\n' +
        'var lLength = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLengthSlider + ').value;\n' +
        'var ikLength = length(uPos,cPos);\n' +
        'if (ikLength == 0) ikLength = 1;\n' +
        'var d1 = sq(mLength) - sq(ikLength) - sq(uLength-lLength);\n' +
        'var d2 = sq(ikLength) * (uLength+lLength);\n' +
        'var d3 = -sq(ikLength) * uLength * lLength;\n' +
        'var d4 = (-d2 - Math.sqrt( sq(d2) - 4*d1*d3 )) / (2*d1);\n' +
        'var baseA = Math.acos(clamp(ikLength/(2*d4),-1,1));\n' +
        'var upperA = cw ? -baseA : baseA ;\n' +
        'upperA = radiansToDegrees(upperA);\n' +
        'var uToC =getAngle(uPos,cPos);\n' +
        'var uToM =getAngle(uPos,mPos);\n' +
        'var ikResult = upperA + uToC - uToM;\n' +
        'if (ikResult < limit) ikResult +=360;\n' +
        'return ikResult;\n' +
        '}\n' +
        'function fk()\n' +
        '{\n' +
        'var FK = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperAngle + ').value;\n' +
        'FK += fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.fkAngle + ').value;\n' +
        'var follow = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.parentRotationCheckbox + ').value;\n' +
        'var p = thisLayer;\n' +
        'if (!follow)\n' +
        '{\n' +
        'while(p.hasParent)\n' +
        '{\n' +
        'p = p.parent;\n' +
        'FK -= p.rotation.value;\n' +
        '}\n' +
        '}\n' +
        'return FK;\n' +
        '}\n' +
        'IKFK ? result += ik() : result += fk();\n' +
        '}\n' +
        '}\n' +
        'result;\n';

    var layer2Data = DuAEF.DuAE.Layer.addPseudoEffect( layer2, DuAEF.Duik.PseudoEffects.IK, DuAEF.Duik.PseudoEffectsMatchNames.IK, "IK" );
    layer2Data( 1 ).setValue( controller.layer.index );

    layer2.transform.rotation.expression = '//Duik.threeLayerIK\n' +
        'var controller = null;\n' +
        'var result = value;\n' +
        'try{controller=effect("' + layer2Data.name + '")(1)}catch(e){}\n' +
        'if (controller !=null)\n' +
        '{\n' +
        'var fx = controller.effect("' + ikEffect.name + '");\n' +
        'IKFK = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.ikCheckbox + ').value;\n' +
        'layer1 = null;\n' +
        'layer2 = thisLayer;\n' +
        'layer3 = null;\n' +
        'try{ layer1 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLayer + '); layer3 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLayer + '); }  catch (e){}\n' +
        'if (layer1 != null)\n' +
        '{\n' +
        'function ik()\n' +
        '{\n' +
        'endPos = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalPositionPoint + ').value;\n' +
        'FK = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleAngle + ').value;\n' +
        'cw = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.reverseCheckbox + ').value;\n' +
        'function getWorldPos(layer)\n' +
        '{\n' +
        'return layer.toWorld(layer.anchorPoint);\n' +
        '}\n' +
        'function sq(result)\n' +
        '{\n' +
        'return result*result;\n' +
        '}\n' +
        'function getAngle(p1,p2)\n' +
        '{\n' +
        'var dist = p2-p1;\n' +
        'var angle = Math.atan2(dist[1],dist[0]);\n' +
        'return radiansToDegrees(angle);\n' +
        '}\n' +
        'var uPos = getWorldPos(layer1);\n' +
        'var mPos = getWorldPos(layer2);\n' +
        'var lPos = getWorldPos(layer3);\n' +
        'var cPos = getWorldPos(controller);\n' +
        'var uLength = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLengthSlider + ').value\n' +
        'var mLength = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLengthSlider + ').value;\n' +
        'var lLength = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLengthSlider + ').value;\n' +
        'var ikLength = length(uPos,cPos);\n' +
        'if (ikLength == 0) ikLength = 1;\n' +
        'var d1 = sq(mLength) - sq(ikLength) - sq(uLength-lLength);\n' +
        'var d2 = sq(ikLength) * (uLength+lLength);\n' +
        'var d3 = -sq(ikLength) * uLength * lLength;\n' +
        'var d4 = (-d2 - Math.sqrt( sq(d2) - 4*d1*d3 )) / (2*d1);\n' +
        'var baseA = Math.acos(clamp(ikLength/(2*d4),-1,1));\n' +
        'var d5 = Math.sqrt( sq(ikLength) + sq(lLength) - 2*ikLength*lLength*Math.cos(baseA));\n' +
        'var middleA = Math.acos(clamp((sq(d5)-sq(uLength)-sq(mLength)) / (-2*uLength*mLength),-1,1));\n' +
        'middleA = cw ? -middleA : middleA ;\n' +
        'middleA = radiansToDegrees(middleA);\n' +
        'var uToM =getAngle(uPos,mPos);\n' +
        'var mToL =getAngle(mPos,lPos);\n' +
        'var ikResult = middleA + uToM - mToL +180;\n' +
        'return ikResult % 360;\n' +
        '}\n' +
        'function fk()\n' +
        '{\n' +
        'var ctrlRot = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.fkAngle + ');\n' +
        'var delay = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.resistanceSlider + ').value;\n' +
        'var amp = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.flexibilitySlider + ').value;\n' +
        'var manual = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleAngle + ').value;\n' +
        'var follow = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.parentRotationCheckbox + ').value;\n' +
        'var ftEnabled = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.followThroughCheckbox + ').value;\n' +
        'if (!ftEnabled)\n' +
        '{\n' +
        'amp = 0;\n' +
        'delay = 0;\n' +
        '}\n' +
        'else\n' +
        '{\n' +
        'delay = delay / 100;\n' +
        'amp = amp / 100 ;\n' +
        '}\n' +
        'var FK = ctrlRot.valueAtTime(time-delay);\n' +
        'if (follow && hasParent)\n' +
        '{\n' +
        'var cP = parent;\n' +
        'while(cP.hasParent)\n' +
        '{\n' +
        'cP = cP.parent;\n' +
        'if (cP.index = controller.index) follow = false;\n' +
        'FK -= cP.rotation.value - cP.rotation.valueAtTime(time-delay) ;\n' +
        '}\n' +
        '}\n' +
        'FK = FK - ctrlRot.value ;\n' +
        'FK = FK * amp;\n' +
        'FK = FK - ctrlRot.velocity*(delay/5);\n' +
        'if (follow) result -= parent.transform.rotation.valueAtTime(0);\n' +
        'FK += manual;\n' +
        'return FK;\n' +
        '}\n' +
        'IKFK ? result += ik() : result += fk();\n' +
        '}\n' +
        '}\n' +
        'result;\n';

    layer2.transform.position.expression = '//Duik.threeLayerIK.stretch\n' +
        'var controller = null;\n' +
        'var result = value;\n' +
        'try { controller = effect("' + layer2Data.name + '")(1); } catch (e){ value };\n' +
        'if (controller != null)\n' +
        '{\n' +
        'fx = controller.effect("' + ikEffect.name + '");\n' +
        'layer1 = null;\n' +
        'try{layer1=fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLayer + ')}catch(e){}\n' +
        'if (layer1 != null)\n' +
        '{\n' +
        'stretch = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.stretchSlider + ').value;\n' +
        'auto = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.autoStretchCheckbox + ').value;\n' +
        'IK = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.ikCheckbox + ').value;\n' +
        'shrinkVal = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.autoShrinkSlider + ').value/100;\n' +
        'function getWorldPos(L){\n' +
        'return L.toWorld(L.anchorPoint);\n' +
        '}\n' +
        'var upperAP = ' + rootAp + ';\n' +
        'var middlePos = ' + middlePos + ';\n' +
        'var middleAP = ' + middleAp + ';\n' +
        'var lowerPos = ' + lowerPos + ';\n' +
        'var lowerAP = ' + lowerAp + ';\n' +
        'var zeroPos = ' + goalPos.toSource() + ';\n' +
        'dist1 = length(upperAP,middlePos);\n' +
        'dist2 = length(middleAP,lowerPos);\n' +
        'dist3 = length(lowerAP,zeroPos);\n' +
        'IKLength = dist1+dist2+dist3;\n' +
        'IKStretched = IKLength+stretch;\n' +
        'boneStretch = 0;\n' +
        'proportion = dist1/(IKLength);\n' +
        'posC = getWorldPos(controller);\n' +
        'posR = getWorldPos(layer1);\n' +
        'distC = length(posC,posR);\n' +
        'shrinkMax = IKLength*shrinkVal;\n' +
        'shrink = 0;\n' +
        'if (distC < IKStretched && IK) shrink = 1-distC/IKStretched;\n' +
        'boneStretch -= easeOut(shrink,0,shrinkMax)*proportion;\n' +
        'if (distC > IKStretched && auto && IK) boneStretch += (distC-IKLength)*proportion;\n' +
        'else boneStretch += stretch*proportion;\n' +
        'coef = 1;\n' +
        'dist1 != 0 ? coef = (dist1+boneStretch)/dist1 : coef = 1;\n' +
        'result = (middlePos-upperAP)*coef+upperAP;\n' +
        '}\n' +
        '}\n' +
        'result;';


    var layer3Data = DuAEF.DuAE.Layer.addPseudoEffect( layer3, DuAEF.Duik.PseudoEffects.IK, DuAEF.Duik.PseudoEffectsMatchNames.IK, "IK" );
    layer3Data( 1 ).setValue( controller.layer.index );

    layer3.transform.rotation.expression = '//Duik.threeLayerIK\n' +
        'var controller = null;\n' +
        'var result = value;\n' +
        'try{controller=effect("' + layer3Data.name + '")(1)}catch(e){}\n' +
        'if (controller !=null)\n' +
        '{\n' +
        'var fx = controller.effect("' + ikEffect.name + '");\n' +
        'IKFK = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.ikCheckbox + ').value;\n' +
        'layer1 = null;\n' +
        'layer2 = null;\n' +
        'layer3 = thisLayer;\n' +
        'try{ layer1 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLayer + '); layer2 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLayer + '); }  catch (e){}\n' +
        'if (layer1 != null)\n' +
        '{\n' +
        'function ik()\n' +
        '{\n' +
        'endPos = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalPositionPoint + ').value;\n' +
        'cw = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.reverseCheckbox + ').value;\n' +
        'function getWorldPos(layer)\n' +
        '{\n' +
        'return layer.toWorld(layer.anchorPoint);\n' +
        '}\n' +
        'function sq(result)\n' +
        '{\n' +
        'return result*result;\n' +
        '}\n' +
        'function getAngle(p1,p2)\n' +
        '{\n' +
        'var dist = p2-p1;\n' +
        'var angle = Math.atan2(dist[1],dist[0]);\n' +
        'return radiansToDegrees(angle);\n' +
        '}\n' +
        'var uPos = getWorldPos(layer1);\n' +
        'var mPos = getWorldPos(layer2);\n' +
        'var lPos = getWorldPos(layer3);\n' +
        'var zPos = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalWorldPositionPoint + ').value;\n' +
        'var cPos = getWorldPos(controller);\n' +
        'var uLength = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLengthSlider + ').value\n' +
        'var mLength = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLengthSlider + ').value;\n' +
        'var lLength = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLengthSlider + ').value;\n' +
        'var ikLength = length(uPos,cPos);\n' +
        'if (ikLength == 0) ikLength = 1;\n' +
        'var d1 = sq(mLength) - sq(ikLength) - sq(uLength-lLength);\n' +
        'var d2 = sq(ikLength) * (uLength+lLength);\n' +
        'var d3 = -sq(ikLength) * uLength * lLength;\n' +
        'var d4 = (-d2 - Math.sqrt( sq(d2) - 4*d1*d3 )) / (2*d1);\n' +
        'var baseA = Math.acos(clamp(ikLength/(2*d4),-1,1));\n' +
        'var d6 = Math.sqrt( sq(ikLength) + sq(uLength) - 2*ikLength*uLength*Math.cos(baseA));\n' +
        'var lowerA = Math.acos(clamp((sq(d6) - sq(lLength) - sq(mLength)) / (-2*lLength*mLength),-1,1));\n' +
        'lowerA = cw ? -lowerA : lowerA;\n' +
        'lowerA = radiansToDegrees(lowerA);\n' +
        'var mToL =getAngle(mPos,lPos);\n' +
        'var lToZ =getAngle(lPos,zPos);\n' +
        'var ikResult = lowerA + mToL - lToZ +180;\n' +
        'return ikResult % 360;\n' +
        '}\n' +
        'function fk()\n' +
        '{\n' +
        'var parentRot = parent.transform.rotation ;\n' +
        'var ctrlRot = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.fkAngle + ');\n' +
        'var delay = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.resistanceSlider + ').value;\n' +
        'var amp = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.flexibilitySlider + ').value;\n' +
        'var manual = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerAngle + ').value;\n' +
        'var follow = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.parentRotationCheckbox + ').value;\n' +
        'var ftEnabled = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.followThroughCheckbox + ').value;\n' +
        'if (!ftEnabled)\n' +
        '{\n' +
        'amp = 0;\n' +
        'delay = 0;\n' +
        '}\n' +
        'else\n' +
        '{\n' +
        'delay = delay / 100;\n' +
        'amp = amp / 100 ;\n' +
        '}\n' +
        'var FK = parentRot.valueAtTime(time-delay);\n' +
        'FK = FK * amp;\n' +
        'FK = FK + manual - parent.transform.rotation.valueAtTime(0);\n' +
        'return FK;\n' +
        '}\n' +
        'IKFK ? result += ik() : result += fk();\n' +
        '}\n' +
        '}\n' +
        'result;\n';

    layer3.transform.position.expression = '//Duik.threeLayerIK.stretch\n' +
        'var controller = null;\n' +
        'var result = value;\n' +
        'try { controller = effect("' + layer3Data.name + '")(1); } catch (e){ value };\n' +
        'if (controller != null)\n' +
        '{\n' +
        'fx = controller.effect("' + ikEffect.name + '");\n' +
        'layer1 = null;\n' +
        'try{layer1=fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLayer + ')}catch(e){}\n' +
        'if (layer1 != null)\n' +
        '{\n' +
        'stretch = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.stretchSlider + ').value;\n' +
        'auto = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.autoStretchCheckbox + ').value;\n' +
        'IK = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.ikCheckbox + ').value;\n' +
        'shrinkVal = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.autoShrinkSlider + ').value/100;\n' +
        'function getWorldPos(L){\n' +
        'return L.toWorld(L.anchorPoint);\n' +
        '}\n' +
        'var upperAP = ' + rootAp + ';\n' +
        'var middlePos = ' + middlePos + ';\n' +
        'var middleAP = ' + middleAp + ';\n' +
        'var lowerPos = ' + lowerPos + ';\n' +
        'var lowerAP = ' + lowerAp + ';\n' +
        'var zeroPos = ' + goalPos.toSource() + ';\n' +
        'dist1 = length(upperAP,middlePos);\n' +
        'dist2 = length(middleAP,lowerPos);\n' +
        'dist3 = length(lowerAP,zeroPos);\n' +
        'IKLength = dist1+dist2+dist3;\n' +
        'IKStretched = IKLength+stretch;\n' +
        'boneStretch = 0;\n' +
        'proportion = dist2/(IKLength);\n' +
        'posC = getWorldPos(controller);\n' +
        'posR = getWorldPos(layer1);\n' +
        'distC = length(posC,posR);\n' +
        'shrinkMax = IKLength*shrinkVal;\n' +
        'shrink = 0;\n' +
        'if (distC < IKStretched && IK) shrink = 1-distC/IKStretched;\n' +
        'boneStretch -= easeOut(shrink,0,shrinkMax)*proportion;\n' +
        'if (distC > IKStretched && auto && IK) boneStretch += (distC-IKLength)*proportion;\n' +
        'else boneStretch += stretch*proportion;\n' +
        'coef = 1;\n' +
        'dist2 != 0 ? coef = (dist2+boneStretch)/dist2 : coef = 1;\n' +
        'result = (middlePos-upperAP)*coef+upperAP;\n' +
        '}\n' +
        '}\n' +
        'result;';

    if ( goal != null )
    {
        var goalData = DuAEF.DuAE.Layer.addPseudoEffect( goal, DuAEF.Duik.PseudoEffects.IK, DuAEF.Duik.PseudoEffectsMatchNames.IK, "IK" );
        goalData( 1 ).setValue( controller.layer.index );

        var rotExpr = '//Duik.goal\n' +
            'var ctrl = null;\n' +
            'var result = value;\n' +
            'try { ctrl = effect("' + goalData.name + '")(1); } catch (e){};\n' +
            'if (ctrl != null)\n' +
            '{\n' +
            'var fx = ctrl.effect("' + ikEffect.name + '");\n' +
            'var IKFK = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.ikCheckbox + ').value;\n' +
            'function ik()\n' +
            '{\n' +
            'var layer = thisLayer;\n' +
            'var IK = 0;\n' +
            'while (layer.hasParent)\n' +
            '{\n' +
            'layer = layer.parent;\n' +
            'IK = IK - layer.rotation;\n' +
            '}\n' +
            'return IK;\n' +
            '}\n' +
            'function fk()\n' +
            '{\n' +
            'var parentRot = parent.transform.rotation ;\n' +
            'var ctrlRot = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.fkAngle + ');\n' +
            'var delay = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.resistanceSlider + ').value;\n' +
            'var amp = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.flexibilitySlider + ').value;\n' +
            'var ftEnabled = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.followThroughCheckbox + ').value;\n' +
            'var manual = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalAngle + ').value;\n' +
            'var follow = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.parentRotationCheckbox + ').value;\n' +
            'if (!ftEnabled)\n' +
            '{\n' +
            'amp = 0;\n' +
            'delay = 0;\n' +
            '}\n' +
            'else\n' +
            '{\n' +
            'delay = delay / 100;\n' +
            'amp = amp / 100 ;\n' +
            '}\n' +
            'var FK = parentRot.valueAtTime(time-delay);\n' +
            'FK = FK * amp;\n' +
            'FK = FK + manual - parent.transform.rotation.valueAtTime(0);\n' +
            'return FK;\n' +
            '}\n' +
            'IKFK ? result += ik() : result += fk();\n' +
            '}\n' +
            'result;\n' +
            '';

        DuAEF.DuAE.Property.setExpression( goal.transform.rotation, rotExpr );

        goal.transform.position.expression = 'var ctrl = null;\n' +
            'var result = value;\n' +
            'try { ctrl = effect("' + goalData.name + '")(1); } catch (e){ value };\n' +
            'if (ctrl != null)\n' +
            '{\n' +
            'result = ctrl.effect("' + ikEffect.name + '")(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalPositionPoint + ').value;\n' +
            '}\n' +
            'result;';
    }

    return controller;
}

/**
 * Creates a bezier ik on the layers
 * @param {Layer[]|Structure} layers - The layers, ordered from root to end
 * @param {Layer|null} [goal] - The goal layer, at the end of the IK
 * @param {Layer|Controller|null} [controllers] - The layer to use as controller, can be automatically created.<br />
 * Must be provided if goal is undefined.
 * @return {Controller[]} The controllers [curve,end,root]
 */
DuAEF.Duik.Rigging.bezierIK = function( layers, goal, controller )
{
    if ( goal == undefined ) goal = null;
    if ( controller == undefined ) controller = null;
    if ( controller == null && goal == null ) throw "You must provide either a goal layer or a controller";

    if ( layers instanceof Structure ) layers = layers.elements;

    var comp = layers[ 0 ].containingComp;

    //create controllers
    if ( controller == null )
    {
        var ctrlType = DuAEF.Duik.Controller.Types.TRANSFORM;
        if ( DuAEF.Duik.Controller.defaultType == DuAEF.Duik.Controller.Types.NULL ) ctrlType = DuAEF.Duik.Controller.Types.NULL;
        controller = DuAEF.Duik.Controller.create( comp, ctrlType, goal );
        goal.parent = null;
        controller.layer.transform.rotation.setValue( goal.transform.rotation.value );
    }

    if ( goal ) goal.parent = controller.layer;

    //add effect
    var name = layers[ 0 ].name;
    var ikEffect = DuAEF.DuAE.Layer.addPseudoEffect( controller.layer, DuAEF.Duik.PseudoEffects.BEZIER_IK, DuAEF.Duik.PseudoEffectsMatchNames.BEZIER_IK, DuAEF.Duik.generateName( 'IK', name ) );

    //create curve controller
    var curveController = DuAEF.Duik.Controller.create( comp, DuAEF.Duik.Controller.Types.POSITION, layers[ 0 ] );
    curveController.layer.transform.scale.expression = '';
    curveController.layer.name = curveController.layer.name + " | Curve";
    if ( controller.effect ) curveController.layer.effect( DuAEF.Duik.PseudoEffectsMatchNames.CONTROLLER )( 4 ).setValue( controller.layer.effect( DuAEF.Duik.PseudoEffectsMatchNames.CONTROLLER )( 4 ).value * 1 / 2 );

    //create root controller
    var rootController = DuAEF.Duik.Controller.create( comp, DuAEF.Duik.Controller.Types.POSITION, layers[ 0 ] );
    rootController.layer.name = rootController.layer.name + " | Root";
    if ( controller.effect ) rootController.layer.effect( DuAEF.Duik.PseudoEffectsMatchNames.CONTROLLER )( 4 ).setValue( controller.layer.effect( DuAEF.Duik.PseudoEffectsMatchNames.CONTROLLER )( 4 ).value * 1 / 2 );

    //add effect
    var curveEffect = DuAEF.Duik.PseudoEffects.BEZIER_IK_CURVE.apply( curveController.layer );
    curveEffect( DuAEF.Duik.PseudoEffects.BEZIER_IK_CURVE.rootLayer ).setValue( rootController.layer.index );
    curveEffect( DuAEF.Duik.PseudoEffects.BEZIER_IK_CURVE.curveLayer ).setValue( curveController.layer.index );
    curveEffect( DuAEF.Duik.PseudoEffects.BEZIER_IK_CURVE.endLayer ).setValue( controller.layer.index );

    //useful positions
    var endPosition = DuAEF.DuAE.Layer.getWorldPos( controller.layer );
    if ( goal != null ) endPosition = DuAEF.DuAE.Layer.getWorldPos( goal );
    var rootPosition = DuAEF.DuAE.Layer.getWorldPos( layers[ 0 ] );
    curveController.layer.transform.position.setValue( ( endPosition + rootPosition ) / 2 );
    var cOutPosition = ( 2 * endPosition + rootPosition ) / 3;
    var cInPosition = ( endPosition + 2 * rootPosition ) / 3;

    //add handles
    var handleInGroup = curveController.layer( "ADBE Root Vectors Group" ).addProperty( "ADBE Vector Group" );
    handleInGroup.name = 'Handle In';
    handleInContent = handleInGroup.property( "ADBE Vectors Group" );
    var circle = handleInContent.addProperty( "ADBE Vector Shape - Ellipse" );
    circle( "ADBE Vector Ellipse Size" ).setValue( [ 25, 25 ] );
    var fill = handleInContent.addProperty( "ADBE Vector Graphic - Fill" );
    fill( "ADBE Vector Fill Color" ).expression = 'effect("Controller")(2)-[0.2,0.2,0.2,0]\n';
    handleInGroup.transform.scale.expression = '[effect("Controller")(4),effect("Controller")(4)]';

    handleInGroup.transform.position.expression = 'var fx = effect("' + curveEffect.name + '");\n' +
        'var root = null;\n' +
        'var curve = thisLayer;\n' +
        'var result = value;\n' +
        'try { root = fx(' + DuAEF.Duik.PseudoEffects.BEZIER_IK_CURVE.rootLayer + ') ;} catch(e){}\n' +
        'if (root != null)\n' +
        '{\n' +
        'var rootPos = root.toWorld(root.anchorPoint);\n' +
        'rootPos = fromWorld(rootPos);\n' +
        'result += rootPos/2;\n' +
        '}\n' +
        'result;';
    //Auto handle position disabled as it mess up the order of the evaluation of the expressions
    //DuAEF.DuAE.Property.removeExpression(handleInGroup.transform.position);

    handleInGroup.transform.opacity.expression = 'var fx = effect("' + curveEffect.name + '");\n' +
        'fx(' + DuAEF.Duik.PseudoEffects.BEZIER_IK_CURVE.showHandlesCheckbox + ').value*100';

    var handleOutGroup = curveController.layer( "ADBE Root Vectors Group" ).addProperty( "ADBE Vector Group" );
    handleOutGroup.name = 'Handle Out';
    handleOutContent = handleOutGroup.property( "ADBE Vectors Group" );
    var circle = handleOutContent.addProperty( "ADBE Vector Shape - Ellipse" );
    circle( "ADBE Vector Ellipse Size" ).setValue( [ 25, 25 ] );
    var fill = handleOutContent.addProperty( "ADBE Vector Graphic - Fill" );
    fill( "ADBE Vector Fill Color" ).expression = 'effect("Controller")(2)-[0.2,0.2,0.2,0]\n';
    handleOutGroup.transform.scale.expression = '[effect("Controller")(4),effect("Controller")(4)]';

    //Auto handle position disabled as it mess up the order of the evaluation of the expressions
    handleOutGroup.transform.position.expression = 'var fx = effect("' + curveEffect.name + '");\n' +
        'var end = null;\n' +
        'var curve = thisLayer;\n' +
        'var result = value;\n' +
        'try { end = fx(' + DuAEF.Duik.PseudoEffects.BEZIER_IK_CURVE.endLayer + '); } catch(e){}\n' +
        'if (end != null)\n' +
        '{\n' +
        'var endPos = end.toWorld(end.anchorPoint);\n' +
        'endPos = fromWorld(endPos);\n' +
        'result += endPos/2;\n' +
        '}\n' +
        'result;';
    //Auto handle position disabled as it mess up the order of the evaluation of the expressions
    //DuAEF.DuAE.Property.removeExpression(handleOutGroup.transform.position);

    handleOutGroup.transform.opacity.expression = 'var fx = effect("' + curveEffect.name + '");\n' +
        'fx(' + DuAEF.Duik.PseudoEffects.BEZIER_IK_CURVE.showHandlesCheckbox + ').value*100';

    //add line
    if ( DuAEF.DuAE.App.version >= 15 )
    {
        var lineGroup = curveController.layer( "ADBE Root Vectors Group" ).addProperty( "ADBE Vector Group" );
        lineGroup.name = 'IK Line';
        var lineContent = lineGroup.property( "ADBE Vectors Group" );
        var shape = lineContent.addProperty( "ADBE Vector Shape - Group" );
        shape( 'ADBE Vector Shape' ).expression = 'var fx = effect("' + curveEffect.name + '");\n' +
            'var root = null;\n' +
            'var curve = thisLayer;\n' +
            'var end = null;\n' +
            'var result = [[0,0]];\n' +
            'if (fx(' + DuAEF.Duik.PseudoEffects.BEZIER_IK_CURVE.drawGuidesCheckbox + ').value)\n' +
            '{\n' +
            'try { root = fx(' + DuAEF.Duik.PseudoEffects.BEZIER_IK_CURVE.rootLayer + ') ; end = fx(' + DuAEF.Duik.PseudoEffects.BEZIER_IK_CURVE.endLayer + ') } catch(e){}\n' +
            'if (root != null)\n' +
            '{\n' +
            'var r = root.toWorld(root.anchorPoint);\n' +
            'r = fromWorld(r);\n' +
            'var e = end.toWorld(end.anchorPoint);\n' +
            'e = fromWorld(e);\n' +
            'var t1 = content("Handle In").transform.position;\n' +
            'var t2 = content("Handle Out").transform.position;\n' +
            'result = [r,t1,t2,e];\n' +
            '}\n' +
            '}\n' +
            'createPath(result,[],[],false);';
        var stroke = lineContent.addProperty( "ADBE Vector Graphic - Stroke" );
        stroke( "ADBE Vector Stroke Color" ).expression = 'effect("Controller")(2)-[0.2,0.2,0.2,0]';
        stroke( "ADBE Vector Stroke Width" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Line Cap" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
        stroke( "ADBE Vector Stroke Dashes" )( "ADBE Vector Stroke Dash 1" ).setValue( 5 );
    }

    //setup layers
    var rootIndex = rootController.layer.index;
    var endIndex = controller.layer.index;
    var curveIndex = curveController.layer.index;
    var totalLength = DuAEF.DuJS.Math.getLength( rootPosition, cInPosition ) + DuAEF.DuJS.Math.getLength( cOutPosition, cInPosition ) + DuAEF.DuJS.Math.getLength( cOutPosition, endPosition );

    //un-parent
    for ( var i = 1; i < layers.length; i++ )
    {
        layers[ i ].parent = null;
    }

    layers[ 0 ].parent = rootController.layer;

    for ( var i = 0; i < layers.length; i++ )
    {
        var layer = layers[ i ];
        //add effect
        var layerEffect = DuAEF.DuAE.Layer.addPseudoEffect( layer, DuAEF.Duik.PseudoEffects.BEZIER_IK_LAYER, DuAEF.Duik.PseudoEffectsMatchNames.BEZIER_IK_LAYER, "Bezier IK" );
        layerEffect( 3 ).setValue( rootIndex );
        layerEffect( 4 ).setValue( curveIndex );
        layerEffect( 5 ).setValue( endIndex );
        if ( i < layers.length - 1 ) layerEffect( 6 ).setValue( layers[ i + 1 ].index );
        else layerEffect( 6 ).setValue( controller.layer.index );

        //expressions

        //position
        if ( i != 0 )
        {
            var index = DuAEF.DuJS.Math.getLength( endPosition, layer.transform.position.value );
            index = index / totalLength;
            layer.transform.position.expression = '//Duik.bezierIK\n' +
                'var end = null;\n' +
                'var root = null;\n' +
                'var curve = null;\n' +
                'var result = value;\n' +
                'var thisFx = effect("' + layerEffect.name + '");\n' +
                'try{end=thisFx(5);curve=thisFx(4);root=thisFx(3);}catch(e){};\n' +
                'if(root !=null)\n' +
                '{\n' +
                'var ind = ' + index + ';\n' +
                'var fx = end.effect("' + ikEffect.name + '");\n' +
                'var offset = thisFx(1)/100;\n' +
                'var generalOffset = fx(2)/100;\n' +
                'var endPosition = end.toComp(end.anchorPoint);\n' +
                'var rootPosition = root.toComp(root.anchorPoint);\n' +
                'var curvePosition1 = curve.toComp(curve.content("Handle Out").transform.position);\n' +
                'var curvePosition2 = curve.toComp(curve.content("Handle In").transform.position);\n' +
                'var t = ind + generalOffset + offset;\n' +
                'var c = 3*(curvePosition1 - endPosition);\n' +
                'var b = 3*(curvePosition2 - curvePosition1) - c;\n' +
                'var a = rootPosition - endPosition - c - b;\n' +
                'result += ((a*t +b )*t + c)*t + endPosition ;\n' +
                'result -= ' + layer.transform.position.value.toSource() + ';\n' +
                '}\n' +
                'result;';
        }

        //rotation
        var expr = '//Duik.bezierIK\n' +
            'var c = null;\n' +
            'var result = value;\n' +
            'var thisFx = effect("' + layerEffect.name + '");\n' +
            'try{c = thisFx(5)}catch(e){}\n' +
            'if (c!=null)\n' +
            '{\n' +
            'var n = c;\n' +
            'try {n=thisFx(6); if (n.index == index) n=c}catch(e){}\n' +
            'var fx = c.effect("' + ikEffect.name + '");\n' +
            'var autoOrient = fx(1).value;\n' +
            'var C = n.toWorld(n.anchorPoint);\n' +
            'var O =  thisLayer.toWorld(thisLayer.anchorPoint);\n' +
            'var vec = O-C;\n' +
            'var angle = Math.atan2(vec[1], vec[0]);\n' +
            'var ik = radiansToDegrees(angle);\n' +
            'if (autoOrient==1) result += ik;\n';
        if ( i == 0 )
        {
            expr += 'var layer = thisLayer;\n' +
                'while(layer.hasParent)\n' +
                '{\n' +
                'layer = layer.parent;\n' +
                'result -= layer.transform.rotation;\n' +
                '}\n';
        }
        expr += '}\n' +
            'result;';

        DuAEF.DuAE.Property.setExpression( layer.transform.rotation, expr );
    }

    curveController.layer.selected = false;
    controller.layer.moveBefore( curveController.layer );

    return [ curveController, controller, rootController ];
}

DuAEF.Duik.Rigging.goal = function( layers, controller )
{
    if ( layers instanceof Array ) layers = DuAEF.DuAE.Layer.sortByParent( layers );
    else layers = [ layers ];
    var numLayers = layers.length;

    if ( controller instanceof Controller ) controller = controller.layer;
    //add checkbox and data
    var effect = controller.effect.addProperty( "ADBE Checkbox Control" );
    effect.name = layers[ 0 ].name + " Follow";
    var effectName = effect.name;


    for ( var i = 0; i < layers.length; i++ )
    {
        var goalData = layers[ i ].effect.addProperty( "ADBE Layer Control" );
        goalData.name = "Goal";
        goalData( 1 ).setValue( controller.index );

        var exp = "//Duik.goal\n" +
            "var ctrl = null;\n" +
            "var result = value;\n" +
            "try { ctrl = effect(\"Goal\")(1); } catch (e){};\n" +
            "if (ctrl != null)\n" +
            "{\n" +
            "var goal = ctrl.effect(\"" + effectName + "\")(1).value;\n" +
            "result += ctrl.rotation.value/" + ( numLayers / ( i + 1 ) ) + ";\n" +
            "if (!goal)\n" +
            "{\n" +
            "var layer = thisLayer;\n" +
            "while (layer.hasParent)\n" +
            "{\n" +
            "layer = layer.parent;\n" +
            "result = result - layer.rotation/" + ( numLayers / ( i + 1 ) ) + ";\n" +
            "}\n" +
            "}\n" +
            "}\n" +
            "result;";

        DuAEF.DuAE.Property.setExpression( layers[ i ].transform.rotation, exp );
    }
}

/**
 * Creates a FK with auto-overlapping and its controller on the layers/the structure.
 * @param {Layer[]|Structure} layers - The layers, already parented or ordered from root (at index 0) to end
 * @param {Layer|Controller|null} [controller] - An already existing controller.
 * @return {Controller} The controller of the FK.
 */
DuAEF.Duik.Rigging.fkOverlap = function( layers, controller )
{
    if ( typeof controller === 'undefined' ) controller = null;
    if ( layers instanceof Structure ) layers = layers.elements;

    var comp = layers[ 0 ].containingComp;

    //check if there is a controller in the selection
    if ( controller == null )
    {
        for ( var i = 0, num = layers.length; i < num; i++ )
        {
            var l = layers[ i ];
            if ( DuAEF.Duik.isLayerType( l, DuAEF.Duik.LayerTypes.CONTROLLER ) )
            {
                controller = l;
                layers.splice( i, 1 );
                break;
            }
        }
    }

    //sort layers and parent them
    var layers = DuAEF.DuAE.Layer.sortByParent( layers );
    //reset rotation and scale if structures
    var it = new Iterator( layers )
    it.do( DuAEF.Duik.Structure.resetTransform );
    DuAEF.DuAE.Layer.parentChain( layers );

    //Create controller
    if ( controller == null )
    {
        var ctrlType = DuAEF.Duik.Controller.Types.ROTATION;
        if ( DuAEF.Duik.Controller.defaultType == DuAEF.Duik.Controller.Types.NULL ) ctrlType = DuAEF.Duik.Controller.Types.NULL;
        controller = DuAEF.Duik.Controller.create( comp, ctrlType, layers[ 0 ] );
    }
    if ( !( controller instanceof Controller ) )
    {
        controller = new Controller( controller );
    }

    var name = layers[ 0 ].name;
    var fkEffect = DuAEF.DuAE.Layer.addPseudoEffect( controller.layer, DuAEF.Duik.PseudoEffects.FK_OVERLAP, DuAEF.Duik.PseudoEffectsMatchNames.FK_OVERLAP, DuAEF.Duik.generateName( 'FK Overlap', name ) );
    fkEffect( 7 ).setValue( -180 );
    fkEffect( 1 ).setValue( 100 );
    fkEffect( 2 ).setValue( 10 );
    var fkEffectName = fkEffect.name;

    //rig layers
    var it = new Iterator( layers );
    it.do( function( layer )
    {
        //add Data
        var layerData = DuAEF.DuAE.Layer.addPseudoEffect( layer, DuAEF.Duik.PseudoEffects.IK, DuAEF.Duik.PseudoEffectsMatchNames.IK, "FK Overlap" );
        layerData( 1 ).setValue( controller.layer.index );

        //add FK control
        var fkControl = controller.layer( 'ADBE Effect Parade' ).addProperty( 'ADBE Angle Control' );
        fkControl.name = layer.name;

        //add expression
        if ( it.current == 0 )
        {
            layer.transform.rotation.expression = '//Duik.fkOverlap\n ' +
                'var controller = null;\n ' +
                'var result = value;\n ' +
                'try{controller=effect("' + layerData.name + '")(1)}catch(e){}\n ' +
                'if (controller !=null)\n ' +
                '{\n ' +
                'var fx = controller.effect("' + fkEffectName + '");\n ' +
                'result += controller.transform.rotation.value + fx(3).value ;\n ' +
                'var follow = fx(4).value;\n ' +
                'var p = thisLayer;\n ' +
                'if (!follow)\n ' +
                '{\n ' +
                'while(p.hasParent)\n ' +
                '{\n ' +
                'p = p.parent;\n ' +
                'result -= p.rotation.value;\n ' +
                '}\n ' +
                '}\n ' +
                'for (var i = 1 ; i <= controller("Effects").numProperties ; i++)\n ' +
                '{\n ' +
                'var fk = controller("Effects")(i);\n ' +
                'if (fk.name == thisLayer.name)\n ' +
                '{\n ' +
                'result+=fk(1).value;\n ' +
                'break;\n' +
                '}	\n ' +
                '}\n ' +
                '}\n ' +
                'result;';
        }
        else if ( it.current == 1 )
        {
            layer.transform.rotation.expression = '//Duik.fkOverlap\n ' +
                'var controller = null;\n ' +
                'var result = value;\n ' +
                'try{controller=effect("' + layerData.name + '")(1)}catch(e){}\n ' +
                'if (controller !=null && hasParent)\n ' +
                '{\n ' +
                'var fx = controller.effect("' + fkEffectName + '");\n ' +
                'var ctrlRot = controller.transform.rotation;\n ' +
                'var delay = fx(2).value ;\n ' +
                'var amp = fx(1).value ;\n ' +
                'var uLimit = fx(6).value ;\n ' +
                'var lLimit = fx(7).value ;\n ' +
                'var manual = fx(3).value ;\n ' +
                'var follow = fx(4).value;\n ' +
                'delay = delay / 100;\n ' +
                'amp = amp / 100 ;\n ' +
                'result = ctrlRot.valueAtTime(time-delay) + fx(3).valueAtTime(time-delay);\n ' +
                'if (follow && hasParent)\n ' +
                '{\n ' +
                'var cP = parent;\n ' +
                'while(cP.hasParent)\n ' +
                '{\n ' +
                'cP = cP.parent;\n ' +
                'if (cP.index = controller.index) follow = false;\n ' +
                'result -= cP.rotation.value - cP.rotation.valueAtTime(time-delay) ;\n ' +
                '}\n ' +
                '}\n ' +
                'result = result - ctrlRot.value ;\n ' +
                'result = result * amp;\n ' +
                'result = result - ctrlRot.velocity*(delay/5);\n ' +
                'if (result > uLimit) result = uLimit;\n ' +
                'if (result < lLimit) result = lLimit;\n ' +
                'result = result + value + manual;\n ' +
                'if (follow) result -= parent.transform.rotation.valueAtTime(0);\n ' +
                'for (var i = 1 ; i <= controller("Effects").numProperties ; i++)\n ' +
                '{\n ' +
                'var fk = controller("Effects")(i);\n ' +
                'if (fk.name == thisLayer.name)\n ' +
                '{\n ' +
                'result+=fk(1).value;\n ' +
                'break;\n' +
                '}	\n ' +
                '}\n ' +
                '}\n ' +
                'result;';
        }
        else
        {
            layer.transform.rotation.expression = '//Duik.fkOverlap\n ' +
                'var controller = null;\n ' +
                'var result = value;\n ' +
                'try{controller=effect("' + layerData.name + '")(1)}catch(e){}\n ' +
                'if (controller !=null && hasParent)\n ' +
                '{\n ' +
                'var fx = controller.effect("' + fkEffectName + '");\n ' +
                'var ctrlRot = controller.transform.rotation;\n ' +
                'var parentRot = parent.transform.rotation ;\n ' +
                'var delay = fx(2).value ;\n ' +
                'var amp = fx(1).value ;\n ' +
                'var uLimit = fx(6).value ;\n ' +
                'var lLimit = fx(7).value ;\n ' +
                'var manual = fx(3).value ;\n ' +
                'delay = delay / 100;\n ' +
                'amp = amp / 100 ;\n ' +
                'result = parentRot.valueAtTime(time-delay);\n ' +
                'result = result * amp;\n ' +
                'if (result > uLimit) result = uLimit;\n ' +
                'if (result < lLimit) result = lLimit;\n ' +
                'result = result + value + manual - parent.transform.rotation.valueAtTime(0);\n ' +
                'for (var i = 1 ; i <= controller("Effects").numProperties ; i++)\n ' +
                '{\n ' +
                'var fk = controller("Effects")(i);\n ' +
                'if (fk.name == thisLayer.name)\n ' +
                '{\n ' +
                'result+=fk(1).value;\n ' +
                'break;\n' +
                '}	\n ' +
                '}\n ' +
                '}\n ' +
                'result;';
        }
    } );

    controller.layer.selected = true;

    return controller;
}

DuAEF.Duik.Rigging.exposeTransform = function( comp, layer )
{
    if (typeof comp === 'undefined')
	{
		if (typeof layer !== 'undefined')
		{
			comp = layer.containingComp;
		}
		else
		{
			comp = DuAEF.DuAE.Project.getActiveComp();
		}
	}
	if (!comp) return;

    var ctrl = DuAEF.Duik.Controller.create( comp, DuAEF.Duik.Controller.Types.EXPOSE_TRANSFORM, layer);
    ctrl = ctrl.layer;

    //add pseudo effect
    var pE = DuAEF.Duik.PseudoEffects.EXPOSE_TRANSFORM;
    var index = pE.index;
    var effect = pE.apply(ctrl);

    //add guides
    var guidesGroup = ctrl("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
	guidesGroup.name = 'Guides';

    var refGroup = guidesGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
    refGroup.name = 'Reference';

    var refOrientationGroup = refGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
    refOrientationGroup.name = 'Orientation';
    refOrientation = refOrientationGroup("ADBE Vectors Group");

    var path = refOrientation.addProperty("ADBE Vector Shape - Group");
    path("ADBE Vector Shape").expression = ['//Duik.exposeTransform',
        'var fx = effect("' + effect.name + '");',
        'if (fx(' + index['DisplayGuidesCheckbox'] + ').value)',
        '{',
        '	var A = [0,0];',
        '	var B = [ 0 , -thisComp.height/20 ];',
        '	createPath([A,B],[],[],false);',
        '}',
        'else',
        '{',
        '	value;',
        '}'
        ].join('\n');

    path = refOrientation.addProperty("ADBE Vector Shape - Ellipse");
    path("ADBE Vector Ellipse Size").expression = ['//Duik.exposeTransform',
        'var fx = effect("' + effect.name + '");',
	    'var s = thisComp.height/40;',
	    'if (fx(' + index['DisplayGuidesCheckbox'] + ').value) [s,s];',
	    'else [0,0];'
	    ].join('\n');

    var stroke = refOrientation.addProperty("ADBE Vector Graphic - Stroke");
    stroke("ADBE Vector Stroke Color").expression = 'effect("Expose Transform")(' + index['DisplayReferenceColor'] + ');';
    stroke("ADBE Vector Stroke Width").expression = 'thisComp.height/500;';
    stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
    stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Dash 1').expression = 'thisComp.height/100;';
    stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Gap 1" );
    stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Gap 1').expression = 'thisComp.height/500;';

    refOrientationTransform = refOrientationGroup('ADBE Vector Transform Group');
    refOrientationTransform('ADBE Vector Position').expression = ['//Duik.exposeTransform',
        'var fx = effect("' + effect.name + '");',
        'var P = fx(' + index['2D Position (Comp projection)Absolute Point'] + ');',
        'var R = fx(' + index['2D Position (Comp projection)Absolute Point'] + ') - fx(' + index['2D Position (Comp projection)Relative to referencePoint'] + ');',
        'fromComp(R);'
    ].join('\n');
    refOrientationTransform('ADBE Vector Rotation').expression = 'content("Guides").content("Target").transform.rotation + content("Guides").content("Target").content("Reference Orientation").transform.rotation;'

    var targetGroup = guidesGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
    targetGroup.name = 'Target';

    var targetOrientationGroup = targetGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
    targetOrientationGroup.name = 'Orientation';
    targetOrientation = targetOrientationGroup("ADBE Vectors Group");

    path = targetOrientation.addProperty("ADBE Vector Shape - Group");
    path("ADBE Vector Shape").expression = ['//Duik.exposeTransform',
        'var fx = effect("' + effect.name + '");',
        'if (fx(' + index['DisplayGuidesCheckbox'] + ').value)',
        '{',
        '	var A = [0,0];',
        '	var B = [ 0 , -thisComp.height/10 ];',
        '	createPath([A,B],[],[],false);',
        '}',
        'else',
        '{',
        '	value;',
        '}'
    ].join('\n');

    path = targetOrientation.addProperty("ADBE Vector Shape - Ellipse");
    path("ADBE Vector Ellipse Size").expression = ['//Duik.exposeTransform',
        'var fx = effect("' + effect.name + '");',
	    'var s = thisComp.height/20;',
	    'if (fx(' + index['DisplayGuidesCheckbox'] + ').value) [s,s];',
	    'else [0,0];'
	].join('\n');

    stroke = targetOrientation.addProperty("ADBE Vector Graphic - Stroke");
    stroke("ADBE Vector Stroke Color").expression = 'effect("Expose Transform")(' + index['DisplayTargetColor'] + ');';
    stroke("ADBE Vector Stroke Width").expression = 'thisComp.height/500;';
    stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
    stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Dash 1').expression = 'thisComp.height/100;';
    stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Gap 1" );
    stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Gap 1').expression = 'thisComp.height/500;';

    var refOrientationGroup = targetGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
    refOrientationGroup.name = 'Reference Orientation';
    refOrientation = refOrientationGroup("ADBE Vectors Group");

    path = refOrientation.addProperty("ADBE Vector Shape - Group");
    path("ADBE Vector Shape").expression = ['//Duik.exposeTransform',
        'var fx = effect("' + effect.name + '");',
        'if (fx(' + index['DisplayGuidesCheckbox'] + ').value)',
        '{',
        '	var A = [0,0];',
        '	var B = [ 0 , -thisComp.height/20 ];',
        '	createPath([A,B],[],[],false);',
        '}',
        'else',
        '{',
        '	value;',
        '}'
    ].join('\n');

    stroke = refOrientation.addProperty("ADBE Vector Graphic - Stroke");
    stroke("ADBE Vector Stroke Color").expression = 'effect("Expose Transform")(' + index['DisplayReferenceColor'] + ');';
    stroke("ADBE Vector Stroke Width").expression = 'thisComp.height/500;';
    stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
    stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Dash 1').expression = 'thisComp.height/100;';
    stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Gap 1" );
    stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Gap 1').expression = 'thisComp.height/500;';
    
    refOrientationTransform = refOrientationGroup('ADBE Vector Transform Group');

    refOrientationTransform('ADBE Vector Rotation').expression = ['//Duik.exposeTransform',
        'var fx = effect("' + effect.name + '");',
        '-fx(' + index['2D OrientationRelative to referenceAngle'] + ');'
	].join('\n');

    targetTransform = targetGroup('ADBE Vector Transform Group');
    targetTransform('ADBE Vector Position').expression = ['//Duik.exposeTransform',
        'var fx = effect("' + effect.name + '");',
        'if (fx(' + index['DisplayGuidesCheckbox'] + ').value)',
        '{',
        '	fromComp(fx(' + index['2D Position (Comp projection)Absolute Point'] + '));',
        '}',
        'else',
        '{',
        '	value;',
        '}'
    ].join('\n');
    targetTransform('ADBE Vector Rotation').expression = ['//Duik.exposeTransform',
        'var fx = effect("' + effect.name + '");',
        'var result = fx(' + index['2D OrientationAbsoluteAngle'] + ');',
        'var l = thisLayer;',
        'result -= l.rotation.value;',
        'while(l.hasParent)',
        '{',
        '	l = l.parent;',
        '	result -= l.rotation.value;',
        '}',
        'result;'
	].join('\n');

    var angleGroup = guidesGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
    angleGroup.name = 'Angle';

    var angleGroup1 = angleGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
    angle1 = angleGroup1("ADBE Vectors Group");

    path = angle1.addProperty("ADBE Vector Shape - Group");
    path("ADBE Vector Shape").expression = ['//Duik.exposeTransform',
        'var fx = effect("Expose Transform");',
        'if (fx(' + index['DisplayGuidesCheckbox'] + ').value)',
        '{',
        '	var A = fromComp(fx(' + index['2D Position (Comp projection)Absolute Point'] + '));',
        '	var B = fromComp( fx(' + index['2D Position (Comp projection)Absolute Point'] + ') - fx(' + index['2D Position (Comp projection)Relative to referencePoint'] + ') );',
        '	createPath([A,[0,0],B],[],[],false);',
        '}',
        'else',
        '{',
        '	value;',
        '}'
	].join('\n');

    stroke = angle1.addProperty("ADBE Vector Graphic - Stroke");
    stroke("ADBE Vector Stroke Color").expression = 'effect("Expose Transform")(' + index['DisplayAngleColor'] + ');';
    stroke("ADBE Vector Stroke Width").expression = 'thisComp.height/500;';
    stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
    stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Dash 1').expression = 'thisComp.height/100;';
    stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Gap 1" );
    stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Gap 1').expression = 'thisComp.height/500;';

    var angleGroup2 = angleGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
    angle2 = angleGroup2("ADBE Vectors Group");

    path = angle2.addProperty("ADBE Vector Shape - Group");
    path("ADBE Vector Shape").expression = ['//Duik.exposeTransform',
        'var fx = effect("' + effect.name + '");',
        'if (fx(' + index['DisplayGuidesCheckbox'] + ').value)',
        '{',
        '	var A = fromComp(fx(' + index['2D Position (Comp projection)Absolute Point'] + '));',
        '	var B = fromComp( fx(' + index['2D Position (Comp projection)Absolute Point'] + ') - fx(' + index['2D Position (Comp projection)Relative to referencePoint'] + ') );',
        '	var M = (A+B)/2;',
        '	var tA = [0,0];',
        '	var tB = [0,0];',
        '	var lB = length(B);',
        '	var lA = length(A);',
        '	if (lA > lB)',
        '	{',
        '		var q = 1;',
        '		if (lA != 0) q = lB/lA;',
        '		A = A/3*q;',
        '		B = B/3;',
        '		tA = M/6*q;',
        '		tB = M/6;',
        '	}',
        '	else',
        '	{',
        '		var q = 1;',
        '		if (lB != 0) q = lA/lB;',
        '		A = A/3;',
        '		B = B/3*q;',
        '		tA = M/6;',
        '		tB = M/6*q;',
        '	}',
        '	createPath([A,B],[ [0,0], tB ],[ tA, [0,0] ],false);',
        '}',
        'else',
        '{',
        '	value;',
        '}'
	].join('\n');

    stroke = angle2.addProperty("ADBE Vector Graphic - Stroke");
    stroke("ADBE Vector Stroke Color").expression = 'effect("Expose Transform")(' + index['DisplayAngleColor'] + ');';
    stroke("ADBE Vector Stroke Width").expression = 'thisComp.height/500;';
    stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
    stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Dash 1').expression = 'thisComp.height/100;';
    stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Gap 1" );
    stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Gap 1').expression = 'thisComp.height/500;';
    
    var distanceGroup = guidesGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
    distanceGroup.name = 'Distance';
    distance = distanceGroup("ADBE Vectors Group");

    path = distance.addProperty("ADBE Vector Shape - Group");
    path("ADBE Vector Shape").expression = ['//Duik.exposeTransform',
        'var fx = effect("' + effect.name + '");',
        'if (fx(' + index['DisplayGuidesCheckbox'] + ').value)',
        '{',
        '	var A = fromComp(fx(' + index['2D Position (Comp projection)Absolute Point'] + '));',
        '	var B = fromComp( fx(' + index['2D Position (Comp projection)Absolute Point'] + ') - fx(' + index['2D Position (Comp projection)Relative to referencePoint'] + ') );',
        '	createPath([A,B],[],[],false);',
        '}',
        'else',
        '{',
        '	value;',
        '}'
	].join('\n');

    stroke = distance.addProperty("ADBE Vector Graphic - Stroke");
    stroke("ADBE Vector Stroke Color").expression = 'effect("Expose Transform")(' + index['DisplayDistanceColor'] + ');';
    stroke("ADBE Vector Stroke Width").expression = 'thisComp.height/500;';
    stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
    stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Dash 1').expression = 'thisComp.height/100;';
    stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Gap 1" );
    stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Gap 1').expression = 'thisComp.height/500;';

    //Effect expressions

    effect(index['2D Position (Comp projection)Absolute Point']).expression = ['//Duik.exposeTransform',
        'var fx = thisProperty.propertyGroup();',
        'var l = null;',
        'try { l = fx(' + index['Target LayerLayer'] + '); } catch (e){ }',
        'if (!l) l = thisLayer;',
        'var result = l.toComp(l.anchorPoint);',
        'result;'
	].join('\n');

    effect(index['2D Position (Comp projection)Relative to referencePoint']).expression = ['//Duik.exposeTransform',
        'var fx = thisProperty.propertyGroup();',
        'var useParent = fx(' + index['ReferenceCheckbox'] + ').value;',
        'var layerPosition = fx(' + index['2D Position (Comp projection)Absolute Point'] + ');',
        'var referencePosition = [0,0];',
        'var rL = null;',
        'if (useParent)',
        '{',
        '   var l = null;',
        '	try { l = fx(' + index['Target LayerLayer'] + '); } catch (e){ }',
        '   if (!l) l = thisLayer;',
        '	if (l.hasParent) rL = l.parent;',
        '	else rL = l;',
        '}',
        'else',
        '{',
        '	try { rL = fx(' + index['Reference LayerLayer'] + '); } catch (e){ }',
        '   if (!rL) rL = thisLayer;',
        '}',
        'referencePosition = rL.toComp(rL.anchorPoint);',
        'var result = layerPosition - referencePosition;',
        'result;'
	].join('\n');

    effect(index['2D Position (Comp projection)2D DistanceSlider']).expression = ['//Duik.exposeTransform',
        'var fx = thisProperty.propertyGroup();',
        'var relativePosition = fx(' + index['2D Position (Comp projection)Relative to referencePoint'] + ');',
        'var result = length( relativePosition );',
        'result;'
	].join('\n');

    effect(index['3D Position (World)AbsolutePoint3D']).expression = ['//Duik.exposeTransform',
        'var fx = thisProperty.propertyGroup();',
        'var l = null;',
        'try { l = fx(' + index['Target LayerLayer'] + '); } catch (e){ }',
        'if (!l) l = thisLayer;',
        'var result = l.toWorld(l.anchorPoint);',
        'result;'
	].join('\n');

    effect(index['3D Position (World)Relative to referencePoint3D']).expression = ['//Duik.exposeTransform',
        'var fx = thisProperty.propertyGroup();',
        'var layerPosition = fx(' + index['3D Position (World)AbsolutePoint3D'] + ');',
        'var useParent = fx(' + index['ReferenceCheckbox'] + ').value;',
        'var rL = null;',
        'if (useParent)',
        '{',
        '   var l = null;',
        '	try { l = fx(' + index['Target LayerLayer'] + '); } catch (e){ }',
        '   if (!l) l = thisLayer;',
        '	if (l.hasParent) rL = l.parent;',
        '	else rL = l;',
        '}',
        'else',
        '{',
        '	try { rL = fx(' + index['Reference LayerLayer'] + '); } catch (e){ }',
        '   if (!rL) rL = thisLayer;',
        '}',
        'var referencePosition = rL.toWorld(rL.anchorPoint);',
        'var result = layerPosition - referencePosition;',
        'result;'
	].join('\n');

    effect(index['3D Position (World)3D DistanceSlider']).expression = ['//Duik.exposeTransform',
        'var fx = thisProperty.propertyGroup();',
        'var relativePosition = fx(' + index['3D Position (World)Relative to referencePoint3D'] + ');',
        'var result = length( relativePosition );',
        'result;'
	].join('\n');

    effect(index['2D OrientationAbsoluteAngle']).expression = ['//Duik.exposeTransform',
        'var fx = thisProperty.propertyGroup();',
        'var l = null;',
        'try { l = fx(' + index['Target LayerLayer'] + ') } catch (e){ }',
        'if (!l) l = thisLayer;',
        'var result = l.rotation;',
        'if (l.position.value.length == 3) result += l.orientation[2];',
        'while(l.hasParent)',
        '{',
        '	l = l.parent;',
        '	result += l.rotation;',
        '	if (l.position.value.length == 3) result += l.orientation[2];',
        '}',
        'result;'
	].join('\n');

    effect(index['2D OrientationRelative to referenceAngle']).expression = ['//Duik.exposeTransform',
        'var fx = thisProperty.propertyGroup();',
        'var useParent = fx(' + index['ReferenceCheckbox'] + ').value;',
        'var rot = fx(' + index['2D OrientationAbsoluteAngle'] + ');',
        'var result = value;',
        'var rL = null;',
        'if (useParent)',
        '{',
        '   var l = null;',
        '	try { l = fx(' + index['Target LayerLayer'] + '); } catch (e){ }',
        '   if (!l) l = thisLayer;',
        '	if (l.hasParent) rL = l.parent;',
        '	else rL = l;',
        '}',
        'else',
        '{',
        '	try { rL = fx(' + index['Reference LayerLayer'] + '); } catch (e){ }',
        '   if (!rL) rL = thisLayer;',
        '}',
        'var refRot = rL.rotation.value;',
        'if (rL.position.value.length == 3) refRot += rL.orientation.value[2];',
        'while(rL.hasParent)',
        '{',
        '	rL = rL.parent;',
        '	refRot += rL.rotation.value;',
        '	if (rL.position.value.length == 3) refRot += rL.orientation.value[2];',
        '}',
        'result = rot - refRot;',
        'result;'
	].join('\n');

    effect(index['Angle (Layer-This-Reference)Angle']).expression = ['//Duik.exposeTransform',
        'var fx = thisProperty.propertyGroup();',
        'var useParent = fx(' + index['ReferenceCheckbox'] + ').value;',
        'var O = thisLayer.toComp(thisLayer.anchorPoint);',
        'var l = null;',
        'var rL = null;',
        'try { l = fx(' + index['Target LayerLayer'] + '); } catch (e){ }',
        'if (!l) l = thisLayer;',
        'if (useParent)',
        '{',
        '	if (l.hasParent) rL = l.parent;',
        '	else rL = l;',
        '}',
        'else',
        '{',
        '	try { rL = fx(' + index['Reference LayerLayer'] + '); } catch (e){ }',
        '   if (!rL) rL = thisLayer;',
        '}',
        'var A = l.toComp(l.anchorPoint);',
        'var B = rL.toComp(rL.anchorPoint);',
        'var OA = O-A;',
        'var OB = O-B;',
        'var angleA = Math.atan2(OA[1], OA[0]);',
        'var angleB = Math.atan2(OB[1], OB[0]);',
        'var result = angleA + angleB;',
        'result = radiansToDegrees(angleB-angleA);',
        'if (result < -180) result += 360;',
        'result;'
	].join('\n');

    //set the layer as target
    if (typeof layer !== 'undefined')
    {
        effect(index['Target LayerLayer'] ).setValue(layer.index);
    }

    return ctrl;
}