/*
	DuTVPaintLib
	Library for interchange with TVPaint
	Copyright (c) 2017-2018 Nicolas Dufresne, Rainbox Productions
	https://rainboxprod.coop

	__Contributors:__

		Nicolas Dufresne - Lead developer
		Kevin Masson - Developer

	__Thanks to:__

		Dan Ebberts - Writing the first IK Expressions
		Eric Epstein - making the IK's work with 3D Layers
		Kevin Schires – Including images in the script
		Matias Poggini – Bezier IK feature
		Eric Epstein - Making the IK's work with 3D Layers
		Assia Chioukh and Quentin Saint-Georges – User Guides composition
		Motion Cafe – Ideas and feedback
		Fous d’anim – Ideas and feedback
		All 258 Duik 15 indiegogo backers for making this libDuik possible!


	This file is part of DuAEF.

	DuAEF is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	DuAEF is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with DuAEF. If not, see <http://www.gnu.org/licenses/>.
*/


/**
	* @class
	* @name TVPCamera
	* @classdesc For use with {@link DuAEF.TVPaint}.<br />
	* A TVPaint camera.<br />
	* Do not instanciate this class,<br />
	* Use {@link DuAEF.TVPaint.parseCam} to create a TVPaint Camera from a .cpt file.
	* @property {TVPCameraPoint[]} points - the points of the animation (keyframe values)
	* @property {int} pointCout - the number of points
	* @property {TVPProfileprof} profileprof - the profileprof (animation interpolations)
*/
function TVPCamera ()
{
	this.points = [];
	this.pointCount = 0;
	this.profileprof = {};
	this.profileprof.points = [];
	this.profileprof.linear = false;
	this.profileprof.pointCount = 0;
}

/**
 * Applies a TVPCamera animation on an After Effects layer
 * @memberof TVPCamera
 * @param {Layer} layer - The layer to animate
 * @param {bool} link - true to automatically all un-parented layers in the composition to the camera.
 * @param {bool} useAnchorPoint - true to animate the anchor point instead of the position.
*/
TVPCamera.prototype.applyToLayer = function(layer,link,useAnchorPoint)
{
	var comp = layer.containingComp;
	var numPoints = this.pointCount;

	if (typeof link === "undefined") link = false;
	if (typeof useAnchorPoint === "undefined") useAnchorPoint = false;

	var moveProp = layer.transform.anchorPoint;
	var rotationLayer = layer;

	// Move
	if (!useAnchorPoint)
	{
		moveProp = layer.transform.position;
		rotationLayer = layer.containingComp.layers.addNull();
		rotationLayer.name = "TVPaint Rotation & Scale";
	}
	var startPos = layer.transform.position.value;
	var intialDif = [0,0];
	for (var i = 0;i< numPoints;i++)
	{
		var point = this.points[i];
		var time = (comp.duration-comp.frameDuration)/(numPoints-1)*i;

		if (i == 0) initialDif = startPos - [point.x,point.y];
		var val;
		useAnchorPoint ? val = [point.x,point.y] : val = 2*startPos-[point.x,point.y]-initialDif;

		moveProp.setValueAtTime(time,val);

		if (i == 0 || i == numPoints-1)
		{
			moveProp.setSpatialTangentsAtKey(i+1,[0,0,0],[0,0,0]);
		}
		else
		{
			moveProp.setSpatialAutoBezierAtKey(i+1,true);
			var inTangent = moveProp.keyInSpatialTangent(i+1);
			var outTangent = moveProp.keyOutSpatialTangent(i+1);
		}
	}

	//rotation & scale
	for (var i =0; i < numPoints;i++)
	{
		var point = this.points[i];
		moveProp.setRovingAtKey(i+1,true);
		time = moveProp.keyTime(i+1);
		rotationLayer.transform.rotation.setValueAtTime(time,point.rotation);
		var zoom = (1+(1-point.zoom))*100;
		rotationLayer.transform.scale.setValueAtTime(time,[zoom,zoom,zoom]);
	}

	//Morpher
	var morpher = layer.Effects.addProperty("ADBE Slider Control");
	morpher.name = "Camera Interpolation";

	var exp = "//Duik.TVPCamera\nvalueAtTime((thisComp.layer(\"" + layer.name +"\").effect(\"Camera Interpolation\")(1)-thisComp.displayStartTime/thisComp.frameDuration)*thisComp.frameDuration)";
	moveProp.expression = exp;
	rotationLayer.transform.rotation.expression = exp;
	rotationLayer.transform.scale.expression = exp;

	//add morpher keys
	var numProfPoints = this.profileprof.pointCount;
	for (var i = 0;i<numProfPoints;i++)
	{
		var point = this.profileprof.points[i];
		morpher(1).setValueAtTime((comp.duration-comp.frameDuration)*point.u,(comp.duration-comp.frameDuration)/comp.frameDuration*point.v);
	}
	//bezier
	if (!this.profileprof.linear)
	{
		for (var i = 1;i<= morpher(1).numKeys;i++)
		{
			morpher(1).setInterpolationTypeAtKey(i,KeyframeInterpolationType.BEZIER);
			if (i != 1 && i != morpher(1).numKeys)
			{
				morpher(1).setTemporalContinuousAtKey(i, true);
				morpher(1).setTemporalAutoBezierAtKey(i, true);
			}
			else
			{
				var easeIn = new KeyframeEase(0,100/3);
				morpher(1).setTemporalEaseAtKey(i,[easeIn]);
			}
		}
	}

	if (!useAnchorPoint) layer.parent = rotationLayer;

	if (link) DuAEF.DuAE.Comp.parentAllOrphans(layer);
}

/**
	* @class
	* @name TVPCameraPoint
	* @classdesc For use with {@link DuAEF.TVPaint}.<br />
	* A TVPaint camera point (keyframe value).<br />
	* This is not a real class, and cannot be instanciated.<br />
	* Use {@link DuAEF.TVPaint.importCamera} to create a TVPaint Camera from a .cpt file.
	* @property {float} x - the X coordinate
	* @property {float} y - the y coordinate
	* @property {float} zoom - the zoom value
	* @property {float} rotation - the rotation angle
*/

/**
	* @class
	* @name TVPProfileprof
	* @classdesc For use with {@link DuAEF.TVPaint}.<br />
	* A TVPaint camera profileprof (animation interpolation).<br />
	* This is not a real class, and cannot be instanciated.<br />
	* Use {@link DuAEF.TVPaint.importCamera} to create a TVPaint Camera from a .cpt file.
	* @property {TVPProfileprofPoint[]} points - the interpolation tangents for each TVPCameraPoint (keyframe)
	* @property {bool} linear - the interpolation (bezier when false)
	* @property {int} pointCount - the number of points
*/

/**
	* @class
	* @name TVPProfileprofPoint
	* @classdesc For use with {@link DuAEF.TVPaint}.<br />
	* A TVPaint camera profileprof point (keyframe tangents).<br />
	* This is not a real class, and cannot be instanciated.<br />
	* Use {@link DuAEF.TVPaint.parseCam} to create a TVPaint Camera from a .cpt file.
	* @property {float} u - the first coordinate
	* @property {float} v - the second coordinate
*/

/**
	* TVPaint interchange tools<br />
	* Dependencies: JSON.jsxinc; DuAEFLib.jsxinc; DuJSLib.jsxinc
	* @namespace
	* @memberof DuAEF
*/
DuAEF.TVPaint = {};

/**
 * Loads a TVPaint Camera
 * @memberof DuAEF.TVPaint
 * @param {File} camFile - The .cpt TVPaint camera file
 * @return {TVPCamera} The TVPaint camera
 */
DuAEF.TVPaint.loadCamera = function(camFile)
{
	var camString = "";
	if (camFile.open("r"))
	{
		camString = camFile.read();
		camFile.close();
	}
	if (camString == "") return;

	return DuAEF.TVPaint.parseCam(camString);
}

/**
 * Parses a TVPaint Camera from its string representation in a .cpt file
 * @memberof DuAEF.TVPaint
 * @param {String} camString - The camera as a .cpt string
 * @return {TVPCamera} The TVPaint camera
*/
DuAEF.TVPaint.parseCam = function(camString)
{
	var camera = new TVPCamera();

	function createTVPaintCameraPoint()
	{
		var point = {};
		point.x = 0.0;
		point.y = 0.0;
		point.zoom = 1.0;
		point.rotation = 0.0;
		return point;
	}

	var lines = camString.split("\n");

	var reXPoint = /point\.(\d+)\.x=(-?\d+\.?\d*)/i;
	var reYPoint = /point\.(\d+)\.y=(-?\d+\.?\d*)/i;
	var reZPoint = /point\.(\d+)\.zoom=(\d+\.?\d*)/i;
	var reRPoint = /point\.(\d+)\.rotation=(-?\d+\.?\d*)/i;
	var reLinear = /profileprof_linear=([01])/i;
	var reProfPoint = /profileprof\_point(\d+)=(\d+.?\d*) (\d+.?\d*)/i;
	var rePointCout = /pointcount=(\d+)/i;
	var reProfPointCount = /profileprof_numpoint=(\d+)/i;
	for (var i=0;i<lines.length;i++ )
	{
		var line = lines[i];
		var count = line.match(rePointCout);
		if (count != null)
		{
			camera.pointCount = parseInt(count[1]);
		}
		var xPoint = line.match(reXPoint);
		if (xPoint != null)
		{
			var index = parseInt(xPoint[1]);
			var value = parseFloat(xPoint[2]);
			var point = camera.points[index];
			if (point === undefined) point = createTVPaintCameraPoint();
			point.x = value ;
			camera.points[index] = point;
		}
		var yPoint = line.match(reYPoint);
		if (yPoint != null)
		{
			var index = parseInt(yPoint[1]);
			var value = parseFloat(yPoint[2]);
			var point = camera.points[index];
			if (point == undefined) point = createTVPaintCameraPoint();
			point.y = value ;
			camera.points[index] = point;
		}
		var zPoint = line.match(reZPoint);
		if (zPoint != null)
		{
			var index = parseInt(zPoint[1]);
			var value = parseFloat(zPoint[2]);
			var point = camera.points[index];
			if (point == undefined) point = createTVPaintCameraPoint();
			point.zoom = value ;
			camera.points[index] = point;
		}
		var rPoint = line.match(reRPoint);
		if (rPoint != null)
		{
			var index = parseInt(rPoint[1]);
			var value = parseFloat(rPoint[2]);
			var point = camera.points[index];
			if (point == undefined) point = createTVPaintCameraPoint();
			point.rotation = value ;
			camera.points[index] = point;
		}
		var linear = line.match(reLinear);
		if (linear != null)
		{
			var lin = parseInt(linear[1]);
			camera.profileprof.linear = (lin == 1);
		}
		var profPoint = line.match(reProfPoint);
		if (profPoint != null)
		{
			var index = parseInt(profPoint[1]);
			var u = parseFloat(profPoint[2]);
			var v = parseFloat(profPoint[3]);
			var point = {};
			point.u = u;
			point.v = v;
			camera.profileprof.points[index] = point;
		}
		var profCount = line.match(reProfPointCount);
		if (profCount != null)
		{
			camera.profileprof.pointCount = parseInt(profCount[1]);
		}
	}

	return camera;
}

/**
	* Imports a clip exported from TVPaint with the MJ_AFX_Export_1.0 tool
	* @memberof DuAEF.TVPaint
	* @param {File} clipInfo - The clipinfo.txt file to import. If a string is provided instead of a File object, it will be used as a path for the file.
*/
DuAEF.TVPaint.importClip = function (clipInfo)
{
	if (typeof clipInfo === 'undefined') throw "You must provide the clipInfo file.";
	if (typeof clipInfo === 'string') clipInfo = File(clipInfo);
	if (!(clipInfo instanceof File)) throw "clipInfo must be a File or a string path.";
	if (!clipInfo.exists) throw "clipInfo file does not exist."

	//get path
	clipFolder = clipInfo.parent;

	//get infos
	clipInfoData = [];
	clipInfo.open('r');
	while(!clipInfo.eof)
	{
		clipInfoData.push(clipInfo.readln());
	}
	clipInfo.close();
	var framerate,clipDuration,bgColor;
	for (var i = 0 ; i < clipInfoData.length ; i++)
	{
		var data = clipInfoData[i].split(';');
		if (data[0].toLowerCase() == 'framerate')
		{
			framerate = data[1];
		}
		else if (data[0].toLowerCase() == 'duration')
		{
			clipDuration = data[1];
		}
		else if (data[0].toLowerCase() == 'bgcolor')
		{
			bgColor = data[1].split(',');
		}
	}

	if (!framerate || !clipDuration || !bgColor) throw "Invalid clipInfo file. Please re-export from TVPaint."

	//get layers
	projClipFolder = app.project.items.addFolder(clipFolder.displayName);
	myNewCompositions = new Array();
	var folders = clipFolder.getFiles(DuAEF.DuJS.Fs.isFolder);
	for(var i = 0; i < folders.length; i++)
	{
		var curLayerFolder = folders[i];
		var folderName = curLayerFolder.displayName;
		var itemArray = curLayerFolder.getFiles("*.png");
		if(itemArray.length > 0)
		{
			itemArray.sort();
		}

		projLayerFolder = app.project.items.addFolder(folderName);
		projLayerFolder.parentFolder = projClipFolder;
		projFramesFolder = app.project.items.addFolder(folderName + "_frames");
		projFramesFolder.parentFolder = projLayerFolder;

		//Importing
		var footage = new Array();
		var files = new Array();
		for(var j = 0; j < itemArray.length;j++)
		{
			var curFile = new File(itemArray[j]);
			var ioRef = new ImportOptions(curFile);
			ioRef.importAs = ImportAsType.FOOTAGE;
			var footageRef = app.project.importFile(ioRef);
			footageRef.parentFolder = projFramesFolder;

			footage[j] = footageRef;
		}

		// read layerinfo
		layerInfopath= curLayerFolder.absoluteURI+"/layerinfo.txt";
		layerInfo = new File(layerInfopath);

		if (layerInfo.exists)
		{
			layerInfo.open();

			var layerIN = layerInfo.readln();
			layerIN = layerIN.split(";");
			layerIN = layerIN[1];

				var layerOUT = layerInfo.readln();
			layerOUT = layerOUT.split(";");
			layerOUT = layerOUT[1];

			var layerBlendmode = layerInfo.readln();
			layerBlendmode = layerBlendmode.split(";");
			layerBlendmode = layerBlendmode[1];

			var layerOpacity = layerInfo.readln();
				layerOpacity = layerOpacity.split(";");
				layerOpacity = layerOpacity[1];
			try
			{
				var layerLabel = layerInfo.readln();
				layerLabel = layerLabel.split(";");
				layerLabel = layerLabel[1]*1;
			}
			catch(e)
			{
				layerLabel = 0;
			}


			layerInfo.close();
		}
		else
		{
			layerIN = 1
			layerOUT = layerIN+clipDuration
			layerBlendmode ="COLOR";
		}

		layerDuration = layerOUT-layerIN+1
		layerDuration=layerDuration*(1/framerate)

		//Creating Composition
		curComp = app.project.items.addComp(folderName,footageRef.width,footageRef.height,1,layerDuration,framerate);
		curComp.parentFolder = projLayerFolder;
		var compStats=new Array(curComp,layerIN,layerOUT,layerBlendmode,layerOpacity,layerLabel);
		myNewCompositions.push(compStats);

		//Timing layers
		for(k=0;k<footage.length;k++)
		{
			curImage = footage[k];
			path = curImage.file.absoluteURI;
			imageNUM =  DuAEF.DuJS.Fs.ImageSequence.getNumber(path)*1;

			//frame duration
			var imageIN = imageNUM/framerate-layerIN/framerate;

			if(k==footage.length-1)
			{
				var imageDuration =  curComp.duration-imageIN;
			}
			else
			{
				nextImage = footage[k+1];
				path = nextImage.file.absoluteURI;
				nextNUM =  DuAEF.DuJS.Fs.ImageSequence.getNumber(path)*1;
				var deltaFrame = nextNUM-imageNUM;
				var imageDuration = deltaFrame/framerate;
			}

			//finding file
			try
			{
				mylayers = curComp.layers.add(curImage);
				mylayers.inPoint = imageIN;
				mylayers.outPoint = imageIN+imageDuration;
			}
			catch(e)
			{
				alert("Cant Add Frame "+xsht_file+"\nof "+nameMain+"\n Probably because the footage wasnt imported because there is a write failue in the File");
			}
		}
	}

	//collect Layers In animation Comp
	var collectComp = app.project.items.addComp(clipFolder.displayName,myNewCompositions[0][0].width,myNewCompositions[0][0].height,1,clipDuration/framerate,framerate);
	collectComp.parentFolder = projClipFolder;

	collectComp.bgColor =bgColor;
	for(var p = myNewCompositions.length;p>0 ;p--)
	{
		var curCompStats = myNewCompositions[p-1];
		var curComp=curCompStats[0];
		var curIN=curCompStats[1];
		var curOUT=curCompStats[2];
		var curBLEND=curCompStats[3];
		var curOPACITY=curCompStats[4];
		var curLABEL=curCompStats[5];
		var curLayer = collectComp.layers.add(curComp);
		DuAEF.TVPaint.setBlendingMode(curLayer,curBLEND);
		curLayer.startTime =(curIN-1)/framerate;
		curLayer.opacity.setValue(curOPACITY);

		try
		{
			curLayer.label=curLABEL*1;
		}
		catch(e)
		{
			curLayer.label=15;
		}
	}

	//detect exposure in precomps
	for (var j = 1;j<= collectComp.numLayers;j++)
	{
		//get layer
		precompLayer = collectComp.layer(j);
		DuAEF.Duik.Animation.getPrecompExposure(precompLayer);
	}
}

/**
	* Sets the blending mode of an AE Layer based on the TVPaint blend mode name
	* @memberof DuAEF.TVPaint
	* @param {AVLayer}		layer		The layer
	* @param {string}		blendName	The TVPaint blending mode name
*/
DuAEF.TVPaint.setBlendingMode = function (layer,blendName)
{
	switch (blendName)
	{
		case "Color":
			layer.blendingMode = BlendingMode.NORMAL;
			break;
		case "Add":
			layer.blendingMode =  BlendingMode.ADD;
		case "Screen":
			layer.blendingMode =  BlendingMode.SCREEN;
			break;
		case "Multiply":
			layer.blendingMode =  BlendingMode.MULTIPLY;
			break;
		case "Overlay":
			layer.blendingMode =  BlendingMode.OVERLAY;
			break;
		default:
			layer.blendingMode = BlendingMode.NORMAL;
	}
}