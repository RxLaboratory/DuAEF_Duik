/**
	* Constructs a new KeySpatialProperty
	* @class KeySpatialProperties
	* @classdesc Spatial properties of a {@linkcode KeyFrame}.
	* @property {float[]|null}	  [inTangent=null]     - The incoming spatial tangent
	* @property {float[]|null}    [outTangent=null]            -  The outgoing spatial tangent
	* @property {boolean}      [_continuous=true]         - true if the specified keyframe has spatial continuity
	* @property {boolean}	[_autoBezier=false]			- true if the specified keyframe has temporal auto-Bezier interpolation
	* @property {boolean}	[_roving=false]	- true if the specified keyframe is roving
*/
function KeySpatialProperties (){
	this.inTangent = null;
	this.outTangent = null;
	this._continuous = true;
	this._autoBezier = false;
	this._roving = false;
}

/**
	 Constructs a new KeyFrame
	* @class KeyFrame
	* @classdesc Properties of an After Effects Keyframe, as returned by {@linkcode DuAEF.DuAE.Property.getKeyFrames} or {@linkcode DuAEF.DuAE.Property.getKeyFrameAtIndex} or {@linkcode DuAEF.DuAE.Property.getKeyFrameAtTime}.
	* @property {float}	  _time     - The keyframe time
	* @property {null|folat[]|float|MarkerValue|int|Shape|TextDocument}    value  -  The keyframe value
	* @property {KeyframeInterpolationType}   _inInterpolationType  - The incoming temporal interpolation type
	* @property {KeyframeInterpolationType}	_outInterpolationType		- The outgoing temporal interpolation type
	* @property {boolean}	_spatial	- true if this keyframe has a spatial value
	* @property {KeySpatialProperties}	spatialProperties	- the spatial properties {@linkcode KeySpatialProperties} of this keyframe
	* @property {KeyframeEase[]}	inEase	- The incoming temporal ease. The number of objects in the Array depends on the value type
	* @property {KeyframeEase[]}	outEase	- The outgoing temporal ease. The number of objects in the Array depends on the value type
	* @property {boolean}	_continuous	- true if the keyframe has temporal continuity
	* @property {boolean}	_autoBezier	- true if the keyframe has temporal auto-Bezier interpolation
	* @property {int}		_index	- The index of the keyFrame. Warning: not updated when another key frame is added on the property some time before this key._time!
*/
function KeyFrame(){
	this._time = 0;
	this.value = null;
	this._inInterpolationType = KeyframeInterpolationType.LINEAR;
	this._outInterpolationType = KeyframeInterpolationType.LINEAR;
	this._spatial = false;
	this.spatialProperties = new KeySpatialProperties();
	this.inEase = null;
	this.outEase = null;
	this._continuous = false;
	this._autoBezier = false;
	this._index = 0;
}

/**
	* Constructs a new animation
	* @class PropertyAnim
	* @classdesc Describes the animation of an After Effects property
	* @property {string}	  [_name=""]     - The property name
	* @property {string}    [_matchName=""]  - The property matchName
	* @property {KeyFrame[]}   [keys=[]]  - The keyframes of the animation
	* @property {null|float[]|float|MarkerValue|int|Shape|TextDocument}	[startValue=null]		- The value at the beginning of the animation
	* @property {string}	[expression=""]		- The expression on the property, if any.
	* @property {string}   [type="anim"]  - Read Only.
	* @property {float}   startTime  - Read Only. The starting time of the animation.
	* @property {float}   endTime  - Read Only. The ending time of the animation.
*/
function PropertyAnim()
{
	this._name = "";
	this._matchName = "";
	this.keys = [];
	this.startValue = null;
	this.type = "anim";
	this.expression = "";
	this.dimensions = 0;
	this.startTime = null;
	this.endTime = null;
}

/**
	* Constructs a new group animation
	* @class PropertyGroupAnim
	* @classdesc Contains all PropertyAnim from an After Effects PropertyGroup
	* @property {string}	  [_name=""]     - The property name
	* @property {string}    [_matchName=""]  - The property matchName
	* @property {PropertyAnim[]|PropertyGroupAnim[]}   [anims=[]]  - The animations in the group
	* @property {string}   [type="group"]  - Read Only.
	* @property {float}   startTime  - Read Only. The starting time of the animation.
	* @property {float}   endTime  - Read Only. The ending time of the animation.
*/
function PropertyGroupAnim()
{
	this._name = "";
	this._matchName = "";
	this.anims = [];
	this.type = "group";
	this.startTime = null;
	this.endTile = null;
}

/**
	* Constructs a new layer animation
	* @class LayerAnim
	* @classdesc Contains all PropertyGroupAnim from an After Effects Layer
	* @property {string}	  [_name=""]     - The property name
	* @property {int}    [_index=""]  - The index of the layer
	* @property {PropertyGroupAnim[]} [anims=[]] - All the animations of the layer
	* @property {float} [firstKeyFrameTime=0] - The time of the first keyframe
	* @property {string}   [type="layer"]  - Read Only.
	* @property {float}   startTime  - Read Only. The starting time of the animation.
	* @property {float}   endTime  - Read Only. The ending time of the animation.
*/
function LayerAnim()
{
	this._name = "";
	this._index = 0;
	this.anims = [];
	this.type = 'layer';
	this.startTime = null;
	this.endTile = null;
}

/**
	* Constructs a new PropertyInfo
	* @example
	* var propInfo = new PropertyInfo(property);
	* layer("ADBE effect parade").addProperty("ADBE layer control"); //now the property object is broken
	* property = propInfo.getProperty(); // You can retrieve the property like this, fixed if it's an effect
	* @class PropertyInfo
	* @classdesc Get some handy informations about a property<br />
	* This class is able to "fix" effects properties which have been broken by
	* the addition of another effect on the same layer, as long as the class has been
	* instanciated before the effect has been broken.
	* @param {PropertyBase|PropertyInfo} property - The property. If a PropertyInfo is provided, the constructor returns it (it does not make a copy).<br />
	* This makes it easy to avoid type checking, as you can always pass any property or PropertyInfo to the constructor to be sure to handle a PropertyInfo, without any impact on performance.<br />
	* @example
	* myFunction (prop) //This function can be passed either a property or a PropertyInfo
	* {
	* propInfo = new PropertyInfo(prop);
	* prop = propInfo.getProperty();
	* }
	* @property {int} index - The propertyIndex
	* @property {boolean} isEffect - true if this is an effect (sub)property
	* @property {boolean} riggable  - true if this prop can be rigged (it's a value which can set expressions)
	* @property {Layer} layer - The layer containing the property
	* @property {int} dimensions - The number of dimensions, 0 if this is not a dimensionnal value (ie color, text, shape...)
	* @property {string} name - The name of the property
	* @property {string} matchName - The matchName of the property
	* @property {PropertyGroup|null} effect - The effect containing the property
	* @property {boolean} editable - true if the value of the property can be changed
	* @property {boolean} numerical - true if the value is a number or an array of numbers
	* @property {boolean} isPercent - true if the unit is a percentage
	* @property {boolean} isAngle - true if the unit is a degree
	* @property {boolean} isPixels - true if the unit is a pixel
	* @property {int} numKeys - the number of keyframes on the property
	* @property {bool} group - true if the property is a PropertyGroup
	* @property {string} unitsText - the name of the unit (localized)
	* @property {string} unit - the abbreviated unit, as displayed in the UI (localized)
*/
function PropertyInfo(property)
{
	if (property instanceof PropertyInfo) return property;
	
	var expressionEnabled = property.expressionEnabled;
	if (property.propertyType == PropertyType.PROPERTY)
	{
		this.numKeys = property.numKeys;
		this.group = false;
	}
	else
	{
		this.group = true;
		this.numKeys = 0;
	}
	this.property = property;
	this.name = property.name;
	this.matchName = property.matchName;
	this.index = property.propertyIndex;
	this.parentIndices  = [this.index];
	this.isEffect = property.isEffect;
	this.effect = null;
	if (!this.isEffect)
	{
		var parentProp = property;
		while (parentProp.parentProperty)
		{
			// Traverse up the property tree
			parentProp = parentProp.parentProperty;
			this.isEffect = parentProp.isEffect;
			this.parentIndices.unshift(parentProp.propertyIndex);
			if (this.isEffect) this.effect = parentProp;
			if (this.isEffect) break;
		}
	}
	else this.effect = property;

	this.riggable = DuAEF.DuAE.Property.isRiggable(property);
	this.editable = DuAEF.DuAE.Property.isEditable(property);
	this.numerical = DuAEF.DuAE.Property.isNumerical(property);
	this.layer = DuAEF.DuAE.Property.getLayer(property);
	this.comp = this.layer.containingComp;
	this.dimensions = DuAEF.DuAE.Property.getDimensions(property);
	this.unitsText = property.unitsText;
	this.isPercent = this.unitsText == localize("$$$/AE/TLW/GraphEditor/PercentSource=percent");
	this.isAngle = this.unitsText == localize("$$$/AE/TLW/GraphEditor/DegreesSource=degrees");
	this.isPixels = this.unitsText == localize("$$$/AE/TLW/GraphEditor/PixelsSource=pixels");
	this.unit = "";
	if (this.isPercent) this.unit = localize("$$$/AE/TLW/GraphEditor/PercentDest=%");
	if (this.isAngle) this.unit = localize("$$$/AE/TLW/GraphEditor/DegreesDest=°");
	if (this.isPixels) this.unit = localize("$$$/AE/TLW/GraphEditor/PixelsDest=px");

	if (this.riggable) property.expressionEnabled = expressionEnabled;
}

/**
	* Gets the original Property<br />
	* Always works even if this PropertyInfo represents an effect which has been broken<br />
	* ---AE Hack---
	* @memberof PropertyInfo
	* @return {PropertyBase} The property
	* @todo When returning an effect, check if the matchName corresponds too.
*/
PropertyInfo.prototype.getProperty = function()
{
	if (this.isEffect)
	{
		var parentProp = this.layer("ADBE Effect Parade");
		for (var i = 0 ; i < this.parentIndices.length ; i++)
		{
			parentProp = parentProp(this.parentIndices[i]);
		}
		this.property = parentProp;
	}
	return this.property;
}

/**
 * After Effects Tools
 * @author Nicolas Dufresne, Kevin Masson and contributors
 * @copyright 2017,2018 Nicolas Dufresne, Rainbox Productions<br />
 * {@link https://rainboxprod.coop}
 * @namespace
 * @memberof DuAEF
 * @license GPL-3.0 <br />
 * DuAEF is free software: you can redistribute it and/or modify<br />
 * it under the terms of the GNU General Public License as published by<br />
 * the Free Software Foundation, either version 3 of the License, or<br />
 * (at your option) any later version.<br />
 *<br />
 * DuAEF is distributed in the hope that it will be useful,<br />
 * but WITHOUT ANY WARRANTY; without even the implied warranty of<br />
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<br />
 * GNU General Public License for more details.<br />
 *<br />
 * You should have received a copy of the GNU General Public License<br />
 * along with DuAEF. If not, see {@link http://www.gnu.org/licenses/}.
*/
DuAEF.DuAE = {};


// low-level undocumented method
// Loads pseudo effects and presets
// just before entering runtime
DuAEF.DuAE.postInit = function()
{

	//PRESETS

	#include "pseudoEffects/duaef_magic.ffx.jsxinc"
	duaef_magic = DuAEF.DuBinary.toFile(duaef_magic);

	DuAEF.DuAE.Presets =
	{
		MAGIC: duaef_magic
	};

	//PSEUDO EFFECTS

	
}


/**
 * The axis or channels
 * @enum {int}
 * @readonly
*/
DuAEF.DuAE.Axis =
{
	X: 1,
	Y: 2,
	Z: 3,
	RED: 4,
	GREEN: 5,
	BLUE: 6,
	ALPHA: 7,
	HUE: 8,
	SATURATION: 9,
	VALUE: 10
}

/**
 * Types of values
 * @enum {int}
 * @readonly
*/
DuAEF.DuAE.Types =
{
	VALUE: 1,
	VELOCITY: 2
}

/**
 * Abbreviated units used in the UI.<br />
 * These strings are localized based on internal After Effects dictionnaries.
 * @enum {string}
 * @readonly
*/
DuAEF.DuAE.Units =
{
	PIXELS: localize("$$$/AE/TLW/GraphEditor/PixelsDest=px"),
	DEGREES: localize("$$$/AE/TLW/GraphEditor/DegreesDest=°"),
	PERCENT: localize("$$$/AE/TLW/GraphEditor/PercentDest=%")
}

/**
 * Units used in the UI<br />
 * These strings are localized based on internal After Effects dictionnaries.
 * @enum {string}
 * @readonly
*/
DuAEF.DuAE.UnitsText =
{
	PERCENT: localize("$$$/AE/TLW/GraphEditor/PixelsSource=percent"),
	DEGREES: localize("$$$/AE/TLW/GraphEditor/DegreesSource=degrees"),
	PIXELS: localize("$$$/AE/TLW/GraphEditor/PercentSource=pixels")
}

/**
	* Associative array that converts property match names to their compact English expression statements.
	* @example
	* DuAEF.DuAE.compactExpressions["ADBE Transform Group"]
	* //returns "'transform'"
	* @type {Object}
*/
DuAEF.DuAE.compactExpressions =
{
	"ADBE Transform Group":"'transform'",
	// Handle camera/light vs. AV layers
	"ADBE Anchor Point":"((prop.propertyGroup(prop.propertyDepth).property('intensity')!=null) || (prop.propertyGroup(prop.propertyDepth).property('zoom')!=null)) ? '.pointOfInterest' : '.anchorPoint'",
	"ADBE Position":"'.position'",
	"ADBE Scale":"'.scale'",
	"ADBE Orientation":"'.orientation'",
	"ADBE Rotate X":"'.xRotation'",
	"ADBE Rotate Y":"'.yRotation'",
	// Handle 3D vs. 2D layers
	"ADBE Rotate Z":"(prop.propertyGroup(prop.propertyDepth).threeDLayer || (prop.propertyGroup(prop.propertyDepth).property('intensity')!=null) || (prop.propertyGroup(prop.propertyDepth).property('zoom')!=null)) ? '.zRotation' : '.rotation'",
	"ADBE Opacity":"'.opacity'",
	"ADBE Material Options Group":"'materialOption'",
	"ADBE Casts Shadows":"'.castsShadows'",
	"ADBE Light Transmission":"'.lightTransmission'",
	"ADBE Accepts Shadows":"'.acceptsShadows'",
	"ADBE Accepts Lights":"'.acceptsLights'",
	"ADBE Ambient Coefficient":"'.ambient'",
	"ADBE Diffuse Coefficient":"'.diffuse'",
	"ADBE Specular Coefficient":"'.specular'",
	"ADBE Shininess Coefficient":"'.shininess'",
	"ADBE Metal Coefficient":"'.metal'",
	"ADBE Light Options Group":"'lightOption'",
	"ADBE Light Intensity":"'.intensity'",
	"ADBE Light Color":"'.color'",
	"ADBE Light Cone Angle":"'.coneAngle'",
	"ADBE Light Cone Feather 2":"'.coneFeather'",
	"ADBE Light Shadow Darkness":"'.shadowDarkness'",
	"ADBE Light Shadow Diffusion":"'.shadowDiffusion'",
	"ADBE Camera Options Group":"'cameraOption'",
	"ADBE Camera Zoom":"'.zoom'",
	"ADBE Camera Depth of Field":"'.depthOfField'",
	"ADBE Camera Focus Distance":"'.focusDistance'",
	"ADBE Camera Aperture":"'.aperture'",
	"ADBE Camera Blur Level":"'.blurLevel'",
	"ADBE Text Properties":"'text'",
	"ADBE Text Document":"'.sourceText'",
	"ADBE Text Path Options":"'.pathOption'",
	"ADBE Text Path":"'.path'",
	"ADBE Text Reverse Path":"'.reversePath'",
	"ADBE Text Perpendicular To Path":"'.perpendicularToPath'",
	"ADBE Text Force Align Path":"'.forceAlignment'",
	"ADBE Text First Margin":"'.firstMargin'",
	"ADBE Text Last Margin":"'.lastMargin'",
	"ADBE Text More Options":"'.moreOption'",
	"ADBE Text Anchor Point Option":"'.anchorPointGrouping'",
	"ADBE Text Anchor Point Align":"'.groupingAlignment'",
	"ADBE Text Render Order":"'.fillANdStroke'",
	"ADBE Text Character Blend Mode":"'.interCharacterBlending'",
	"ADBE Text Animators":"'.animator'",
	"ADBE Text Selectors":"'.selector'",
	"ADBE Text Percent Start":"'.start'",
	"ADBE Text Percent End":"'.end'",
	"ADBE Text Percent Offset":"'.offset'",
	"ADBE Text Index Start":"'.start'",
	"ADBE Text Index End":"'.end'",
	"ADBE Text Index Offset":"'.offset'",
	"ADBE Text Range Advanced":"'.advanced'",
	"ADBE Text Range Units":"'.units'",
	"ADBE Text Range Type2":"'.basedOn'",
	"ADBE Text Selector Mode":"'.mode'",
	"ADBE Text Selector Max Amount":"'.amount'",
	"ADBE Text Range Shape":"'.shape'",
	"ADBE Text Selector Smoothness":"'.smoothness'",
	"ADBE Text Levels Max Ease":"'.easeHigh'",
	"ADBE Text Levels Min Ease":"'.easeLow'",
	"ADBE Text Randomize Order":"'.randomizeOrder'",
	"ADBE Text Random Seed":"'.randomSeed'",
	"ADBE Text Selector Mode":"'.mode'",
	"ADBE Text Wiggly Max Amount":"'.maxAmount'",
	"ADBE Text Wiggly Min Amount":"'.minAmount'",
	"ADBE Text Range Type2":"'.basedOn'",
	"ADBE Text Temporal Freq":"'.wigglesSecond'",
	"ADBE Text Character Correlation":"'.correlation'",
	"ADBE Text Temporal Phase":"'.temporalPhase'",
	"ADBE Text Spatial Phase":"'.spatialPhase'",
	"ADBE Text Wiggly Lock Dim":"'.lockDimensions'",
	"ADBE Text Wiggly Random Seed":"'.randomSeed'",
	"ADBE Text Range Type2":"'.basedOn'",
	"ADBE Text Expressible Amount":"'.amount'",
	"ADBE Text Animator Properties":"'.property'",
	"ADBE Text Anchor Point 3D":"'.anchorPoint'",
	"ADBE Text Position 3D":"'.position'",
	"ADBE Text Scale 3D":"'.scale'",
	"ADBE Text Skew":"'.skew'",
	"ADBE Text Skew Axis":"'.skewAxis'",
	"ADBE Text Rotation X":"'.xRotation'",
	"ADBE Text Rotation Y":"'.yRotation'",
	"ADBE Text Rotation":"'.zRotation'",
	"ADBE Text Opacity":"'.opacity'",
	"ADBE Text Fill Opacity":"'.fillOpacity'",
	"ADBE Text Fill Color":"'.fillColor'",
	"ADBE Text Fill Hue":"'.fillHue'",
	"ADBE Text Fill Saturation":"'.fillSaturation'",
	"ADBE Text Fill Brightness":"'.fillBrightness'",
	"ADBE Text Stroke Opacity":"'.strokeOpacity'",
	"ADBE Text Stroke Color":"'.strokeColor'",
	"ADBE Text Stroke Hue":"'.strokeHue'",
	"ADBE Text Stroke Saturation":"'.strokeSaturation'",
	"ADBE Text Stroke Brightness":"'.strokeBrightness'",
	"ADBE Text Stroke Width":"'.strokeWidth'",
	"ADBE Text Line Anchor":"'.lineAnchor'",
	"ADBE Text Line Spacing":"'.lineSpacing'",
	"ADBE Text Track Type":"'.trackingType'",
	"ADBE Text Tracking Amount":"'.trackingAmount'",
	"ADBE Text Character Change Type":"'.characterAlignment'",
	"ADBE Text Character Range":"'.characterRange'",
	"ADBE Text Character Replace":"'.characterValue'",
	"ADBE Text Character Offset":"'.characterOffset'",
	"ADBE Text Blur":"'.blur'",
	"ADBE Mask Parade":"'mask'",
	"ADBE Mask Shape":"'.maskPath'",
	"ADBE Mask Feather":"'.maskFeather'",
	"ADBE Mask Opacity":"'.maskOpacity'",
	"ADBE Mask Offset":"'.maskExpansion'",
	"ADBE Effect Parade":"'effect'",
	"ADBE Paint Group":"'.stroke'",
	"ADBE Paint Shape":"'.path'",
	"ADBE Paint Properties":"'.strokeOption'",
	"ADBE Paint Begin":"'.start'",
	"ADBE Paint End":"'.end'",
	"ADBE Paint Color":"'.color'",
	"ADBE Paint Diameter":"'.diameter'",
	"ADBE Paint Angle":"'.angle'",
	"ADBE Paint Hardness":"'.hardness'",
	"ADBE Paint Roundness":"'.roundness'",
	"ADBE Paint Tip Spacing":"'.spacing'",
	"ADBE Paint Target Channels":"'.channels'",
	"ADBE Paint Opacity":"'.opacity'",
	"ADBE Paint Flow":"'.flow'",
	"ADBE Paint Clone Layer":"'.cloneSource'",
	"ADBE Paint Clone Position":"'.clonePosition'",
	"ADBE Paint Clone Time":"'.cloneTime'",
	"ADBE Paint Clone Time Shift":"'.cloneTimeShift'",
	"ADBE Paint Transform":"'.transform'",
	"ADBE Paint Anchor Point":"'.anchorPoint'",
	"ADBE Paint Position":"'.position'",
	"ADBE Paint Scale":"'.scale'",
	"ADBE Paint Rotation":"'.rotation'",
	"ADBE MTrackers":"'motionTracker'",
	"ADBE MTracker Pt Feature Center":"'.featureCenter'",
	"ADBE MTracker Pt Feature Size":"'.featureSize'",
	"ADBE MTracker Pt Search Ofst":"'.searchOffset'",
	"ADBE MTracker Pt Search Size":"'.searchSize'",
	"ADBE MTracker Pt Confidence":"'.confidence'",
	"ADBE MTracker Pt Attach Pt":"'.attachPoint'",
	"ADBE MTracker Pt Attach Pt Ofst":"'.attachPointOffset'",
	"ADBE Audio Group":"'audio'",
	"ADBE Audio Levels":"'.audioLevels'",
	"ADBE Time Remapping":"'timeRemap'",
	"ADBE Layer Styles":"'layerStyle'",
	"ADBE Blend Options Group":"'.blendingOption'",
		"ADBE Global Angle2":"'.globalLightAngle'",
		"ADBE Global Altitude2":"'.globalLightAltitude'",
		"ADBE Adv Blend Group":"'.advancedBlending'",
		"ADBE Layer Fill Opacity2":"'.fillOpacity'",
		"ADBE R Channel Blend":"'.red'",
		"ADBE G Channel Blend":"'.green'",
		"ADBE B Channel Blend":"'.blue'",
		"ADBE Blend Interior":"'.blendInteriorStylesAsGroup'",
		"ADBE Blend Ranges":"'.useBlendRangesFromSource'",
	"dropShadow/enabled":"'.dropShadow'",
		"dropShadow/mode2":"'.blendMode'",
		"dropShadow/color":"'.color'",
		"dropShadow/opacity":"'.opacity'",
		"dropShadow/useGlobalAngle":"'.useGlobalLight'",
		"dropShadow/localLightingAngle":"'.angle'",
		"dropShadow/distance":"'.distance'",
		"dropShadow/chokeMatte":"'.spread'",
		"dropShadow/blur":"'.size'",
		"dropShadow/noise":"'.noise'",
		"dropShadow/layerConceals":"'.layerKnocksOutDropShadow'",
	"innerShadow/enabled":"'.innerShadow'",
		"innerShadow/mode2":"'.blendMode'",
		"innerShadow/color":"'.color'",
		"innerShadow/opacity":"'.opacity'",
		"innerShadow/useGlobalAngle":"'.useGlobalLight'",
		"innerShadow/localLightingAngle":"'.angle'",
		"innerShadow/distance":"'.distance'",
		"innerShadow/chokeMatte":"'.choke'",
		"innerShadow/blur":"'.size'",
		"innerShadow/noise":"'.noise'",
	"outerGlow/enabled":"'.outerGlow'",
		"outerGlow/mode2":"'.blendMode'",
		"outerGlow/opacity":"'.opacity'",
		"outerGlow/noise":"'.noise'",
		"outerGlow/AEColorChoice":"'.colorType'",
		"outerGlow/color":"'.color'",
		"outerGlow/gradientSmoothness":"'.gradientSmoothness'",
		"outerGlow/glowTechnique":"'.technique'",
		"outerGlow/chokeMatte":"'.spread'",
		"outerGlow/blur":"'.size'",
		"outerGlow/inputRange":"'.range'",
		"outerGlow/shadingNoise":"'.jitter'",
	"innerGlow/enabled":"'.innerGlow'",
		"innerGlow/mode2":"'.blendMode'",
		"innerGlow/opacity":"'.opacity'",
		"innerGlow/noise":"'.noise'",
		"innerGlow/AEColorChoice":"'.colorType'",
		"innerGlow/color":"'.color'",
		"innerGlow/gradientSmoothness":"'.gradientSmoothness'",
		"innerGlow/glowTechnique":"'.technique'",
		"innerGlow/innerGlowSource":"'.source'",
		"innerGlow/chokeMatte":"'.choke'",
		"innerGlow/blur":"'.size'",
		"innerGlow/inputRange":"'.range'",
		"innerGlow/shadingNoise":"'.jitter'",
	"bevelEmboss/enabled":"'.bevelAndEmboss'",
		"bevelEmboss/bevelStyle":"'.style'",
		"bevelEmboss/bevelTechnique":"'.technique'",
		"bevelEmboss/strengthRatio":"'.depth'",
		"bevelEmboss/bevelDirection":"'.direction'",
		"bevelEmboss/blur":"'.size'",
		"bevelEmboss/softness":"'.soften'",
		"bevelEmboss/useGlobalAngle":"'.useGlobalLight'",
		"bevelEmboss/localLightingAngle":"'.angle'",
		"bevelEmboss/localLightingAltitude":"'.altitude'",
		"bevelEmboss/highlightMode":"'.highlightMode'",
		"bevelEmboss/highlightColor":"'.highlightColor'",
		"bevelEmboss/highlightOpacity":"'.highlightOpacity'",
		"bevelEmboss/shadowMode":"'.shadowMode'",
		"bevelEmboss/shadowColor":"'.shadowColor'",
		"bevelEmboss/shadowOpacity":"'.shadowOpacity'",
	"chromeFX/enabled":"'.satin'",
		"chromeFX/mode2":"'.blendMode'",
		"chromeFX/color":"'.color'",
		"chromeFX/opacity":"'.opacity'",
		"chromeFX/localLightingAngle":"'.angle'",
		"chromeFX/distance":"'.distance'",
		"chromeFX/blur":"'.size'",
		"chromeFX/invert":"'.invert'",
	"solidFill/enabled":"'.colorOverlay'",
		"solidFill/mode2":"'.blendMode'",
		"solidFill/color":"'.color'",
		"solidFill/opacity":"'.opacity'",
	"gradientFill/enabled":"'.gradientOverlay'",
		"gradientFill/mode2":"'.blendMode'",
		"gradientFill/opacity":"'.opacity'",
		"gradientFill/gradientSmoothness":"'.gradientSmoothness'",
		"gradientFill/angle":"'.angle'",
		"gradientFill/type":"'.style'",
		"gradientFill/reverse":"'.reverse'",
		"gradientFill/align":"'.alignWithLayer'",
		"gradientFill/scale":"'.scale'",
		"gradientFill/offset":"'.offset'",
	"patternFill/enabled":"'.patternOverlay'",
		"patternFill/mode2":"'.blendMode'",
		"patternFill/opacity":"'.opacity'",
		"patternFill/align":"'.linkWithLayer'",
		"patternFill/scale":"'.scale'",
		"patternFill/phase":"'.offset'",
	"frameFX/enabled":"'.stroke'",
		"frameFX/mode2":"'.blendMode'",
		"frameFX/color":"'.color'",
		"frameFX/size":"'.size'",
		"frameFX/opacity":"'.opacity'",
		"frameFX/style":"'.position'",
};

/**
	* Menu Command Ids<br />
	* These are the ids which can be found using <code>app.findMenuCommandID("insertMenuNameHere");</code><br />
	* Use <code>app.executeCommand(id)</code> to run them.
	* @enum {int}
	* @readonly
	* @example
	* app.executeCommand(DuAEF.DuAE.menuCommandID.COPY); //copies the selection
	* app.executeCommand(DuAEF.DuAE.menuCommandID.PASTE); //pastes the selection
*/
DuAEF.DuAE.menuCommandID =
{
	//EDIT menu
	CUT: 18,
	COPY: 19,
	COPY_WITH_PROPERTY_LINKS: 10310,
	PASTE: 20,
	DUPLICATE: 2080
}

/**
	* How to place new layers
	* @enum {int}
	* @readonly
*/
DuAEF.DuAE.LayerPlacements =
{
	BOTTOM: 0,
	UNDER_LAYER: 1,
	ABOVE_LAYER: 2,
	TOP: 3
}

/**
 * Types of layers used by Ae
 * @enum {string}
 * @readonly
*/
DuAEF.DuAE.LayerTypes =
{
	NULL: 'null',
	SOLID: 'solid',
	SHAPE: 'shape',
	TEXT: 'text',
	ADJUSTMENT: 'adjustment',
	LIGHT: 'light',
	CAMERA: 'camera'
}

/**
 * Attributes of layers in Ae
 * @enum {string}
 * @readonly
*/
DuAEF.DuAE.LayerAttributes =
{
	SELECTED: 'selected',
	VISIBLE: 'visible',
	AUDIO: 'audio',
	SOLO: 'solo',
	LOCKED: 'locked',
	SHY: 'shy',
	EFFECTS_ENABLED: 'effects',
	MOTION_BLUR: 'motionblur',
	THREE_D: '3d',
	GUIDE: 'guide'
}

/**
 * Loop types
 * @enum {string}
 * @readonly
*/
DuAEF.DuAE.LoopTypes = 
{
	HOLD: 'hold',
	NONE: 'none',
	CYCLE: 'cycle',
	PINGPONG: 'pingpong',
	OFFSET: 'offset',
	CONTINUE: 'continue'
}

/**
 * Default color labels
 * @readonly
 * @todo get real labels (from pref file?)
 */
DuAEF.DuAE.ColorLabels = [];
DuAEF.DuAE.ColorLabels[0]  = [0, 0, 0 ];	// 0. None
DuAEF.DuAE.ColorLabels[1]  = [121/255, 058/255, 058/255 ];	// 1. Red
DuAEF.DuAE.ColorLabels[2]  = [144/255, 138/255, 068/255 ];	// 2. Yellow
DuAEF.DuAE.ColorLabels[3]  = [115/255, 132/255, 130/255 ];	// 3. Aqua
DuAEF.DuAE.ColorLabels[4]  = [145/255, 124/255, 131/255 ];	// 4. Pink
DuAEF.DuAE.ColorLabels[5]  = [115/255, 115/255, 131/255 ];	// 5. Lavender
DuAEF.DuAE.ColorLabels[6]  = [146/255, 127/255, 109/255 ];	// 6. Peach
DuAEF.DuAE.ColorLabels[7]  = [120/255, 130/255, 120/255 ];	// 7. Sea Foam
DuAEF.DuAE.ColorLabels[8]  = [082/255, 093/255, 142/255 ];	// 8. Blue
DuAEF.DuAE.ColorLabels[9]  = [067/255, 112/255, 068/255 ];	// 9. Green
DuAEF.DuAE.ColorLabels[10] = [101/255, 052/255, 107/255 ];	// 10. Purple
DuAEF.DuAE.ColorLabels[11] = [146/255, 103/255, 037/255 ];	// 11. Orange
DuAEF.DuAE.ColorLabels[12] = [094/255, 065/255, 051/255 ];	// 12. Brown
DuAEF.DuAE.ColorLabels[13] = [152/255, 085/255, 137/255 ];	// 13. Fuchsia
DuAEF.DuAE.ColorLabels[14] = [061/255, 111/255, 113/255 ];	// 14. Cyan
DuAEF.DuAE.ColorLabels[15] = [114/255, 105/255, 090/255 ];	// 15. Sandstone
DuAEF.DuAE.ColorLabels[16] = [045/255, 062/255, 045/255 ];	// 16. DarkGreen

/**
	* Checks if the param is an AE collection or an Array
	* @param {Array|Collection} collection - The list to check
	* @return {boolean} true if collection is a collection, false if it's an array
*/
DuAEF.DuAE.isCollection = function (collection)
{
	return collection instanceof ItemCollection || collection instanceof LayerCollection || collection instanceof OMCollection || collection instanceof RQItemCollection;
}

/**
	* Gets the PropertyInfo for the properties
	* @param {PropertyBase[]} props - The Properties
	* @return {PropertyInfo[]} The info
*/
DuAEF.DuAE.getPropertyInfos = function (props)
{
	//convert to propinfo
	var propInfos = [];
	for (var i = 0 ; i < props.length ; i++)
	{
		var propInfo;
		if (props[i] instanceof PropertyInfo) propInfo = props[i];
		else propInfo = new PropertyInfo(props[i]);
		propInfos.push(propInfo);
	}
	return propInfos;
}

/**
	* Converts an AE Collection to an Array<br />
	* Should only be used in case you need an copy of the collection as an Array,<br />
	* you should use an {@link Iterator} otherwise
	* @param {Array|Collection} collection - The collection to convert
	* @return {Array} The array
*/
DuAEF.DuAE.convertCollectionToArray = function (collection)
{
	var arr = [];
	if (DuAEF.DuAE.isCollection(collection))
	{
		for (var i = 1;i<=collection.length;i++)
		{
			arr.push(collection[i]);
		}
	}
	else
	{
		arr = collection;
	}
	return arr;
}

/**
	* Application related methods
	* @namespace
	* @memberof DuAEF.DuAE
*/
DuAEF.DuAE.App = {};

//App Properties
(function ()
{
	//detect AE Version
	var reV = /^(\d+\.?\d*)/i;
	var v = app.version.match(reV);

	/**
	* The After Effects version
	* @memberof DuAEF.DuAE.App
	* @readonly
	* @type {float}
	*/
	DuAEF.DuAE.App.versionAsString = v[1];
	DuAEF.DuAE.App.version = parseFloat(v[1]);

	/**
	 * Has scripting file and network authorization
	 * @readonly
	 * @type {boolean}
	 */
	DuAEF.DuAE.App.hasFilesAndNetworkAccess = app.preferences.getPrefAsLong("Main Pref Section","Pref_SCRIPTING_FILE_NETWORK_SECURITY") == 1;
})();

/**
	* Asks the user to check the file and network security pref if not already set.
	* Opens the general prefrences of After Effects.
	* @memberof DuAEF.DuAE.App
	* @param {boolean}	[showAlert=true]	- Wether to display an alert before opening the preferences
	* @param {string}	[message=The Duduf After Effects scripting framework needs to be allowed to write files\nPlease, check the box called 'Allow Scripts to write files...' in the general preferences of After Effects.]	- The message to display in the alert.
	* @return {boolean}	Wether the preference has been set
*/
DuAEF.DuAE.App.askFilesAndNetworkAccess = function(showAlert,message)
{
	if (showAlert == undefined) alert = true;
	if (message == undefined ) message = "The Duduf After Effects framework needs to be allowed to write files\nPlease, check the box called 'Allow Scripts to write files...' in the general preferences of After Effects.";
	if (!DuAEF.DuAE.App.hasFilesAndNetworkAccess)
	{
		if (showAlert) alert(message);
		if (DuAEF.DuAE.App.version < 16.1) app.executeCommand(2359);
		else app.executeCommand(3131);
		DuAEF.DuAE.App.hasFilesAndNetworkAccess = app.preferences.getPrefAsLong("Main Pref Section","Pref_SCRIPTING_FILE_NETWORK_SECURITY") == 1;
	}
	return DuAEF.DuAE.App.hasFilesAndNetworkAccess;
}

/**
	* Gets the public name of a version of After Effects (like CC2015.3 for version 13.8)
	* @param {float}	[versionAsFloat]	- The version as a float. If not provided, will default to the current version of the running instance of After Effects.
	* @return {string}	The version name.
*/
DuAEF.DuAE.App.getAEVersionName = function(versionAsFloat)
{
	if (versionAsFloat == undefined) versionAsFloat = DuAEF.DuAE.App.version;
	if (versionAsFloat < 8) return "" + versionAsFloat;
	if (versionAsFloat >= 8 && versionAsFloat < 9) return "CS3";
	if (versionAsFloat >= 9 && versionAsFloat < 10) return "CS4";
	if (versionAsFloat >= 10 && versionAsFloat < 10.5) return "CS5";
	if (versionAsFloat >= 10.5 && versionAsFloat < 11) return "CS5.5";
	if (versionAsFloat >= 11 && versionAsFloat < 12) return "CS6";
	if (versionAsFloat >= 12 && versionAsFloat < 13) return "CC";
	if (versionAsFloat >= 13 && versionAsFloat < 13.1) return "CC2014";
	if (versionAsFloat >= 13.1 && versionAsFloat < 13.2) return "CC2014.1";
	if (versionAsFloat >= 13.2 && versionAsFloat < 13.5) return "CC2014.2";
	if (versionAsFloat >= 13.5 && versionAsFloat < 13.6) return "CC2015";
	if (versionAsFloat >= 13.6 && versionAsFloat < 13.7) return "CC2015.1";
	if (versionAsFloat >= 13.7 && versionAsFloat < 13.8) return "CC2015.2";
	if (versionAsFloat >= 13.8 && versionAsFloat < 14) return "CC2015.3";
	if (versionAsFloat >= 14 && versionAsFloat < 15) return "CC2017";
	if (versionAsFloat >= 15 && versionAsFloat < 16) return "CC2018";
	if (versionAsFloat >= 16 && versionAsFloat < 17) return "CC2019";
	else return "Unknown";
}

//low-level undocumented flag.
//true if an undo group has been opened and has not been closed yet.
DuAEF.DuAE.App.openedUndoGroup = false;

//low-level undocumented flag.
//the name of the currently opened undo group
DuAEF.DuAE.App.undoGroupName = '';

/**
 * Begins an undoGroup.<br />
 * Automatically prepend the group name with the script name.<br />
 * Using this method is safer than the native one, as DuAEF will try to avoid opening several undo groups at once.<br />
 * The group name is translatable.
 * @param {string} groupName - The name of the Undo Group.
 * @param {boolean} [autoClose=true] - By default, DuAEF will close any previously opened undogroup (which has a different name) to prevent any error.<br />
 * Set this to <code>false</code> in order to ignore this new group beginning and keep the previously opened one.
*/
DuAEF.DuAE.App.beginUndoGroup = function (groupName, autoClose)
{
	groupName = def(groupName, "");
	autoClose = def(autoClose, true);

	if (groupName != "")
	{
		DuAEF.DuScriptUI.uiStrings.push( groupName );
		groupName = tr( groupName );
	}

	if (DuAEF.DuAE.App.openedUndoGroup)
	{
		if ( autoClose && DuAEF.DuAE.App.undoGroupName != groupName ) DuAEF.DuAE.App.endUndoGroup();
		else return;
	}
	app.beginUndoGroup(DuAEF.scriptName + ' | ' + groupName);

	DuAEF.DuAE.App.undoGroupName = groupName;

	DuAEF.DuAE.App.openedUndoGroup = true;
}

/**
 * Ends an undoGroup.<br />
 * Using this method is safer than the native one, as DuAEF will try to avoid opening several undo groups at once.
*/
DuAEF.DuAE.App.endUndoGroup = function ()
{
	app.endUndoGroup();
	DuAEF.DuAE.App.openedUndoGroup = false;
} 

/**
 * Runs app.executeCommand in a safer way, taking care of undogroups.
 * @param {int|string} commandID - The ID of the command as given by app.findMenuCommandID(), or if it is a string, the name of the command.
 */
DuAEF.DuAE.App.executeCommand = function(commandID)
{
	if (commandID === "") return;
	if (DuAEF.DuJS.typeof(commandID) == 'string') commandID = app.findMenuCommandId(commandID);
	//the command will mess undo groups up if there already is one opened.
	openedUndoGroup = DuAEF.DuAE.App.openedUndoGroup;
	DuAEF.DuAE.App.endUndoGroup();
	app.executeCommand(commandID);
	if (openedUndoGroup) DuAEF.DuAE.App.beginUndoGroup(DuAEF.DuAE.App.undoGroupName);
}

/**
 * Opens a ScriptUI Panel if it is installed, or displays an alert otherwise.
 * @param {string} panelScriptName - The Script name of the panel "script.jsx"
 */
DuAEF.DuAE.App.openScriptUIPanel = function (panelScriptName)
{
	if ( panelScriptName == "") return;
	var scriptUIFile = new File(Folder.appPackage.absoluteURI + '/Scripts/ScriptUI Panels/' + panelScriptName );
	if (!scriptUIFile.exists)
	{
		scriptUIFile = new File(Folder.userData.absoluteURI + '/Adobe/After Effects/' + DuAEF.DuAE.App.versionAsString + '/Scripts/ScriptUI Panels/' + panelScriptName);
	}
	if (!scriptUIFile.exists)
	{
		alert("The panel " + panelScriptName + " is not installed.");
		return;
	}
	DuAEF.DuAE.App.executeCommand(panelScriptName);
}

/**
	* Cuts the selection (runs the cut menu command)
*/
DuAEF.DuAE.App.cut = function()
{
	DuAEF.DuAE.App.executeCommand(DuAEF.DuAE.menuCommandID.CUT);
}

/**
	* Copies the selection (runs the copy menu command)
*/
DuAEF.DuAE.App.copy = function()
{
	DuAEF.DuAE.App.executeCommand(DuAEF.DuAE.menuCommandID.COPY);
}

/**
	* Duplcates the selection (runs the duplicate menu command)
*/
DuAEF.DuAE.App.duplicate = function()
{
	DuAEF.DuAE.App.executeCommand(DuAEF.DuAE.menuCommandID.DUPLICATE);
}

/**
	* Copies the selection with property links (runs the copy menu command)<br />
	* Only on versions of After Effects greater than 11.0 (CS6)<br />
	* On CS6 and below, a standard copy will be done.
*/
DuAEF.DuAE.App.copyWithPropertyLinks = function()
{
	if (DuAEF.DuAE.App.version >= 12.0) DuAEF.DuAE.App.executeCommand(DuAEF.DuAE.menuCommandID.COPY_WITH_PROPERTY_LINKS);
	else DuAEF.DuAE.App.copy();
}

/**
	* Pastes the selection (runs the paste menu command)
*/
DuAEF.DuAE.App.paste = function()
{
	DuAEF.DuAE.App.executeCommand(DuAEF.DuAE.menuCommandID.PASTE);
}

/**
	* After Effects project methods
	* @namespace
	* @memberof DuAEF.DuAE
*/
DuAEF.DuAE.Project = {};

//undocumented flags
DuAEF.DuAE.Project.progressMode = false;
DuAEF.DuAE.Project.activeComp = null;
DuAEF.DuAE.Project.progressComp = null;
DuAEF.DuAE.Project.viewerMaximized = false;

/**
 * Sets the project in "waiting mode" to speed up things.
 * @param {bool} inProgress - True to set progress mode, false to stop it.
*/
DuAEF.DuAE.Project.setProgressMode = function(inProgress)
{
	if (inProgress && DuAEF.DuAE.Project.progressMode) return;
	if (!inProgress && !DuAEF.DuAE.Project.progressMode) return;

	if (inProgress)
	{
		//store the current comp
		DuAEF.DuAE.Project.activeComp = DuAEF.DuAE.Project.getActiveComp();

		if (app.activeViewer != null) DuAEF.DuAE.Project.viewerMaximized = app.activeViewer.maximized;

		//create a temp comp, open it
		DuAEF.DuAE.Project.progressComp = app.project.items.addComp("MAGIC IS HAPPENING...", 500, 500, 1, 1, 1);

		var tempL = DuAEF.DuAE.Project.progressComp.layers.addShape();
		tempL.applyPreset(DuAEF.DuAE.Presets.MAGIC);
		tempL.selected = false;

		DuAEF.DuAE.Project.progressComp.openInViewer();
		if (app.activeViewer != null) app.activeViewer.maximized = true;

		DuAEF.DuAE.Project.progressMode = true;
	}
	else
	{
		//remove temp comp
		if (DuAEF.DuAE.Project.progressComp != null) DuAEF.DuAE.Project.progressComp.remove();
		//re-activate previous comp
		if (DuAEF.DuAE.Project.activeComp != null) DuAEF.DuAE.Project.activeComp.openInViewer();
		if (app.activeViewer != null) app.activeViewer.maximized = DuAEF.DuAE.Project.viewerMaximized;

		DuAEF.DuAE.Project.progressMode = false;
	}

}

/**
	* Gets all compositions in the project
	* @return {CompItem[]} The compositions
*/
DuAEF.DuAE.Project.getComps = function()
{
	var comps = [];
	var it = new Iterator(app.project.items);
	it.do(function(comp)
	{
		if (comp instanceof CompItem) comps.push(comp);
	});
	return comps;
}

/**
	* Gets the After Effects current composition
	* @return {CompItem|null} The current composition or null if there's no current comp
*/
DuAEF.DuAE.Project.getActiveComp = function()
{
	if (DuAEF.DuAE.Project.progressMode) return DuAEF.DuAE.Project.activeComp;
	var comp = app.project.activeItem;
	if (!comp) return null;
	if (!(comp instanceof CompItem)) return null;
	return comp;
}

/**
	* Retrieves an item by its Item ID
	* @return {Item|null} The item
*/
DuAEF.DuAE.Project.getItemById = function (id)
{

	var it = new Iterator(app.project.items);
	while(item = it.next())
	{
		if (item.id == id) return item;
	}
	return null;
}

/**
	* Generates a new unique name for a composition
	* @param {string} newName - The wanted new name
	* @param {CompItem} comp  - The comp
	* @param {boolean} [increment=true] - true to automatically increment the new name if it already ends with a digit
	* @return {string}	The unique name, with a new number at the end if needed.
*/
DuAEF.DuAE.Project.newUniqueCompName = function(newName, increment)
{
	if (typeof increment == 'undefined') increment = true;
	var compNames = [];
	var it = new Iterator(app.project.items);
	it.do(function(comp)
	{
		if (comp instanceof CompItem) compNames.push(comp.name);
	});
	return DuAEF.DuJS.String.generateUnique(newName,compNames,increment);
}

/**
 * Makes sure all compositions in the project have unique names, renaming them if needed.
*/
DuAEF.DuAE.Project.setUniqueCompNames = function()
{
	var comps = DuAEF.DuAE.Project.getComps();
	var it = new Iterator(app.project.items);
	it.do(function(comp)
	{
		//temporarily set another name to correctly generate a new unique name 
		var newName = comp.name;
		comp.name = '***Duik-temp-name-xxx***';
		comp.name = DuAEF.DuAE.Project.newUniqueCompName(newName);
	});
}

/**
	* After Effects composition methods
	* @namespace
	* @memberof DuAEF.DuAE
*/
DuAEF.DuAE.Comp = {};

/**
 * Makes sure the composition has a unique name, renaming it if needed.
 * @param {CompItem} comp - The composition
 * @return {string} The new name.
*/
DuAEF.DuAE.Comp.setUniqueCompName = function (comp)
{
	if (!(comp instanceof CompItem)) throw "Cannot set a unique composition name, this is not a composition.";
	//temporarily rename the comp to check for its name
	var newName = comp.name;
	comp.name = '***Duik-temp-name-xxx***';
	comp.name = DuAEF.DuAE.Project.newUniqueCompName(newName, false);
	return comp.name;
}

/**
	* Gets the After Effects selected properties in the current comp
	* @param {PropertyType|PropertyValueType|string|function}	 [filter]	- A filter to get only a certain type, or value type, or property name or matchName.<br />
	* A function which take one PropertyBase as argument can be used to filter the properties: the Property will be returned if the function returns true.
	* @param {boolean}	[strict=false]	- If a string filter is provided, wether to search for the exact name/matchName or if it contains the filter.
	* @param {boolean}	[caseSensitive=true]	- If a string filter is provided, and not strict is false, does the search have to be case sensitive?
	* @return {PropertyInfo[]} The selected properties, an empty Array if nothing active or selected
*/
DuAEF.DuAE.Comp.getSelectedProps = function(filter,strict,caseSensitive)
{
	var props = [];
	var comp = DuAEF.DuAE.Project.getActiveComp();
	if (!comp) return props;

	//if no filter, get all using AE native API
	if (typeof filter === 'undefined')
	{
		var layers = comp.selectedLayers;
		var itLayers = new Iterator(layers);
		itLayers.do(function(layer)
		{
			props = props.concat(layer.selectedProperties);
		});
	}
	else
	{
		var layers = comp.selectedLayers;
		if (layers.length === 0) return props;

		for (var i = 0 ; i < layers.length ; i++)
		{
			props = props.concat(DuAEF.DuAE.Layer.getSelectedProps(layers[i],filter,strict,caseSensitive));
		}
	}

	return DuAEF.DuAE.getPropertyInfos(props);
}

/**
	* Gets the selected layers in the current comp
	* @return {Layer[]} The selected layers
*/
DuAEF.DuAE.Comp.getSelectedLayers = function()
{
	var comp = DuAEF.DuAE.Project.getActiveComp();
	if (!comp) return [];
	return comp.selectedLayers;
}

/**
	* Runs a function on all the selected layers
	* @param {function} method - The function to run on the layers, which takes a layer as its only argument.
	* @param {string} [undoGroupName] - The name of the undoGroup created before the execution. If not provided, there will not be any undoGroup created.
	*/
DuAEF.DuAE.Comp.doSelectedLayers = function(method, undoGroupName)
{
	//get layers
	var layers = DuAEF.DuAE.Comp.unselectLayers();
	
	// run
	DuAEF.DuAE.Layer.doLayers(layers, method, undoGroupName);

	//reselect
	DuAEF.DuAE.Comp.selectLayers(layers);
}

/**
	* Runs a function on all the layers
	* @param {function} method - The function to run on the layers, which takes a layer as its only argument.
	* @param {string} [undoGroupName] - The name of the undoGroup created before the execution. If not provided, there will not be any undoGroup created.
	* @param {CompItem} [comp] - The comp containing the layers. Will use the current comp if not provided.
	*/
DuAEF.DuAE.Comp.doLayers = function(method, undoGroupName, comp)
{
	if (typeof comp === 'undefined') 
	{
		comp = DuAEF.DuAE.Project.getActiveComp();
	}
	if (!(comp instanceof CompItem)) return;

	//get layers
	var layers = comp.layers;
	if (layers.length == 0) return;
	
	// run
	DuAEF.DuAE.Layer.doLayers(layers, method, undoGroupName);
}

/**
	* Gets the After Effects animated (with keyframes) properties in the current comp
	* @param {PropertyType|PropertyValueType|string|function}	 [filter]	- A filter to get only a certain type, or value type, or property name or matchName.<br />
	* A function which take one PropertyBase as argument can be used to filter the properties: the Property will be returned if the function returns true.
	* @param {boolean}	[strict=false]	- If a string filter is provided, wether to search for the exact name/matchName or if it contains the filter.
	* @param {boolean}	[caseSensitive=true]	- If a string filter is provided, and not strict is false, does the search have to be case sensitive?
	* @param {boolean}	[selectedLayersOnly=false]	- True to get the properties on the selected layers only
	* @param {CompItem}	[comp=DuAEF.DuAE.Project.getActiveComp]	- The composition
	* @return {PropertyInfo[]} The selected properties, an empty Array if nothing active or selected
*/
DuAEF.DuAE.Comp.getAnimatedProps = function(filter, strict, caseSensitive, selectedLayersOnly, comp)
{
	var props = [];
	if (typeof comp === 'undefined') comp = DuAEF.DuAE.Project.getActiveComp();
	if (!comp) return props;

	if (typeof selectedLayersOnly === 'undefined') selectedLayersOnly = false;


	var layers;
	if (selectedLayersOnly) layers = comp.selectedLayers;
	else layers = comp.layers;

	var it = new Iterator(layers);
	it.do(function (layer)
	{
		props = props.concat(DuAEF.DuAE.Property.getAnimatedProps(layer, filter, strict, caseSensitive));
	});

	return props;
}

/**
	* Deselects all properties in the current composition
*/
DuAEF.DuAE.Comp.unselectProperties = function()
{
	var comp = DuAEF.DuAE.Project.getActiveComp();
	if (!comp) return props;
	var props = comp.selectedProperties;
	for (var i = 0; i < props.length ; i++)
	{
		props[i].selected = false;
	}
}

/**
	* Deselects all layers in a composition
	* @param {CompItem} [comp=app.project.activeItem] - The composition
	* @return {Layer[]} The previously selected layers.<br />
	* A custom attribute, Layer.props is added on each layer object which is an array of all previously selected properties as PropertyInfo objects
*/
DuAEF.DuAE.Comp.unselectLayers = function(comp)
{
	if (typeof comp === 'undefined') comp = DuAEF.DuAE.Project.getActiveComp();
	if (!comp) return [];

	var layers = [];

	if (!comp) return layers;
	if (!(comp instanceof CompItem)) return layers;

	layers = [];

	while (comp.selectedLayers.length > 0)
	{
		var layer = comp.selectedLayers[0];
		layer.props = DuAEF.DuAE.getPropertyInfos(layer.selectedProperties);
		layer.selected = false;
		layers.push(layer);
	}

	return layers;
}

/**
	* Selects the layers
	* @param {Layer[]} layers - The layers
*/
DuAEF.DuAE.Comp.selectLayers = function (layers)
{
	new Iterator(layers).do(function(layer)
	{
		if (layer == undefined) return;
		if (layer == null) return;
		layer.selected = true;
	});
}

/**
	* Generates a new unique name for a layer
	* @param {string} newName	- The wanted new name
	* @param {CompItem} comp 	- The comp
	* @param {boolean} [increment=true] - true to automatically increment the new name if it already ends with a digit
	* @return {string}	The unique name, with a new number at the end if needed.
*/
DuAEF.DuAE.Comp.newUniqueLayerName = function(newName, comp, increment)
{
	if (increment == undefined) increment = true;
	var layerNames = [];
	for (var i = 1 ; i <= comp.layers.length ; i++)
	{
		layerNames.push(comp.layer(i).name);
	}
	return DuAEF.DuJS.String.generateUnique(newName,layerNames,increment);
}

/**
	* Generates a new unique name for a marker for this comp
	* @param {string} newName	- The wanted new name
	* @param {CompItem} comp 	- The comp
	* @param {boolean} [increment=true] - true to automatically increment the new name if it already ends with a digit
	* @return {string}	The unique name, with a new number at the end if needed.
*/
DuAEF.DuAE.Comp.newUniqueMarkerName = function(newName, comp,increment)
{
	if (increment == undefined) increment = true;
	var markerNames = [];
	for (var i = 1, num = comp.markerProperty.numKeys ; i <= num ; i++)
	{
		markerNames.push(comp.markerProperty.keyValue(i).comment);
	}
	return DuAEF.DuJS.String.generateUnique(newName,markerNames,increment);
}

/**
	* Creates a new Adjustment layer
	* @param {CompItem} comp 	- The comp
	* @return {AVLayer}	The layer.
*/
DuAEF.DuAE.Comp.addAdjustmentLayer = function(comp)
{
	if (comp == undefined) return null;
	var layer = comp.layers.addSolid([1,1,1], DuAEF.DuAE.Comp.newUniqueLayerName("Adjustment Layer",comp) , comp.width, comp.height, comp.pixelAspect, comp.duration);
	layer.adjustmentLayer = true;
	return layer;
}

/**
	* Links all orphan layers in the comp to a layer
	* @param {Layer} layer - The parent layer
	* @param {bool} [includeLockedLayers=false] - True to parent layers even if they are locked
*/
DuAEF.DuAE.Comp.parentAllOrphans = function(layer,includeLockedLayers)
{
	if (typeof includeLockedLayers === "undefined") includeLockedLayers = false;
	var comp = layer.containingComp;
	for (var i = 1,num = comp.numLayers;i<=num;i++)
	{
		if (i == layer.index) continue;
		var l = comp.layer(i);
		if (DuAEF.DuAE.Layer.getRelation(l,layer) < 0) continue;
		var locked = l.locked;
		if (locked && includeLockedLayers) l.locked = false;
		if (!locked && l.parent == null) l.parent = layer;
		if (locked && includeLockedLayers) l.locked = locked;
	}
}

/**
 * Gets all precomps and parent comps of the composition
 * @param {CompItem} [comp=DuAEF.DuAE.Project.getActiveComp()] - The composition
 * @param {bool} [recursive=false] - True to search to more than one level of precomposition
 * @return {CompItem[]} The related compositons
*/
DuAEF.DuAE.Comp.getRelatives = function(comp, recursive)
{
	if (typeof recursive === 'undefined') recursive = false;
	if (typeof comp === 'undefined') comp = DuAEF.DuAE.Project.getActiveComp();
	if (!comp) return [];
	//get precomps
	var precomps = DuAEF.DuAE.Comp.getPrecomps(comp,recursive);
	//get parent
	var parentComps = [];
	if (recursive)
	{
		parentComps = DuAEF.DuAE.Comp.getParentComps(comp);
	}
	else
	{
		parentComps = comp.usedIn;
	}

	return precomps.concat(parentComps);
}

/**
	* Gets all the precomposition found in the comp.
	* @param {CompItem} comp - The composition
	* @param {bool} [recursive=false] - True to get nested compositions
	* @return {CompItem[]} The precompositions
*/
DuAEF.DuAE.Comp.getPrecomps = function(comp,recursive)
{
	if (typeof recursive === 'undefined') recursive = true;
	var precomps = [];
	var it = new Iterator(comp.layers);
	it.do(function(layer)
	{
		var precomp = layer.source;
		if (precomp instanceof CompItem)
		{
			precomps.push(precomp);
			if (recursive) precomps = precomps.concat(DuAEF.DuAE.Comp.getPrecomps(precomp));
		}
	});
	//remove duplicates
	DuAEF.DuJS.Array.removeDuplicates(precomps);
	return precomps;
}

/**
	* Recursively gets all compositions where this item is used
	* @param {AVItem} item - The item
	* @return {CompItem[]} The compositions
*/
DuAEF.DuAE.Comp.getParentComps = function(item)
{
	var parentComps = item.usedIn;
	new Iterator(parentComps).do(function(parentComp)
	{
		parentComps = parentComps.concat(DuAEF.DuAE.Comp.getParentComps(parentComp));
	});
	DuAEF.DuJS.Array.removeDuplicates(parentComps);
	return parentComps;
}

/**
	* Gets all the layers with audio in the composition
	* @param {CompItem}	 comp	The composition where the audio will be searched
	* @param {bool}	[audioActiveOnly=false]	 If true, does not get muted layers.
	* @return {AVLayer[]} An array of AVLayer containing the audio layers
*/
DuAEF.DuAE.Comp.getAudioLayers = function (comp,audioActiveOnly)
{
	if (typeof audioActiveOnly === 'undefined') audioActiveOnly = false;
	var layers = comp.layers;
	var audioLayers = [];
	var it = new Iterator(layers);
	it.do(function (layer)
	{
		if (layer.hasAudio)
		{
			if (audioActiveOnly && layer.audioEnabled || !audioActiveOnly)
			{
				audioLayers.push(layer);
			}
		}
	});

	return audioLayers;
}

/**
	* After Effects layer methods
	* @namespace
	* @memberof DuAEF.DuAE
*/
DuAEF.DuAE.Layer = {};

/**
	* Runs a function on all the layers
	* @param {function} method - The function to run on the layers, which takes a layer as its only argument.
	* @param {string} [undoGroupName] - The name of the undoGroup created before the execution. If not provided, there will not be any undoGroup created.
	*/
DuAEF.DuAE.Layer.doLayers = function(layers, method, undoGroupName)
{
	if (typeof undoGroupName === 'undefined') undoGroupName = "";
	// run
	if (undoGroupName != "") DuAEF.DuAE.App.beginUndoGroup(undoGroupName);
	new Iterator(layers).do(method);
	if (undoGroupName != "") DuAEF.DuAE.App.endUndoGroup();
}

/**
	* Generates a new unique name for an effect
	* @param {string} newName	- The wanted new name
	* @param {Layer} layer 	- The layer
	* @param {boolean} [increment=true] - true to automatically increment the new name if it already ends with a digit
	* @return {string}	The unique name, with a new number at the end if needed.
*/
DuAEF.DuAE.Layer.newUniqueEffectName = function(newName, layer, increment)
{
	if (!layer) throw new Error("Needs a layer to generate a new unique effect name","DuAECOreLib",645);
	if (increment == undefined) increment = true;
	if (newName == undefined) return "";
	if (newName == "") return "";
	var effectNames = [];
	for (var i = 1 ; i <= layer.effect.numProperties ; i++)
	{
		effectNames.push(layer.effect(i).name);
	}
	return DuAEF.DuJS.String.generateUnique(newName,effectNames,increment);
}

/**
	* Generates a new unique name for a marker for this comp
	* @param {string} newName	- The wanted new name
	* @param {Layer} layer 	- The comp
	* @param {boolean} [increment=true] - true to automatically increment the new name if it already ends with a digit
	* @return {string}	The unique name, with a new number at the end if needed.
*/
DuAEF.DuAE.Layer.newUniqueMarkerName = function(newName, layer,increment)
{
	if (increment == undefined) increment = true;
	var markerNames = [];
	for (var i = 1, num = layer.property('ADBE Marker').numKeys ; i <= num ; i++)
	{
		markerNames.push(layer.property('ADBE Marker').keyValue(i).comment);
	}
	return DuAEF.DuJS.String.generateUnique(newName,markerNames,increment);
}

/**
	* Gets the After Effects selected properties in the layer
	* @param {Layer}	layer	- The layer
	* @param {PropertyType|PropertyValueType|string|function}	 [filter]	- A filter to get only a certain type, or value type, or property name or matchName.<br />
	* A function which take one PropertyBase as argument can be used to filter the properties: the Property will be returned if the function returns true.
	* @param {boolean}	[strict=false]	- If a string filter is provided, wether to search for the exact name/matchName or if it contains the filter.
	* @param {boolean}	[caseSensitive=true]	- If a string filter is provided, and not strict is false, does the search have to be case sensitive?
	* @return {PropertyBase[]} The selected properties, an empty Array if nothing active or selected
*/
DuAEF.DuAE.Layer.getSelectedProps = function(layer,filter,strict,caseSensitive)
{
	if (typeof strict === 'undefined') strict = false;
	if (typeof caseSensitive === 'undefined') caseSensitive = true;

	var props = [];

	if (!caseSensitive && typeof filter === "string") filter = filter.toLowerCase();

	var selectedProps = layer.selectedProperties;
	if (typeof filter === 'undefined')
	{
		props = props.concat(selectedProps);
	}
	else
	{
		for (var j = 0 ; j < selectedProps.length ; j++)
		{
			var prop = selectedProps[j];

			var name = prop.name;
			var matchName = prop.matchName;
			if (!caseSensitive)
			{
				name = name.toLowerCase();
				matchName = matchName.toLowerCase();
			}

			if (strict && name === filter)
			{
				props.push(prop);
			}
			else if (strict && matchName === filter)
			{
				props.push(prop);
			}
			else if (typeof filter === "string")
			{
				if (name.indexOf(filter) >= 0) props.push(prop);
				else if (matchName.indexOf(filter) >= 0) props.push(prop);
			}
			else if (prop.propertyType == PropertyType.PROPERTY)
			{
				if ( prop.propertyValueType == filter ) props.push(prop);
			}
			else if ( props.length == 0 && filter == PropertyValueType.SHAPE )
			{
				if (matchName == 'ADBE Mask Atom') props.push( prop.property('ADBE Mask Shape') );
				else if (matchName == 'ADBE Vector Shape - Group') props.push( prop.property('ADBE Vector Shape') );
			}
			else if (prop.propertyType == filter)
			{
				props.push(prop);
			}
			else if (typeof filter === "function")
			{
				if (filter(prop)) props.push(prop);
			};
		}
	}
	return DuAEF.DuAE.getPropertyInfos(props);
}

/**
	* Gets all animations on the layer in the whole timeline or in the time range<br />
	* The first KeyFrame._time will be adjusted relatively to the start of the time range (if provided) instead of the startTime of the composition.
	* @param {Layer}	layer	- The layer.
	* @param {boolean}	[selected=false]	- true to get only selected keyframes.
	* @param {float[]}	[timeRange]	- The time range, an array of two time values, in seconds.
	* @return {LayerAnim}	The animation.
*/
DuAEF.DuAE.Layer.getAnim = function (layer,selected,timeRange)
{
	var anim = new LayerAnim();
	anim._name = layer.name;
	anim._index = layer.index;
	anim.anims = [];
	for (var propIndex = 1;propIndex <= layer.numProperties;propIndex++)
	{
		var prop = layer.property(propIndex);
		if (prop.matchName == 'ADBE Marker') continue;

		var subAnim = DuAEF.DuAE.Property.getAnim(prop,selected,timeRange);
		if (subAnim != null)
		{
			if (anim.startTime == null) anim.startTime = subAnim.startTime;
			else if (anim.startTime > subAnim.startTime) anim.startTime = subAnim.startTime;
			if (anim.endTime == null) anim.endTime = subAnim.endTime;
			else if (anim.endTime > subAnim.endTime) anim.endTime = subAnim.endTimeendTime;
			anim.anims.push(subAnim);
		}

	}
	return anim;
}

/**
	* Gets all animations on the layers in the whole timeline or in the time range<br />
	* The first KeyFrame._time will be adjusted relatively to the start of the time range (if provided) instead of the startTime of the composition.
	* @param {Layer[]|LayerCollection}	layers	- The layers.
	* @param {boolean}	[selected=false]	- true to get only selected keyframes.
	* @param {float[]}	[timeRange]	- The time range, an array of two time values, in seconds.
	* @return {LayerAnim[]}	The animations.
*/
DuAEF.DuAE.Layer.getAnims = function (layers,selected,timeRange)
{
	var anims = [];
	new Iterator(layers).do(function(layer)
	{
		anims.push(DuAEF.DuAE.Layer.getAnim(layer,selected,timeRange));
	});
	return anims;
}

/**
	* Sets the property animation on the property
	* @param {Layer}	layer	- The layer.
	* @param {LayerAnim} anims	- The animation
	* @param {float}	[time=comp.time]	- The time where to begin the animation
	* @param {boolean}	[ignoreName=false]	- true to set the anim even if name of the property do not match the name of the animation.<br />
	* This way, only the type of property (i.e. matchName) is checked.
	* @param {boolean}	[setExpression=false]	- Set the expression on the property
	* @param {boolean}	[onlyKeyframes=true]	- If false, the value of properties without keyframes will be set too.
	* @param {boolean}	[replace=false]	- true to remove any existing keyframe on the properties before adding new keyframes
	* @param {string[]}	[propertyWhiteList]	- A list of matchNames used as a white list for properties to set anims.<br />
	* Can be the matchName of a propertyGroup to set all the subproperties.
	* @param {boolean}	[offset=false]	- true to offset the current value, instead of replacing it
	* @param {boolean}	[reverse=false]	- true to reverse the keyframes (in time)
	* @return {boolean} true if the anim was actually set.
*/
DuAEF.DuAE.Layer.setAnim = function(layer, anim, time, ignoreName, setExpression, onlyKeyframes, replace, whiteList, offset, reverse)
{
	if (typeof time === 'undefined') time = layer.containingComp.time;
	if (typeof ignoreName === 'undefined') ignoreName = false;
	if (typeof setExpression === 'undefined') setExpression = false;
	if (typeof onlyKeyframes === 'undefined') onlyKeyframes = false;
	if (typeof replace === 'undefined') replace = false;
	if (typeof offset === 'undefined') offset = false;

	if (reverse) DuAEF.DuAE.Layer.reverseAnims(anim);

	for (var i = 0 ; i < anim.anims.length ; i++)
	{
		var subAnim = anim.anims[i];
		for (var propIndex = 1;propIndex <= layer.numProperties;propIndex++)
		{
			var subProp = layer.property(propIndex);
			if (subProp == null) continue;
			if (subProp.matchName == subAnim._matchName && subProp.matchName != 'ADBE Marker')
			{
				var ok = DuAEF.DuAE.Property.setGroupAnim(subProp, subAnim, time, ignoreName, setExpression, onlyKeyframes, replace, whiteList, offset, reverse);
				if (ok) break;
			}
		}
	}
}

/**
	* Sets the animations on the layers.<br />
	* If you need to set only on the same layers (same index, same name), use {@link DuAEF.DuAE.Layer.setAnims}.
	* @param {Layer[]|LayerCollection}	layers	- The layers.<br />
	* If there are more layers than animations, the layers array will be truncated.
	* @param {LayerAnim[]} anims	- The layer animations.<br />
	* If there are more animations than layers, the animations array will be truncated.
	* @param {float}	[time=comp.time]	- The time where to begin the animation
	* @param {boolean}	[ignoreName=false]	- true to set the anim even if name of the property do not match the name animation.<br />
	* This way, only the type of property (i.e. matchName) is checked.
	* @param {boolean}	[setExpression=false]	- Set the expression on the property
	* @param {boolean}	[onlyKeyframes=true]	- If false, the value of properties without keyframes will be set too.
	* @param {boolean}	[replace=false]	- true to remove any existing keyframe on the properties before adding new keyframes
	* @param {string[]}	[whiteList]	- A list of matchNames used as a white list for properties to set anims.<br />
	* Can be the matchName of a propertyGroup to set all the subproperties.
	* @param {boolean}	[offset=false]	- true to offset the current value, instead of replacing it
	* @param {boolean}	[reverse=false]	- true to reverse the keyframes (in time)<br />
	* Note: the remaining animations which are returned will already be reversed, do not set this to true again if you plan to set them later.
*/
DuAEF.DuAE.Layer.setAllAnims = function(layers, anims, time, ignoreName, setExpression, onlyKeyframes, replace, whiteList, offset, reverse)
{
	layers = DuAEF.DuAE.convertCollectionToArray (layers);
	var num = anims.length;
	if (num > layers.length) num = layers.length;

	if (reverse) DuAEF.DuAE.Layer.reverseAnims(anims);

	for (var i = 0; i < num; i++)
	{
		var layer = layers[i];
		if (layer) DuAEF.DuAE.Layer.setAnim(layer, anims[i], time, ignoreName, setExpression, onlyKeyframes, replace, whiteList, offset, false);
	}
}

/**
	* Sets the animations on the corresponding layers.<br />
	* The animation will be set only on layers with the same name and index.<br />
	* To set all animations on all layers, not checking their names or indices, use {@link DuAEF.DuAE.Layer.setAllAnims}.
	* @param {Layer[]|LayerCollection}	layers	- The layers.
	* @param {LayerAnim[]} anims	- The layer animations
	* @param {float}	[time=comp.time]	- The time where to begin the animation
	* @param {boolean}	[ignoreName=false]	- true to set the anim even if name of the property do not match the name animation.<br />
	* This way, only the type of property (i.e. matchName) is checked.
	* @param {boolean}	[setExpression=false]	- Set the expression on the property
	* @param {boolean}	[onlyKeyframes=true]	- If false, the value of properties without keyframes will be set too.
	* @param {boolean}	[replace=false]	- true to remove any existing keyframe on the properties before adding new keyframes
	* @param {string[]}	[whiteList]	- A list of matchNames used as a white list for properties to set anims.<br />
	* Can be the matchName of a propertyGroup to set all the subproperties.
	* @param {boolean}	[offset=false]	- true to offset the current value, instead of replacing it
	* @param {boolean}	[reverse=false]	- true to reverse the keyframes (in time)<br />
	* Note: the remaining animations which are returned will already be reversed, do not set this to true again if you plan to set them later.
	* @return {LayerAnim[]} The animations which were not set (no corresponding layers)
*/
DuAEF.DuAE.Layer.setAnims = function(layers, anims, time, ignoreName, setExpression, onlyKeyframes, replace, whiteList, offset, reverse)
{
	//clone the array
	var remaining = anims.slice();

	if (reverse) DuAEF.DuAE.Layer.reverseAnims(anims);

	//for each layeranim, search for the layer and apply anim
	for (var i = remaining.length-1; i >= 0; i--)
	{
		var anim = remaining[i];
		var it = new Iterator(layers);
		var ok = false;
		while(layer = it.next())
		{
			if (layer.name == anim._name && layer.index == anim._index)
			{
				DuAEF.DuAE.Layer.setAnim(layer, anim, time, ignoreName, setExpression, onlyKeyframes, replace, whiteList, offset, false);
				ok = true;
				break;
			}
		}
		if (ok) remaining.pop();
	}

	return remaining;
}

/**
	* Reverses the times of the keyframes to reverse the animation
	* @param {LayerAnim[]|LayerAnim} anims The animation
*/
DuAEF.DuAE.Layer.reverseAnims = function(anims)
{
	if (anims instanceof LayerAnim) anims = [anims];

	var it = new Iterator(anims);

	//get times
	var startTime = null;
	var endTime = null;
	it.do(function(anim)
	{
		if (startTime == null) startTime = anim.startTime;
		else if (startTime > anim.startTime) startTime = anim.startTime;
		if (endTime == null) endTime = anim.endTime;
		else if (endTime > anim.endTime) endTime = anim.endTime;
	});

	var duration = endTime - startTime;


	//recursive function to reverse keyframes in anim
	function reverse(anim)
	{
		if (anim.type == 'anim')
		{
			//reverse the array
			anim.keys = anim.keys.reverse();
			//set the new times
			for (var i = 0, num = anim.keys.length; i < num; i++)
			{
				var ratio = 1 - ( (anim.keys[i]._time - startTime) / duration);
				anim.keys[i]._time = ratio * duration + startTime;
				var sV = anim.endValue;
				anim.endValue = anim.startValue;
				anim.startValue = sV;
			}
		}
		else if (anim.anims)
		{
			for (var i = 0, num = anim.anims.length; i < num; i++)
			{
				reverse(anim.anims[i]);
			}
		}
	}

	//reverse keyframes and times
	it.do(reverse);
}

/**
	* Gets the children of a layer
	* @param {Layer}	layer	- The layer.
	* @return {Layer[]} All the children of the layer
*/
DuAEF.DuAE.Layer.getChildren = function(layer)
{
	var comp = layer.containingComp;
	var children = [];
	for (var i = 1 ; i <= comp.layers.length ; i++)
	{
		var l = comp.layer(i);
		if (l.index == layer.index) continue;
		if (l.parent == null) continue;
		if (l.parent.index == layer.index) children.push(l);
	}
	return children;
}

/**
 * Checks if a layer is a descendant of another layer
 * @param {Layer} layer1 - The first layer
 * @param {Layer} layer2 - The second layer
 * @return {int|null} the degree of relation. 0 if layer1 is not a relative of layer2,<br />
 * negative if layer2 is a descendant of layer1, positive if layer2 is an ancestor.<br />
 * null if the two layers are not in the same composition or if they are the same layer.
*/
DuAEF.DuAE.Layer.getRelation = function(layer1,layer2)
{
	var comp1 = layer1.containingComp;
	var comp2 = layer2.containingComp;
	if (comp1 !== comp2) return null;
	if (layer1.index == layer2.index) return null;
	if (layer1.parent == null && layer2.parent == null) return 0;
	//check
	var degree = 0;
	var parent = layer1.parent;
	while (parent)
	{
		degree++;
		if (layer2.index == parent.index) return degree;
		parent = parent.parent;
	}
	var parent = layer2.parent;
	degree = 0;
	while(parent)
	{
		degree++;
		if (layer1.index == parent.index) return -degree;
		parent = parent.parent;
	}
	return 0;
}

/**
	* Measures the distance between two layers
	* @param {Layer} layer1 - The first layer
	* @param {Layer} layer2 - The second layer
	* @return {int} The distance (in pixels)
*/
DuAEF.DuAE.Layer.getDistance = function (layer1,layer2)
{
	var O = DuAEF.DuAE.Layer.getWorldPos(layer1);
	var A = DuAEF.DuAE.Layer.getWorldPos(layer2);
	var OA = DuAEF.DuJS.Math.getLength(O,A);

	return Math.round(OA);
}

/**
	* Gets the world coordinates of the point of a layer
	* @param {Layer} layer - The layer
	* @param {float[]} [point=layer.transform.anchorPoint.value] - the point
	* @return {float[]} The world coordinates of the layer
*/
DuAEF.DuAE.Layer.getWorldPos = function (layer, point)
{
	if (layer instanceof CameraLayer || layer instanceof LightLayer || layer.threeDLayer )
	{
		var parent = layer.parent;
		layer.parent = null;
		var pos = layer.transform.position.value;
		layer.parent = parent;
		return pos;
	}

	var matrix = DuAEF.DuAE.Layer.getTransformMatrix(layer);
	if (typeof point === 'undefined')
	{
		if (layer.transform.anchorPoint) point = layer.transform.anchorPoint.value;
	}
	
	return matrix.applyToPoint(point);
}

/**
 * Adds an animation preset on the layer.<br />
 * Be careful as layer selection will be kept but not properties selection,<br />
 * and this can result in an "invalid object" if referencing a property.
 * @param {Layer} layer - The layer
 * @param {File} preset - The preset file
 * @param {string} matchName - The pseudo Effect matchName
 * @return {PropertyGroup|null} The effect corresponding to matchName or null if anything went wrong
*/
DuAEF.DuAE.Layer.applyPreset = function (layer,preset,matchName)
{
	if (typeof layer === 'undefined') return null;
	if (typeof preset === 'undefined') return null;
	if (typeof matchName === 'undefined') matchName = '';
	if (!preset.exists) throw new Error("The pseudo effect file does not exist");

	//remove layer selection
	var comp = layer.containingComp;
	var selection = [];
	for (var i = 1,num = comp.numLayers; i <= num;i++)
	{
		var l = comp.layer(i);
		selection.push(l.selected);
		l.selected = false;
	}

	layer.selected = true;
	layer.applyPreset(preset);

	var effect = null;
	if(matchName != '') effect = layer.property("ADBE Effect Parade")(matchName);

	//restore selection
	for (var i = 1,num = comp.numLayers; i <= num;i++)
	{
		var l = comp.layer(i);
		l.selected = selection[i-1];
	}

	return effect;
}

/**
	* This method is a workaround to AE API method layer.applyPreset to work like addProperty when adding pseudoEffects
	* @param {Layer} layer - The layer
	* @param {File} preset - The preset file
	* @param {string} matchName - The pseudo Effect matchName.
	* @param {string} [name] - The name to set on the effect
	* @return {PropertyGroup|null} The effect or null if anything went wrong
*/
DuAEF.DuAE.Layer.addPseudoEffect = function (layer,preset,matchName,name)
{
	var typeofPreset = DuAEF.DuJS.typeof(preset);
	if (typeofPreset != 'File') throw new Error("DuAEF.DuAE.Layer.addPseudoEffect( layer, preset, matchName, name): error. preset has to be a File object, got a " + typeofPreset + ".");
	if (!preset.exists) throw new Error("DuAEF.DuAE.Layer.addPseudoEffect( layer, preset, matchName, name): error. The pseudo effect file does not exist");
	if (layer == undefined) return null;
	if (preset == undefined) return null;
	if (matchName == undefined) return null;

	var effects = layer("ADBE Effect Parade");
	//add the preset to a temp comp if not available as an effect
	if (!effects.canAddProperty(matchName) || DuAEF.debug)
	{
		//create comp
		var comp = app.project.items.addComp("DuAEF Temp", 10, 10, 1, 1, 24);
		//add null
		var n = comp.layers.addNull();
		//apply preset
		n.applyPreset(preset);
		//remove all
		var nullSource = n.source;
		n.remove();
		nullSource.remove();
		comp.remove();
	}

	if (!effects.canAddProperty(matchName))
	{
		throw new Error("Invalid pseudo effect file or match name");
	}

	//add the pseudoEffect as a property
	var newEffectName = "";
	newEffectName = DuAEF.DuAE.Layer.newUniqueEffectName(name,layer);
	var effect = effects.addProperty(matchName);
	if (newEffectName != "") effect.name = newEffectName;
	return effect;
}

/**
	* Checks if the layers have some selected keyframes
	* @param {Layer[]|LayerCollection} layers - The layers
	* @return {boolean} true if the layers have at least one selected keyframe
*/
DuAEF.DuAE.Layer.haveSelectedKeys = function (layers)
{
	var it = new Iterator(layers);
	if (it.length == 0) return;
	while(layer = it.next())
	{
		if (DuAEF.DuAE.Property.hasSelectedKeys(layer)) return true;
	}
	return false;
}

/**
	* Gets the time of the first keyFrame
	* @param {Layer[]|LayerCollection} layer - The layer
	* @param {boolean} selected - true to check selected keyframes only
	* @return {float|null} The keyframe time or null if there are no keyframe
*/
DuAEF.DuAE.Layer.firstKeyFrameTime = function (layers,selected)
{
	var it =  new Iterator(layers);
	var time = null;
	for (var i = it.min ; i <= it.max ; i++)
	{
		var test = DuAEF.DuAE.Property.firstKeyFrameTime(layers[i],selected);
		if (time == null) time = test;
		else if (test != null) { if (time > test) time = test; }
	}
	return time;
}

/**
	* Sort the layers by their parenting (root at first index 0)
	* @param {Layer[]|Collection} layers - The layers to sort
	* @return {Layer[]} The sorted array
*/
DuAEF.DuAE.Layer.sortByParent = function (layers)
{
	var sortedLayers = [];
	var layersToSort = DuAEF.DuAE.convertCollectionToArray(layers);

	//add layers with a parent outside
	//those with a parent outside of the selection
	for (var i = layersToSort.length - 1 ; i >= 0 ; i--)
	{
		var l = layersToSort[i];
		var parent = l.parent;
		if (parent == null) continue;
		var isParentOutside = true;
		for (var j = 0 ; j < layersToSort.length ; j++ )
		{
			if (parent.index == layersToSort[j].index)
			{
				isParentOutside = false;
				break;
			}
		}
		if (isParentOutside)
		{
			sortedLayers.push(l);
			layersToSort.splice(i,1);
		}
	}

	//add layers with no parents
	for (var i = layersToSort.length - 1 ; i >= 0 ; i--)
	{
		var l = layersToSort[i];
		if (l.parent == null)
		{
			sortedLayers.push(l);
			layersToSort.splice(i,1);
		}
	}

	//sort the rest
	while (layersToSort.length > 0)
	{
		for (var i = layersToSort.length - 1 ; i >= 0 ; i--)
		{
			var l = layersToSort[i];
			for (var j = 0 ; j < sortedLayers.length ; j++ )
			{
				var sL = sortedLayers[j];
				if (l.parent.index == sL.index)
				{
					sortedLayers.push(l);
					layersToSort.splice(i,1);
					break;
				}
			}
		}
	}
	return sortedLayers;

}

/**
	* Sort the layers by their indices. Returns a new Array, the original array or collection is not changed.
	* @param {Layer[]|LayerCollection} layers - The layers to sort
	* @return {Layer[]} The sorted array
*/
DuAEF.DuAE.Layer.sortByIndex = function (layers)
{
	var sortedLayers = DuAEF.DuAE.convertCollectionToArray(layers);
	function compareLayerIndices(lay1,lay2)
	{
		return lay1.index-lay2.index;
	}
	return sortedLayers.sort(compareLayerIndices);
}

/**
	* Parents all the layers together beginning by the end of the array
	* @param {Layer[]} layers - The layers to parent
*/
DuAEF.DuAE.Layer.parentChain = function (layers)
{
	//unparent  all but the first
	var layersUnparent = [];
	for (var i = 1 ; i < layers.length ; i++)
	{
		layersUnparent.push(layers[i]);
	}
	DuAEF.DuAE.Layer.unparent(layersUnparent);

	for (var i = layers.length -1 ; i >= 1 ; i--)
	{
		layers[i].parent = layers[i-1];
	}
}

/**
	* Un-parents all the layers
	* @param {Layer[]} layers - The layers
*/
DuAEF.DuAE.Layer.unparent = function (layers)
{
	for (var i = layers.length -1 ; i >= 0 ; i--)
	{
		layers[i].parent = null;
	}
}

/**
	* (Un)parent the children of the layer.< br/>
	* When children are unparented, an effect is added and the name of the layer is changed to show the "edit mode" is enabled.<br />
	* When toggled again, the effect is removed, and the name is restored.
	* @param {Layer} layer - The layer to toggle.
*/
DuAEF.DuAE.Layer.toggleEditMode = function(layer)
{
	//a reg exp to retrieve the list of children
	var reChildren = / \|Duik::ChildrenLayers:([\d,]*)\|/;

	var setEditMode = !reChildren.test(layer.comment);

	var comp = layer.containingComp;

	if (setEditMode)
	{
		var children = DuAEF.DuAE.Layer.getChildren(layer);
		layer.comment = layer.comment + ' |Duik::ChildrenLayers:';
		for (var j = 0, num = children.length ; j < num ; j++)
		{
			var child = children[j];
			layer.comment = layer.comment + child.index;
			if (j < children.length -1) layer.comment = layer.comment + ',';
			child.parent = null;
		}
		layer.comment = layer.comment + "|";
		layer.name = '=EDIT= ' + layer.name;
         var tint = layer.property('ADBE Effect Parade').addProperty('ADBE Tint');
         tint.name = 'DUIK EDIT MODE';
         tint(1).setValue([0.5,0,0,1]);
         tint(2).setValue([1,0,0,1]);
	}
	else
	{
		var match = reChildren.exec(layer.comment);
		if (match.length == 2)
		{
			var indices = match[1].split(',');
			//reparent
			if (indices.length > 0)
			{
				for (var i = 0 ; i < indices.length ; i++)
				{
					var index = parseInt(indices[i]);
					if (isNaN(index)) continue;
					comp.layer(index).parent = layer;
				}
			}
			//remove comment
			layer.comment = layer.comment.replace(match[0],'');
			layer.name = layer.name.replace('=EDIT= ','');
             var tint = layer.property('ADBE Effect Parade').property('ADBE Tint');
             if (tint) if (tint.name == 'DUIK EDIT MODE') tint.remove();
		}
	}
}

/**
	* Creates a sequence with the layers, but using opacities.
	* This enables more possibilities to rig them, like with the Connector
	* @param {Layer[]|LayerCollection} layers - The layers
	* @param {string} [expr] - An expression to add to the opacity of the layers
*/
DuAEF.DuAE.Layer.sequence = function (layers,expr)
{
	if (layers.length == 0) return;
	if (expr == undefined) expr = '';
	var comp = layers[0].containingComp;
	var it = new Iterator(layers);
	it.do(function (layer)
	{
		while (layer.transform.opacity.numKeys > 0)
		{
			layer.transform.opacity.removeKey(layer.transform.opacity.numKeys);
		}
		var i = it.current;
		var t = i*comp.frameDuration;
		var endTime = (layers.length-1)*comp.frameDuration;
		layer.transform.opacity.setValueAtTime(0,0);
		layer.transform.opacity.setValueAtTime(endTime,0);
		layer.transform.opacity.setValueAtTime(t,100);
		if (i < layers.length -1 ) layer.transform.opacity.setValueAtTime(t+comp.frameDuration,0);
		for (var keyIndex = 1;keyIndex <= layer.transform.opacity.numKeys;keyIndex++)
		{
			layer.transform.opacity.setInterpolationTypeAtKey(keyIndex,KeyframeInterpolationType.HOLD,KeyframeInterpolationType.HOLD);
		}
		layer.transform.opacity.expression = expr;
	});
}

/**
	* Adds a new Null object just above a layer, at the same position
	* @param {Layer} layer - The layer
	* @return {Layer} the null
*/
DuAEF.DuAE.Layer.addNull = function (layer)
{
	if (layer == undefined) return null;
	var nullLayer = layer.containingComp.layers.addNull();
	layerParent = layer.parent;
	layer.parent = null;
	nullLayer.transform.position.setValue(layer.transform.position.value);
	layer.parent = layerParent;
	nullLayer.moveBefore(layer);
	nullLayer.name = "N | " + layer.name;
	return nullLayer;
}

/**
	* Locks the scale with an expression so its value cannot be changed
	* @param {Layer} layer - The layer
	* @param {bool} [allAEVersions=false] - true to lock scale even on CS6 and older<br />
	* Those older versions will display the scale property when typing the "U" shorcut when it's locked.
*/
DuAEF.DuAE.Layer.lockScale = function (layer,allAEVersions)
{
	if (typeof allAEVersions == "undefined") allAEVersions = false;
	if (allAEVersions || DuAEF.DuAE.App.version > 12) DuAEF.DuAE.Property.lock(layer.transform.scale);
}

/**
	* Copies the layers to another comp
	* @param {Layer[]} layers - The layers to copy and paste
	* @param {CompItem} destinationComp - The composition to copy to
	* @param {boolean} [withPropertyLinks=false] - Add expressions on the properties to link them to the orriginal layers<br />
	* Works only on 12.0 and above, ignored on 11.0 (CS6) and below
	* @return {Layer[]} The new layers
*/
DuAEF.DuAE.Layer.copyToComp = function (layers, destinationComp, withPropertyLinks)
{
	if (DuAEF.DuAE.App.version < 12.0) withPropertyLinks = false;
	if (typeof withPropertyLinks === 'undefined') withPropertyLinks = false;

	if (layers.length == 0) return;

	var it = new Iterator(layers);

	var previousActiveComp = DuAEF.DuAE.Project.getActiveComp();

	//activate the origin comp
	var originComp = it.firstItem().containingComp;
	originComp.openInViewer();

	//select the layers
	var previousSelection = DuAEF.DuAE.Comp.unselectLayers(originComp);
	DuAEF.DuAE.Comp.selectLayers(layers);

	//copy
	if (withPropertyLinks) DuAEF.DuAE.App.copyWithPropertyLinks();
	else DuAEF.DuAE.App.copy();

	//destination
	destinationComp.openInViewer();

	//unselect layers in destination
	var previousSelectionDestination = DuAEF.DuAE.Comp.unselectLayers(destinationComp);

	//paste
	DuAEF.DuAE.App.paste();

	//keep new layers to return them
	var newLayers = destinationComp.selectedLayers;

	//restore previous state
	DuAEF.DuAE.Comp.selectLayers(previousSelection);
	previousActiveComp.openInViewer();
	DuAEF.DuAE.Comp.selectLayers(previousSelectionDestination);

	return newLayers;
}

/**
	* Parents all (unparented) layers
	* @param {Layer|LayerCollection|Layer[]} layers - The layers to parent
	* @param {Layer} [parent] - The parent. If not defined, will use the last layer of the list
	* @param {boolean} [unparentedOnly=true] - True to parent only layers which do not have a parent yet 
*/
DuAEF.DuAE.Layer.parent = function(layers, parent, unparentedOnly)
{
	unparentedOnly = def( unparentedOnly, true );
	if (typeof parent === 'undefined')
	{
		if (!layers.length) return;
		if (layers.length == 1) return;
		parent = layers.pop();
	}

	if (layers.length)
	{
		var it = new Iterator (layers);
		it.do(function(layer)
		{
			var locked = layer.locked;
			layer.locked = false;
			if ((layer.parent == null && unparentedOnly) || !unparentedOnly)
			{
				if (layer.parent != parent ) layer.parent = parent;
			}
			layer.locked = locked;
		});
	}
	else 
	{
		var locked = layers.locked;
		layers.locked = false;
		if ((layers.parent == null && unparentedOnly) || !unparentedOnly)
		{
			if (layers.parent != parent) layers.parent = parent;
		}
		layers.locked = locked;
	}
}

/**
 * Gets all the (selected) puppet pins found on the layer.<br />
 * Will return all puppet pins if there is no puppet selection.
 * @param {Layer} layer - The layer
 * @return {PropertyInfo[]} The properties
*/
DuAEF.DuAE.Layer.getPuppetPins = function (layer)
{
	var pins = [];
	var selectedProps = layer.selectedProperties;

	function getPins(puppet)
	{
		//get pins
		var mesh = puppet.property("ADBE FreePin3 ARAP Group").property("ADBE FreePin3 Mesh Group").property("ADBE FreePin3 Mesh Atom").property("ADBE FreePin3 PosPins");
		for (var i = 1, num = mesh.numProperties ; i <= num; i++)
		{
			pins.push(new PropertyInfo(mesh.property(i)));
		}
	}

	if (selectedProps == 0)
	{
		//look for puppet effects
		for (var i = 1, num = layer('ADBE Effect Parade').numProperties; i <= num; i++)
		{
			var effect = layer.effect(i);
			if (effect.matchName == 'ADBE FreePin3')
			{
				getPins(effect);
			}
		}
	}
	else
	{
		//get any selected pin
		var itProps = new Iterator(selectedProps);
		itProps.do(function(prop)
		{
			if (prop.matchName == 'ADBE FreePin3 PosPin Atom') pins.push(new PropertyInfo(prop));
		});
		//try to find selected puppets
		if (pins.length == 0)
		{
			itProps.do(function(prop)
			{
				if (prop.matchName == 'ADBE FreePin3') getPins(prop);
			});
		}
	}


	return pins;
}

/**
* Aligns a layer in position to another layer
* @param {Layer} layer - The layer to align.
* @param {Layer} target - The reference layer.
*/
DuAEF.DuAE.Layer.alignPosition = function (layer, target)
{
	//parent to target
	var layerParent = layer.parent;
	if (layerParent != target) layer.parent = target;

	var comp = layer.containingComp;

	//TODO if dimensions dimensions separated
	//TODO if 3D

	//set position
	if (layer.transform.position.numKeys == 0) layer.transform.position.setValue(target.transform.anchorPoint.value);
	else layer.transform.position.setValueAtTime(comp.time, target.transform.anchorPoint.value);

	//reparent
	if (layerParent != target) layer.parent = layerParent;
}

/**
* Aligns a layer's orientation to another layer
* @param {Layer} layer - The layer to align.
* @param {Layer} target - The reference layer.
*/
DuAEF.DuAE.Layer.alignOrientation = function (layer, target)
{
	//parent to target
	var layerParent = layer.parent;
	if (layerParent != target) layer.parent = target;

	var comp = layer.containingComp;

	//TODO if 3D/2D

	//set rotation
	if (layer.transform.rotation.numKeys == 0) layer.transform.rotation.setValue(0);
	else layer.transform.rotation.setValueAtTime(comp.time, 0);

	//reparent
	if (layerParent != target) layer.parent = layerParent;
}

/**
* Aligns a layer's scale to another layer
* @param {Layer} layer - The layer to align.
* @param {Layer} target - The reference layer.
*/
DuAEF.DuAE.Layer.alignScale = function (layer, target)
{
	//parent to target
	var layerParent = layer.parent;
	if (layerParent != target) layer.parent = target;

	var comp = layer.containingComp;

	//TODO 3D

	//set scale
	if (layer.transform.scale.numKeys == 0) layer.transform.scale.setValue([100,100]);
	else layer.transform.scale.setValueAtTime(comp.time, [100,100]);

	//reparent
	if (layerParent != target) layer.parent = layerParent;
}

/**
* Aligns a layer's opcaity to another layer
* @param {Layer} layer - The layer to align.
* @param {Layer} target - The reference layer.
*/
DuAEF.DuAE.Layer.alignOpacity = function (layer, target)
{
	var comp = layer.containingComp;

	//set scale
	if (layer.transform.opacity.numKeys == 0) layer.transform.opacity.setValue(target.transform.opacity.value);
	else layer.transform.opacity.setValueAtTime(comp.time, target.transform.opacity.value);
}

/**
* Aligns the layers' transformations (position, rotation, scale) to another layer
* @param {Layer[]|LayerCollection} layers - The layers to align.
* @param {Layer} target - The reference layer.
* @param {boolean} [position=true] - True to align position.
* @param {boolean} [rotation=true] - True to align orientation.
* @param {boolean} [scale=true] - True to align scale.
* @param {boolean} [opacity=false] - True to align opcacity.
*/
DuAEF.DuAE.Layer.align = function (layers, target, position, rotation, scale, opacity)
{
	if (typeof position === 'undefined') position = true;
	if (typeof rotation === 'undefined') rotation = true;
	if (typeof scale === 'undefined') scale = true;
	if (typeof opacity === 'undefined') opacity = false;

	var it = new Iterator(layers);


	var comp = layers[0].containingComp;

	var targetParent = target.parent;
	target.parent = null;

	//unparent all layers
	var parents = [];
	it.do(function (layer) {
		if (layer == target) return;
		//parent to target
		parents[it.current] = layer.parent;

		layer.parent = target;
	});

	//set values
	it.do(function (layer) {
		if (layer == target) return;

		if (position) DuAEF.DuAE.Layer.alignPosition(layer, target);
		if (rotation) DuAEF.DuAE.Layer.alignOrientation(layer, target);
		if (scale) DuAEF.DuAE.Layer.alignScale(layer, target);
		if (opacity) DuAEF.DuAE.Layer.alignOpacity(layer, target);
	});

	//re-parent
	it.do(function (layer) {
		if (layer == target) return;
		//reparent
		layer.parent = parents[it.current];
	});

	target.parent = targetParent;
}

/**
* Gets the transformation matrix of the layer from the compostion.<br />
* Use Matrix.applyToPoint(point) to transform any coordinate with the matrix returned by this method.
* @param {Layer[]} layer - the layer
* @return {Matrix} The coordinates.
*/
DuAEF.DuAE.Layer.getTransformMatrix = function(layer)
{
	var matrix = new Matrix();

	//get the ancestors
	var layers = [layer];
	var parent = layer.parent;
	while (parent)
	{
		layers.push(parent);
		parent = parent.parent;
	}

	//apply transforms from the ancestor
	for (var i = layers.length - 1; i >= 0; i--)
	{
		var l = layers[i];
				
		//position
		matrix.translate(l.transform.position.value);
		
		//rotation
		if (l.threeDLayer || l instanceof CameraLayer) matrix.rotate(l.transform.zRotation.value);
		else matrix.rotate(l.transform.rotation.value);

		if (!(l instanceof CameraLayer))
		{
			//anchor point inverse transform, taking scale into account
			var aPX = - (l.transform.anchorPoint.value[0]*l.transform.scale.value[0]/100);
			var aPY = - (l.transform.anchorPoint.value[1]*l.transform.scale.value[1]/100);

			matrix.translate([aPX,aPY]);

			//scale
			matrix.scale(l.transform.scale.value/100);
		}
	}

	return matrix;
}

/**
 * Moves a layer to the coordinates of a spatial property
 * @param {Layer} layer - The layer
 * @param {Property|PropertyInfo} prop - The property
 */
DuAEF.DuAE.Layer.moveLayerToProperty = function(layer, prop)
{
	var propInfo;
	if (prop instanceof PropertyInfo)
	{
		propInfo = prop;
		prop = propInfo.getProperty();
	}
	else
	{
		propInfo = new PropertyInfo(prop);
	}

	var propLayer = propInfo.layer;
	var comp = propInfo.comp;

	if (!(propLayer instanceof ShapeLayer))
	{
		var matrix = DuAEF.DuAE.Layer.getTransformMatrix(propLayer);
		var pos = matrix.applyToPoint(prop.value);
		var parent = layer.parent;
		layer.parent = null;
		layer.position.setValue(pos);
		layer.parent = parent;
	}
	else
	{
		var parent = layer.parent;
		layer.parent = null;
		layer.position.setValue(prop.value);
		layer.parent = parent;
	}
}

/**
 * Sets the In and Out points of a layer according to its opacity (cuts at 0%)
 * @param {Layer} layer - The layer
 * @param {boolean} [preExpression=false] - Whether to check for the opacity post or pre-expression value
 */
DuAEF.DuAE.Layer.autoDuration = function( layer, preExpression )
{
	if (typeof preExpression === 'undefined') preExpression = false;

	var comp = layer.containingComp;

	var inPoint = layer.inPoint;
	var outPoint = layer.outPoint;
	var inFrame = inPoint / comp.frameDuration;
	var outFrame = outPoint / comp.frameDuration;

	//search in
	if (layer.transform.opacity.valueAtTime(inPoint, preExpression) == 0)
	{
		for (var i = inFrame; i < outFrame; i++)
		{
			var time = i * comp.frameDuration;
			if (layer.transform.opacity.valueAtTime(time, preExpression) == 0) inPoint = time + comp.frameDuration;
			else break;
		}
	}

	//search out 
	if (layer.transform.opacity.valueAtTime(outPoint, preExpression) == 0)
	{
		for (var i = outFrame; i > inFrame; i--)
		{
			var time = i * comp.frameDuration;
			if (layer.transform.opacity.valueAtTime(time, preExpression) == 0) outPoint = time;
			else break;
		}
	}

	//set new in and out points
	if (inPoint != layer.inPoint) layer.inPoint = inPoint;
	if (outPoint != layer.outPoint) layer.outPoint = outPoint;
}

/**
	* After Effects properties methods
	* @namespace
	* @memberof DuAEF.DuAE
*/
DuAEF.DuAE.Property = {};

/**
	* Gets the After Effects properties in the property
	* @param {PropertyBase|PropertyInfo}	property	- The layer
	* @param {PropertyType|PropertyValueType|string|function}	 [filter]	- A filter to get only a certain type, or value type, or property name or matchName.<br />
	* A function which take one PropertyBase as argument can be used to filter the properties: the Property will be returned if the function returns true.
	* @param {boolean}	[strict=false]	- If a string filter is provided, wether to search for the exact name/matchName or if it contains the filter.
	* @param {boolean}	[caseSensitive=true]	- If a string filter is provided, and not strict is false, does the search have to be case sensitive?
	* @return {PropertyInfo[]} The selected properties, an empty Array if nothing found
*/
DuAEF.DuAE.Property.getProps = function(property,filter,strict,caseSensitive)
{
	if (strict == undefined) strict = false;
	if (caseSensitive == undefined) caseSensitive = true;
	var prop;
	if (property instanceof PropertyInfo) prop = property.getProperty();
	else prop = property;

	var props = [];

	if (!caseSensitive && typeof filter === "string") filter = filter.toLowerCase();

	var name = prop.name;
	var matchName = prop.matchName;
	if (!caseSensitive)
	{
		name = name.toLowerCase();
		matchName = matchName.toLowerCase();
	}

	if (strict && name === filter) props.push(prop);
	else if (strict && matchName === filter) props.push(prop);
	else if (!strict && typeof filter === "string")
	{
		if (name.indexOf(filter) >= 0) props.push(prop);
		else if (matchName.indexOf(filter) >= 0) props.push(prop);
	}
	else if (typeof filter === "function") if (filter(prop)) props.push(prop);
	else if (prop.propertyType == PropertyType.PROPERTY) if (prop.propertyValueType == filter) props.push(prop);
	else if (prop.propertyType == filter) props.push(prop);

	if (prop.numProperties > 0)
	{
		for (var k = 1 ; k <= prop.numProperties ; k++)
		{
			props = props.concat(DuAEF.DuAE.Property.getProps(prop.property(k),filter,strict,caseSensitive));
		}
	}

	return DuAEF.DuAE.getPropertyInfos(props);
}

/**
	* Gets the layer containing the property
	* @param {PropertyBase|PropertyInfo}	prop	- The After Effects Property
	* @return {Layer}	The layer
*/
DuAEF.DuAE.Property.getLayer = function (prop)
{
	if (prop == undefined) throw "You must provide a property.";
	if (prop instanceof PropertyInfo) prop = prop.getProperty();
	var parentProp = prop;
	while (parentProp.parentProperty)
	{
		// Traverse up the property tree
		parentProp = parentProp.parentProperty;
	}
	return parentProp;
}

/**
	* Gets the composition containing the property
	* @param {PropertyBase|PropertyInfo}	prop	- The After Effects Property
	* @return {CompItem}	The composition
*/
DuAEF.DuAE.Property.getComp = function (prop)
{
	var layer = DuAEF.DuAE.Property.getLayer(prop);
	return layer.containingComp;
}

/**
	* Generates a new unique name for a marker for this marker porperty
	* @param {string} newName	- The wanted new name
	* @param {Property} prop 	- The comp
	* @param {boolean} [increment=true] - true to automatically increment the new name if it already ends with a digit
	* @return {string}	The unique name, with a new number at the end if needed.
*/
DuAEF.DuAE.Property.newUniqueMarkerName = function(newName, prop,increment)
{
	if (increment == undefined) increment = true;
	var markerNames = [];
	for (var i = 1, num = prop.numKeys ; i <= num ; i++)
	{
		markerNames.push(prop.keyValue(i).comment);
	}
	return DuAEF.DuJS.String.generateUnique(newName,markerNames,increment);
}

/**
	* Gets the number of dimensions of a property
	* @param {Property|PropertyInfo}	prop	- The After Effects Property
	* @return {int}	The number of dimensions, 0 if this is not a dimensionnal value (ie color, text, shape...)
*/
DuAEF.DuAE.Property.getDimensions = function (prop)
{
	if (prop instanceof PropertyInfo) prop = prop.getProperty();
	var dimensions = 0;
	if (prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL || prop.propertyValueType == PropertyValueType.ThreeD)
	{
		//if this is a position or scale and the layer is not 3D, AFX uses a 3D value in the position (with 0 as Z position), but the expression must return a 2D value.......
		if ((prop.matchName == "ADBE Scale" || prop.matchName == "ADBE Position") && !DuAEF.DuAE.Property.getLayer(prop).threeDLayer)
		{
			dimensions = 2;
		}
		else
		{
			dimensions = 3;
		}
	}
	else if (prop.propertyValueType == PropertyValueType.TwoD_SPATIAL || prop.propertyValueType == PropertyValueType.TwoD)
	{
		dimensions = 2;
	}
	else if (prop.propertyValueType == PropertyValueType.OneD)
	{
		dimensions = 1;
	}
	else if (prop.propertyValueType == PropertyValueType.COLOR)
	{
		dimensions = 4;
	}
	return dimensions;
}

/**
	* Checks if this property value can be edited
	* @param {Property|PropertyInfo} prop - The After Effects Property
	* @return {bool} true if the value of the property can be edited, false otherwise
*/
DuAEF.DuAE.Property.isEditable = function (prop)
{
	if (prop instanceof PropertyInfo) prop = prop.getProperty();

	if (prop.propertyType != PropertyType.PROPERTY) return false;
	if (prop.elided) return false;
	if (prop.dimensionsSeparated) return false;
	if (typeof prop.value === 'undefined') return false;
	//TODO find a way to detect if prop is hidden without using a try/catch
	//try to set a value if there's no keyframe
	if (prop.numKeys == 0)
	{
		try
		{
			prop.setValue(prop.valueAtTime(0,true));
			return true;
		}
		catch (e)
		{
			return false;
		}
	}
	else
	{
		try
		{
			prop.setValueAtKey(1, prop.keyValue(1));
			return true;
		}
		catch (e)
		{
			return false;
		}
	}

	return true;
}

/**
	* Checks if this property value can be rigged (with an expression)
	* @param {Property|PropertyInfo} prop - The After Effects Property
	* @return {bool} true if the value of the property can be rigged, false otherwise
*/
DuAEF.DuAE.Property.isRiggable = function (prop)
{
	if (prop instanceof PropertyInfo) prop = prop.getProperty();

	if (prop.propertyType != PropertyType.PROPERTY) return false;
	if (!prop.canVaryOverTime) return false;
	if (!prop.canSetExpression) return false;
	if (prop.elided) return false;
	if (prop.dimensionsSeparated) return false;
	if (typeof prop.expression !== 'string') return false;
//TODO find a way to detect if prop is hidden without using a try/catch
	try { prop.expression = prop.expression; return true } catch(e) { return false; }
}

/**
	* Gets the key at a given index on a property
	* @param {Property|PropertyInfo}	prop	- The property.
	* @param {int}	keyIndex	- The index of the key to retrieve. If the index is negative, it is counted from the end i.e. to retrieve the keyframe before the last one, use -2 (-1 is the last)
	* @return {KeyFrame}	The keyframe, or null if incorrect index
*/
DuAEF.DuAE.Property.getKeyFrameAtIndex = function (prop,keyIndex)
{
	if (prop instanceof PropertyInfo) prop = prop.getProperty();
	if (Math.abs(keyIndex) > prop.numKeys || keyIndex == 0)
	{
		return null;
	}
	if (keyIndex < 0)
	{
		keyIndex = prop.numKeys - keyIndex + 1;
	}

	var key = new KeyFrame();
	key._time = prop.keyTime(keyIndex);
	key.value = prop.keyValue(keyIndex);
	key._inInterpolationType = prop.keyInInterpolationType(keyIndex);
	key._outInterpolationType = prop.keyOutInterpolationType(keyIndex);
	if ( prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL || prop.propertyValueType == PropertyValueType.TwoD_SPATIAL )
	{
		key._spatial = true;
		key.spatialProperties.inTangent = prop.keyInSpatialTangent(keyIndex);
		key.spatialProperties.outTangent  = prop.keyOutSpatialTangent(keyIndex);
		key.spatialProperties._continuous = prop.keySpatialContinuous(keyIndex);
		key.spatialProperties._autoBezier = prop.keySpatialAutoBezier(keyIndex);
		key.spatialProperties._roving = prop.keyRoving(keyIndex);
	}
	key.inEase = prop.keyInTemporalEase(keyIndex);
	key.outEase = prop.keyOutTemporalEase(keyIndex);
	key._continuous = prop.keyTemporalContinuous(keyIndex);
	key._autoBezier = prop.keyTemporalAutoBezier(keyIndex);
	key._index = keyIndex;

	return key;
}

/**
	* Gets the nearest key at a given time on a property
	* @param {Property|PropertyInfo}	prop	- The property.
	* @param {float}	time	- The time of the key to retrieve.
	* @return {KeyFrame}	The keyframe, or null if incorrect time or not found
*/
DuAEF.DuAE.Property.getNearestKeyFrameAtTime = function (prop,time)
{
	if (prop instanceof PropertyInfo) prop = prop.getProperty();
	return DuAEF.DuAE.Property.getKeyFrameAtIndex(prop.nearestKeyIndex(time));
}

/**
	* Gets the key at an exactly given time on a property
	* @param {Property|PropertyInfo}	prop	- The property.
	* @param {float}	time	- The time of the key to retrieve.
	* @return {KeyFrame}	The keyframe, or null if incorrect time
*/
DuAEF.DuAE.Property.getKeyFrameAtTime = function (prop,time)
{
	if (prop instanceof PropertyInfo) prop = prop.getProperty();
	if (!prop.canVaryOverTime) return null;
	if (prop.numKeys == 0) return null;
	var key = DuAEF.DuAE.Property.getKeyFrameAtIndex(prop,prop.nearestKeyIndex(time));
	if (key === null) return key;
	if (key._time == time) return key;
	else return null;
}

/**
	* Gets the property keyframes in the whole timeline or in the time range<br />
	* The KeyFrame._time will be adjusted relatively to the start of the time range instead of the startTime of the composition.
	* @param {Property|PropertyInfo}	prop	- The property.
	* @param {boolean}	[selected=false]	- true to get only selected keyframes.
	* @param {float[]}	[timeRange]	- The time range, an array of two time values, in seconds. If not provided, will use the comp time range.<br />
	* Ignored if selected is true;
	* @return {KeyFrame[]}	The keyframes, or null of this property is of type PropertyValueType.NO_VALUE or PropertyValueType.CUSTOM_VALUE
*/
DuAEF.DuAE.Property.getKeyFrames = function(prop,selected,timeRange)
{
	if (prop instanceof PropertyInfo) prop = prop.getProperty();
	if (prop.propertyValueType == PropertyValueType.NO_VALUE) return [];
	if (prop.propertyValueType == PropertyValueType.CUSTOM_VALUE) return [];

	var comp = DuAEF.DuAE.Property.getComp(prop);
	if (timeRange == undefined) timeRange = [0,comp.duration];
	if (selected == undefined) selected = false;

	var keyFrames = [];

	if (prop.elided) return keyFrames;

	if (prop.isTimeVarying)
	{
		if (selected)
		{
			for (var keyIndex = 0; keyIndex < prop.selectedKeys.length ; keyIndex++)
			{
				var key = DuAEF.DuAE.Property.getKeyFrameAtIndex(prop,prop.selectedKeys[keyIndex]);
				if (key._time >= timeRange[0] && key._time <= timeRange[1])
				{
					key._time = key._time - timeRange[0];
					keyFrames.push(key);
				}
			}
		}
		else if (prop.numKeys > 0)
		{
			for (var keyIndex = 1; keyIndex <= prop.numKeys ; keyIndex++)
			{
				var key = DuAEF.DuAE.Property.getKeyFrameAtIndex(prop,keyIndex);
				if (key._time >= timeRange[0] && key._time <= timeRange[1])
				{
					key._time = key._time - timeRange[0];
					keyFrames.push(key);
				}
			}
		}
	}
	return keyFrames;
}

/**
	* Gets all animations in the group in the whole timeline or in the time range<br />
	* The first KeyFrame._time will be adjusted relatively to the start of the time range (if provided) instead of the startTime of the composition.
	* @param {PropertyGroup|PropertyInfo}	prop	- The property.
	* @param {boolean}	[selected=false]	- true to get only selected keyframes.
	* @param {float[]}	[timeRange]	- The time range, an array of two time values, in seconds. If not provided, will use the comp time range.
	* @return {PropertyGroupAnim|PropertyAnim}	The animations. A PropertyAnim if prop is a Property, a PopertyGroupAnim if it is a PropertyGroup
*/
DuAEF.DuAE.Property.getAnim = function (prop,selected,timeRange)
{
	var comp = DuAEF.DuAE.Property.getComp(prop);
	if (typeof timeRange === 'undefined') timeRange = [0,comp.duration];
	if (typeof selected === 'undefined') selected = false;

	if (prop instanceof PropertyInfo) prop = prop.getProperty();

	if (selected && !DuAEF.DuAE.Property.hasSelectedKeys(prop)) return null;

	if (prop.propertyType === PropertyType.PROPERTY)
	{
		if (prop.propertyValueType == PropertyValueType.NO_VALUE) return null;
		if (prop.elided) return null;
		if (!prop.canVaryOverTime) return null;
		var anim = new PropertyAnim();
		anim._name = prop.name;
		anim._matchName = prop.matchName;
		anim.startValue = prop.valueAtTime(timeRange[0],true);
		anim.endValue = prop.valueAtTime(timeRange[1],true);
		anim.keys = DuAEF.DuAE.Property.getKeyFrames(prop,selected,timeRange);
		if (anim.keys.length > 0)
		{
			anim.startTime = anim.keys[0]._time;
			anim.endTime = anim.keys[anim.keys.length-1]._time;
		}
		else
		{
			anim.startTime = 0;
			anim.endTime = 0;
		}
		anim.dimensions = DuAEF.DuAE.Property.getDimensions(prop);
		if (prop.canSetExpression) anim.expression = prop.expression;
		return anim;
	}
	else if (prop.numProperties > 0)
	{
		var groupAnim = new PropertyGroupAnim();
		groupAnim._name = prop.name;
		groupAnim._matchName = prop.matchName;

		for (var propIndex = 1;propIndex <= prop.numProperties;propIndex++)
		{
			var anim = DuAEF.DuAE.Property.getAnim(prop.property(propIndex),selected,timeRange);
			if (anim != null)
			{
				if (groupAnim.startTime == null) groupAnim.startTime = anim.startTime;
				else if (groupAnim.startTime > anim.startTime) groupAnim.startTime = anim.startTime;
				if (groupAnim.endTime == null) groupAnim.endTime = anim.endTime;
				else if (groupAnim.endTime > anim.endTime) groupAnim.endTime = anim.endTimeendTime;
				groupAnim.anims.push(anim);
			}
		}
		return groupAnim;
	}
	return null;
}

/**
	* Gets the time of the first keyFrame
	* @param {PropertyBase[]|PropertyInfo[]} props - The properties
	* @param {boolean} selected - true to check selected keyframes only
	* @return {float|null} The keyframe time or null if there are no keyframe
*/
DuAEF.DuAE.Property.firstKeyFrameTime = function (prop,selected)
{
	var time = null;

	if (prop instanceof PropertyInfo) prop = prop.getProperty();
	if (prop.propertyType == PropertyType.PROPERTY)
	{
		if (!prop.canVaryOverTime) return null;
		if (selected)
		{
			if (prop.selectedKeys.length == 0) return null;
			for (var keyIndex = 0; keyIndex < prop.selectedKeys.length ; keyIndex++)
			{
				var key = DuAEF.DuAE.Property.getKeyFrameAtIndex(prop,prop.selectedKeys[keyIndex]);
				if (time == null) time = key._time;
				else if (time > key._time) time = key._time;
			}
		}
		else
		{
			if (prop.numKeys == 0) return null;
			for (var keyIndex = 1; keyIndex <= prop.numKeys ; keyIndex++)
			{
				var key = DuAEF.DuAE.Property.getKeyFrameAtIndex(prop,keyIndex);
				if (time == null) time = key._time;
				else if (time > key._time) time = key._time;
			}
		}
	}
	else if (prop.numProperties > 0)
	{
		for (var propIndex = 1;propIndex <= prop.numProperties;propIndex++)
		{
			var test = DuAEF.DuAE.Property.firstKeyFrameTime(prop.property(propIndex),selected);
			if (time == null) time = test;
			else if (test != null) { if (time > test) time = test; }
		}
	}

	return time;
}

/**
	* Sets a {@linkcode KeyFrame} on a property
	* @param {Property|PropertyInfo}	prop	- The property.
	* @param {KeyFrame}	key	- The KeyFrame.
	* @param {float}	[timeOffset=comp.time]	- The time offset (added to KeyFrame._time) where to add the key frame.
*/
DuAEF.DuAE.Property.setKey = function (prop,key,timeOffset)
{
	if (prop instanceof PropertyInfo) prop = prop.getProperty();
	if (prop.elided) return;
	if (!prop.propertyType === PropertyType.PROPERTY) throw "Can not set a key on a group property";
	if (!prop.canVaryOverTime) return;
	if (prop.isSeparationLeader) if (prop.dimensionsSeparated) return;

	if (timeOffset == undefined) timeOffset = DuAEF.DuAE.Property.getPropertyComp(prop).time;
	var time = key._time + timeOffset;
	var propDimensions = DuAEF.DuAE.Property.getDimensions(prop);
	var val = key.value;

	if (propDimensions > 1 && !(val instanceof Array))
	{
		val = [val];
	}

	//adjust dimensions
	if (val instanceof Array)
	{
		while (val.length < propDimensions)
		{
			val.push(0);
		}
		while (val.length > propDimensions)
		{
			val.pop();
		}
	}

	DuAEF.DuAE.Property.setValueAtTime(prop,val,time);
	if (prop.numKeys == 0) return;

	//get the index of the created key
	var index = prop.nearestKeyIndex(time);

	//set interpolations
	if (key._spatial && (prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL || prop.propertyValueType == PropertyValueType.TwoD_SPATIAL))
	{
		try{
			prop.setSpatialContinuousAtKey(index,key.spatialProperties._continuous);
			prop.setSpatialAutoBezierAtKey(index,key.spatialProperties._autoBezier);
			prop.setRovingAtKey(index,key.spatialProperties._roving);
			prop.setSpatialTangentsAtKey(index,key.spatialProperties.inTangent,key.spatialProperties.outTangent);
		}
		catch(err)
		{
			if (DuAEF.debug) alert(err.description);
		};
	}

	try
	{
		prop.setTemporalContinuousAtKey(index,key._continuous);
		prop.setTemporalAutoBezierAtKey(index,key._autoBezier);
		prop.setTemporalEaseAtKey(index,key.inEase,key.outEase);
		prop.setInterpolationTypeAtKey(index,key._inInterpolationType,key._outInterpolationType);
	}
	catch(err)
	{
		if (DuAEF.debug) alert(err.description);
	}

}

/**
	* Sets the property animation on the property.<br />
	* Use this method only to force the animation onto the property without checks.<br />
	* Must be used on a Property (not a group) with a PropertyAnim (not a PropertyGroupAnim).<br />
	* To easily set an animation on a property with automatic compatibility checks, you should use setGroupAnim().
	* @param {Property|PropertyInfo}	prop	- The property.
	* @param {PropertyAnim} anims	- The animation
	* @param {float}	[time=comp.time]	- The time where to begin the animation
	* @param {boolean}	[setExpression=false]	- Sets the expression too
	* @param {boolean}	[replace=false]	- true to remove any existing keyframe on the properties before adding new keyframes
	* @param {boolean}	[offset=false]	- true to offset the current value, instead of replacing it
	* @return {boolean} true if the anim was actually set.
*/
DuAEF.DuAE.Property.setAnim = function(prop,anim,time,setExpression, replace, offset)
{
	var propInfo = new PropertyInfo(prop);
	prop = propInfo.getProperty();
	var comp = propInfo.comp;
	time = def(time, comp.time );
	setExpression = def(setExpression, false);
	replace = def(replace, false);
	offset = def(offset, false);

	if (!propInfo.numerical) offset = false;

	var dimensions = anim.dimensions;

	var ok = false;

	if (anim == null) return true;
	if (anim.type == 'group') return false;

	if (propInfo.editable)
	{
		//keep current value
		var val = prop.valueAtTime(comp.time, true);

		//remove keyframes
		if (replace && prop.numKeys > 0)
		{
			for (var i = prop.numKeys; i > 0; i--)
			{
				prop.removeKey(i);
			}
			DuAEF.DuAE.Property.setValue(prop, val);
		}

		//if there are keys, set them
		if (anim.keys.length > 0)
		{
			for (var iclef = 0; iclef < anim.keys.length;iclef++)
			{
				var key = anim.keys[iclef];
				if (offset)
				{
					if (iclef == 0) key.value = val;
					else key.value = val + (key.value - anim.startValue);
				}
				DuAEF.DuAE.Property.setKey(prop,key,time);
				ok = true;
			}
		}
		else //set the start value
		{
			var value = anim.startValue;
			if (value instanceof Array)
			{
				while (value.length < dimensions)
				{
					value.push(0);
				}
				while (value.length > dimensions)
				{
					value.pop();
				}
			}

			if (anim.startValue != null && !offset)
			{
				if (prop.numKeys == 0)
				{
					DuAEF.DuAE.Property.setValue(prop,anim.startValue);
				}
				else
				{
					try { prop.setValueAtTime(time,anim.startValue); } catch (e) {};
				}
			}
			ok = true;
		}

		//set the expression
		if (propInfo.riggable && setExpression)
		{
			try { prop.expression = anim.expression; } catch(e) { if (DuAEF.debug) alert(e.description); };
		}
	}

	return ok;
}

/**
	* Sets all animations on a Property or a PropertyGroup.
	* @param {PropertyGroup|PropertyInfo}	prop	- The property group.
	* @param {PropertyAnim} anims	- The animation
	* @param {float}	[time=comp.time]	- The time where to begin the animation
	* @param {boolean}	[ignoreName=false]	- true to set the anim even if name of the property do not match the animation.
	* @param {boolean}	[setExpression=false]	- Sets the expression too
	* @param {boolean}	[onlyKeyframes=true]	- If false, the value of properties without keyframes will be set too.
	* @param {boolean}	[replace=false]	- true to remove any existing keyframe on the properties before adding new keyframes
	* @param {string[]}	[whiteList]	- A list of matchNames used as a white list for properties to set anims.<br />
	* Can be the matchName of a propertyGroup to set all the subproperties.<br />
	* Ignored if the list is empty.
	* @param {boolean}	[offset=false]	- true to offset the current value, instead of replacing it
	* @return {boolean} true if the anim was actually set.
*/
DuAEF.DuAE.Property.setGroupAnim = function(prop, anim, time, ignoreName, setExpression, onlyKeyframes, replace, whiteList, offset, set )
{
	if (prop instanceof PropertyInfo) prop = prop.getProperty();
	if (typeof time === 'undefined') time = DuAEF.DuAE.Property.getPropertyComp(prop).time;
	if (typeof ignoreName === 'undefined') ignoreName = false;
	if (typeof setExpression === 'undefined') setExpression = false;
	if (typeof onlyKeyframes === 'undefined') onlyKeyframes = false;
	if (typeof replace === 'undefined') replace = false;
	if (typeof whiteList === 'undefined') whiteList = [];
	if (typeof offset === 'undefined') offset = false;
	if (typeof reverse === 'undefined') reverse = false;
	if (typeof set === 'undefined') set = false;

	if (whiteList.length == 0) set = true;
	if (DuAEF.DuJS.Array.indexOf(whiteList, anim._matchName) >= 0) set = true;

	var ok = false;

	if (anim == null) return true;

	if (anim.type == 'anim')
	{
		if (set)
		{
			var okToSet = false;
			if (prop.matchName == anim._matchName)
			{
				if (!ignoreName && prop.name == anim._name) okToSet = true;
				if (ignoreName) okToSet = true;
				if (onlyKeyframes && anim.keys.length == 0) okToSet = false;
			}

			if (okToSet) return DuAEF.DuAE.Property.setAnim(prop, anim, time, setExpression, replace, offset);
		}
	}
	else
	{
		for (var i = 0 ; i < anim.anims.length ; i++)
		{
			var propAnim = anim.anims[i];
			//find the property with the same name and matchname
			for (var j = 1 ; j <= prop.numProperties ; j++)
			{
				var subProp = prop.property(j);
				var okToSet = false;
				if (subProp.matchName == propAnim._matchName)
				{
					if (!ignoreName && subProp.name == propAnim._name) okToSet = true;
					if (ignoreName) okToSet = true;
				}
				if (okToSet)
				{
					ok = DuAEF.DuAE.Property.setGroupAnim(subProp, propAnim, time, ignoreName, setExpression, onlyKeyframes, replace, whiteList, offset, set );
					break;
				}
			}
		}
	}

	return ok;
}

/**
	* Removes the animation from the property
	* @param {Property|PropertyInfo} prop -The property
	* @param {boolean} [removeExpression=false] - Set to true to remove the expression too
*/
DuAEF.DuAE.Property.removeAnim = function(prop,removeExpression)
{
	if (prop instanceof PropertyInfo) prop = prop.getProperty();
	while (prop.numKeys > 0)
	{
		prop.removeKey(1);
	}
	if (removeExpression && prop.canSetExpression)
	{
		prop.expression = '';
	}
}

/**
	* Selects the keyframes in the propoerty.<br />
	* Selects all nested keyframes if the property is a group.
	* @param {PropertyBase|PropertyInfo} property - The property
	* @param {float} [inTime=0] - The time at which to select the keyframes
	* @param {float} [outTime=inTime] - The end time
*/
DuAEF.DuAE.Property.selectKeyFrames = function(property,inTime,outTime)
{
	if (inTime == undefined) inTime = 0;
	if (outTime == undefined) outTime = inTime;
	var prop;
	if (property instanceof PropertyInfo) prop = property.getProperty();
	else prop = property;

	if (prop.propertyType == PropertyType.PROPERTY)
	{
		if (prop.elided) return;
		if (prop.isSeparationLeader) if (prop.dimensionsSeparated) return;
		if (inTime == outTime)
		{
			//get key
			var key = DuAEF.DuAE.Property.getKeyFrameAtTime(prop,inTime);
			if (key) prop.setSelectedAtKey(key._index,true);
		}
		else
		{
			//get keys
			var keys = DuAEF.DuAE.Property.getKeyFrames(prop,false,[inTime,outTime]);
			if (!keys) return;
			for (var i = 0 ; i < keys.length ; i++)
			{
				prop.setSelectedAtKey(keys[i]._index,true);
			}
		}
	}
	else if (prop.numProperties > 0)
	{
		for (var i = 1 ; i <= prop.numProperties ; i++)
		{
			DuAEF.DuAE.Property.selectKeyFrames(prop.property(i),inTime,outTime);
		}
	}
}

/**
 * Gets an expression link to the property
 * @memberof DuAEF.DuAE.Property
 * @param {Property|PropertyInfo}	prop			- The property
 * @param {bool}		[useThisComp=false]		- Wether to begin the expression by 'thisComp' or 'comp("name")'
 * @param {bool}		[fromLayer=true]		- Wether to begin the expression by comp.layer or directly from the first prop of the layer
 * @return {str}		The expression link to the property
*/
DuAEF.DuAE.Property.getExpressionLink = function (prop,useThisComp,fromLayer)
{
	if (prop instanceof PropertyInfo) prop = prop.getProperty();
	if (useThisComp == undefined) useThisComp = false;
	if (fromLayer == undefined) fromLayer = true;

	//get compact expression from matchName, if available
	function getCompactExpression(matchName, name)
	{
		var translatedName = DuAEF.DuAE.compactExpressions[matchName];

		if (translatedName !== undefined)
			return eval(translatedName);
		else
			return ("(" + name + ")");
	}

	var exprCode = "";
	var name;
	while (prop.parentProperty !== null)
	{
		if (prop.propertyType == PropertyType.PROPERTY ) name = prop.propertyIndex;
		else if (prop.parentProperty.propertyType == PropertyType.INDEXED_GROUP)
		{
			name = "\"" + prop.name + "\"";
		}
		else name =  "\"" + prop.matchName + "\"";
		compactName = getCompactExpression(prop.matchName, name);
		exprCode = compactName + exprCode;

		// Traverse up the property tree
		prop = prop.parentProperty;
	}

	if (exprCode.indexOf("(") != 0 && exprCode != "") exprCode = '.' + exprCode;

	if (fromLayer)
	{
		var comp = prop.containingComp;
		// Prefix the layer reference
		name = "\"" + prop.name + "\"";
		exprCode = "layer(" + name + ")" + exprCode;
		// Prefix the comp reference
		if (useThisComp) exprCode = "thisComp." + exprCode;
		else exprCode = "comp(\"" + comp.name + "\")." + exprCode;
	}

	return exprCode;
}

/**
	* Sets a value on a property, adjusting the dimensions if needed
	* @param {Property|PropertyInfo} prop - The property
	* @param {any} value - The value to set
	* @return {boolean} True if the value has correctly been set, false otherwise.
*/
DuAEF.DuAE.Property.setValue = function(prop,value)
{
	var dimensions = 0;
	var editable = false;
	if (prop instanceof PropertyInfo)
	{
		propInfo = prop;
		prop = propInfo.getProperty();
	}
	else
	{
		propInfo = new PropertyInfo(prop);
	}
	dimensions = propInfo.dimensions;
	editable = propInfo.editable;

	if (prop.isSeparationLeader) if (prop.dimensionsSeparated) return false;

	if (!editable) return false;

	//check dimensions of the property
	if (dimensions == 0 || dimensions == 1)
	{
		if (value instanceof Array) value = value[0];
		try { prop.setValue(value); return true; } catch (e) { if (DuAEF.debug) alert(e.description); return false; }
	}
	else
	{
		if (!(value instanceof Array)) value = [value];
		while (value.length < dimensions)
		{
			value.push(0);
		}
		while (value.length > dimensions)
		{
			value.pop();
		}
		try { prop.setValue(value); return true; } catch (e) { if (DuAEF.debug) alert(e.description); return false; }
	}
}

/**
	* Sets a new keyframe on a property, adjusting the dimensions if needed, at desired time
	* @param {Property|PropertyInfo} prop - The property
	* @param {any} value - The value to set
	* @param {float} [time] - The time of the new keyframe
*/
DuAEF.DuAE.Property.setValueAtTime = function(prop,value,time)
{
	var dimensions = 0;
	var editable = false;
	if (prop instanceof PropertyInfo)
	{
		propInfo = prop;
		prop = propInfo.getProperty();
	}
	else
	{
		propInfo = new PropertyInfo(prop);
	}
	dimensions = propInfo.dimensions;
	editable = propInfo.editable;

	if (typeof time === 'undefined') time = propInfo.comp.time;

	if (!prop.canVaryOverTime) return;
	if (prop.isSeparationLeader) if (prop.dimensionsSeparated) return;

	if (!editable) return;

	//check dimensions of the property
	if (dimensions == 0 || dimensions == 1)
	{
		if (value instanceof Array) value = value[0];
		try { prop.setValueAtTime(time, value); } catch (e) { if (DuAEF.debug) alert(e.description); }
	}
	else
	{
		if (!(value instanceof Array)) value = [value];
		while (value.length < dimensions)
		{
			value.push(0);
		}
		while (value.length > dimensions)
		{
			value.pop();
		}
		try { prop.setValueAtTime(time, value); } catch (e) { if (DuAEF.debug) alert(e.description); }
	}
}

/**
	* Changes the interpolation type on selected keyframes, or sets a new key at current time if there are no keyframes selected.
	* @param {Layer[]|LayerCollection} layers - The layers containing the properties
	* @param {PropertyBase[]|PropertyInfo[]} props - The properties
	* @param {KeyframeInterpolationType|string} typeIn - The in interpolation type (see AE API) or the string "roving" or "continuous"
	* @param {KeyframeInterpolationType|string} [typeOut=typeIn] - The out interpolation type (see AE API)
	* @param {int[]|int} [easeInValue=33] - The in interpolation ease value (used if typeIn is KeyframeInterpolationType.BEZIER)
	* @param {int[]|int} [easeOutValue=easeInValue] - The out interpolation ease value (used if typeOut is KeyframeInterpolationType.BEZIER)
*/
DuAEF.DuAE.Property.setInterpolationType = function(layers,props,typeIn,typeOut,easeInValue,easeOutValue)
{
	if (typeOut == undefined) typeOut = typeIn;
	if (easeInValue == undefined) easeInValue = 33;
	if (isNaN(easeInValue)) easeInValue = 33;
	if (easeOutValue == undefined) easeOutValue = easeInValue;
	if (isNaN(easeOutValue)) easeOutValue = 33;

	if (layers.length == 0) return;

	if (!DuAEF.DuAE.Layer.haveSelectedKeys(layers))
	{
		DuAEF.DuAE.Property.addKey(props,typeIn,typeOut,easeInValue,easeOutValue);
	}
	else
	{
		for (var i=0;i<props.length;i++)
		{
			var propInfo = props[i];
			var prop = props[i];
			if (!(propInfo instanceof PropertyInfo)) propInfo = new PropertyInfo(prop);
			prop = props[i].getProperty();

			if (prop.canVaryOverTime)
			{
				//for keys
				for (var k=0,num = prop.selectedKeys.length; k<num; k++)
				{
					DuAEF.DuAE.Property.setKeyInterpolation(prop,prop.selectedKeys[k],typeIn,typeOut,easeInValue,easeOutValue);
				}
			}
		}
	}
}

/**
 * Sets interpolations on a keyframe.<br />
 * @param {Property} prop - The property
 * @param {int} key - The key index
 * @param {KeyframeInterpolationType|string} typeIn - The in interpolation type (see AE API) or the string "roving" or "continuous"
 * @param {KeyframeInterpolationType|string} [typeOut=typeIn] - The out interpolation type (see AE API)
 * @param {int[]|int} [easeInValue=33] - The in interpolation ease value (used if typeIn is KeyframeInterpolationType.BEZIER)
 * @param {int[]|int} [easeOutValue=easeInValue] - The out interpolation ease value (used if typeOut is KeyframeInterpolationType.BEZIER)
*/
DuAEF.DuAE.Property.setKeyInterpolation = function (prop, key, typeIn, typeOut, easeInValue, easeOutValue)
{
	if (typeOut == undefined) typeOut = typeIn;
	if (easeInValue == undefined) easeInValue = 33;
	if (isNaN(easeInValue)) easeInValue = 33;
	if (easeOutValue == undefined) easeOutValue = easeInValue;
	if (isNaN(easeOutValue)) easeOutValue = 33;

	easeInValue = new KeyframeEase(0,easeInValue);
	easeOutValue = new KeyframeEase(0,easeOutValue);

	if (typeIn == "roving" && prop.isSpatial)
	{
		prop.setRovingAtKey(key,true);
	}
	else if (typeIn == "continuous")
	{
		prop.setInterpolationTypeAtKey(key,KeyframeInterpolationType.BEZIER);
		prop.setTemporalContinuousAtKey(key, true);
		prop.setTemporalAutoBezierAtKey(key, true);
		//not roving
		if (prop.isSpatial) prop.setRovingAtKey(key,false);
	}
	else if (typeIn != "roving")
	{
		//influences
		if (!prop.isSpatial && prop.value.length == 3) { prop.setTemporalEaseAtKey(key,[easeInValue,easeInValue,easeInValue],[easeOutValue,easeOutValue,easeOutValue]); }
		else if (!prop.isSpatial && prop.value.length == 2) { prop.setTemporalEaseAtKey(key,[easeInValue,easeInValue],[easeOutValue,easeOutValue]); }
		else { prop.setTemporalEaseAtKey(key,[easeInValue],[easeOutValue]); }
		//type
		prop.setInterpolationTypeAtKey(key,typeIn,typeOut);
		//not roving
		if (prop.isSpatial)
		{
			if (prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL || prop.propertyValueType == PropertyValueType.TwoD_SPATIAL) prop.setRovingAtKey(key,false);
		}
		//not continuous
		prop.setTemporalContinuousAtKey(key, false);
	}
}

/**
 * Adds a new keyframe on the properties.<br />
 * To set a value of your choice on one property,<br />
 * you can create a new {@link KeyFrame}, then use {@link DuAEF.DuAE.Property.setKey}.
 * @param {PropertyBase[]|PropertyInfo[]} props - The properties
 * @param {KeyframeInterpolationType|string} typeIn - The in interpolation type (see AE API) or the string "roving" or "continuous"
 * @param {KeyframeInterpolationType|string} [typeOut=typeIn] - The out interpolation type (see AE API)
 * @param {int[]|int} [easeInValue=33] - The in interpolation ease value (used if typeIn is KeyframeInterpolationType.BEZIER)
 * @param {int[]|int} [easeOutValue=easeInValue] - The out interpolation ease value (used if typeOut is KeyframeInterpolationType.BEZIER)
 * @param {float} [time=comp.time] - The time at which to add the key
*/
DuAEF.DuAE.Property.addKey = function(props, typeIn, typeOut, easeInValue, easeOutValue, time)
{
	for (var i=0;i<props.length;i++)
	{
		var propInfo = props[i];
		var prop = props[i];
		if (!(propInfo instanceof PropertyInfo)) propInfo = new PropertyInfo(prop);
		prop = props[i].getProperty();
		var comp = DuAEF.DuAE.Property.getComp(prop);
		if (prop.canVaryOverTime)
		{
			var keyTime;
			if (typeof time === 'undefined') keyTime = comp.time;
			else keyTime = time;
			var key = prop.addKey(keyTime);
			DuAEF.DuAE.Property.setKeyInterpolation(prop, key, typeIn, typeOut, easeInValue, easeOutValue);
		}
	}
}

/**
 * Computes a percentage from a velocity on a given keyframe. 
 * @param {Property|PropertyInfo} prop - The property
 * @param {int} key - The index of the keyframe where to compute the velocity
 * @return {float[]} The velocities [in, out] as a percentage.
*/
DuAEF.DuAE.Property.velocityToPercent = function(prop, key)
{
	var propInfo = new PropertyInfo(prop);
	prop = propInfo.getProperty();

	var speedIn = prop.keyInTemporalEase(key)[0].speed;
	var speedOut = prop.keyOutTemporalEase(key)[0].speed;

	//get speed just before and after as if it was linear
	var prevSpeed = 0;
	var nextSpeed = 0;
	var val = prop.keyValue(key);
	var currentTime = prop.keyTime(key);
	if (key > 1)
	{
		var valBefore = prop.keyValue(key-1);
		var timeBefore = prop.keyTime(key-1);
		prevSpeed = DuAEF.DuJS.Math.getLength(val, valBefore) / (currentTime-timeBefore);
	}

	if (key < prop.numKeys)
	{
		var valAfter = prop.keyValue(key+1);
		var timeAfter = prop.keyTime(key+1);
		nextSpeed = DuAEF.DuJS.Math.getLength(val, valBefore) / (timeAfter-currentTime);
	}

	//get average speed
	var speed = (prevSpeed + nextSpeed) / 2;

	//compare to the original speeds 
	var speedInAsPercent = speedIn / speed * 100;
	var speedOutAsPercent = speedOut / speed * 100;

	return [speedInAsPercent, speedOutAsPercent];
}

/**
	* Changes the ease influences of the selected keys
	* @param {PropertyBase[]|PropertyInfo[]} props - The properties
	* @param {int[]|int} [easeInValue] - The in interpolation ease value. Will be ignored if undefined.
	* @param {int[]|int} [easeOutValue] - The out interpolation ease value. Will be ignored if undefined.
	* @param {int[]|int} [velocityInValue] - The out interpolation ease value. Will be ignored if undefined.
	* @param {int[]|int} [velocityOutValue] - The out interpolation ease value. Will be ignored if undefined.
	* @param {boolean} [velocityAsPercent=false] - Use a percent instead of a value to set velocities.<br />
	* In this case, the proper velocity value will be deduced by multiplying the max speed of the property by the percent.
*/
DuAEF.DuAE.Property.setEase = function(props,easeInValue,easeOutValue,velocityInValue,velocityOutValue,velocityAsPercent)
{
	if (isNaN(easeInValue) && typeof easeInValue !== 'undefined') easeInValue = 33;
	if (isNaN(easeOutValue) && typeof easeOutValue !== 'undefined') easeOutValue = 33;
	if (isNaN(velocityInValue) && typeof velocityInValue !== 'undefined') velocityInValue = 0;
	if (isNaN(velocityOutValue) && typeof velocityOutValue !== 'undefined') velocityOutValue = 0;

	for (var i = 0; i < props.length ; i++)
	{
		var propInfo = new PropertyInfo(props[i]);
		var prop = propInfo.getProperty();

		var comp = propInfo.comp;

		if (prop.canVaryOverTime)
		{
			
			var vInValue = velocityInValue;
			var vOutValue = velocityOutValue;

			for (var k=0 ; k < prop.selectedKeys.length ; k++)
			{
				var key = prop.selectedKeys[k];

				if (typeof easeInValue !== 'undefined')
				{
					if (typeof velocityInValue === 'undefined' && prop.keyInInterpolationType(key) == KeyframeInterpolationType.LINEAR)
					{
						vInValue = 0;
					}
				}

				if (typeof easeOutValue !== 'undefined')
				{
					if (typeof velocityOutValue === 'undefined' && prop.keyOutInterpolationType(key) == KeyframeInterpolationType.LINEAR)
					{
						vOutValue = 0;
					}
				}

				//compute the velocity
				if (velocityAsPercent)
				{
					//get speed just before and after as if it was linear
					var prevSpeed;
					var nextSpeed;
					var val = prop.keyValue(key);
					var currentTime = prop.keyTime(key);
					var valBefore = val;
					var valAfter = val;
					if (key > 1)
					{
						var valBefore = prop.keyValue(key-1);
						var timeBefore = prop.keyTime(key-1);
						prevSpeed = DuAEF.DuJS.Math.getLength(val, valBefore) / (currentTime-timeBefore);
					}

					if (key < prop.numKeys)
					{
						var valAfter = prop.keyValue(key+1);
						var timeAfter = prop.keyTime(key+1);
						nextSpeed = DuAEF.DuJS.Math.getLength(val, valBefore) / (timeAfter-currentTime);
					}

					if (typeof prevSpeed === 'undefined' && typeof nextSpeed === 'undefined')
					{
						prevSpeed = 0;
						nextSpeed = 0;
					}
					else if (typeof prevSpeed === 'undefined')
					{
						prevSpeed = nextSpeed;
					}
					else if (typeof nextSpeed === 'undefined')
					{
						nextSpeed = prevSpeed;
					}

					//detect sign
					var signBefore = 1;
					var signAfter = 1;
					if (propInfo.dimensions == 1)
					{
						if (val - valBefore < 1) signBefore = -1;
						if (valAfter - val < 1) signAfter = -1;
					}

					if (velocityInValue == velocityOutValue)
					{
						//select average speed
						var speed = (prevSpeed + nextSpeed) / 2;

						vInValue = velocityInValue * speed / 100 * signBefore;
						vOutValue = velocityOutValue * speed / 100 * signBefore;
					}
					else 
					{

						vInValue = velocityInValue * prevSpeed / 100 * signBefore;
						vOutValue = velocityOutValue * nextSpeed / 100 * signAfter;
					}

				}


				//set interpolation 
				var easeIn =  [ new KeyframeEase(
					def( vInValue, prop.keyInTemporalEase(key)[0].speed ) ,
					def( easeInValue, prop.keyInTemporalEase(key)[0].influence )
					) ];
				var easeOut = [ new KeyframeEase(
					def( vOutValue, prop.keyOutTemporalEase(key)[0].speed ) ,
					def( easeOutValue, prop.keyOutTemporalEase(key)[0].influence )
					) ];
				
				if (!prop.isSpatial)
				{
					for (var j = 1;j < prop.keyInTemporalEase(prop.selectedKeys[k]).length ; j++)
					{
						easeIn.push( new KeyframeEase(
							def( vInValue, prop.keyInTemporalEase(key)[j].speed ) ,
							def( easeInValue, prop.keyInTemporalEase(key)[j].influence )
							) );
						easeOut.push( new KeyframeEase(
							def( vOutValue, prop.keyOutTemporalEase(key)[j].speed ) ,
							def( easeOutValue, prop.keyOutTemporalEase(key)[j].influence )
							) );
					}
				}

				//adjust interpolation types
				var inType = KeyframeInterpolationType.BEZIER;
				var outType = KeyframeInterpolationType.BEZIER;

				if (typeof easeInValue === 'undefined' && typeof velocityInValue === 'undefined')
				{
					inType = prop.keyInInterpolationType(key);
				}
				if (typeof easeOutValue === 'undefined' && typeof velocityOutValue === 'undefined')
				{
					outType = prop.keyOutInterpolationType(key);
				}

				prop.setInterpolationTypeAtKey(key, inType, outType);

				prop.setTemporalEaseAtKey(key,easeIn,easeOut);
			}
		}
	}
}

/**
	* Checks if the property has some selected keyframes.<br />
	* The property can be either a Property or a PropertyGroup.
	* @param {PropertyBase} prop - The property
	* @return {boolean} true if the property have at least one selected keyframe
*/
DuAEF.DuAE.Property.hasSelectedKeys = function (prop)
{
	var yes = false;

	if (prop.propertyType == PropertyType.PROPERTY)
	{
		if (prop.selectedKeys.length >0)
		{
			yes = true;
		}
	}
	else if (prop.numProperties > 0)
	{
		for (var propIndex = 1;propIndex <= prop.numProperties;propIndex++)
		{
			yes = DuAEF.DuAE.Property.hasSelectedKeys(prop.property(propIndex));
			if (yes) break;
		}
	}
	return yes;
}

/**
	* Sets the spatial interpolation of the selected keyframes on the property
	* @param {Property|PropertyInfo} prop - The property
	* @param {KeyframeInterpolationType} typeIn - The in interpolation type (see AE API)
	* @param {KeyframeInterpolationType} [typeOut=typeIn] - The in interpolation type (see AE API)
*/
DuAEF.DuAE.Property.setSpatialInterpolation = function (prop,typeIn,typeOut)
{
	if (prop instanceof PropertyInfo) prop = prop.getProperty();
	if (typeOut == undefined) typeOut = typeIn;
	if (!prop.isSpatial) return;
		if (prop.selectedKeys.length == 0) return;
	for (var k=0;k<prop.selectedKeys.length;k++)
	{
		if (typeIn == KeyframeInterpolationType.BEZIER && typeOut == KeyframeInterpolationType.BEZIER)
		{
			prop.setSpatialAutoBezierAtKey(prop.selectedKeys[k],true);
		}
		else if (typeIn == KeyframeInterpolationType.LINEAR && typeOut == KeyframeInterpolationType.LINEAR)
		{
			prop.setSpatialContinuousAtKey(prop.selectedKeys[k],false);
			prop.setSpatialAutoBezierAtKey(prop.selectedKeys[k],false);
			if (prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL)
			{
				prop.setSpatialTangentsAtKey(prop.selectedKeys[k],[0,0,0],[0,0,0]);
			}
			else if (prop.propertyValueType == PropertyValueType.TwoD_SPATIAL)
			{
				prop.setSpatialTangentsAtKey(prop.selectedKeys[k],[0,0],[0,0]);
			}
		}
		else if (typeIn == KeyframeInterpolationType.BEZIER)
		{
			prop.setSpatialContinuousAtKey(prop.selectedKeys[k],false);
			prop.setSpatialAutoBezierAtKey(prop.selectedKeys[k],false);
			var keyIndex = prop.selectedKeys[k];
			if (prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL)
			{
				if (prop.keyInSpatialTangent(keyIndex)[0] == 0 && prop.keyInSpatialTangent(keyIndex)[1] == 0 && prop.keyInSpatialTangent(keyIndex)[2] == 0)
				{
					prop.setSpatialAutoBezierAtKey(prop.selectedKeys[k],true);
				}
				prop.setSpatialTangentsAtKey(keyIndex,prop.keyInSpatialTangent(keyIndex),[0,0,0]);
			}
			else if (prop.propertyValueType == PropertyValueType.TwoD_SPATIAL)
			{
				if (prop.keyInSpatialTangent(keyIndex)[0] == 0 && prop.keyInSpatialTangent(keyIndex)[1] == 0)
				{
					prop.setSpatialAutoBezierAtKey(prop.selectedKeys[k],true);
				}
				prop.setSpatialTangentsAtKey(keyIndex,prop.keyInSpatialTangent(keyIndex),[0,0]);
			}
		}
		else if (typeIn == KeyframeInterpolationType.LINEAR)
		{
			prop.setSpatialContinuousAtKey(prop.selectedKeys[k],false);
			prop.setSpatialAutoBezierAtKey(prop.selectedKeys[k],false);
			var keyIndex = prop.selectedKeys[k];
			if (prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL)
			{
				if (prop.keyOutSpatialTangent(keyIndex)[0] == 0 && prop.keyOutSpatialTangent(keyIndex)[1] == 0 && prop.keyOutSpatialTangent(keyIndex)[2] == 0)
				{
					prop.setSpatialAutoBezierAtKey(prop.selectedKeys[k],true);
				}
				prop.setSpatialTangentsAtKey(keyIndex,[0,0,0],prop.keyOutSpatialTangent(keyIndex));
			}
			else if (prop.propertyValueType == PropertyValueType.TwoD_SPATIAL)
			{
				if (prop.keyOutSpatialTangent(keyIndex)[0] == 0 && prop.keyOutSpatialTangent(keyIndex)[1] == 0)
				{
					prop.setSpatialAutoBezierAtKey(prop.selectedKeys[k],true);
				}
				prop.setSpatialTangentsAtKey(keyIndex,[0,0],prop.keyOutSpatialTangent(keyIndex));
			}
		}
	}
}

/**
	* Fixes the spatial interpolation of the selected keys.<br />
	* Sets the interpolation to linear when the property does not move between keyframes
	* @param {Property|PropertyInfo} prop - The property
*/
DuAEF.DuAE.Property.fixSpatialInterpolation = function(prop)
{
	if (prop instanceof PropertyInfo) prop = prop.getProperty();

	if (!prop.isSpatial) return;
	if (!prop.canVaryOverTime) return;

	var keyIndices = prop.selectedKeys;
	if (keyIndices.length < 2) return;

	for (var k=0;k<keyIndices.length-1;k++)
	{
		var key = keyIndices[k];
		var nextKey = keyIndices[k+1]
		//get this key value
		var keyValue = prop.valueAtTime(prop.keyTime(key),true);
		//get next key value
		var nextKeyValue = prop.valueAtTime(prop.keyTime(key+1),true);

		//compare and set
		if (prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL)
		{
			if (keyValue[0] == nextKeyValue[0] && keyValue[1] == nextKeyValue[1] && keyValue[2] == nextKeyValue[2])
			{
				prop.setSpatialTangentsAtKey(key,prop.keyInSpatialTangent(key),[0,0,0]);
				prop.setSpatialTangentsAtKey(nextKey,[0,0,0],prop.keyOutSpatialTangent(nextKey));
			}
		}
		else if (prop.propertyValueType == PropertyValueType.TwoD_SPATIAL)
		{
			if (keyValue[0] == nextKeyValue[0] && keyValue[1] == nextKeyValue[1])
			{
				prop.setSpatialTangentsAtKey(key,prop.keyInSpatialTangent(key),[0,0]);
				prop.setSpatialTangentsAtKey(nextKey,[0,0],prop.keyOutSpatialTangent(nextKey));
			}
		}
	}
}

/**
	* Removes all unneeded keyframes from the property.< br/>
	* Also checks the interpolation values to reset the correct display as linear/smooth.
	* @param {Property|PropertyInfo} property - The property
*/
DuAEF.DuAE.Property.cleanKeyframes = function(property)
{
	var prop = property;
	if (prop instanceof PropertyInfo) prop = property.getProperty();

	var numKeys = prop.numKeys;
	if (numKeys == 0) return;
	if (numKeys == 1)
	{
		prop.removeKey(1);
		return;
	}

	for (var i = numKeys ; i > 0 ; i--)
	{
		var currentKey = DuAEF.DuAE.Property.getKeyFrameAtIndex(prop,i);

		if (i > 1) var prevKey = DuAEF.DuAE.Property.getKeyFrameAtIndex(prop,i-1);
		if (i < prop.numKeys) var nextKey = DuAEF.DuAE.Property.getKeyFrameAtIndex(prop,i+1);

		//check values
		if (i > 1 && !DuAEF.DuJS.Array.compare(currentKey.value,prevKey.value,3)) continue;
		if (i < prop.numKeys && !DuAEF.DuJS.Array.compare(currentKey.value,nextKey.value,3)) continue;
		//check velocities
		var remove = false;
		for (var j = 0 ; j < currentKey.inEase.length ; j++)
		{
			remove = false
			if (i > 1 && !DuAEF.DuJS.Math.compare(prevKey.outEase[j].speed,0,4)) break;
			if (i > 1 && !DuAEF.DuJS.Math.compare(currentKey.inEase[j].speed,0,4)) break;
			if (i < prop.numKeys && !DuAEF.DuJS.Math.compare(currentKey.outEase[j].speed,0,4)) break;
			if (i < prop.numKeys && !DuAEF.DuJS.Math.compare(nextKey.inEase[j].speed,0,4)) break;
			remove = true;
		}
		//remove key
		if (remove) prop.removeKey(i);
	}
}

/**
	* Gets the average speed of the animated propreties
	* @param {Property[]|PropertyInfo[]} props - The Properties
	* @param {bool}	 [preExpression=true]	- True to get the velocity from keyframes instead of the result of the exression
	* @return {float} The average speed in unit per second
*/
DuAEF.DuAE.Property.getAverageSpeed = function(props, preExpression)
{
	if (typeof preExpression === 'undefined') preExpression = true;

	var averageSpeed = 0;
	var count = 0;

	for (var i = 0 ; i < props.length ; i++)
	{
		var prop = props[i];
		if (prop instanceof PropertyInfo) prop = prop.getProperty();
		if (prop.propertyType != PropertyType.PROPERTY) continue;
		if (!prop.canVaryOverTime) continue;
		if (prop.numKeys < 1) continue;

		var comp = DuAEF.DuAE.Property.getComp(prop);
		var frames = comp.duration / comp.frameDuration ;
		var lastTime = comp.duration;
		var firstTime = 0;
		if (preExpression)
		{
			lastTime = prop.keyTime(prop.numKeys);
			firstTime = prop.keyTime(1);
		}
		var lastFrame = lastTime/comp.frameDuration ;
		var firstFrame = firstTime/comp.frameDuration ;
		if (lastFrame > frames) lastFrames = frames;
		if (firstFrame < 1) firstFrame = 1;
		var sum = 0;
		for (var frame = firstFrame ; frame < lastFrame ; frame++)
		{
			var time = frame*comp.frameDuration;
			sum += DuAEF.DuAE.Property.getSpeed(prop,time, preExpression);
		}
		var speed = sum/(lastFrame-firstFrame);

		if (speed > 0)
		{
			averageSpeed += speed;
			count++;
		}
	}

	averageSpeed = averageSpeed/count;
	return averageSpeed;
}

/**
	* Gets the maximum speed of the animated propreties
	* @param {Property[]|PropertyInfo[]} props - The Properties
	* @param {bool}	 [preExpression=true]	- True to get the velocity from keyframes instead of the result of the exression
	* @return {float} The average speed
*/
DuAEF.DuAE.Property.getMaximumSpeed = function(props)
{
	var maxSpeed = 0;

	for (var i = 0 ; i < props.length ; i++)
	{
		var speed = DuAEF.DuAE.Property.getMaxVelocity(props[i],false);
		if (speed > maxSpeed) maxSpeed = speed;
	}

	return maxSpeed;
}

/**
	* Gets the speed of a property at a given time
	* @param {Property|PropertyInfo} prop - The property
	* @param {float} [time=composition.time] - The time.
	* @return {float} The speed
*/
DuAEF.DuAE.Property.getSpeed = function (prop,time, preExpression)
{
	if (prop instanceof PropertyInfo) prop = prop.getProperty();
	if (prop.propertyType != PropertyType.PROPERTY) return 0;
	if (prop.numKeys == 0) return 0;
	var comp = DuAEF.DuAE.Property.getComp(prop);
	if (time == undefined) time = comp.time;

	var speed = DuAEF.DuJS.Math.getLength(prop.valueAtTime(time+comp.frameDuration/2,preExpression),prop.valueAtTime(time-comp.frameDuration/2,preExpression));
	return speed/comp.frameDuration;
}

/**
	* Sets an expression to a property.<br />
	* With the ability to keep the initial value.
	* @param {Property|PropertyInfo} property - The property
	* @param {string} expr - The expression
	* @param {bool} [keepValue=true] - When true, the method will try to keep the same resulting value as before applying the expression.
*/
DuAEF.DuAE.Property.setExpression = function (property, expr, keepValue)
{
	keepValue = def(keepValue, true);

	var propInfo = new PropertyInfo(property);
	if (!propInfo.riggable) return;

	property = propInfo.getProperty();

	var originalValue = property.valueAtTime(propInfo.comp.time, false);

	//remove current expression
	if (keepValue) DuAEF.DuAE.Property.removeExpression(property);
	else try { property.expression = "" } catch (e) { if (DuAEF.debug) alert(e.description); return; }
	//set new expression
	try { property.expression = expr; } catch (e) { if (DuAEF.debug) alert(e.description); }

	//restore value
	if (propInfo.editable && keepValue && propInfo.dimensions > 0) DuAEF.DuAE.Property.setValue(property, 2*originalValue - property.valueAtTime(propInfo.comp.time, false));
}

/**
	* Replaces text in Expressions
	* @param {PropertyBase|PropertyInfo} prop - The property (can be a group)
	* @param {string} oldString - The string to replace
	* @param {string} newString - The new string
	* @param {boolean} [caseSensitive=true] - Wether the search has to be case sensitive
*/
DuAEF.DuAE.Property.replaceInExpressions = function (prop,oldString,newString,caseSensitive)
{
	if (caseSensitive == undefined) caseSensitive = true;

	if (prop.propertyType == PropertyType.PROPERTY)
	{
		if (prop.canSetExpression)
		{
			if (prop.expression  = '') return;
			if (prop.expression.length < oldString.length) return;
			try {prop.expression = DuAEF.DuJS.String.replace(prop.expression,oldString,newString,caseSensitive);}
			catch(e){};
		}
	}
	else if (prop.numProperties > 0)
	{
		for (var propertyIndex = 1;propertyIndex <= prop.numProperties;propertyIndex++)
		{
			DuAEF.DuAE.Property.replaceInExpressions(prop.property(propertyIndex),oldString,newString,caseSensitive);
		}
	}
}

/**
 * Adds an expression to the child property, linking it to the parent property
 * @memberof DuAEF.DuAE.Property
 * @param {Property} childProp - The child property (the one which gets an expression).
 * @param {Property} parentProp - The parent property.
 * @param {bool} useThisComp - Wether to begin the expression by 'thisComp' or 'comp("name")', default: will detect if the properties are in the same comp
*/
DuAEF.DuAE.Property.pickWhip = function (childProp,parentProp,useThisComp)
{
	if (!childProp.canSetExpression) return;
	if (typeof useThisComp === 'undefined')
	{
		var parentComp = DuAEF.DuAE.Property.getComp(parentProp);
		var childComp = DuAEF.DuAE.Property.getComp(childProp);
		if (parentComp.id == childComp.id) useThisComp = true;
		else useThisComp = false;
	}
	var exp = DuAEF.DuAE.Property.getExpressionLink( parentProp, useThisComp );
	DuAEF.DuAE.Property.setExpression( childProp, exp, false );
}

/**
 * Link all the properties found in childProp to all the same properties of parentProp (this is a recursive method)<br />
 * Note: any Property or PropertyGroup (and its subproperties) named "Data" will be ignored.
 * @memberof DuAEF.DuAE.Property
 * @param {PropertyBase} childProp - The child property
 * @param {PropertyBase} parentProp - The parent property
 * @param {bool} [useThisComp] - Wether to begin the expression by 'thisComp' or 'comp("name")', default: will detect if the properties are in the same comp
 * @param {LayerItem} [timeLayer=null] - A layer used to offset the time (typically, in case of link between precompositions, the precomposition layer).<br />
 * When not null, the start time of this layer will be taken into account to get the values and synchronize them.
 */
DuAEF.DuAE.Property.linkProperties = function (childProp,parentProp,useThisComp,timeLayer)
{	
	if (parentProp.name.toLowerCase() == 'data') return;
	if (childProp.propertyType == PropertyType.PROPERTY && !childProp.elided && childProp.propertyValueType != PropertyValueType.NO_VALUE)
	{
		if (typeof timeLayer === 'undefined') timeLayer = null;
		
		if (typeof useThisComp === 'undefined')
		{
			var parentComp = DuAEF.DuAE.Property.getComp(parentProp);
			var childComp = DuAEF.DuAE.Property.getComp(childProp);

			useThisComp = parentComp.id == childComp.id;
		}

		//copy paste the animation / value
		var anim = DuAEF.DuAE.Property.getAnim(parentProp,false);
		if (anim != null) DuAEF.DuAE.Property.setAnim(childProp,anim,0,true,true, false);

		//set the link
		var exp = DuAEF.Duik.expressionIds.LINK + '\n';
		if (timeLayer != null)
		{
			exp += 'var timeLayer = ' + DuAEF.DuAE.Property.getExpressionLink( timeLayer ) + ';\n' +
				'var st = timeLayer.startTime;\n' +
				'var t = time + st;\n' +
				DuAEF.DuAE.Property.getExpressionLink( parentProp, useThisComp ) + '.valueAtTime(t);';

		}
		else
		{
			exp += DuAEF.DuAE.Property.getExpressionLink( parentProp, useThisComp ) + ';';
		}

		DuAEF.DuAE.Property.setExpression( childProp, exp, false );
	}
	else
	{
		if (parentProp.isEffect)
		{
			var insideData = 0;
			for (var p = 1, num = childProp.numProperties; p <= num ; p++)
			{
				var subProp = parentProp(p);
				if (subProp.propertyValueType == PropertyValueType.NO_VALUE)
				{
					if (subProp.name.toLowerCase() == 'data')
					{
						insideData++;
						continue;
					}

					if (insideData > 0)
					{
						if (subProp.name == parentProp.name || subProp.name == "") insideData--;
						else insideData++;
						continue;
					}
				}
				if (insideData == 0) DuAEF.DuAE.Property.linkProperties(childProp(p),subProp,useThisComp,timeLayer);
			}
		}
		else
		{
			for (var p = 1, num = childProp.numProperties ; p <= num ; p++)
			{
				DuAEF.DuAE.Property.linkProperties(childProp(p),parentProp(p),useThisComp,timeLayer);
			}
		}
	}
}

/**
 * Removes all expressions found in groups or sections named "Data" in the property.
 * @memberof DuAEF.DuAE.Property
 * @param {PropertyBase} prop - The property
*/
DuAEF.DuAE.Property.removeDataExpressions = function (prop)
{
	if (prop.propertyType == PropertyType.PROPERTY && prop.name.toLowerCase() == 'data')
	{
		DuAEF.DuAE.Property.removeExpression(prop);
	}
	else if (prop.isEffect)
	{
		var insideData  = 0;
		for (var p = 1, num = prop.numProperties ; p <= num ; p++)
		{
			var subProp = prop(p);
			if (subProp.propertyValueType == PropertyValueType.NO_VALUE)
			{
				if (subProp.name.toLowerCase() == 'data')
				{
					insideData++;
					continue;
				}

				if (insideData > 0)
				{
					if (subProp.name == "" || subProp.name == prop.name) insideData--;
					else insideData++;
					continue;
				}
			}
			if (insideData > 0) DuAEF.DuAE.Property.removeExpression(subProp);
		}
	}
	else 
	{
		if (prop.name.toLowerCase() == 'data') DuAEF.DuAE.Property.removeExpressions(prop);
		for (var p = 1, num = prop.numProperties ; p <= num ; p++)
		{
			DuAEF.DuAE.Property.removeDataExpressions(prop(p));
		}
	}
}

/**
 * Removes all expressions found in the property.
 * @memberof DuAEF.DuAE.Property
 * @param {PropertyBase} prop - The property
*/
DuAEF.DuAE.Property.removeExpressions = function (prop)
{
	if (prop.propertyType == PropertyType.PROPERTY)
	{
		DuAEF.DuAE.Property.removeExpression(prop);
	}
	else 
	{
		for (var p = 1, num = prop.numProperties ; p <= num ; p++)
		{
			DuAEF.DuAE.Property.removeExpressions(prop(p));
		}
	}
}

/**
 * Adds all the (supported) properties found in a property to the essential graphics panel<br />
 * Note: any Property or PropertyGroup (and its subproperties) named "Data" will be ignored.
 * @memberof DuAEF.DuAE.Property
 * @param {PropertyBase}	prop			- The property
 * @return {int} The number of properties added
*/
DuAEF.DuAE.Property.addToEGP = function(prop)
{
	var numProps = 0;
	if (prop.name.toLowerCase() == 'data') return numProps;
	if (prop.propertyType == PropertyType.PROPERTY && prop.propertyValueType != PropertyValueType.NO_VALUE)
	{
		var comp = DuAEF.DuAE.Property.getComp(prop);
		var layer = DuAEF.DuAE.Property.getLayer(prop);
		//set the link
		if (prop.canAddToMotionGraphicsTemplate(comp) && !prop.elided && prop.canSetExpression)
		{
			prop.addToMotionGraphicsTemplate(comp);
			//rename the master property if >=15.1
			if (DuAEF.DuAE.App.version >= 15.1)
			{
				var it = new Iterator(comp.usedIn);
				it.do(function (mainComp)
				{
					//search the layer of the precomp
					for (var i = 1, num = mainComp.numLayers; i <= num; i++)
					{
						var l = mainComp.layer(i);
						if (l.source) if (l.source.id == comp.id)
						{
							 l('ADBE Layer Overrides')(1).name = layer.name + ' / ' + DuAEF.DuAE.Property.getExpressionLink(prop,true,false);
						}
					}
				});
			}
			numProps++;
		}
	}
	else
	{
		if (prop.isEffect)
		{
			var insideData = 0;
			for (var p = 1, num =  prop.numProperties; p <= num ; p++)
			{
				var subProp = prop(p);
				if (subProp.propertyValueType == PropertyValueType.NO_VALUE)
				{
					if (subProp.name.toLowerCase() == 'data')
					{
						insideData++;
						continue;
					}

					if (insideData > 0)
					{
						if (subProp.name == prop.name) insideData--;
						else insideData++;
						continue;
					}
				}
				if (insideData == 0) numProps += DuAEF.DuAE.Property.addToEGP(subProp);
			}
		}
		else
		{
			for (var p = 1 ; p <= prop.numProperties ; p++)
			{
				numProps += DuAEF.DuAE.Property.addToEGP(prop(p));
			}
		}
	}
	return numProps;
}

/**
 * Locks the property with an expression so its value cannot be changed
 * @memberof DuAEF.DuAE.Property
 * @param {PropertyBase|PropertyInfo|PropertyBase[]|PropertyInfo[]} properties - The property or properties
*/
DuAEF.DuAE.Property.lock = function(properties)
{
	var it = new Iterator(properties);
	it.do(function (property)
	{
		var p = property;
		var riggable = false;
		var dimensions = 0;
		if (property instanceof PropertyInfo)
		{
			p = property.getProperty();
			riggable = property.riggable;
			dimensions = property.dimensions;
		}
		else
		{
			riggable = DuAEF.DuAE.Property.isRiggable(p);
			dimensions = DuAEF.DuAE.Property.getDimensions(p);
		}

		if (riggable)
		{
			var exp = "";
			if (dimensions == 0) exp = "value";
			else if (dimensions == 1) exp = p.value.toString();
			else exp = p.value.toSource();
			DuAEF.DuAE.Property.setExpression(property,exp);
		}
	});
}

/**
 * Removes the expression from the property, keeping the post-expression value.
 * @memberof DuAEF.DuAE.Property
 * @param {Property|PropertyInfo} prop - The property
*/
DuAEF.DuAE.Property.removeExpression = function(prop)
{
	if (typeof(prop) === 'undefined') return;

	var propInfo = new PropertyInfo(prop);
	prop = propInfo.getProperty();
	
	if (prop.expression == '') return;
	if (propInfo.riggable)
	{
		DuAEF.DuAE.Property.setValue(prop, prop.value);
		prop.expression = '';
	}
}

/**
 * Checks if the property has an animation (keyframes)
 * @param {Property} prop - The property
 * @return {boolean} True if the property is animated
 */
DuAEF.DuAE.Property.isAnimated = function(prop)
{
	if (prop.canVaryOverTime)
	{
		if (prop.numKeys > 0) return true;
	}
	return false;
}

/**
	* Gets the After Effects animated (with keyframes) properties in the propertyGroup
	* @param {PropertyGroup}	 prop	- The parent propertyGroup where to search for animations
	* @param {PropertyType|PropertyValueType|string|function}	 [filter]	- A filter to get only a certain type, or value type, or property name or matchName.<br />
	* A function which take one PropertyBase as argument can be used to filter the properties: the Property will be returned if the function returns true.
	* @param {boolean}	[strict=false]	- If a string filter is provided, wether to search for the exact name/matchName or if it contains the filter.
	* @param {boolean}	[caseSensitive=true]	- If a string filter is provided, and not strict is false, does the search have to be case sensitive?
	* @return {PropertyInfo[]} The selected properties, an empty Array if nothing active or selected
*/
DuAEF.DuAE.Property.getAnimatedProps = function(prop, filter, strict, caseSensitive)
{
	if (strict == undefined) strict = false;
	if (caseSensitive == undefined) caseSensitive = true;

	var props = [];

	if (!caseSensitive && typeof filter === "string") filter = filter.toLowerCase();

	if (prop.propertyType == PropertyType.PROPERTY)
	{
		if (DuAEF.DuAE.Property.isAnimated(prop))
		{
			if (typeof filter === 'undefined')
			{
				props.push(prop);
			}
			else
			{
				var name = prop.name;
				var matchName = prop.matchName;
				if (!caseSensitive)
				{
					name = name.toLowerCase();
					matchName = matchName.toLowerCase();
				}

				if (strict && name === filter) props.push(prop);
				else if (strict && matchName === filter) props.push(prop);
				else if (typeof filter === 'string')
				{
					if (name.indexOf(filter) >= 0) props.push(prop);
					else if (matchName.indexOf(filter) >= 0) props.push(prop);
				}
				else if (prop.propertyValueType == filter) props.push(prop);
				else if (typeof filter === 'function')
				{
					if (filter(prop)) props.push(prop);
				}
			}
		}
	}
	else
	{
		for (var i = 0, num = prop.numProperties ; i < num ; i++)
		{
			props = props.concat(DuAEF.DuAE.Property.getAnimatedProps(prop.property(i+1), filter, strict, caseSensitive));
		}
	}


	return DuAEF.DuAE.getPropertyInfos(props);
}

/**
	* Checks if the property value is a number or an Array of Number.<br >
	* I.e if its value type is one of: one D, two D, three D (spatial or not), Color.
	* @param {Property}	 prop	- The property
	* @return {bool}
*/
DuAEF.DuAE.Property.isNumerical = function (prop)
{
	if (prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL) return true;
	if (prop.propertyValueType == PropertyValueType.ThreeD) return true;
	if (prop.propertyValueType == PropertyValueType.TwoD_SPATIAL) return true;
	if (prop.propertyValueType == PropertyValueType.TwoD) return true;
	if (prop.propertyValueType == PropertyValueType.OneD) return true;
	if (prop.propertyValueType == PropertyValueType.COLOR) return true;
	return false;
}

/**
	* Gets the value range of the animated property.<br >
	* The property type must be one of: one D, two D, three D (spatial or not), Color.
	* If the property is not one of these types, returns an empty Array.
	* @param {Property|PropertyInfo}	 prop	- The property
	* @param {int}	 [axis=0]	- The axis (or the color channel) to get the range
	* @param {bool}	 [preExpression=true]	- True to get the range from keyframes instead of the result of the exression
	* @return {float[]} The minimum and maximum value.<br />
	* The first item in the Array is not necesarily the lowest value, it is the first in time.
*/
DuAEF.DuAE.Property.getRange = function(prop,axis,preExpression)
{
	if (typeof axis === 'undefined') axis = 0;
	if (typeof preExpression === 'undefined') preExpression = true;

	var propInfo = new PropertyInfo(prop);
	prop = propInfo.getProperty();

	if (!propInfo.numerical) return [];

	if (prop.expression == '' || !prop.expressionEnabled) preExpression = true;

	var comp = propInfo.comp;
	var frames = comp.duration/comp.frameDuration;
	var min = prop.valueAtTime(0,preExpression);
	var minTime = 0;
	var max = prop.valueAtTime(0,preExpression);
	var maxTime = 0;

	if (propInfo.dimensions > 1)
	{
		max = max[axis];
		min = min[axis];
	}

	for (var i = 1; i < frames; i++)
	{
		var val = prop.valueAtTime(i*comp.frameDuration,preExpression);
		if (propInfo.dimensions > 1) val = val[axis];
		if (val < min)
		{
			min = val;
			minTime = i;
		}
		if (val > max)
		{
			max = val;
			maxTime = i;
		}
	}

	if (minTime < maxTime) return [min,max];
	else return [max,min];
}

/**
	* Gets the maximum velocity of the animated property.<br >
	* The property type must be one of: one D, two D, three D (spatial or not), Color.
	* If the property is not one of these types, returns 0.
	* @param {Property|PropertyInfo}	 prop	- The property
	* @param {bool}	 [preExpression=true]	- True to get the velocity from keyframes instead of the result of the exression
	* @return {float} The velocity.
*/
DuAEF.DuAE.Property.getMaxVelocity = function(prop,preExpression)
{
	if (typeof preExpression === 'undefined') preExpression = true;

	var propInfo = prop;
	if (!(prop instanceof PropertyInfo))
	{
		propInfo = new PropertyInfo(prop);
	}
	else
	{
		prop = propInfo.getProperty();
	}

	var velocity = 0;
	if (!propInfo.numerical) return velocity;

	if (prop.expression == '') preExpression = true;

	var comp = propInfo.comp;
	var frames = comp.duration/comp.frameDuration;

	var prevVal = prop.valueAtTime(0,preExpression);

	for (var i = 1; i < frames; i++)
	{
		var val = prop.valueAtTime(i*comp.frameDuration, preExpression);
		var vel = DuAEF.DuJS.Math.getLength(val,prevVal);
		if (vel > velocity) velocity = vel;
		prevVal = val;
	}

	return velocity/comp.frameDuration;

}

/**
* Converts the expression as a string which can be copy/pasted and included in a script.
* @param {Property|PropertyInfo} prop - The property containing the expression.
* @return {string} The stringified expression.
*/
DuAEF.DuAE.Property.scriptifyExpression = function(prop)
{
	if (prop instanceof PropertyInfo) prop = prop.getProperty();
	var exp = prop.expression;
	var expArray = exp.split('\n');
	var expString = "var expression = ['" + expArray[0].replace("\r","") + "'";
	for (var i = 1 ; i < expArray.length ; i++)
	{
		expString += ",\n\t'" + expArray[i].replace('\r','') + "'";
	}
	expString += "\n\t].join('\\n');";

	return expString;
}

/**
	* Puppet tool methods
	* @namespace
	* @memberof DuAEF.DuAE.Property
*/
DuAEF.DuAE.Property.PuppetTool = {};

/**
 * Checks if a pin can be rigged or not.\nFor now, the only pins which can not be rigged are starch pins.
 * @param {PropertyGroup} pin - The pin to test
 * @return {boolean} True if this pin has either a position, rotation or scale property
*/
DuAEF.DuAE.Property.PuppetTool.isRiggable = function (pin)
{
	if (pin.position.canSetExpression) return true;
	if (pin.rotation.canSetExpression) return true;
	if (pin.scale.canSetExpression) return true;
	return false;
}

/**
	* Bezier Path methods
	* @namespace
	* @memberof DuAEF.DuAE.Property
*/
DuAEF.DuAE.Property.Bezier = {};

/**
	* Scriptifies the given shape property.<br/>
	* @param {Property}	 [shapeProp]	- The path property to export
	* @param {boolean}	[offsetToCenter=false]	- If true, offset the path to the center
	* @param {string}	[varName=shape]	- A name for the variable storing the shape
	* @return {string} The scriptified shape
*/
DuAEF.DuAE.Property.Bezier.scriptify = function(pathProperty, offsetToCenter, varName)
{
	if (pathProperty instanceof PropertyInfo) pathProperty = pathProperty.getProperty();
	offsetToCenter = def(offsetToCenter, false);
	varName = def(varName, 'shape');

	if (pathProperty.propertyType !== PropertyType.PROPERTY) throw "Expected a shape property, got a group.";
	if (pathProperty.propertyValueType !== PropertyValueType.SHAPE) throw "Expected a shape property, got another type of value.";
	offsetToCenter = def(offsetToCenter, false);

	var shape = pathProperty.value;
	var vertices = shape.vertices;

	if (offsetToCenter)
	{
		//get center and offset
		var sum = [0,0];
		for (var i = 0 ; i < vertices.length ; i++)
		{
			sum[0] += vertices[i][0];
			sum[1] += vertices[i][1];
		}
		var center = sum/vertices.length;
		//adjust values
		for (var i = 0 ; i < vertices.length ; i++)
		{
			vertices[i][0] -= center[0];
			vertices[i][1] -= center[1];
		}
	}

	var verticesStr = vertices.toSource();
	var inTangentsStr = shape.inTangents.toSource();
	var outTangentsStr = shape.outTangents.toSource();
	var closedStr = shape.closed ? 'true' : 'false';

	var scriptified = [
		'var ' + varName + ' = new Shape();',
		varName + '.vertices = ' + verticesStr + ';',
		varName + '.inTangents = ' + inTangentsStr + ';',
		varName + '.outTangents = ' + outTangentsStr + ';',
		varName + '.closed = ' + closedStr + ';'
		].join('\n');

	return scriptified;
}

/**
	* Export the given shape property to the given file <br/>
	* The file name in the given path will be used to name the shape in the jsx code
	* @example
	* var props = DuAEF.DuAE.Comp.getSelectedProps(PropertyValueType.SHAPE);
	* var prop = props[0].getProperty();
	* var out = DuAEF.DuAE.Property.Shape.exportToJsxinc(prop, "D:/shape.test");
	* @param {Property}	 [shapeProp]	- The path property to export
	* @param {String}	[file]	- The path or File where the jsxinc shape will be written
	* @param {boolean}	[offsetToCenter=false]	- If true, offset the path to the center
	* @param {boolean}	[append=false]	- If true, appends the shape at the end of the file instead of overwriting it.
	* @param {string}	[varName=shape]	- A name for the variable storing the shape
	* @return {int} A status code. [0: success, ...]
*/
DuAEF.DuAE.Property.Bezier.exportToJsxinc = function(pathProperty, file, offsetToCenter, append, varName)
{
	append = def(append, false);

	if (!(file instanceof File)) file = new File(file);

	var mode = 'w';
	if (append) mode = 'a';

	if(!file.open(mode)) return 3;

	if (append) file.write('\n');
	file.write( DuAEF.DuAE.Property.Bezier.scriptify( pathProperty, offsetToCenter, varName) );

	file.close();
	return 0;
}

/**
	* Makes a horizontal symetry transformation on the paths, using the same axis of symetry for all shapes (shapes must be on the same layer).
	* @param {Property[]}	pathProperties	- The After Effects Properties containing the paths to symetrize
*/
DuAEF.DuAE.Property.Bezier.horizontalSymetry = function(pathProperties)
{
	if (!(pathProperties instanceof Array)) pathProperties = [pathProperties];

	var shapes = [];
	//get shapes and center
	var center = 0;
	var verticesCount = 0;
	for (var i = 0 ; i < pathProperties.length ; i++)
	{
		var prop = pathProperties[i];
		if (prop instanceof PropertyInfo) prop = prop.getProperty();
		var shape = prop.value;
		shapes.push(shape);
		for (var j = 0 ; j < shape.vertices.length; j++)
		{
			verticesCount++;
			center += shape.vertices[j][0];
		}
	}
	center = center / verticesCount;
	center = center *2;

	//compute
	for (var i = 0 ; i < shapes.length; i++)
	{
		var prop = pathProperties[i];
		if (prop instanceof PropertyInfo) prop = prop.getProperty();
		var shape = shapes[i];
		var vertices = shape.vertices;
		var inTangents = shape.inTangents;
		var outTangents = shape.outTangents;
		for (var j = 0 ; j < shape.vertices.length ; j++)
		{
			vertices[j][0] = center - vertices[j][0];
			inTangents[j][0] = -inTangents[j][0];
			outTangents[j][0] = -outTangents[j][0];
		}
		shape.vertices = vertices;
		shape.inTangents = inTangents;
		shape.outTangents = outTangents;
		if (prop.numKeys > 0)
		{
			prop.setValueAtTime(DuAEF.DuAE.Property.getComp(prop).time,shape);
		}
		else
		{
			prop.setValue(shape);
		}
	}
}

/**
	* Makes a vertical symetry transformation on the paths, using the same axis of symetry for all shapes (shapes must be on the same layer).
	* @param {Property[]}	pathProperties	- The After Effects Properties containing the paths to symetrize
*/
DuAEF.DuAE.Property.Bezier.verticalSymetry = function(pathProperties)
{
	if (!(pathProperties instanceof Array)) pathProperties = [pathProperties];

	var shapes = [];
	//get shapes and center
	var center = 0;
	var verticesCount = 0;
	for (var i = 0 ; i < pathProperties.length ; i++)
	{
		var prop = pathProperties[i];
		if (prop instanceof PropertyInfo) prop = prop.getProperty();
		var shape = prop.value;
		shapes.push(shape);
		for (var j = 0 ; j < shape.vertices.length; j++)
		{
			verticesCount++;
			center += shape.vertices[j][1];
		}
	}
	center = center / verticesCount;
	center = center *2;

	//compute
	for (var i = 0 ; i < shapes.length; i++)
	{
		var prop = pathProperties[i];
		if (prop instanceof PropertyInfo) prop = prop.getProperty();
		var shape = shapes[i];
		var vertices = shape.vertices;
		var inTangents = shape.inTangents;
		var outTangents = shape.outTangents;
		for (var j = 0 ; j < shape.vertices.length ; j++)
		{
			vertices[j][1] = center - vertices[j][1];
			inTangents[j][1] = -inTangents[j][1];
			outTangents[j][1] = -outTangents[j][1];
		}
		shape.vertices = vertices;
		shape.inTangents = inTangents;
		shape.outTangents = outTangents;
		if (prop.numKeys > 0)
		{
			prop.setValueAtTime(DuAEF.DuAE.Property.getComp(prop).time,shape);
		}
		else
		{
			prop.setValue(shape);
		}
	}
}

/**
 * Gets the vertices array in comp coordinates.
 * @param {Property|PropertyInfo} prop - The property, a bezier path.
 * @return {float[][]} The vertices in comp coordinates.
 */
DuAEF.DuAE.Property.Bezier.verticesToComp = function(pathProperty)
{
	var propInfo = DuAEF.DuAE.Property.Bezier.checkProperty(pathProperty);
	if (!propInfo) throw "Expected a shape property, got another type of value.";
	var pathProperty = propInfo.getProperty();

	//get the layer matrix
	var matrix = DuAEF.DuAE.Shape.getTransformMatrix(propInfo);

	//apply transform
	var vertices = [];
	var origin  = pathProperty.value.vertices;
	for (var i = 0, num = origin.length; i < num; i++)
	{
		vertices.push(matrix.applyToPoint(origin[i]));
	}

	return vertices;
}

/**
	* Checks if the property is a bezier property, or return the child bezier property if this is a shape or a mask
	* @param {Property|PropertyInfo} prop - The property
	* @return {PropertyInfo|null} the bezier property or null if it is not.
*/
DuAEF.DuAE.Property.Bezier.checkProperty = function(prop)
{
	propInfo = new PropertyInfo(prop);
	prop = propInfo.getProperty();

	//get the path property in case it was a mask or a shape path selected
	if (prop.matchName == "ADBE Vector Shape - Group")
	{
		prop = prop.property("ADBE Vector Shape");
		return new PropertyInfo(prop);
	}
	else if (prop.matchName == "ADBE Mask Atom")
	{
		prop = prop.property("ADBE Mask Shape");
		return new PropertyInfo(prop);
	}
	else if (prop.propertyType !== PropertyType.PROPERTY) return null;
	if (prop.propertyValueType !== PropertyValueType.SHAPE) return null;

	return propInfo;
}

/**
	* Shape Layers methods
	* @namespace
	* @memberof DuAEF.DuAE
*/
DuAEF.DuAE.Shape = {};

/**
	* Gets the transformation matrix for all the parent groups of a given property
	* @param {Property|PropertyInfo} prop - The property
	* @return {Matrix} The transformation matrix.
*/
DuAEF.DuAE.Shape.getTransformMatrix = function(prop)
{
	var propInfo = new PropertyInfo(prop);
	prop = propInfo.getProperty();
	var matrix = DuAEF.DuAE.Layer.getTransformMatrix(propInfo.layer);

	var props = [];

	//get the groups
	var parentProp = prop;
	while (parentProp.parentProperty)
	{
		if (parentProp.matchName == "ADBE Vector Group")
		{
			props.push(parentProp);
		}
		// Traverse up the property tree
		parentProp = parentProp.parentProperty;
	}

	//apply transforms from the ancestor
	for (var i = props.length - 1; i >= 0; i--)
	{
		var p = props[i].property("ADBE Vector Transform Group");
		matrix.translate(-p.property("ADBE Vector Anchor").value);
		matrix.translate(p.property("ADBE Vector Position").value);
		matrix.rotate(p.property("ADBE Vector Rotation").value);
		matrix.scale(p.property("ADBE Vector Scale").value/100);
	}

	return matrix;
}

/**
	* Checks if this shape layers contains only one shape, one fill, and one stroke,\n
	* just like After Effects creates them at first.
	* @param {Layer} layer - The layer to test
	* @return {bool} True if the layer is a shape layer containing only one shape, one fill, and one stroke in a group. False otherwise.
*/
DuAEF.DuAE.Shape.isSingleShape = function(layer)
{
	if (!(layer instanceof ShapeLayer)) return false;

	var content = layer.property("ADBE Root Vectors Group");
	if (content.numProperties != 1) return false;

	var shape = content.property("ADBE Vector Group").property("ADBE Vectors Group");
	if (shape.numProperties != 3) return false;

	var path = shape.property(1);
	if (path.matchName != "ADBE Vector Shape - Group" && path.matchName != "ADBE Vector Shape - Rect"  && path.matchName != "ADBE Vector Shape - Ellipse"  && path.matchName != "ADBE Vector Shape - Star" ) return false;
	var stroke = shape.property(2);
	if (stroke.matchName != "ADBE Vector Graphic - Stroke") return false;
	var fill = shape.property(3);
	if (fill.matchName != "ADBE Vector Graphic - Fill") return false;

	return true;
}
