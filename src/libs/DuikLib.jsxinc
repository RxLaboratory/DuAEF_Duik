/*
DuikLib
Library with Duik tools.
Copyright (c) 2017 Nicolas Dufresne, Rainbox Productions
https://rainboxprod.coop

__Contributors:__

	Nicolas Dufresne - Lead developer
	Kevin Masson - Developer

__Thanks to:__

	Dan Ebberts - Writing the first IK Expressions
	Eric Epstein - making the IK's work with 3D Layers
	Kevin Schires – Including images in the script
	Matias Poggini – Bezier IK feature
	Eric Epstein - Making the IK's work with 3D Layers
	Assia Chioukh and Quentin Saint-Georges – User Guides composition
	Motion Cafe – Ideas and feedback
	Fous d’anim – Ideas and feedback
	All 258 Duik 15 indiegogo backers for making this libDuik possible!


This file is part of DuAEF.

DuAEF is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

DuAEF is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with DuAEF. If not, see <http://www.gnu.org/licenses/>.
*/

/**
* An onion skin
* @typedef {Object} OnionSkin
* @property {boolean} activated - Is it activated
* @property {int} duration - Duration in frames
* @property {int} exposure - Animation exposure
* @property {int} outOpacity - out opacity
* @property {int} inOpacity - in opacity
*/

/**
* Constructs a Bone
* @class Bone
* @classdesc A Bone.
* @param {ShapeLayer} layer - The layer of the bone
* @property {ShapeLayer} layer - The Shape layer of the bone
* @property {PropertyGroup} effect - The effect on the bone
*/
function Bone(layer)
{
	this.layer = layer;
	var effect = this.layer.effect(DuAEF.Duik.PseudoEffectsMatchNames.BONE);
	this.effect = effect;
}

/**
* Sets a new display size for the bone
* @memberof Bone
* @param {int} [size] - The bone size, a percentage. By default, it will adjust automatically depending on comp size and DuAEF.Duik.boneSizeHint
*/
Bone.prototype.setSize = function (size)
{
	if (this.layer == null) return;
	if (size == undefined)
	{
		var comp = this.layer.containingComp;
		size = comp.width/2 + comp.height/2;
		if (DuAEF.Duik.boneSizeHint == DuAEF.Duik.Sizes.SMALL) size = Math.floor(size*100/1500);
		else if (DuAEF.Duik.boneSizeHint == DuAEF.Duik.Sizes.MEDIUM) size = Math.floor(size*150/1500);
		else if (DuAEF.Duik.boneSizeHint == DuAEF.Duik.Sizes.LARGE) size = Math.floor(size*200/1500);
		else if (DuAEF.Duik.boneSizeHint == DuAEF.Duik.Sizes.CUSTOM) size = DuAEF.Duik.boneSize;
	}

	this.effect(2).setValue(size);
}

/**
* Sets a new display color for the bone
* @memberof Bone
* @param {float[]} color - The new color
*/
Bone.prototype.setColor = function (color)
{
	if (color == undefined) color = DuAEF.Duik.boneColor;
	if (color == DuAEF.DuJS.Color.Colors.RANDOM) color = DuAEF.DuJS.Color.random();

	this.effect(1).setValue(color);
}

/**
* Constructs a Controller
* @class Controller
* @classdesc A Controller.
* @param {ShapeLayer} layer - The layer of the controller
* @property {ShapeLayer} layer - The Shape layer of the controller
* @property {DuAEF.Duik.ControllerType} type - The type of the controller
* @property {PropertyGroup} effect - The effect on the layer
*/
function Controller(layer)
{
	this.layer = layer;
	var effect = this.layer.effect(DuAEF.Duik.PseudoEffectsMatchNames.CONTROLLER_SLIDER);
	if (!effect) effect = this.layer.effect(DuAEF.Duik.PseudoEffectsMatchNames.CONTROLLER_DOUBLE_SLIDER);
	if (!effect) effect = this.layer.effect(DuAEF.Duik.PseudoEffectsMatchNames.CONTROLLER_ANGLE);
	if (!effect) effect = this.layer.effect(DuAEF.Duik.PseudoEffectsMatchNames.CONTROLLER);
	if (effect) this.effect = effect;
	else
	{
		this.effect = {};
		this.effect.name = '';
	}
}

/**
* Sets a new display size for the controller
* @memberof Controller
* @param {int} [size] - The controller size, a percentage. By default, it will adjust automatically depending on comp size and DuAEF.Duik.controllerSizeHint
*/
Controller.prototype.setSize = function (size)
{
	if (this.layer == null) return;
	if (size == undefined)
	{
		var comp = this.layer.containingComp;
		size = comp.width/2 + comp.height/2;
		if (DuAEF.Duik.controllerSizeHint == DuAEF.Duik.Sizes.SMALL) size = Math.floor(size*100/1500);
		else if (DuAEF.Duik.controllerSizeHint == DuAEF.Duik.Sizes.MEDIUM) size = Math.floor(size*150/1500);
		else if (DuAEF.Duik.controllerSizeHint == DuAEF.Duik.Sizes.LARGE) size = Math.floor(size*200/1500);
		else if (DuAEF.Duik.controllerSizeHint == DuAEF.Duik.Sizes.CUSTOM) size = DuAEF.Duik.controllerSize;
	}
	var index1 = 4;
	var index2 = 10;
	if (this.effect.matchName == DuAEF.Duik.PseudoEffectsMatchNames.CONTROLLER_SLIDER || this.effect.matchName == DuAEF.Duik.PseudoEffectsMatchNames.CONTROLLER_DOUBLE_SLIDER || this.effect.matchName == DuAEF.Duik.PseudoEffectsMatchNames.CONTROLLER_ANGLE)
	{
		index1 = 3;
		index2 = 8;
	}

	this.effect(index1).setValue(size);
	this.effect(index2).setValue(size);
}

/**
* Sets a new display color for the controller
* @memberof Controller
* @param {float[]} color - The new color
*/
Controller.prototype.setColor = function (color)
{
	if (color == undefined) color = DuAEF.Duik.controllerColor;
	if (color == DuAEF.DuJS.Color.Colors.RANDOM) color = DuAEF.DuJS.Color.random();

	this.effect(2).setValue(color);
}

/**
* Constructs a Structure
* @class Structure
* @classdesc A Structure.
* @property {Layer[]} elements - The elements of the structure, sorted by their parenting, root at 0
*/
function Structure()
{
	this.elements = [];
	this.editModeRegExp = / \|StructureElementChildren:([\d,]*)\|/;
}

/**
* Sets a new display size for the structure
* @memberof Structure
* @param {int} [size] - The element size, a percentage. By default, it will adjust automatically depending on comp size and DuAEF.Duik.structureSizeHint
*/
Structure.prototype.setSize = function (size)
{
	if (this.elements.length == 0) return;
	var comp = this.elements[0].containingComp;
	if (size == undefined)
	{
		size = comp.width/2 + comp.height/2;
		if (DuAEF.Duik.structureSizeHint == DuAEF.Duik.Sizes.SMALL) size = Math.floor(size/14);
		else if (DuAEF.Duik.structureSizeHint == DuAEF.Duik.Sizes.MEDIUM) size = Math.floor(size/10);
		else if (DuAEF.Duik.structureSizeHint == DuAEF.Duik.Sizes.LARGE) size = Math.floor(size/6);
		else if (DuAEF.Duik.structureSizeHint == DuAEF.Duik.Sizes.CUSTOM) size = DuAEF.Duik.structureSize;
	}
	for (var i = 0 ; i < this.elements.length ; i++)
	{
		var layer = this.elements[i];
		layer.effect(DuAEF.Duik.PseudoEffectsMatchNames.STRUCTURE_ELEMENT)(2).setValue(size);
	}
}

/**
* Sets a new display color for the structure
* @memberof Structure
* @param {float[]} [color=DuAEF.Duik.structureColor] - The color
*/
Structure.prototype.setColor = function (color)
{
	if (this.elements.length == 0) return;
	var comp = this.elements[0].containingComp;

	if (color == undefined) color = DuAEF.Duik.structureColor;
	if (color == DuAEF.DuJS.Color.Colors.RANDOM) color = DuAEF.DuJS.Color.random();

	for (var i = 0 ; i < this.elements.length ; i++)
	{
		var layer = this.elements[i];
		layer.effect(DuAEF.Duik.PseudoEffectsMatchNames.STRUCTURE_ELEMENT)(4).setValue(color);
	}
}

/**
* Toggles the edit mode
* @memberof Structure
*/
Structure.prototype.toggleEditMode = function (color)
{
	if (this.elements.length == 0) return;

	var setEditMode = !this.editModeRegExp.test(this.elements[0].comment);

	for (var i = 0 ; i < this.elements.length ; i++)
	{
		this.toggleElementEditMode(i,setEditMode)
	}
}

/**
* Toggles the edit mode of one element in the structure
* @memberof Structure
* @param {int} elementIndex - The index of the element to toggle in the Structure.elements Array
* @param {boolean} setEditMode - true to turn on edit mode, false to turn it off.
*/
Structure.prototype.toggleElementEditMode = function (elementIndex,setEditMode)
{
	var element = this.elements[elementIndex];
	var comp = element.containingComp;
	var already = this.editModeRegExp.test(element.comment);

	if (setEditMode && !already)
	{
		var children = DuAEF.DuAE.Layer.getChildren(element);
		element.comment = element.comment + ' |StructureElementChildren:';
		for (var j = 0 ; j < children.length ; j++)
		{
			var child = children[j];
			element.comment = element.comment + child.index;
			if (j < children.length -1) element.comment = element.comment + ',';
			child.parent = null;
		}
		element.comment = element.comment + "|";
		element.name = '=EDIT= ' + element.name;
	}
	else if (already)
	{
		var match = this.editModeRegExp.exec(element.comment);
		if (match.length == 2)
		{
			var indices = match[1].split(',');
			//reparent
			if (indices.length > 0)
			{
				for (var i = 0 ; i < indices.length ; i++)
				{
					var index = parseInt(indices[i]);
					if (isNaN(index)) continue;
					comp.layer(index).parent = element;
				}
			}
			//remove comment
			element.comment = element.comment.replace(match[0],'');
			element.name = element.name.replace('=EDIT= ','');
		}
	}
}

/**
* Toggles visibility of the structure
* @memberof Structure
*/
Structure.prototype.showHide = function ()
{
	if (this.elements.length == 0) return;
	var comp = this.elements[0].containingComp;
	var show = !this.elements[0].enabled;

	for (var i = 0 ; i < this.elements.length ; i++)
	{
		this.elements[i].enabled = show;
	}
}

/**
* Gets the unique identifier of the structure
* @memberof Structure
* @return {int} the id
*/
Structure.prototype.getId = function ()
{
	if (this.elements.length == 0) return -1;
	var params = DuAEF.Duik.getDuikMarkerParameters(this.elements[0]);
	if (!params) return -1;
	if (params[DuAEF.Duik.MarkerParameters.STRUCTURE_ID]) return params[DuAEF.Duik.MarkerParameters.STRUCTURE_ID];
	return -1;
}

/**
* Duik tools
* @namespace
* @memberof DuAEF
*/
DuAEF.Duik = {};

//Initialize
(function ()
{
	//structures
	#include "pseudoEffects/duik_structure.ffx.jsxinc"
	duik_structure = DuAEF.DuBinary.toFile(duik_structure);
	//list
	#include "pseudoEffects/duik_1d_list.ffx.jsxinc"
	duik_1d_list = DuAEF.DuBinary.toFile(duik_1d_list);
	#include "pseudoEffects/duik_2d_list.ffx.jsxinc"
	duik_2d_list = DuAEF.DuBinary.toFile(duik_2d_list);
	#include "pseudoEffects/duik_3d_list.ffx.jsxinc"
	duik_3d_list = DuAEF.DuBinary.toFile(duik_3d_list);
	//wiggle
	#include "pseudoEffects/duik_1d_wiggle.ffx.jsxinc"
	duik_1d_wiggle = DuAEF.DuBinary.toFile(duik_1d_wiggle);
	#include "pseudoEffects/duik_1d_multiwiggle.ffx.jsxinc"
	duik_1d_multiwiggle = DuAEF.DuBinary.toFile(duik_1d_multiwiggle);
	#include "pseudoEffects/duik_2d_wiggle.ffx.jsxinc"
	duik_2d_wiggle = DuAEF.DuBinary.toFile(duik_2d_wiggle);
	#include "pseudoEffects/duik_3d_wiggle.ffx.jsxinc"
	duik_3d_wiggle = DuAEF.DuBinary.toFile(duik_3d_wiggle);
	//swing
	#include "pseudoEffects/duik_1d_swing.ffx.jsxinc"
	duik_1d_swing = DuAEF.DuBinary.toFile(duik_1d_swing);
	#include "pseudoEffects/duik_2d_swing.ffx.jsxinc"
	duik_2d_swing = DuAEF.DuBinary.toFile(duik_2d_swing);
	#include "pseudoEffects/duik_3d_swing.ffx.jsxinc"
	duik_3d_swing = DuAEF.DuBinary.toFile(duik_3d_swing);
	#include "pseudoEffects/duik_spatial_swing.ffx.jsxinc"
	duik_spatial_swing = DuAEF.DuBinary.toFile(duik_spatial_swing);
	//Wheel
	#include "pseudoEffects/duik_wheel.ffx.jsxinc"
	duik_wheel = DuAEF.DuBinary.toFile(duik_wheel);
	//Effector
	#include "pseudoEffects/duik_effector.ffx.jsxinc"
	duik_effector = DuAEF.DuBinary.toFile(duik_effector);
	//Spring
	#include "pseudoEffects/duik_1d_spring.ffx.jsxinc"
	duik_1d_spring = DuAEF.DuBinary.toFile(duik_1d_spring);
	#include "pseudoEffects/duik_multid_spring.ffx.jsxinc"
	duik_multid_spring = DuAEF.DuBinary.toFile(duik_multid_spring);
	#include "pseudoEffects/duik_spatial_spring.ffx.jsxinc"
	duik_spatial_spring = DuAEF.DuBinary.toFile(duik_spatial_spring);
	//Blink
	#include "pseudoEffects/duik_1d_blink.ffx.jsxinc"
	duik_1d_blink = DuAEF.DuBinary.toFile(duik_1d_blink);
	#include "pseudoEffects/duik_2d_blink.ffx.jsxinc"
	duik_2d_blink = DuAEF.DuBinary.toFile(duik_2d_blink);
	#include "pseudoEffects/duik_3d_blink.ffx.jsxinc"
	duik_3d_blink = DuAEF.DuBinary.toFile(duik_3d_blink);
	#include "pseudoEffects/duik_color_blink.ffx.jsxinc"
	duik_color_blink = DuAEF.DuBinary.toFile(duik_color_blink);
	//Paint Rig
	#include "pseudoEffects/duik_paint_rig.ffx.jsxinc"
	duik_paint_rig = DuAEF.DuBinary.toFile(duik_paint_rig);
	//Motion Trail
	#include "pseudoEffects/duik_motion_trail.ffx.jsxinc"
	duik_motion_trail = DuAEF.DuBinary.toFile(duik_motion_trail);
	//X-Sheet
	#include "pseudoEffects/duik_x_sheet.ffx.jsxinc"
	duik_x_sheet = DuAEF.DuBinary.toFile(duik_x_sheet);
	//Controller
	#include "pseudoEffects/duik_controller.ffx.jsxinc"
	duik_controller = DuAEF.DuBinary.toFile(duik_controller);
	#include "pseudoEffects/duik_controller_slider.ffx.jsxinc"
	duik_controller_slider = DuAEF.DuBinary.toFile(duik_controller_slider);
	#include "pseudoEffects/duik_controller_dslider.ffx.jsxinc"
	duik_controller_dslider = DuAEF.DuBinary.toFile(duik_controller_dslider);
	#include "pseudoEffects/duik_controller_angle.ffx.jsxinc"
	duik_controller_angle = DuAEF.DuBinary.toFile(duik_controller_angle);
	//constraints
	#include "pseudoEffects/duik_orientation.ffx.jsxinc"
	duik_orientation = DuAEF.DuBinary.toFile(duik_orientation);
	#include "pseudoEffects/duik_position.ffx.jsxinc"
	duik_position = DuAEF.DuBinary.toFile(duik_position);
	#include "pseudoEffects/duik_path.ffx.jsxinc"
	duik_path = DuAEF.DuBinary.toFile(duik_path);
	#include "pseudoEffects/duik_parent.ffx.jsxinc"
	duik_parent = DuAEF.DuBinary.toFile(duik_parent);
	#include "pseudoEffects/duik_attachment.ffx.jsxinc"
	duik_attachment = DuAEF.DuBinary.toFile(duik_attachment);
	#include "pseudoEffects/duik_attachment_options.ffx.jsxinc"
	duik_attachment_options = DuAEF.DuBinary.toFile(duik_attachment_options);
	//bones
	#include "pseudoEffects/duik_bone.ffx.jsxinc"
	duik_bone = DuAEF.DuBinary.toFile(duik_bone);
	#include "pseudoEffects/duik_bone_linker.ffx.jsxinc"
	duik_bone_linker = DuAEF.DuBinary.toFile(duik_bone_linker);
	//connector
	#include "pseudoEffects/duik_1d_connector.ffx.jsxinc"
	duik_1d_connector = DuAEF.DuBinary.toFile(duik_1d_connector);
	#include "pseudoEffects/duik_2d_connector.ffx.jsxinc"
	duik_2d_connector = DuAEF.DuBinary.toFile(duik_2d_connector);
	#include "pseudoEffects/duik_3d_connector.ffx.jsxinc"
	duik_3d_connector = DuAEF.DuBinary.toFile(duik_3d_connector);
	#include "pseudoEffects/duik_color_connector.ffx.jsxinc"
	duik_color_connector = DuAEF.DuBinary.toFile(duik_color_connector);
	//ik
	#include "pseudoEffects/duik_1layer_ik.ffx.jsxinc"
	duik_1layer_ik = DuAEF.DuBinary.toFile(duik_1layer_ik);
	#include "pseudoEffects/duik_2layer_ik.ffx.jsxinc"
	duik_2layer_ik = DuAEF.DuBinary.toFile(duik_2layer_ik);
	#include "pseudoEffects/duik_3layer_ik.ffx.jsxinc"
	duik_3layer_ik = DuAEF.DuBinary.toFile(duik_3layer_ik);
	#include "pseudoEffects/duik_bezier_ik.ffx.jsxinc"
	duik_bezier_ik = DuAEF.DuBinary.toFile(duik_bezier_ik);
	#include "pseudoEffects/duik_bezier_ik_curve.ffx.jsxinc"
	duik_bezier_ik_curve = DuAEF.DuBinary.toFile(duik_bezier_ik_curve);
	#include "pseudoEffects/duik_bezier_ik_layer.ffx.jsxinc"
	duik_bezier_ik_layer = DuAEF.DuBinary.toFile(duik_bezier_ik_layer);
	#include "pseudoEffects/duik_ik.ffx.jsxinc"
	duik_ik = DuAEF.DuBinary.toFile(duik_ik);
	//cameras
	#include "pseudoEffects/duik_2d_camera.ffx.jsxinc"
	duik_2d_camera = DuAEF.DuBinary.toFile(duik_2d_camera);

	/**
	 * The pseudo effects needed by Duik
	 * @enum {File}
	 * @readonly
	 */
	DuAEF.Duik.PseudoEffects =
	{
		//camera
		TWOD_CAMERA: duik_2d_camera,
		//ik
		ONELAYER_IK: duik_1layer_ik,
		TWOLAYER_IK: duik_2layer_ik,
		THREELAYER_IK: duik_3layer_ik,
		BEZIER_IK: duik_bezier_ik,
		BEZIER_IK_CURVE: duik_bezier_ik_curve,
		BEZIER_IK_LAYER: duik_bezier_ik_layer,
		IK: duik_ik,
		//connector
		ONED_CONNECTOR: duik_1d_connector,
		TWOD_CONNECTOR: duik_2d_connector,
		THREED_CONNECTOR: duik_3d_connector,
		COLOR_CONNECTOR: duik_color_connector,
		//bones
		BONE: duik_bone,
		BONE_LINKER: duik_bone_linker,
		//constraints
		ATTACHMENT_OPTIONS: duik_attachment_options,
		ATTACHMENT: duik_attachment,
		PARENT: duik_parent,
		PATH: duik_path,
		POSITION: duik_position,
		ORIENTATION: duik_orientation,
		//Controller
		CONTROLLER: duik_controller,
		CONTROLLER_SLIDER: duik_controller_slider,
		CONTROLLER_DOUBLE_SLIDER: duik_controller_dslider,
		CONTROLLER_ANGLE: duik_controller_angle,
		//X-Sheet
		X_SHEET: duik_x_sheet,
		//Motion trail
		MOTION_TRAIL: duik_motion_trail,
		//Paint Rig
		PAINT_RIG: duik_paint_rig,
		//Blink
		COLOR_BLINK: duik_color_blink,
		ONED_BLINK: duik_1d_blink,
		TWOD_BLINK: duik_2d_blink,
		THREED_BLINK: duik_3d_blink,
		//Spring
		ONED_SPRING: duik_1d_spring,
		MULTID_SPRING: duik_multid_spring,
		SPATIAL_SPRING: duik_spatial_spring,
		//Effector
		EFFECTOR: duik_effector,
		//Wheel
		WHEEL: duik_wheel,
		//Swing
		ONED_SWING: duik_1d_swing,
		SPATIAL_SWING: duik_spatial_swing,
		TWOD_SWING: duik_2d_swing,
		THREED_SWING: duik_3d_swing,
		//wiggle
		ONED_WIGGLE: duik_1d_wiggle,
		ONED_MULTIWIGGLE: duik_1d_multiwiggle,
		TWOD_WIGGLE: duik_2d_wiggle,
		THREED_WIGGLE: duik_3d_wiggle,
		//list
		ONED_LIST: duik_1d_list,
		TWOD_LIST: duik_2d_list,
		THREED_LIST: duik_3d_list,
		//structures
		STRUCTURE_ELEMENT: duik_structure
	};

	/**
	 * The pseudo effects match names
	 * @enum {string}
	 * @readonly
	 */
	DuAEF.Duik.PseudoEffectsMatchNames =
	{
		//camera
		TWOD_CAMERA: "Pseudo/DUIK 2d camera",
		//ik
		ONELAYER_IK: "Pseudo/DUIK 1layer ik",
		TWOLAYER_IK: "Pseudo/DUIK 2layer ik",
		THREELAYER_IK: "Pseudo/DUIK 3layer ik",
		BEZIER_IK: "Pseudo/DUIK bezier ik",
		BEZIER_IK_CURVE: "Pseudo/DUIK bezier ik curve",
		BEZIER_IK_LAYER: "Pseudo/DUIK bezier ik layer",
		IK: "Pseudo/DUIK ik",
		//connector
		ONED_CONNECTOR: "Pseudo/DUIK 1d connector",
		TWOD_CONNECTOR: "Pseudo/DUIK 2d connector",
		THREED_CONNECTOR: "Pseudo/DUIK 3d connector",
		COLOR_CONNECTOR: "Pseudo/DUIK color connector",
		//bones
		BONE: "Pseudo/DUIK bone",
		BONE_LINKER: "Pseudo/DUIK bone linker",
		//constraints
		ATTACHMENT_OPTIONS: "Pseudo/DUIK attachment options",
		ATTACHMENT: "Pseudo/DUIK attachment",
		PARENT: "Pseudo/DUIK parent",
		PATH: "Pseudo/DUIK path",
		POSITION: "Pseudo/DUIK position",
		ORIENTATION: "Pseudo/DUIK orientation",
		//Controller
		CONTROLLER: "Pseudo/DUIK controller",
		CONTROLLER_SLIDER: "Pseudo/DUIK controller slider",
		CONTROLLER_DOUBLE_SLIDER: "Pseudo/DUIK controller dslider",
		CONTROLLER_ANGLE: "Pseudo/DUIK controller angle",
		//X-Sheet
		X_SHEET: "Pseudo/DUIK x sheet",
		//Motion trail
		MOTION_TRAIL: "Pseudo/DUIK motion trail",
		//Paint Rig
		PAINT_RIG: "Pseudo/DUIK paint rig",
		//Blink
		COLOR_BLINK: "Pseudo/DUIK color blink",
		ONED_BLINK: "Pseudo/DUIK 1d blink",
		TWOD_BLINK: "Pseudo/DUIK 2d blink",
		THREED_BLINK: "Pseudo/DUIK 3d blink",
		//Spring
		ONED_SPRING: "Pseudo/DUIK 1d spring",
		MULTID_SPRING: "Pseudo/DUIK multid spring",
		SPATIAL_SPRING: "Pseudo/DUIK spatial spring",
		//Effector
		EFFECTOR: "Pseudo/DUIK effector",
		//Wheel
		WHEEL: "Pseudo/DUIK wheel",
		//Swing
		ONED_SWING: "Pseudo/DUIK 1d swing",
		SPATIAL_SWING: "Pseudo/DUIK spatial swing",
		TWOD_SWING: "Pseudo/DUIK 2d swing",
		THREED_SWING: "Pseudo/DUIK 3d swing",
		//wiggle
		ONED_WIGGLE: "Pseudo/DUIK 1d wiggle",
		ONED_MULTIWIGGLE: "Pseudo/DUIK 1d multiwiggle",
		TWOD_WIGGLE: "Pseudo/DUIK 2d wiggle",
		THREED_WIGGLE: "Pseudo/DUIK 3d wiggle",
		//list
		ONED_LIST: "Pseudo/DUIK 1d list",
		TWOD_LIST: "Pseudo/DUIK 2d list",
		THREED_LIST: "Pseudo/DUIK 3d list",
		//structures
		STRUCTURE_ELEMENT: "Pseudo/DUIK structure"
	};

	/**
	 * The different types of layers created by Duik
	 * @enum {string}
	 * @readonly
	 */
	DuAEF.Duik.LayerTypes =
	{
		MOTION_TRAIL: 'motionTrail',
		STRUCTURE: 'structure',
		X_SHEET: 'xSheet',
		CEL: 'cel',
		EFFECTOR: 'effector',
		CONTROLLER: 'controller',
		TWOD_CAMERA_LAYER: '2dCameraLayer',
		ZERO: 'zero',
		BONE: 'bone'
	}

	DuAEF.Duik.MarkerParameters =
	{
		AUTORIG_ELEMENT: "autorigElementType",
		AUTORIG_ANIMAL_TYPE: "autorigAnimalType",
		AUTORIG_ELEMENT_NUMBER: "autorigElementNumber",
		STRUCTURE_ID: "structureId"
	}

	/**
	 * Predefined sizes
	 * @enum {int}
	 * @readonly
	 */
	DuAEF.Duik.Sizes =
	{
		SMALL: 0,
		MEDIUM: 1,
		LARGE: 2,
		CUSTOM: 3
	};

	/**
	 * How to get structures depending on selection<br />
	 * All structure, only children elements, or only selected element
	 * @enum {int}
	 * @readonly
	 */
	DuAEF.Duik.StructureSelectionMode =
	{
		STRUCTURE: 0,
		CHILDREN: 1,
		ELEMENT: 2,
		ALL: 3
	}

	/**
	 * The shapes/type/icon of the controllers
	 * @enum {int}
	 * @readonly
	 */
	DuAEF.Duik.ControllerType =
	{
		ROTATION: 1,
		X_POSITION: 2,
		Y_POSITION: 3,
		POSITION: 4,
		TRANSFORM: 5,
		SLIDER: 6,
		DOUBLE_SLIDER: 7,
		ANGLE: 8,
		CAMERA: 9,
		HEAD: 10,
		HAND: 11,
		FOOT: 12,
		CLAWS: 13,
		HOOF: 14,
		EYE: 15,
		EYES: 16,
		FACE: 17,
		SQUARE: 18
	}

	/**
	 * The shapes/type/icon of the bones
	 * @enum {int}
	 * @readonly
	 */
	DuAEF.Duik.BoneType =
	{
		PIN: 1,
		VERTEX: 2,
		TANGENT: 3
	}

	/**
	* Size hint of structure elements
	* @type {int}
	* @default DuAEF.Duik.Sizes.SMALL
	*/
	DuAEF.Duik.structureSizeHint = DuAEF.Duik.Sizes.SMALL;
	/**
	* The default size for new structures if structureSizeHint is DuAEF.Duik.Sizes.CUSTOM
	* @type {int}
	* @default 100
	*/
	DuAEF.Duik.structureSize = 100;
	/**
	* The default color for new structures
	* @type {float[]}
	* @default DuAEF.DuJS.Color.Colors.RANDOM
	*/
	DuAEF.Duik.structureColor = DuAEF.DuJS.Color.Colors.RANDOM
	/**
	* Size hint of controllers
	* @type {int}
	* @default DuAEF.Duik.Sizes.SMALL
	*/
	DuAEF.Duik.controllerSizeHint = DuAEF.Duik.Sizes.SMALL;
	/**
	* The default size for new controllers if controllerSizeHint is DuAEF.Duik.Sizes.CUSTOM
	* @type {int}
	* @default 100
	*/
	DuAEF.Duik.controllerSize = 100;
	/**
	* The default color for new controllers
	* @type {float[]}
	* @default DuAEF.DuJS.Color.Colors.RAINBOX_RED
	*/
	DuAEF.Duik.controllerColor = DuAEF.DuJS.Color.Colors.RAINBOX_RED;
	/**
	* Size hint of bones
	* @type {int}
	* @default DuAEF.Duik.Sizes.SMALL
	*/
	DuAEF.Duik.boneSizeHint = DuAEF.Duik.Sizes.SMALL;
	/**
	* The default size for new bones if boneSizeHint is DuAEF.Duik.Sizes.CUSTOM
	* @type {int}
	* @default 100
	*/
	DuAEF.Duik.boneSize = 100;
	/**
	* The default color for new bones
	* @type {float[]}
	* @default DuAEF.DuJS.Color.Colors.RAINBOX_RED
	*/
	DuAEF.Duik.boneColor = DuAEF.DuJS.Color.Colors.RAINBOX_RED;
})();

//undocumented low-level function used by Duik
DuAEF.Duik.setDuikMarker = function(layer,displayName,layerType)
{
	if (layerType == undefined) layerType = displayName.toLowerCase();
	var marker = layer.property('ADBE Marker').valueAtTime(0,true);
	marker.comment = displayName;
	var params = marker.getParameters();
	params.duik = layerType;
	marker.setParameters(params);
	layer.property('ADBE Marker').setValueAtTime(0,marker);
}

//undocumented low-level function used by Duik
DuAEF.Duik.getDuikMarkerParameters = function(layer)
{
	var marker = layer.property('ADBE Marker').valueAtTime(0,true);
	var params = marker.getParameters();
	if (params.duik) return params;
	return null;
}

//undocumented low-level function used by Duik
DuAEF.Duik.setDuikMarkerParameter = function(layer,name,key)
{
	var marker = layer.property('ADBE Marker').valueAtTime(0,true);
	var params = marker.getParameters();
	if (!params) params = {};
	params[name] = key;
	marker.setParameters(params);
	layer.property('ADBE Marker').setValueAtTime(0,marker);
}

/**
 * Gets layers previously created by Duik
 * @memberof DuAEF.Duik
 * @param {DuAEF.Duik.LayerTypes} [layerType] - The type of the layer.
 * @param {boolean} [selectedOnly=false] - Wether to search only in the layer selection
 * @param {CompItem} [comp] - The composition
 * @return {Layer[]}	The Structure or null if there is no active composition
 */
DuAEF.Duik.getLayers = function(layerType,selectedOnly,comp)
{
	if (layerType == undefined) layerType = '';
	if (comp == undefined) comp = DuAEF.DuAE.Project.getActiveComp();
	if (selectedOnly == undefined) selectedOnly = false;

	var layers = comp.layers;
	if (selectedOnly) layers = comp.selectedLayers;

	if (layers.length == 0) return [];

	var it = new Iterator(layers);
	var found = [];
	it.do(function(layer) {
		var params = DuAEF.Duik.getDuikMarkerParameters(layer);
		if (!params) return;
		if (layerType == '' || params.duik == layerType) found.push(layer);
	});

	return found;
}

/**
 * Gets the first layer of a kind previously created by Duik
 * @memberof DuAEF.Duik
 * @param {DuAEF.Duik.LayerTypes} layerType - The type of the layer.
 * @param {boolean} [selectedOnly=false] - Wether to search only in the layer selection
 * @param {CompItem} [comp] - The composition
 * @return {Layer[]}	The Structure or null if there is no active composition
 */
DuAEF.Duik.getLayer = function(layerType,selectedOnly,comp)
{
	if (comp == undefined) comp = DuAEF.DuAE.Project.getActiveComp();
	if (selectedOnly == undefined) selectedOnly = false;

	var layers = comp.layers;
	if (selectedOnly) layers = comp.selectedLayers;

	if (layers.length == 0) return null;

	var it = new Iterator(layers);
	while(layer = it.next())
	{
		var params = DuAEF.Duik.getDuikMarkerParameters(layer);
		if (!params) continue;
		if (params.duik == layerType) return layer;
	}
	return null;
}

//low-level undocumented function
DuAEF.Duik.getLayerType = function(layer)
{
	var params = DuAEF.Duik.getDuikMarkerParameters(layer);
	if (!params) return '';
	return params.duik;
}

//low-level undocumented function
DuAEF.Duik.isLayerType = function(layer,layerType)
{
	return DuAEF.Duik.getLayerType(layer) == layerType;
}

/**
* Autorig
* @namespace
* @memberof DuAEF.Duik
*/
DuAEF.Duik.Autorig = {}

/**
 * The types of animals which can be rigged
 * @enum {int}
 * @readonly
 */
DuAEF.Duik.Autorig.AnimalTypes =
{
	PLANTIGRADE: 1,
	DIGITIGRADE: 2,
	UNGULATE: 3
}

/**
 * The elements handled by the Autorig
 * @enum {string}
 * @readonly
 */
DuAEF.Duik.Autorig.Elements =
{
	SHOULDER: 'shoulder',
	SHOULDER_BLADE: 'shoulder',
	CLAVICLE: 'shoulder',
	HUMERUS: 'humerus',
	RADIUS: 'radius',
	HAND: 'hand',
	FINGERS: 'fingers',
	FRONT_CLAWS: 'fingers',
	FRONT_HEEL: 'palm',
	FRONT_PALM: 'palm',
	ARM_TIP: 'armTip',
	FEMUR: 'femur',
	THIGH: 'femur',
	TIBIA: 'tibia',
	CALF: 'tibia',
	FOOT: 'foot',
	REAR_CLAWS: 'toes',
	TOES: 'toes',
	CLAWS: 'toes',
	HEEL: 'heel',
	LEG_TIP: 'legTip',
	TIPTOE: 'legTip',
	HIPS: 'hips',
	SPINE: 'spine',
	NECK: 'neck',
	HEAD: 'head',
	SPINE_TIP: "spineTip",
	TAIL: "tail",
	TAIL_TIP: "tailTip"
}

/**
* Structures
* @namespace
* @memberof DuAEF.Duik
*/
DuAEF.Duik.Structure = {};

/**
 * Creates a structure in a composition
 * @memberof DuAEF.Duik.Structure
 * @param {int}		num	- The number of elements of the structure
 * @param {CompItem}	comp	- The composition where to create the Structure
 * @param {string}	[name="Name"]	- The name of the structure (used as layer names)
 * @param {int}	[id] - An identifier for this structure
 * @return {Structure|null}	The Structure or null if there is no active composition
 */
DuAEF.Duik.Structure.addStructure = function (num,comp,name,id)
{
	if (name === undefined) name = "Name";
	if (id === undefined) id = new Date().getTime();

	//end
	num++;

	//structure
	var structure = new Structure();

	//elements length
	var length = comp.width/(num+1);

	var prevElement = null;
	var color = DuAEF.Duik.structureColor;
	if (color == DuAEF.DuJS.Color.Colors.RANDOM)
	{
		color = DuAEF.DuJS.Color.random();
	}

	for (var i = 0 ; i < num ; i++)
	{
		var end = i == num-1;
		var element = DuAEF.Duik.Structure.addStructureElement(comp,color,undefined,id);
		if (end)
		{
			element.name = DuAEF.DuAE.Comp.newUniqueLayerName("S-End | " + name, comp);
			DuAEF.Duik.setDuikMarker(element,"Structure end",DuAEF.Duik.LayerTypes.STRUCTURE);
		}
		else
		{
			element.name = DuAEF.DuAE.Comp.newUniqueLayerName("S | " + name, comp);
		}

		if (prevElement)
		{
			element.parent = prevElement;
			element.transform.position.setValue([length,0]);
		}
		else
		{
			element.transform.position.setValue([length,comp.height/2]);
		}
		prevElement = element;
		structure.elements.push(element);
	}

	//links and layer selection
	for (var i = 0;i < structure.elements.length ; i++)
	{
		if (i == structure.elements.length - 1)
		{
			structure.elements[i].effect("Structure")(3).setValue(structure.elements[i].index);
			structure.elements[i].selected = false;
		}
		else
		{
			structure.elements[i].effect("Structure")(3).setValue(structure.elements[i+1].index);
		}
	}
	structure.elements[0].selected = true;

	return structure;
}

/**
 * Creates an element for a structure in a composition
 * @memberof DuAEF.Duik.Structure
 * @param {CompItem}	comp	- The composition where to create the Structure
 * @param {float[]}	[color=[1,0.764,0.764,1]]		- The color of the element, [R,G,B,A] Array from 0.0 to 1.0
 * @param {float}	[size] 		- The element size, a percentage. By default, it will adjust automatically depending on comp size and DuikLib.structureSizeHint
 * @return {ShapeLayer}	The element
 */
DuAEF.Duik.Structure.addStructureElement = function (comp,color,size,id)
{
	if (size == undefined)
	{
		size = comp.width/2 + comp.height/2;
		if (DuAEF.Duik.structureSizeHint == DuAEF.Duik.Sizes.SMALL) size = Math.floor(size/14);
		else if (DuAEF.Duik.structureSizeHint == DuAEF.Duik.Sizes.MEDIUM) size = Math.floor(size/10);
		else if (DuAEF.Duik.structureSizeHint == DuAEF.Duik.Sizes.LARGE) size = Math.floor(size/6);
		else if (DuAEF.Duik.structureSizeHint == DuAEF.Duik.Sizes.CUSTOM) size = DuAEF.Duik.structureSize;
	}

	if (!color)
	{
		color = DuAEF.Duik.structureColor;
		if (color == DuAEF.DuJS.Color.Colors.RANDOM)
		{
			color = DuAEF.DuJS.Color.random();
		}
	}


	//======= CREATE ELEMENT USING SHAPE LAYER =======
	var element = comp.layers.addShape();
	DuAEF.Duik.setDuikMarker(element,"Structure",DuAEF.Duik.LayerTypes.STRUCTURE);
	DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.STRUCTURE_ID,id);
	//add effect

	element.applyPreset(DuAEF.Duik.PseudoEffects.STRUCTURE_ELEMENT);
	element.effect("Structure")(2).setValue(size);
	element.effect("Structure")(4).setValue(color);

	//bone group
	var elementGroup = element("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
	elementGroup.name = "Structure Element";
	elementGroup("ADBE Vector Transform Group")("ADBE Vector Scale").expression = '//Duik.structure.size\nif(!enabled) value;\nelse\n{\nvar s = effect("Structure")(2);\n[s,s];\n}';
	//target group
	var targetGroup = elementGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
	targetGroup.name = "Target";
	var targetGroupContent = targetGroup.property("ADBE Vectors Group");
	var ellipse = targetGroupContent.addProperty("ADBE Vector Shape - Ellipse");
	ellipse("ADBE Vector Ellipse Size").setValue([15,15]);
	var ellipse2 = targetGroupContent.addProperty("ADBE Vector Shape - Ellipse");
	ellipse2("ADBE Vector Ellipse Size").setValue([1,1]);
	var targetStroke = targetGroupContent.addProperty("ADBE Vector Graphic - Stroke");
	targetStroke("ADBE Vector Stroke Color").setValue([0.1,0.1,0.1,1]);
	targetStroke("ADBE Vector Stroke Width").setValue(2);


	var displayGroup = elementGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
	displayGroup.name = "Display";
	displayGroup.property("ADBE Vector Transform Group").property("ADBE Vector Group Opacity").setValue(50);
	//stretch group
	var stretchBoneGroup = displayGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
	stretchBoneGroup.name = "Link";
	var stretchBoneContent = stretchBoneGroup.property("ADBE Vectors Group");
	var star = stretchBoneContent.addProperty("ADBE Vector Shape - Star");
	star("ADBE Vector Star Type").setValue(2);
	star("ADBE Vector Star Points").setValue(3);
	star("ADBE Vector Star Outer Radius").setValue(20);
	star("ADBE Vector Star Outer Roundess").setValue(100);

	var roundExp = '//Duik.structure.roundness\n' +
				'var child = null;\n' +
				'var childIndex = -1;\n' +
				'try { child = effect("Structure")(3);childIndex = child.index}\n' +
				'catch (e) {}\n' +
				'if(!enabled || childIndex == thisLayer.index || effect("Structure")(2) == 0) value;\n' +
				'else\n' +
				'{\n' +
				'function isBone(layer)\n' +
				'{\n' +
				'var ok = false;\n' +
				'try { layer.content("Structure Element"); ok = true;}\n' +
				'catch (e) { ok = false;}\n' +
				'return ok;\n' +
				'}\n' +
				'if (!child) if (index > 1) if (thisComp.layer(index-1).hasParent) if (thisComp.layer(index-1).parent.index == index) child = thisComp.layer(index-1);\n' +
				'if (!isBone(child)) child = null;\n' +
				'if (!child) if (index < thisComp.numLayers) if (thisComp.layer(index+1).hasParent) if (thisComp.layer(index+1).parent.index == index) child = thisComp.layer(index+1);\n' +
				'if (!isBone(child)) child = null;\n' +
				'if (!child)\n' +
				'{\n' +
				'for (var i = thisComp.numLayers  ; i > 0 ; i--)\n' +
				'{\n' +
				'if (thisComp.layer(i).hasParent) if (thisComp.layer(i).parent.index == thisLayer.index)\n' +
				'{\n' +
				'child = thisComp.layer(i);\n' +
				'if (!isBone(child)) child = null;\n' +
				'if (child) break;\n' +
				'}\n' +
				'}\n' +
				'}\n' +
				'if (child)\n' +
				'{\n' +
				'var A = child.toWorld(child.anchorPoint);\n' +
				'var B = thisLayer.toWorld(thisLayer.anchorPoint);\n' +
				'var dist = length(A,B);\n' +
				'if (dist < 20) dist = 20;\n' +
				'var s = content("Structure Element").transform.scale[0];\n' +
				'value/(dist/60)*s/80;\n' +
				'}\n' +
				'else value;\n' +
				'}';

	star("ADBE Vector Star Outer Roundess").expression = roundExp;

	var stretchBoneFill = stretchBoneContent.addProperty("ADBE Vector Graphic - Fill");
	stretchBoneFill("ADBE Vector Fill Color").expression = '//Duik.structure.color\neffect("Structure")(4);';
	stretchBoneGroup.property("ADBE Vector Transform Group").property("ADBE Vector Anchor").setValue([0,10]);

	var scaExpr = "//Duik.structure.stretch\n" +
				'var child = null;\n' +
				'var childIndex = -1;\n' +
				'try { child = effect("Structure")(3);childIndex = child.index}\n' +
				'catch (e) {}\n' +
				'if(!enabled || childIndex == thisLayer.index || effect("Structure")(2) == 0) [0,0];\n' +
				'else\n' +
				'{\n' +
				"var X = 100;\n" +
				"var Y = 60;\n" +
				"function isBone(layer)\n" +
				"{\n" +
				"var ok = false;\n" +
				"try { layer.content(\"Structure Element\"); ok = true;}\n" +
				"catch (e) { ok = false;}\n" +
				"return ok;\n" +
				"}\n" +
				"if (!child) if (index > 1) if (thisComp.layer(index-1).hasParent) if (thisComp.layer(index-1).parent.index == index) child = thisComp.layer(index-1);\n" +
				"if (!isBone(child)) child = null;\n" +
				"if (!child) if (index < thisComp.numLayers) if (thisComp.layer(index+1).hasParent) if (thisComp.layer(index+1).parent.index == index) child = thisComp.layer(index+1);\n" +
				"if (!isBone(child)) child = null;\n" +
				"if (!child)\n" +
				"{\n" +
				"for (var i = thisComp.numLayers  ; i > 0 ; i--)\n" +
				"{\n" +
				"if (thisComp.layer(i).hasParent) if (thisComp.layer(i).parent.index == thisLayer.index)\n" +
				"{\n" +
				"child = thisComp.layer(i);\n" +
				"if (!isBone(child)) child = null;\n" +
				"if (child) break;\n" +
				"}\n" +
				"}\n" +
				"}\n" +
				"if (child)\n" +
				"{\n" +
				"var A = child.toWorld(child.anchorPoint);\n" +
				"var B = thisLayer.toWorld(thisLayer.anchorPoint);\n" +
				"var dist = length(A,B);\n" +
				"Y = dist/30*100;\n" +
				"}\n" +
				"[X,Y*100/content(\"Structure Element\").transform.scale[1]];\n" +
				'}';

	stretchBoneGroup.property("ADBE Vector Transform Group").property("ADBE Vector Scale").expression = scaExpr;

	var rotExpr = "//Duik.structure.orientation\n" +
			'var child = null;\n' +
			'var childIndex = -1;\n' +
			'try { child = effect("Structure")(3);childIndex = child.index || effect("Structure")(2) == 0}\n' +
			'catch (e) {}\n' +
			'if(!enabled || childIndex == thisLayer.index) value;\n' +
			'else\n' +
			'{\n' +
			"var R = 45;\n" +
			"function isBone(layer)\n" +
			"{\n" +
			"var ok = false;\n" +
			"try { layer.content(\"Structure Element\"); ok = true;}\n" +
			"catch (e) { ok = false;}\n" +
			"return ok;\n" +
			"}\n" +
			"if (!child) if (index > 1) if (thisComp.layer(index-1).hasParent) if (thisComp.layer(index-1).parent.index == index) child = thisComp.layer(index-1);\n" +
			"if (!isBone(child)) child = null;\n" +
			"if (!child) if (index < thisComp.numLayers) if (thisComp.layer(index+1).hasParent) if (thisComp.layer(index+1).parent.index == index) child = thisComp.layer(index+1);\n" +
			"if (!isBone(child)) child = null;\n" +
			"if (!child)\n" +
			"{\n" +
			"for (var i = thisComp.numLayers  ; i > 0 ; i--)\n" +
			"{\n" +
			"if (thisComp.layer(i).hasParent) if (thisComp.layer(i).parent.index == thisLayer.index)\n" +
			"{\n" +
			"child = thisComp.layer(i);\n" +
			"if (!isBone(child)) child = null;\n" +
			"if (child) break;\n" +
			"}\n" +
			"}\n" +
			"}\n" +
			"var result = value;\n" +
			"var layer = thisLayer;\n" +
			"while (layer.hasParent)\n" +
			"{\n" +
			"layer = layer.parent;\n" +
			"result = result - layer.rotation;\n" +
			"}\n" +
			"if (child)\n" +
			"if (child.index != index)\n" +
			"{\n" +
			"C = child.toWorld(child.anchorPoint);\n" +
			"O =  thisLayer.toWorld(thisLayer.anchorPoint);\n" +
			"var vec = O-C;\n" +
			"var angle = Math.atan2(vec[1], vec[0]);\n" +
			"var ik = radiansToDegrees(angle);\n" +
			"result += (ik-90-rotation)\n" +
			"}\n" +
			"result;\n" +
			"}";

	elementGroup.property("ADBE Vector Transform Group").property("ADBE Vector Rotation").expression = rotExpr;

	var editModeGroup = displayGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
	editModeGroup.name = "Edit Mode";
	var editModeContent = editModeGroup.property("ADBE Vectors Group");
	var circle = editModeContent.addProperty("ADBE Vector Shape - Ellipse");
	circle("ADBE Vector Ellipse Size").setValue([40,40]);

	var editModeExpr = '//Duik.structure.editMode\n' +
					'var child = null;\n' +
					'for (var i = 1 ; i <= thisComp.numLayers ; i++)\n' +
					'{\n' +
					'if (i != thisLayer.index && thisComp.layer(i).hasParent)\n' +
					'if (thisComp.layer(i).parent.index == thisLayer.index) {child = thisComp.layer(i); break;}\n' +
					'}\n' +
					'if (child) [0,0];\n' +
					'else value;';

	circle("ADBE Vector Ellipse Size").expression = editModeExpr;

	var editModeFill = editModeContent.addProperty("ADBE Vector Graphic - Fill");
	editModeFill("ADBE Vector Fill Color").setValue(DuAEF.DuJS.Color.Colors.RAINBOX_RED);

	element.guideLayer = true;

	//group
	DuAEF.Dugr.addLayerToGroup(element,"Structures");

	return element;
}

/**
 * Gets structures in the comp. If some layers are selected, uses selectionMode, else returns all structure elements found.
 * @memberof DuAEF.Duik.Structure
 * @param {CompItem}	comp	- The composition where to get the structures
 * @param {int} [structureSelectionMode=DuAEF.Duik.StructureSelectionMode.STRUCTURE]	- The selection mode. One of {@link DuAEF.Duik.StructureSelectionMode}
 * @return {Structure[]}	The structures. If selectionMode is DuAEF.Duik.StructureSelectionMode.ELEMENT, will be one structure with all elements found
 */
DuAEF.Duik.Structure.getStructures = function (comp,selectionMode)
{
	if (selectionMode == undefined) selectionMode = DuAEF.Duik.StructureSelectionMode.STRUCTURE;
	var layers = comp.selectedLayers;
	var i = 0;
	var m = layers.length-1;
	if (selectionMode == DuAEF.Duik.StructureSelectionMode.ALL)
	{
		layers = comp.layers;
		selectionMode = DuAEF.Duik.StructureSelectionMode.STRUCTURE;
		i = 1;
		m = layers.length;
	}

	var structures = [];
	var indexed = [];

	if (layers.length == 0) return structures;

	var structure = new Structure();

	for ( i ; i <= m ; i++)
	{
		var layer = layers[i];
		if (!DuAEF.Duik.isLayerType(layer,DuAEF.Duik.LayerTypes.STRUCTURE)) continue;
		if (DuAEF.DuJS.Array.indexOf(indexed,layer.index) >= 0) continue;

		indexed.push(layer.index);

		if (selectionMode == DuAEF.Duik.StructureSelectionMode.ELEMENT)
		{
			structure.elements.push(layer);
			continue;
		}
		var structure = new Structure();
		structure.elements.push(layer);
		//get children
		if (selectionMode == DuAEF.Duik.StructureSelectionMode.CHILDREN || selectionMode == DuAEF.Duik.StructureSelectionMode.STRUCTURE)
		{
			//for all layers in the comp, get child
			var childLayer = layer;
			while (childLayer != null)
			{
				var childIndex = childLayer.effect(DuAEF.Duik.PseudoEffectsMatchNames.STRUCTURE_ELEMENT)(3).value;
				if (childIndex == childLayer.index) break;
				var currentIndex = childLayer.index;
				childLayer = null;
				//get child
				if (childIndex != 0)
				{
					var child = comp.layer(childIndex);
					//check if it's a structure element
					if (DuAEF.Duik.isLayerType(child,DuAEF.Duik.LayerTypes.STRUCTURE))
					{
						structure.elements.push(child);
						childLayer = child;
						indexed.push(child.index);
						continue;
					}
				}
				//search child
				for (var j = 1 ; j <= comp.layers.length ; j++)
				{
					var child = comp.layer(j);
					if (child.parent == null) continue;
					if (DuAEF.Duik.isLayerType(child,DuAEF.Duik.LayerTypes.STRUCTURE) && child.parent.index == currentIndex)
					{
						structure.elements.push(child);
						childLayer = child;
						indexed.push(child.index);
						break;
					}
				}
			}
		}

		//get parents
		if (selectionMode == DuAEF.Duik.StructureSelectionMode.STRUCTURE)
		{
			var parentLayer = layer;
			while (parentLayer != null)
			{
				var testParent = parentLayer.parent;
				var childIndex = parentLayer.index;

				if (testParent == null) break;
				else if (!DuAEF.Duik.isLayerType(testParent,DuAEF.Duik.LayerTypes.STRUCTURE)) break;

				var testIndex = testParent.effect(DuAEF.Duik.PseudoEffectsMatchNames.STRUCTURE_ELEMENT)(3).value;

				parentLayer = null;

				if (testIndex == testParent.index) break;
				else if (testIndex == 0 || testIndex == childIndex)
				{
					structure.elements.unshift(testParent);
					parentLayer = testParent;
					indexed.push(testParent.index);
				}
			}
		}

		structures.push(structure);

	}

	if (selectionMode == DuAEF.Duik.StructureSelectionMode.ELEMENT) structures.push(structure);

	return structures;
}

/**
 * Creates a predefined structure for an arm.
 * @memberof DuAEF.Duik.Structure
 * @param {boolean} [shoulder=false] - true if the arm has a shoulder.
 * @param {boolean} [humerus=true] - true if the arm has a humerus.
 * @param {boolean} [radius=true] - true if the arm has a radius.
 * @param {boolean} [hand=true] - true if the arm has a hand.
 * @param {boolean} [claws=false] - true if the arm has claws.
 * @param {boolean} [left=false] - true if this is a Left arm, false for a Right arm
 * @param {DuAEF.Duik.Autorig.AnimalTypes} [type=DuAEF.Duik.Autorig.AnimalTypes.PLANTIGRADE] - the type of animal
 * @param {CompItem} [comp] - The composition where to create the structure. By default, will try with the active item, if any.
 * @return {Structure|null} The structure.
 */
DuAEF.Duik.Structure.createArm = function(shoulder,humerus,radius,hand,claws,left,type,comp)
{
	if (comp == undefined) comp = DuAEF.DuAE.Project.getActiveComp();
	if (!comp) return null;
	if (shoulder == undefined) shoulder = false;
	if (humerus == undefined) humerus = true;
	if (radius == undefined) radius = true;
	if (hand == undefined) hand = true;
	if (claws == undefined) claws = false;
	if (left == undefined) left = false;
	if (type == undefined) type = DuAEF.Duik.Autorig.AnimalTypes.PLANTIGRADE;
	var plantigrade = type == DuAEF.Duik.Autorig.AnimalTypes.PLANTIGRADE;
	var digitigrade = type == DuAEF.Duik.Autorig.AnimalTypes.DIGITIGRADE;
	var ungulate = type == DuAEF.Duik.Autorig.AnimalTypes.UNGULATE;

	//create structure
	var numElements = 0;
	if (shoulder) numElements++;
	if (humerus) numElements++;
	if (radius) numElements++;
	if (hand) numElements++;
	if (claws) numElements++;

	if (numElements == 0) return null;

	var structure = DuAEF.Duik.Structure.addStructure(numElements,comp);

	//name and move

	//element index we're working on
	var currentElement = 0;

	//size of the humerus
	var size = comp.height/5;
	if (digitigrade) size = comp.height/8;
	else if (ungulate) size = comp.height/10;

	//position of the next limb
	var nextPosition = [comp.width/2,comp.height/4];

	if (shoulder)
	{
		//set limb position and name
		var element = structure.elements[currentElement];
		element.name = DuAEF.DuAE.Comp.newUniqueLayerName("S | Shoulder",comp);
		element.effect(DuAEF.Duik.PseudoEffectsMatchNames.STRUCTURE_ELEMENT)(4).setValue(DuAEF.DuJS.Color.Colors.RAINBOX_RED);
		//position of the next limb
		element.transform.position.setValue(nextPosition);
		DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.AUTORIG_ELEMENT,DuAEF.Duik.Autorig.Elements.SHOULDER);
		DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.AUTORIG_ANIMAL_TYPE,type);
		if (plantigrade) nextPosition = [-size/2,size/6];
		else if (digitigrade) nextPosition = [-size*3/4,size*3/4];
		else if (ungulate) nextPosition = [-size,size];

		//next
		currentElement++;
	}
	if (humerus)
	{
		var element = structure.elements[currentElement];
		element.transform.position.setValue(nextPosition);
		element.name = DuAEF.DuAE.Comp.newUniqueLayerName("S | Arm",comp);
		element.effect(DuAEF.Duik.PseudoEffectsMatchNames.STRUCTURE_ELEMENT)(4).setValue(DuAEF.DuJS.Color.Colors.ORANGE);
		DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.AUTORIG_ELEMENT,DuAEF.Duik.Autorig.Elements.HUMERUS);
		DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.AUTORIG_ANIMAL_TYPE,type);
		if (plantigrade)
		{
			if (claws) nextPosition = [size/6,size];
			else nextPosition = [-size/6,size];
		}
		else if (digitigrade) nextPosition = [size*3/4,size*3/4];
		else if (ungulate) nextPosition = [size*3/4,size*3/4];
		currentElement++;
	}
	if (radius)
	{
		var element = structure.elements[currentElement];
		element.transform.position.setValue(nextPosition);
		element.name = DuAEF.DuAE.Comp.newUniqueLayerName("S | Forearm",comp);
		element.effect(DuAEF.Duik.PseudoEffectsMatchNames.STRUCTURE_ELEMENT)(4).setValue(DuAEF.DuJS.Color.Colors.YELLOW);
		DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.AUTORIG_ELEMENT,DuAEF.Duik.Autorig.Elements.RADIUS);
		DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.AUTORIG_ANIMAL_TYPE,type);
		if (plantigrade)
		{
			if (claws) nextPosition = [-size/6,size];
			else nextPosition = [size/6,size];
		}
		else if (digitigrade) nextPosition = [-size/3,size*4/3];
		else if (ungulate) nextPosition = [-size/2,size*3/2];
		currentElement++;
	}
	if (hand)
	{
		var element = structure.elements[currentElement];
		element.transform.position.setValue(nextPosition);
		element.name = DuAEF.DuAE.Comp.newUniqueLayerName("S | Hand",comp);
		element.effect(DuAEF.Duik.PseudoEffectsMatchNames.STRUCTURE_ELEMENT)(4).setValue(DuAEF.DuJS.Color.Colors.LIGHT_BLUE);
		DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.AUTORIG_ELEMENT,DuAEF.Duik.Autorig.Elements.HAND);
		DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.AUTORIG_ANIMAL_TYPE,type);
		if (plantigrade)
		{
			if (claws) nextPosition = [-size/3,size/8];
			else nextPosition = [size/3,size/3];
		}
		else if (digitigrade) nextPosition = [0,size*3/8];
		else if (ungulate) nextPosition = [size/5,size];
		currentElement++;
	}
	if (claws)
	{
		var element = structure.elements[currentElement];
		element.transform.position.setValue(nextPosition);
		element.name = DuAEF.DuAE.Comp.newUniqueLayerName("S | Claws",comp);
		element.effect(DuAEF.Duik.PseudoEffectsMatchNames.STRUCTURE_ELEMENT)(4).setValue(DuAEF.DuJS.Color.Colors.LIGHT_PURPLE);
		DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.AUTORIG_ELEMENT,DuAEF.Duik.Autorig.Elements.FINGERS);
		DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.AUTORIG_ANIMAL_TYPE,type);
		if (plantigrade) nextPosition = [-size/4,0];
		else if (digitigrade) nextPosition = [-size/4,0];
		else if (ungulate) nextPosition = [-size/5,size/2];
		currentElement++;
	}
	var element = structure.elements[currentElement];
	element.transform.position.setValue(nextPosition);
	element.name = DuAEF.DuAE.Comp.newUniqueLayerName("S | Arm Tip",comp);
	DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.AUTORIG_ELEMENT,DuAEF.Duik.Autorig.Elements.ARM_TIP);
	DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.AUTORIG_ANIMAL_TYPE,type);

	//heel
	if (plantigrade && claws)
	{
		var heelStructure = DuAEF.Duik.Structure.addStructure(0,comp,undefined,structure.getId());
		var element = heelStructure.elements[0];
		element.parent = structure.elements[structure.elements.length-1];
		element.transform.position.setValue([size/4+size/3,0]);
		element.name = DuAEF.DuAE.Comp.newUniqueLayerName("S | Heel",comp);
		element.selected = false;
		structure.elements[0].selected = true;
		structure.elements.push(element);
		DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.AUTORIG_ELEMENT,DuAEF.Duik.Autorig.Elements.PALM);
		DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.AUTORIG_ANIMAL_TYPE,type);
	}

	return structure;
}

/**
 * Creates a predefined structure for an leg.
 * @memberof DuAEF.Duik.Structure
 * @param {boolean} [femur=true] - true if the leg has a shoulder.
 * @param {boolean} [tibia=true] - true if the leg has a humerus.
 * @param {boolean} [foot=true] - true if the leg has a radius.
 * @param {boolean} [toes=true] - true if the leg has a hand.
 * @param {boolean} [left=false] - true if this is a Left leg, false for a Right leg
 * @param {DuAEF.Duik.Autorig.AnimalTypes} [type=DuAEF.Duik.Autorig.AnimalTypes.PLANTIGRADE] - the type of animal
 * @param {CompItem} [comp] - The composition where to create the structure. By default, will try with the active item, if any.
 * @return {Structure|null} The structure.
 */
DuAEF.Duik.Structure.createLeg = function(femur,tibia,foot,toes,left,type,comp)
{
	if (comp == undefined) comp = DuAEF.DuAE.Project.getActiveComp();
	if (!comp) return null;
	if (femur == undefined) femur = true;
	if (tibia == undefined) tibia = true;
	if (foot == undefined) foot = true;
	if (toes == undefined) toes = true;
	if (left == undefined) left = false;
	if (type == undefined) type = DuAEF.Duik.Autorig.AnimalTypes.PLANTIGRADE;
	var plantigrade = type == DuAEF.Duik.Autorig.AnimalTypes.PLANTIGRADE;
	var digitigrade = type == DuAEF.Duik.Autorig.AnimalTypes.DIGITIGRADE;
	var ungulate = type == DuAEF.Duik.Autorig.AnimalTypes.UNGULATE;

	//create structure
	var numElements = 0;
	if (femur) numElements++;
	if (tibia) numElements++;
	if (foot) numElements++;
	if (toes) numElements++;

	if (numElements == 0) return null;

	var structure = DuAEF.Duik.Structure.addStructure(numElements,comp);

	//name and move

	//element index we're working on
	var currentElement = 0;

	//size of the femur
	var size = comp.height/4;
	if (digitigrade) size = comp.height/6;
	else if (ungulate) size = comp.height/7;

	//position of the next limb
	var nextPosition = [comp.width/2,comp.height/4];

	if (femur)
	{
		var element = structure.elements[currentElement];
		element.transform.position.setValue(nextPosition);
		element.name = DuAEF.DuAE.Comp.newUniqueLayerName("S | Thigh",comp);
		element.effect(DuAEF.Duik.PseudoEffectsMatchNames.STRUCTURE_ELEMENT)(4).setValue(DuAEF.DuJS.Color.Colors.ORANGE);
		DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.AUTORIG_ELEMENT,DuAEF.Duik.Autorig.Elements.FEMUR);
		DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.AUTORIG_ANIMAL_TYPE,type);
		if (plantigrade) nextPosition = [-size/6,size];
		else if (digitigrade) nextPosition = [-size*3/4,size*3/4];
		else if (ungulate) nextPosition = [-size/2,size*3/4];
		currentElement++;
	}
	if (tibia)
	{
		var element = structure.elements[currentElement];
		element.transform.position.setValue(nextPosition);
		element.name = DuAEF.DuAE.Comp.newUniqueLayerName("S | Calf",comp);
		element.effect(DuAEF.Duik.PseudoEffectsMatchNames.STRUCTURE_ELEMENT)(4).setValue(DuAEF.DuJS.Color.Colors.YELLOW);
		DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.AUTORIG_ELEMENT,DuAEF.Duik.Autorig.Elements.TIBIA);
		DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.AUTORIG_ANIMAL_TYPE,type);
		if (plantigrade) nextPosition = [size/6,size];
		else if (digitigrade) nextPosition = [size*3/4,size*3/4];
		else if (ungulate) nextPosition = [size*2/3,size*3/4];
		currentElement++;
	}
	if (foot)
	{
		var element = structure.elements[currentElement];
		element.transform.position.setValue(nextPosition);
		element.name = DuAEF.DuAE.Comp.newUniqueLayerName("S | Foot",comp);
		element.effect(DuAEF.Duik.PseudoEffectsMatchNames.STRUCTURE_ELEMENT)(4).setValue(DuAEF.DuJS.Color.Colors.LIGHT_BLUE);
		DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.AUTORIG_ELEMENT,DuAEF.Duik.Autorig.Elements.FOOT);
		DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.AUTORIG_ANIMAL_TYPE,type);
		if (plantigrade)nextPosition = [-size*3/8,size/6];
		else if (digitigrade) nextPosition = [0,size/2];
		else if (ungulate) nextPosition = [-size/4,size];
		currentElement++;
	}
	if (toes)
	{
		var element = structure.elements[currentElement];
		element.transform.position.setValue(nextPosition);
		if (plantigrade) element.name = DuAEF.DuAE.Comp.newUniqueLayerName("S | Toes",comp);
		else element.name = DuAEF.DuAE.Comp.newUniqueLayerName("S | Claws",comp);
		element.effect(DuAEF.Duik.PseudoEffectsMatchNames.STRUCTURE_ELEMENT)(4).setValue(DuAEF.DuJS.Color.Colors.LIGHT_PURPLE);
		DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.AUTORIG_ELEMENT,DuAEF.Duik.Autorig.Elements.TOES);
		DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.AUTORIG_ANIMAL_TYPE,type);
		if (ui_armPlantiButton.checked) nextPosition = [-size/8,0];
		else if (ui_armDigiButton.checked) nextPosition = [-size/4,0];
		else if (ui_armUnguButton.checked) nextPosition = [0,size/4];
		currentElement++;
	}
	var element = structure.elements[currentElement];
	element.transform.position.setValue(nextPosition);
	element.name = DuAEF.DuAE.Comp.newUniqueLayerName("S | Tiptoe",comp);
	DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.AUTORIG_ELEMENT,DuAEF.Duik.Autorig.Elements.TIPTOE);
	DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.AUTORIG_ANIMAL_TYPE,type);
	//heel
	if (plantigrade && toes)
	{
		var heelStructure = DuAEF.Duik.Structure.addStructure(0,comp,undefined,structure.getId());
		var element = heelStructure.elements[0];
		element.parent = structure.elements[structure.elements.length-1];
		element.transform.position.setValue([size/8+size*3/8,0]);
		element.name = DuAEF.DuAE.Comp.newUniqueLayerName("S | Heel",comp);
		element.selected = false;
		structure.elements[0].selected = true;
		DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.AUTORIG_ELEMENT,DuAEF.Duik.Autorig.Elements.HEEL);
		DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.AUTORIG_ANIMAL_TYPE,type);
	}

	return structure;
}

/**
 * Creates a predefined structure for an spine / neck / head.
 * @memberof DuAEF.Duik.Structure
 * @param {boolean} [hips=true] - true if the spine has a hips.
 * @param {int} [spineCount=2] - the number of elements for the spine
 * @param {int} [neckCount=1] - the number of elements for the neck
 * @param {boolean} [head=true] - true if the spine has a hand.
 * @param {CompItem} [comp] - The composition where to create the structure. By default, will try with the active item, if any.
 * @return {Structure|null} The structure.
 */
DuAEF.Duik.Structure.createSpine = function(hips,spineCount,neckCount,head,comp)
{
	if (comp == undefined) comp = DuAEF.DuAE.Project.getActiveComp();
	if (!comp) return null;
	if (hips == undefined) hips = true;
	if (spineCount == undefined) spineCount = 2;
	if (neckCount == undefined) neckCount = 1;
	if (head == undefined) head = true;

	//create structure
	var numElements = 0;
	if (head) numElements++;
	numElements += neckCount;
	numElements += spineCount;
	if (hips) numElements++;

	if (numElements == 0) return null;

	var structure = DuAEF.Duik.Structure.addStructure(numElements,comp);

	//name and move

	//element index we're working on
	var currentElement = 0;

	//size of the spine
	var size = comp.height/3;

	//position of the next limb
	var nextPosition = [comp.width/2,comp.height*3/4];

	if (hips)
	{
		var element = structure.elements[currentElement];
		element.transform.position.setValue(nextPosition);
		element.name = DuAEF.DuAE.Comp.newUniqueLayerName("S | Hips",comp);
		element.effect(DuAEF.Duik.PseudoEffectsMatchNames.STRUCTURE_ELEMENT)(4).setValue(DuAEF.DuJS.Color.Colors.RAINBOX_RED);
		DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.AUTORIG_ELEMENT,DuAEF.Duik.Autorig.Elements.HIPS);
		nextPosition = [0,-size/6];
		currentElement++;
	}
	for (var i = 0 ; i < spineCount ; i++)
	{
		var element = structure.elements[currentElement];
		element.transform.position.setValue(nextPosition);
		element.name = DuAEF.DuAE.Comp.newUniqueLayerName("S | Spine",comp);
		element.effect(DuAEF.Duik.PseudoEffectsMatchNames.STRUCTURE_ELEMENT)(4).setValue(DuAEF.DuJS.Color.Colors.ORANGE);
		DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.AUTORIG_ELEMENT,DuAEF.Duik.Autorig.Elements.SPINE);
		DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.AUTORIG_ELEMENT_NUMBER,i+1);
		nextPosition = [0,-size/spineCount];
		currentElement++;
	}
	for (var i = 0 ; i < neckCount ; i++)
	{
		var element = structure.elements[currentElement];
		element.transform.position.setValue(nextPosition);
		element.name = DuAEF.DuAE.Comp.newUniqueLayerName("S | Neck",comp);
		element.effect(DuAEF.Duik.PseudoEffectsMatchNames.STRUCTURE_ELEMENT)(4).setValue(DuAEF.DuJS.Color.Colors.YELLOW);
		DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.AUTORIG_ELEMENT,DuAEF.Duik.Autorig.Elements.NECK);
		DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.AUTORIG_ELEMENT_NUMBER,i+1);
		nextPosition = [0,-size/6/neckCount];
		currentElement++;
	}
	if (head)
	{
		var element = structure.elements[currentElement];
		element.transform.position.setValue(nextPosition);
		element.name = DuAEF.DuAE.Comp.newUniqueLayerName("S | Head",comp);
		element.effect(DuAEF.Duik.PseudoEffectsMatchNames.STRUCTURE_ELEMENT)(4).setValue(DuAEF.DuJS.Color.Colors.LIGHT_BLUE);
		DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.AUTORIG_ELEMENT,DuAEF.Duik.Autorig.Elements.HEAD);
		nextPosition = [0,-size/3];
		currentElement++;
	}
	var element = structure.elements[currentElement];
	element.transform.position.setValue(nextPosition);
	element.name = DuAEF.DuAE.Comp.newUniqueLayerName("S | Spine Tip",comp);
	DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.AUTORIG_ELEMENT,DuAEF.Duik.Autorig.Elements.SPINE_TIP);

	return structure;
}

/**
 * Creates a predefined structure for a tail.
 * @memberof DuAEF.Duik.Structure
 * @param {int} [elementCount=2] - the number of elements for the tail
 * @param {CompItem} [comp] - The composition where to create the structure. By default, will try with the active item, if any.
 * @return {Structure|null} The structure.
 */
DuAEF.Duik.Structure.createTail = function(elementCount,comp)
{
	if (comp == undefined) comp = DuAEF.DuAE.Project.getActiveComp();
	if (!comp) return null;

	//create structure
	if (elementCount === undefined) elementCount = 3;
	if (elementCount == 0) return;

	var structure = DuAEF.Duik.Structure.addStructure(elementCount,comp, "Tail");

	for (var i = 0 ; i < elementCount ; i++)
	{
		var element = structure.elements[i];
		if (i < elementCount/3) element.effect(DuAEF.Duik.PseudoEffectsMatchNames.STRUCTURE_ELEMENT)(4).setValue(DuAEF.DuJS.Color.Colors.ORANGE);
		else if (i < elementCount*2/3) element.effect(DuAEF.Duik.PseudoEffectsMatchNames.STRUCTURE_ELEMENT)(4).setValue(DuAEF.DuJS.Color.Colors.YELLOW);
		else element.effect(DuAEF.Duik.PseudoEffectsMatchNames.STRUCTURE_ELEMENT)(4).setValue(DuAEF.DuJS.Color.Colors.LIGHT_BLUE);
		DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.AUTORIG_ELEMENT,DuAEF.Duik.Autorig.Elements.TAIL);
		DuAEF.Duik.setDuikMarkerParameter(element,DuAEF.Duik.MarkerParameters.AUTORIG_ELEMENT_NUMBER,i+1);
	}
	DuAEF.Duik.setDuikMarkerParameter(structure.elements[elementCount],DuAEF.Duik.MarkerParameters.AUTORIG_ELEMENT,DuAEF.Duik.Autorig.Elements.TAIL_TIP);

}

/**
* Animation tools
* @namespace
* @memberof DuAEF.Duik
*/
DuAEF.Duik.Animation = {};

/**
* Automatically adjust the best bezier interpolations on the keyframes
* @param {Property|PropertyInfo} prop - The property containing the keyframes
* @param {boolean} [easeStart=true] - true to ease the first keyframe, false to set it to linear
* @param {boolean} [easeEnd=true] - true to ease the last keyframe, false to set it to linear
* @todo ability to change ease influence (only when velocity is 0?)
* @todo implement a better multidimensionnal algo
*/
DuAEF.Duik.Animation.smartInterpolation = function (prop,easeStart,easeEnd)
{
	if (prop instanceof PropertyInfo) prop = prop.getProperty();
	if (!prop.canVaryOverTime) return;

	//set all keys to linear
	for (var k=0;k<prop.selectedKeys.length;k++)
	{
		prop.setInterpolationTypeAtKey(prop.selectedKeys[k],KeyframeInterpolationType.LINEAR);
		if (prop.isSpatial) prop.setRovingAtKey(prop.selectedKeys[k],false);
	}

	//smooth!
	for (var k=0;k<prop.selectedKeys.length;k++)
	{
		var key = prop.selectedKeys[k];
		var easeIn = [];
		var easeOut = [];
		//Compute base velocity
		for (var l = 0;l<prop.keyInTemporalEase(key).length;l++)
		{
			var speedIn = prop.keyInTemporalEase(key)[l].speed;
			var speedOut = prop.keyOutTemporalEase(key)[l].speed;
			var speed = 0;

			if ( Math.abs(speedIn) <= Math.abs(speedOut) ) speed = speedIn;
			else speed = speedOut;
			if (( speedIn > 0 && speedOut < 0 ) || ( speedIn < 0 && speedOut > 0 )) speed = 0;
			if (key == prop.numKeys) speed = 0;
			if (key == 1) speed = 0;

			easeIn.push(new KeyframeEase(speed,33));
			easeOut.push(new KeyframeEase(speed, 33));
		}
		prop.setTemporalEaseAtKey(key,easeIn,easeOut);

		//depending on options, remove ease on first and last keyframes
		if (key == prop.numKeys && !easeEnd)
		{
			prop.setInterpolationTypeAtKey(prop.selectedKeys[k],KeyframeInterpolationType.LINEAR);
			if (prop.isSpatial) prop.setRovingAtKey(prop.selectedKeys[k],false);
		}
		if (key == 1 && !easeStart)
		{
			prop.setInterpolationTypeAtKey(prop.selectedKeys[k],KeyframeInterpolationType.LINEAR);
			if (prop.isSpatial) prop.setRovingAtKey(prop.selectedKeys[k],false);
		}
	}

	//Adjust velocities
	for (var k=prop.selectedKeys.length-1;k>=0;k--)
	{
		var key = prop.selectedKeys[k];
		var easeIn = [];
		var easeOut = [];
		if (key < prop.numKeys && key > 1)
		{
			for (var l = 0;l<prop.keyInTemporalEase(key).length;l++)
			{

				var nextSpeed = prop.keyInTemporalEase(key+1)[l].speed;
				var speed = prop.keyOutTemporalEase(key)[l].speed;
				var defaultSpeed = ( prop.valueAtTime(prop.keyTime(key+1),true)-prop.valueAtTime(prop.keyTime(key),true) ) / (prop.keyTime(key+1) - prop.keyTime(key));

				var nextAbsSpeed = Math.abs(nextSpeed);
				var absSpeed = Math.abs(speed);

				var nextDif = nextSpeed - defaultSpeed;
				var dif = speed - defaultSpeed;

				if (speed != 0)
				{
					if (nextAbsSpeed < absSpeed)
					{
						var fix = (1-nextAbsSpeed/absSpeed)*absSpeed;
					}
					else if (nextAbsSpeed != 0)
					{
						var fix = (1-absSpeed/nextAbsSpeed)*absSpeed;
					}

					if (-nextDif > dif) speed += fix;
					else speed -= fix;

				}
				easeIn.push(new KeyframeEase(speed,33));
				easeOut.push(new KeyframeEase(speed, 33));
			}
			prop.setTemporalEaseAtKey(key,easeIn,easeOut);
		}
	}
}

/**
* Creates a motion trail for the layer
* @param {CompItem} [comp] - The comp where to create the trails, can be omitted if you provide a layer
* @param {Layer} [layer] - The layer source of the motion. If not provided, will just create an empty motion trail control
* @param {ShapeLayer|null} [trailLayer] - An existing shape layer containing the trails
* @param {float[]|null} [color] - A color for the motion trail. If not provided, random
* @return {ShapeLayer} The layer containing the motion trail created
*/
DuAEF.Duik.Animation.motionTrail = function (comp,layer,trailLayer,color)
{
	if (comp == undefined && layer == undefined) return;
	if (comp == undefined) comp = layer.containingComp;
	if (color == undefined || color == null) color = DuAEF.DuJS.Color.random();

	//create layer
	if (trailLayer == undefined || trailLayer == null)
	{
		trailLayer = comp.layers.addShape();
		DuAEF.Duik.setDuikMarker(trailLayer,"Motion Trail",DuAEF.Duik.LayerTypes.MOTION_TRAIL);
		trailLayer.name = DuAEF.DuAE.Comp.newUniqueLayerName('Motion Trails',comp);
	}

	//Effect

	var newEffectName = DuAEF.DuAE.Layer.newUniqueEffectName('Motion trail 1',trailLayer);
	//trailLayer.applyPreset(DuAEF.Duik.PseudoEffects.MOTION_TRAIL);
	var effect = DuAEF.DuAE.Layer.addPseudoEffect(trailLayer,DuAEF.Duik.PseudoEffects.MOTION_TRAIL,DuAEF.Duik.PseudoEffectsMatchNames.MOTION_TRAIL);
	effect.name = newEffectName;

	//create shape
	var trailGroup = trailLayer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
	trailGroup.name = effect.name;
	var trailPath = trailGroup("ADBE Vectors Group").addProperty("ADBE Vector Shape - Group");
	trailPath = trailPath.property("ADBE Vector Shape");
	trailPath.expression = '//Duik.motionTrail\n' +
						'var fx = effect("' + effect.name + '");\n' +
						'var layer = null;\n' +
						'try {layer = fx(1);} catch(e){}\n' +
						'if (layer != null) {\n' +
						'var inFrame = fx(2).value;\n' +
						'var outFrame = fx(3).value;\n' +
						'var method = fx(5).value;\n' +
						'var samples = fx(10).value;\n' +
						'var points = [];\n' +
						'var currentFrame = timeToFrames(time);\n' +
						'if (inFrame > outFrame) inFrame = -inFrame;\n' +
						'else if (inFrame == outFrame) inFrame = -1;\n' +
						'var prevPos = null;\n' +
						'var autoSampleLimit = 1/(20*samples)*(thisComp.width+thisComp.height);\n' +
						'for (var i = currentFrame+outFrame ; i >= currentFrame+inFrame; i--)\n' +
						'{\n' +
						'var t = framesToTime(i);\n' +
						'var pos = layer.toWorld( layer.anchorPoint, t );\n' +
						'var subSamples = 0;\n' +
						'if (method == 2 && prevPos)\n' +
						'{\n' +
						'var step = length(pos,prevPos);\n' +
						'var stepRatio = step/autoSampleLimit;\n' +
						'if (stepRatio > 1) subSamples = Math.floor(stepRatio);\n' +
						'}\n' +
						'else if (method == 3) subSamples = samples;\n' +
						'if (method == 2 || method == 3)\n' +
						'{\n' +
						't = t+thisComp.frameDuration;\n' +
						'for (var j = 0;j < subSamples ; j++)\n' +
						'{\n' +
						't = t-thisComp.frameDuration/subSamples;\n' +
						'var subPos = layer.toWorld( layer.anchorPoint, t );\n' +
						'subPos = subPos - position;\n' +
						'points.push( subPos );\n' +
						'}\n' +
						'}\n' +
						'prevPos = pos;\n' +
						'pos = pos - position;\n' +
						'points.push( pos );\n' +
						'}\n' +
						'createPath(points,[],[], false);\n' +
						'} else value';

	var trailStroke = trailGroup("ADBE Vectors Group").addProperty("ADBE Vector Graphic - Stroke");

	trailStroke('ADBE Vector Stroke Color').expression = '//Duik.motionTrail\n' +
													'var fx = effect("' + effect.name + '");\n' +
													'fx(13);';

	trailStroke('ADBE Vector Stroke Opacity').expression = '//Duik.motionTrail\n' +
													'var fx = effect("' + effect.name + '");\n' +
													'fx(14);';

	trailStroke('ADBE Vector Stroke Width').expression = '//Duik.motionTrail\n' +
													'var fx = effect("' + effect.name + '");\n' +
													'fx(15);';

	//set layer
	if (layer != undefined) effect(1).setValue(layer.index);
	//set color
	effect(13).setValue(color);

	return trailLayer;
}

/**
* Adds animation exposure controls
* @param {CompItem} comp - The comp where to create the X-Sheet
* @param {Property|PropertyInfo} [prop] - The property controlled. If not provided, will add an X-Sheet adjustment layer in the comp.
* @param {PropertyGroup|null} [effect] - an X-Sheet effect already created to use as a control for the prop
* @return {PropertyGroup} The effect used to control
*/
DuAEF.Duik.Animation.xSheet = function (comp,prop,effect)
{
	var createLayer = prop == undefined;
	if (effect == undefined) effect = null;
	if (!createLayer)
	{
		if (!(prop instanceof PropertyInfo)) prop = new PropertyInfo(prop);
		if (!prop.riggable) return effect;

		var layer = prop.layer;
		comp = layer.containingComp;

		//add effect
		if (effect == null) effect = DuAEF.DuAE.Layer.addPseudoEffect(layer,DuAEF.Duik.PseudoEffects.X_SHEET,DuAEF.Duik.PseudoEffectsMatchNames.X_SHEET,prop.getProperty().name + " X-Sheet");
		var effectLink = "var fx = " + DuAEF.DuAE.Property.getExpressionLink(effect,true);
		prop.getProperty().expression = '//Duik.XSheet\n' + effectLink + '\n' +
					'var mode = fx(7);\n' +
					'var frameDuration = fx(14).value;\n' +
					'var xSheet = fx(19);\n' +
					'var result = value;\n' +
					'function getValAtKey(prop)\n' +
					'{\n' +
					'if (prop.numKeys > 0)\n' +
					'{\n' +
					'var k = prop.nearestKey(time);\n' +
					'if (k.time > time && k.index > 1) k = prop.key(k.index-1);\n' +
					'return valueAtTime(k.time);\n' +
					'}\n' +
					'else return value;\n' +
					'}\n' +
					'if (mode == 1)\n' +
					'{\n' +
					'frameDuration = Math.round(frameDuration);\n' +
					'timef = timeToFrames(time);\n' +
					'result = valueAtTime(framesToTime( timef - timef%frameDuration ))\n' +
					'}\n' +
					'else if (mode == 2) result = getValAtKey(xSheet);\n' +
					'else if (mode == 3) result = getValAtKey(thisLayer.marker);\n' +
					'else result = getValAtKey(thisComp.marker);\n' +
					'result;';
	}
	else
	{
		if (comp == undefined) return effect;
		var newName = DuAEF.DuAE.Comp.newUniqueLayerName("X-Sheet",comp);
		var layer = DuAEF.DuAE.Comp.addAdjustmentLayer(comp);
		layer.name = newName;
		DuAEF.Duik.setDuikMarker(layer,"X-Sheet",DuAEF.Duik.LayerTypes.X_SHEET);

		//add Effects
		effect = DuAEF.DuAE.Layer.addPseudoEffect(layer,DuAEF.Duik.PseudoEffects.X_SHEET,DuAEF.Duik.PseudoEffectsMatchNames.X_SHEET,"X-Sheet");

		var timeWarp = layer('ADBE Effect Parade').addProperty('ADBE Timewarp');
		timeWarp(1).setValue(1);
		timeWarp(2).setValue(2);

		timeWarp(4).expression = '//Duik.XSheet\n' +
										'var fx = effect("X-Sheet")\n' +
										'var mode = fx(7);\n' +
										'var frameDuration = fx(14).value;\n' +
										'var xSheet = fx(19);\n' +
										'var result = timeToFrames(time);\n' +
										'function getValAtKey(prop)\n' +
										'{\n' +
										'if (prop.numKeys > 0)\n' +
										'{\n' +
										'var k = prop.nearestKey(time);\n' +
										'if (k.time > time && k.index > 1) k = prop.key(k.index-1);\n' +
										'return timeToFrames(k.time);\n' +
										'}\n' +
										'else return timeToFrames(time);\n' +
										'}\n' +
										'if (mode == 1)\n' +
										'{\n' +
										'frameDuration = Math.round(frameDuration);\n' +
										'timef = timeToFrames(time);\n' +
										'result = timef - timef%frameDuration;\n' +
										'}\n' +
										'else if (mode == 2) result = getValAtKey(xSheet);\n' +
										'else if (mode == 3) result = getValAtKey(thisLayer.marker);\n' +
										'else result = getValAtKey(thisComp.marker);\n' +
										'result;\n';
	}

	return effect;
}

/**
* Activate the time remapping on the layers, adding some useful controls or expressions
* @param {Layer[]|LayerCollection} layers - The layers
* @param {string} [loopType] - Looping time, 'in' or 'out'
*/
DuAEF.Duik.Animation.timeRemap = function (layers,loopType)
{
	if (layers == undefined) return;
	if (layers.length == 0 ) return;
	var it = new Iterator(layers);
	while (!it.atEnd)
	{
		it.next();
		var layer = layers[it.current];
		if (!layer.canSetTimeRemapEnabled) continue;

		var comp = layer.containingComp;
		var lastValueTime = layer.outPoint - comp.frameDuration;

		if (!layer.timeRemapEnabled) layer.timeRemapEnabled = true;

		layer.timeRemap.setValueAtTime(lastValueTime,layer.timeRemap.valueAtTime(lastValueTime,true));
		layer.timeRemap.removeKey(3);
		if (loopType == "out")
		{
			layer.timeRemap.setValueAtTime(lastValueTime+comp.frameDuration,0);
			layer.timeRemap.expression = "loopOut();";
		}
		if (loopType == "in")
		{
			layer.timeRemap.setValueAtTime(lastValueTime+comp.frameDuration,0);
			layer.timeRemap.expression = "loopIn();";
			layer.inPoint = 0;
		}
	}
}

/**
* Cel animation tools
* @namespace
* @memberof DuAEF.Duik
*/
DuAEF.Duik.CelAnimation = {};

/**
* Creates a new animation cel on the layer
* @param {CompItem} comp - The composition
* @param {AVLayer|null} [layer] - The layer where to create the cel
*/
DuAEF.Duik.CelAnimation.createCel = function (comp,layer)
{
	if (comp == undefined) return;

	if (layer == undefined || layer == null)
	{
		//create solid
		layer = comp.layers.addSolid([0,0,0], DuAEF.DuAE.Comp.newUniqueLayerName("Cel",comp) , comp.width, comp.height, comp.pixelAspect , comp.duration);
		DuAEF.Duik.setDuikMarker(layer,"Cel",DuAEF.Duik.LayerTypes.CEL);
	}

	var first = true;
	for (var i = 1 ; i <= layer('ADBE Effect Parade').numProperties ; i++)
	{
		if (layer.effect(i).matchName == 'ADBE Paint')
		{
			first = false;
			break;
		}
	}

	var newName = DuAEF.DuAE.Layer.newUniqueEffectName('Celluloid',layer);
	var paint = layer('ADBE Effect Parade').addProperty('ADBE Paint');
	paint.name = newName;

	if (first) paint.property('ADBE Paint On Transparent').setValue(true);

}

/**
* Activates or deactivates the onion skin on a cel
* @param {AVLayer} layer - The layer with the cel
* @param {OnionSkin} onionSkin - Onion skin parameters
*/
DuAEF.Duik.CelAnimation.onionSkin = function (layer,onionSkin)
{
	if (layer == undefined) return;
	if (onionSkin == undefined)
	{
		onionSkin = new OnionSkin();
		onionSkin.activated = true;
	}
	activate = onionSkin.activated;
	onionDuration = onionSkin.duration;
	exposure = onionSkin.exposure;
	inOpacity = onionSkin.inOpacity;
	outOpacity = onionSkin.outOpacity;

	var comp = layer.containingComp;
	for (var i = 1 ; i <= layer.Effects.numProperties ; i++)
	{
		var paint = layer.effect(i);
		if (!paint) continue;
		if (paint.matchName != "ADBE Paint") continue;
		if (paint.name.indexOf('Celluloid') < 0) continue;
		for (var j = 1 ; j <= paint.property("ADBE Paint Group").numProperties ; j++)
		{
			var stroke = paint.property("ADBE Paint Group")(j);
			if (stroke.matchName != "ADBE Paint Atom") continue;

			var inPoint = stroke.property("ADBE Paint Duration").value[0];
			var duration = stroke.property("ADBE Paint Duration").value[1];

			//adjust expo
			if (stroke.name.indexOf("#Duik") < 0)
			{
				duration = exposure*comp.frameDuration;
				stroke.property("ADBE Paint Duration").setValue([inPoint,duration]);
				stroke.name = stroke.name + " #Duik";
			}

			if (activate)
			{
				//stroke.property("ADBE Paint Transfer Mode") : blending mode
				var outPoint = duration + inPoint;
				var opacity = stroke.property("ADBE Paint Properties").property("ADBE Paint Opacity");
				//if keyframes (already activated)
				if (opacity.numKeys > 0)
				{
					if (stroke.name.indexOf("#Out") >= 0 && stroke.name.indexOf("#In") < 0)
					{
						outPoint = opacity.keyTime(2) - layer.startTime;
					}
					else if (stroke.name.indexOf("#Out") < 0 && stroke.name.indexOf("#In") >= 0)
					{
						inPoint = opacity.keyTime(3) - layer.startTime;
					}
					else if (stroke.name.indexOf("#Out") >= 0 && stroke.name.indexOf("#In") >= 0)
					{
						inPoint = opacity.keyTime(3) - layer.startTime;
						outPoint = opacity.keyTime(5) - layer.startTime;
					}

					//remove keys
					while (opacity.numKeys>0)
					{
						opacity.removeKey(1);
					}
					opacity.setValue(100);
					stroke.name = stroke.name.replace(/ #Out/g,"");
					stroke.name = stroke.name.replace(/ #In/g,"");
				}

				//set duration
				if (outOpacity > 0 && inOpacity <= 0)
				{
					duration = outPoint - inPoint + onionDuration*comp.frameDuration;
					stroke.property("ADBE Paint Duration").setValue([inPoint,duration]);
				}
				else if (outOpacity <= 0 && inOpacity > 0)
				{
					duration = outPoint - inPoint + onionDuration*comp.frameDuration;
					stroke.property("ADBE Paint Duration").setValue([inPoint-onionDuration*comp.frameDuration,duration]);
				}
				else
				{
					duration = outPoint - inPoint + 2*onionDuration*comp.frameDuration;
					stroke.property("ADBE Paint Duration").setValue([inPoint-onionDuration*comp.frameDuration,duration]);
				}


				//add keyframes
				if (outOpacity > 0)
				{
				opacity.setValueAtTime(outPoint-comp.frameDuration+layer.startTime,100);
				opacity.setValueAtTime(outPoint+layer.startTime,outOpacity);
				opacity.setValueAtTime(outPoint + onionDuration*comp.frameDuration+layer.startTime,0);
				stroke.name = stroke.name + " #Out";
				}
				if (inOpacity > 0)
				{
				opacity.setValueAtTime(inPoint+layer.startTime,100);
				opacity.setValueAtTime(inPoint-onionDuration*comp.frameDuration+layer.startTime,0);
				opacity.setValueAtTime(inPoint-comp.frameDuration+layer.startTime,inOpacity);
				stroke.name = stroke.name + " #In";
				}

			}
			else
			{
				var opacity = stroke.property("ADBE Paint Properties").property("ADBE Paint Opacity");
				if (opacity.numKeys > 0)
				{
				inPoint = 0;
				outPoint = 1;
				if (stroke.name.indexOf("#Out") >= 0 && stroke.name.indexOf("#In") < 0)
				{
				inPoint = stroke.property("ADBE Paint Duration").value[0];
				outPoint = opacity.keyTime(2);
				}
				else if (stroke.name.indexOf("#Out") < 0 && stroke.name.indexOf("#In") >= 0)
				{
				outPoint = stroke.property("ADBE Paint Duration").value[0] + stroke.property("ADBE Paint Duration").value[1];
				inPoint = opacity.keyTime(3);
				}
				else if (stroke.name.indexOf("#Out") >= 0 && stroke.name.indexOf("#In") >= 0)
				{
				inPoint = opacity.keyTime(3);
				outPoint = opacity.keyTime(5);
				}


				while (opacity.numKeys>0)
				{
				opacity.removeKey(1);
				}
				opacity.setValue(100);
				//set duration
				var o = outPoint-inPoint;
				var i = inPoint;
				if (stroke.name.indexOf("#Out") >= 0 && stroke.name.indexOf("#In") < 0) o = o-layer.startTime;
				else if (stroke.name.indexOf("#Out") < 0) o = o + layer.startTime;
				if (stroke.name.indexOf("#In") >= 0) i = i-layer.startTime;

				stroke.property("ADBE Paint Duration").setValue([i,o]);

				stroke.name = stroke.name.replace(/ #In/g,"");
				stroke.name = stroke.name.replace(/ #Out/g,"");
				}
			}
		}
	}
	//deselect
	while(layer.selectedProperties.length > 0)
	{
		layer.selectedProperties[0].selected = false;
	}
}

/**
* Automations
* @namespace
* @memberof DuAEF.Duik
*/
DuAEF.Duik.Automation = {};

/**
* Adds a list on a property
 * @memberof DuAEF.Duik.Automation
* @param {PropertyInfo} prop - The Property
*/
DuAEF.Duik.Automation.list = function (prop)
{
	if (prop == undefined) throw "Missing Param 1: list needs a Property";
	if (!prop.riggable) return;

	var dim = prop.dimensions;

	var layer =prop.layer;
	var comp = layer.containingComp;

	layer.selected = true;
	if (dim == 1) layer.applyPreset(DuAEF.Duik.PseudoEffects.ONED_LIST);
	else if (dim == 2)layer.applyPreset(DuAEF.Duik.PseudoEffects.TWOD_LIST);
	else if (dim == 3) layer.applyPreset(DuAEF.Duik.PseudoEffects.THREED_LIST);
	else { layer.selected = false; return;}
	layer.selected = false;


	var effect = layer.effect("List");
	effect.name = DuAEF.DuAE.Layer.newUniqueEffectName(prop.getProperty().name + ' List',layer);

	//set animation with expression
	var anim = DuAEF.DuAE.Property.getAnim(prop,false);
	if (anim) DuAEF.DuAE.Property.setAnim(effect(2),anim,0,true,true,true);
	DuAEF.DuAE.Property.removeAnim(prop);

	prop.getProperty().expression =  "//Duik.list\r\n" +
					"var fx = effect(\"" + effect.name + "\");\n" +
					"var v1 = fx(2);\n" +
					"var w1 = fx(3);\n" +
					"var v2 = fx(6);\n" +
					"var w2 = fx(7);\n" +
					"var v3 = fx(10);\n" +
					"var w3 = fx(11);\n" +
					"var v4 = fx(14);\n" +
					"var w4 = fx(15);\n" +
					"var v5 = fx(18);\n" +
					"var w5 = fx(19);\n" +
					"v1*w1/100+v2*w2/100+v3*w3/100+v4*w4/100+v5*w5/100;";
}

/**
 * Adds a wiggle to a property
 * @memberof DuAEF.Duik.Automation
 * @param {PropertyInfo}	prop 				- The property.
 * @param {boolean}		[separateDimensions] 	- Set to true to separate the dimensions (to adjust amplitude and frequency) if the property is multi-dimensionnal.
 * @param {PropertyGroup|null}	[effect]	- A wiggle effect already created by Duik to use as a controller for this wiggle
 * @return {PropertyGroup} The effect created (or provided)
 */
DuAEF.Duik.Automation.wiggle = function (prop,separateDimensions,effect)
{
	if (separateDimensions == undefined) separateDimensions = false;
	if (effect == undefined) effect = null;
	if (!prop) return effect;
	if (!prop.riggable) return effect;

	//dimensions
	var dimensions = prop.dimensions;
	var layer = prop.layer;
	var comp = layer.containingComp;

	if (effect == null)
	{
		layer.selected = true;
		if (!separateDimensions && dimensions > 1) layer.applyPreset(DuAEF.Duik.PseudoEffects.ONED_MULTIWIGGLE);
		else if (dimensions == 3) layer.applyPreset(DuAEF.Duik.PseudoEffects.THREED_WIGGLE);
		else if (dimensions == 2) layer.applyPreset(DuAEF.Duik.PseudoEffects.TWOD_WIGGLE);
		else layer.applyPreset(DuAEF.Duik.PseudoEffects.ONED_WIGGLE);
		layer.selected = false;

		effect = layer.effect("Wiggle");
		effect.name = DuAEF.DuAE.Layer.newUniqueEffectName(prop.getProperty().name + ' Wiggle',layer);
	}

	var compEffect = DuAEF.DuAE.Property.getComp(effect);
	var sameComp = compEffect.name == comp.name;

	if (effect.matchName == DuAEF.Duik.PseudoEffectsMatchNames.ONED_MULTIWIGGLE) effect(3).setValue(comp.duration);
	else if (effect.matchName == DuAEF.Duik.PseudoEffectsMatchNames.THREED_WIGGLE) effect(13).setValue(comp.duration);
	else if (effect.matchName == DuAEF.Duik.PseudoEffectsMatchNames.TWOD_WIGGLE) effect(9).setValue(comp.duration);
	else if (effect.matchName == DuAEF.Duik.PseudoEffectsMatchNames.ONED_WIGGLE) effect(3).setValue(comp.duration);
	//TODO Wiggle for other types of properties
	var effectLink = "var fx = " + DuAEF.DuAE.Property.getExpressionLink(effect,sameComp);

	if (!separateDimensions && dimensions > 1)
	{
		prop.getProperty().expression = "//Duik.1DMultiWiggle\n" + effectLink + "\n" +
				"freq = fx(2);\n" +
				"amp = fx(1);\n" +
				"linked = fx(4).value;\n" +
				"loop = fx(3);\n" +
				"if (loop == 0) loop = thisComp.duration;\n" +
				"t = (time % loop)-loop;\n" +
				"w1 = wiggle(freq,amp, 1, 0.5, t);\n" +
				"w2 = wiggle(freq,amp, 1, 0.5, t - loop);\n" +
				"w = ease(t, -loop,  0, w1, w2);\n" +
				"result = [];\n" +
				"if(linked) while (result.length < value.length) result.push(w[0]);\n" +
				"else result = w;\n" +
				"result + value - valueAtTime(0);";
	}
	else if (dimensions == 3)
	{
		prop.getProperty().expression = "//Duik.3DWiggle\n" + effectLink + "\n" +
				"Xfreq = fx(3);\n" +
				"Yfreq = fx(7);\n" +
				"Zfreq = fx(11);\n" +
				"Xamp = fx(2);\n" +
				"Yamp = fx(6);\n" +
				"Zamp = fx(10);\n" +
				"loop = fx(13);\n" +
				"if (loop == 0) loop = thisComp.duration;\n" +
				"t = (time % loop)-loop;\n" +
				"X1 = wiggle(Xfreq,Xamp, 1, 0.5, t);\n" +
				"Y1 = wiggle(Yfreq,Yamp, 1, 0.5, t);\n" +
				"Z1 = wiggle(Zfreq,Zamp, 1, 0.5, t);\n" +
				"w1 = [X1[0],Y1[1],Z1[2]];\n" +
				"X2 = wiggle(Xfreq,Xamp, 1, 0.5, t - loop);\n" +
				"Y2 = wiggle(Yfreq,Yamp, 1, 0.5, t - loop);\n" +
				"Z2 = wiggle(Zfreq,Zamp, 1, 0.5, t - loop);\n" +
				"w2 = [X2[0],Y2[1],Z2[2]];\n" +
				"w = ease(t, -loop,  0, w1, w2);\n" +
				"w + value - valueAtTime(0)";
	}
	else if (dimensions == 2)
	{
	 	prop.getProperty().expression = "//Duik.2DWiggle\n" + effectLink + "\n" +
				"Xfreq = fx(3);\n" +
				"Yfreq = fx(7);\n" +
				"Xamp = fx(2);\n" +
				"Yamp = fx(6);\n" +
				"loop = fx(9);\n" +
				"if (loop == 0) loop = thisComp.duration;\n" +
				"t = (time % loop)-loop;\n" +
				"X1 = wiggle(Xfreq,Xamp, 1, 0.5, t);\n" +
				"Y1 = wiggle(Yfreq,Yamp, 1, 0.5, t);\n" +
				"w1 = [X1[0],Y1[1]];\n" +
				"X2 = wiggle(Xfreq,Xamp, 1, 0.5, t - loop);\n" +
				"Y2 = wiggle(Yfreq,Yamp, 1, 0.5, t - loop);\n" +
				"w2 = [X2[0],Y2[1]];\n" +
				"w = ease(t, -loop,  0, w1, w2);\n" +
				"w + value - valueAtTime(0)";
	}
	else if (dimensions == 1)
	{
		prop.getProperty().expression = "//Duik.1DWiggle\n" + effectLink + "\n" +
				"freq = fx(2);\n" +
				"amp = fx(1);\n" +
				"loop = fx(3);\n" +
				"if (loop == 0) loop = thisComp.duration;\n" +
				"t = (time % loop)-loop;\n" +
				"w1 = wiggle(freq,amp, 1, 0.5, t);\n" +
				"w2 = wiggle(freq,amp, 1, 0.5, t - loop);\n" +
				"w = ease(t, -loop,  0, w1, w2);\n" +
				"w + value - valueAtTime(0)";
	}

	return effect;
}

/**
 * Adds a swing to a property
 * @memberof DuAEF.Duik.Automation
 * @param {PropertyInfo}	prop 				- The property.
 */
DuAEF.Duik.Automation.swing = function (prop)
{
	if (!prop) return;
	if (!prop.riggable) return;

	var dimensions = prop.dimensions;
	var layer = prop.layer;

	if (dimensions < 1 || dimensions > 3) return;

	layer.selected = true;
	if (prop.getProperty().isSpatial) layer.applyPreset(DuAEF.Duik.PseudoEffects.SPATIAL_SWING);
	else if (dimensions == 1) layer.applyPreset(DuAEF.Duik.PseudoEffects.ONED_SWING);
	else if (dimensions == 2) layer.applyPreset(DuAEF.Duik.PseudoEffects.TWOD_SWING);
	else if (dimensions == 3) layer.applyPreset(DuAEF.Duik.PseudoEffects.THREED_SWING);
	layer.selected = false;
	var effect = layer.effect("Swing");
	effect.name = DuAEF.DuAE.Layer.newUniqueEffectName(prop.getProperty().name + ' Swing',layer);



	if (prop.getProperty().isSpatial)
	{
		prop.getProperty().expression = 	'//Duik.spatialSwing\n' +
					'var fx = effect("' + effect.name + '");\n' +
					'var amp = fx(1);\n' +
					'var freq = fx(2);\n' +
					'var offset = fx(3);\n' +
					'var ease = Math.abs(fx(4));\n' +
					'var angle = fx(5)/180*Math.PI;\n' +
					'var result = [0,0];\n' +
					'if (freq > 0)\n' +
					'{\n' +
					'offset = offset/100/freq;\n' +
					'sin = Math.sin((time+offset)*freq*2*Math.PI);\n' +
					'for(i=0;i<ease;i++) {\n' +
					'sin = Math.sin(sin*Math.PI/2);\n' +
					'}\n' +
					'sin = sin*amp;\n' +
					'result = [0,sin];\n' +
					'var x = -sin*Math.sin(angle);\n' +
					'var y = sin*Math.cos(angle);\n' +
					'result = [ x,y ] ;\n' +
					'}\n' +
					'result + value;\n';
	}
	else if (dimensions == 1)
	{
		prop.getProperty().expression = '//Duik.Swing\n' +
					'var fx = effect("' + effect.name + '");\n' +
					'var amp = fx(1);\n' +
					'var freq = fx(2);\n' +
					'var offset = fx(3);\n' +
					'var ease = fx(4);\n' +
					'var result = 0;\n' +
					'if (freq > 0)\n' +
					'{\n' +
					'offset = offset/100/freq;\n' +
					'sin = Math.sin((time+offset)*freq*2*Math.PI);\n' +
					'for(i=0;i<ease;i++) {\n' +
					'sin = Math.sin(sin*Math.PI/2);\n' +
					'}\n' +
					'result = sin*amp;\n' +
					'}\n' +
					'result + value;';
	}
	else if (dimensions == 2)
	{
		prop.getProperty().expression = '//Duik.Swing\n' +
					'var fx = effect("' + effect.name + '");\n' +
					'var amp = fx(1);\n' +
					'var freq = fx(2);\n' +
					'var offset = fx(3);\n' +
					'var ease = fx(4);\n' +
					'var axis = fx(5);\n' +
					'var result = 0;\n' +
					'if (freq > 0)\n' +
					'{\n' +
					'offset = offset/100/freq;\n' +
					'sin = Math.sin((time+offset)*freq*2*Math.PI);\n' +
					'for(i=0;i<ease;i++) {\n' +
					'sin = Math.sin(sin*Math.PI/2);\n' +
					'}\n' +
					'result = sin*amp;\n' +
					'}\n' +
					'if (axis == 1) result = [result,result];\n' +
					'else if (axis == 2) result =[result,0];\n' +
					'else if (axis == 3) result =[0,result];\n' +
					'result+value;';
	}
	else if (dimensions == 3)
	{
		prop.getProperty().expression = '//Duik.Swing\n' +
					'var fx = effect("' + effect.name + '");\n' +
					'var amp = fx(1);\n' +
					'var freq = fx(2);\n' +
					'var offset = fx(3);\n' +
					'var ease = fx(4);\n' +
					'var axis = fx(5);\n' +
					'var result = 0;\n' +
					'if (freq > 0)\n' +
					'{\n' +
					'offset = offset/100/freq;\n' +
					'sin = Math.sin((time+offset)*freq*2*Math.PI);\n' +
					'for(i=0;i<ease;i++) {\n' +
					'sin = Math.sin(sin*Math.PI/2);\n' +
					'}\n' +
					'result = sin*amp;\n' +
					'}\n' +
					'if (axis == 1) result = [result,result,result];\n' +
					'else if (axis == 2) result =[result,0,0];\n' +
					'else if (axis == 3) result =[0,result,0];\n' +
					'else if (axis == 4) result =[0,0,result];\n' +
					'result+value;';
	}
}

/**
 * Automates the rotation of a layer as a wheel
 * @memberof DuAEF.Duik.Automation
 * @param {Layer}	layer - The layer.
* @param {int}	[radius] - The radius of the wheel, in pixels. Will be auto-detected if possible
 */
DuAEF.Duik.Automation.wheel = function (layer,radius)
{
	if (!layer) throw "Missing Param 1: Wheel needs a Layer";
	if (radius == undefined)
	{
		var parent = layer.parent;
		layer.parent = null;
		var rect = layer.sourceRectAtTime(0,false);
		radius = rect.width/2*layer.transform.scale.value[0]/100;
		layer.parent = parent;
	}
	var rotation = layer.transform.rotation;
	if (layer.threeDLayer) rotation = layer.transform.zRotation;

	var effectName = DuAEF.DuAE.Layer.newUniqueEffectName('Wheel',layer);
	layer.selected = true;
	layer.applyPreset(DuAEF.Duik.PseudoEffects.WHEEL);
	layer.selected = false;
	var effect = layer.effect("Wheel");
	effect.name = effectName;
	effect(1).setValue(radius);

	rotation.expression = '//Duik.Wheel\n' +
						'var fx = thisLayer.effect("' + effect.name + '");\n' +
						'var R = fx(1);\n' +
						'var Rev = fx(2);\n' +
						'var curved = fx(3) == 2;\n' +
						'function pos(frame)\n' +
						'{\n' +
						'return thisLayer.toWorld(thisLayer.anchorPoint,framesToTime(frame));\n' +
						'}\n' +
						'var result = 0;\n' +
						'if (R>0)\n' +
						'{\n' +
						'var distance = 0;\n' +
						'if (curved)\n' +
						'{\n' +
						'var start = thisLayer.inPoint > thisComp.displayStartTime ? timeToFrames(thisLayer.inPoint) : timeToFrames(thisComp.displayStartTime) ;\n' +
						'var end = time < thisLayer.outPoint ? timeToFrames(time) : timeToFrames(thisLayer.outPoint);\n' +
						'for(i=start;i<end;i++)\n' +
						'{\n' +
						'if (pos(i+1)[0] - pos(i)[0] > 0) distance += length(pos(i+1),pos(i));\n' +
						'else distance -= length(pos(i+1),pos(i));\n' +
						'}\n' +
						'}\n' +
						'else\n' +
						'{\n' +
						'distance = pos(timeToFrames(time))[0];\n' +
						'}\n' +
						'result = radiansToDegrees(distance/R);\n' +
						'}\n' +
						'Rev == 1 ? value - result : value + result;';

}

/**
* Links a property to an effector controller
* @param {PropertyInfo} prop - The property to rig
* @param {PropertyGroup|null} [effect] - A Layer expression control used to link to the effector. Will be created on the layer if not provided
* @param {ShapeLayer|null} [ctrlLayer] - The effector layer. will be created if not provided
* @return {object} A custom object with two attributes:<br />
* - effectorLayer: the effector layer
* - effect: the layer expression control on the rigged layer used to link to the effector
*/
DuAEF.Duik.Automation.effector = function (prop,effect,ctrlLayer)
{
	if (effect == undefined) effect = null;
	if (ctrlLayer == undefined) ctrlLayer = null;
	var effector = {};
	effector.effectorLayer = ctrlLayer;
	effector.effect = effect;
	if (!prop) return effector;
	if (!prop.riggable) return effector;

	var layer = prop.layer;
	var comp = layer.containingComp;

	//create effector
	if (ctrlLayer == null)
	{
		ctrlLayer = comp.layers.addShape();
		DuAEF.Duik.setDuikMarker(ctrlLayer,"Effector",DuAEF.Duik.LayerTypes.EFFECTOR);
		ctrlLayer.name = DuAEF.DuAE.Comp.newUniqueLayerName("Effector",comp);
		//effect
		ctrlLayer.selected = true;
		layer.applyPreset(DuAEF.Duik.PseudoEffects.EFFECTOR);
		//content
		var centerGroup = ctrlLayer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
		centerGroup.name = "Center";
		var centerContent = centerGroup.property("ADBE Vectors Group");
		var centerCircle = centerContent.addProperty("ADBE Vector Shape - Ellipse");
		centerCircle("ADBE Vector Ellipse Size").setValue([4,4]);
		var centerFill = centerContent.addProperty("ADBE Vector Graphic - Fill");
		centerFill("ADBE Vector Fill Color").setValue(DuAEF.DuJS.Color.Colors.BLACK);
		centerFill("ADBE Vector Fill Opacity").setValue(50);
		var innerGroup =  ctrlLayer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
		innerGroup.name = "Inner";
		var innerContent = innerGroup.property("ADBE Vectors Group");
		var innerCircle = innerContent.addProperty("ADBE Vector Shape - Ellipse");
		innerCircle("ADBE Vector Ellipse Size").expression = '//Duik.effector.inner\nvar inner = effect("Effector")(1)*2;\n[inner,inner];';
		var innerStroke = innerContent.addProperty("ADBE Vector Graphic - Stroke");
		innerStroke("ADBE Vector Stroke Color").setValue(DuAEF.DuJS.Color.Colors.GREEN);
		var outerGroup =  ctrlLayer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
		outerGroup.name = "Outer";
		var outerContent = outerGroup.property("ADBE Vectors Group");
		var outerCircle = outerContent.addProperty("ADBE Vector Shape - Ellipse");
		outerCircle("ADBE Vector Ellipse Size").expression = '//Duik.effector.outer\nvar outer = effect("Effector")(2)*2;\n[outer,outer];';
		var outerStroke = outerContent.addProperty("ADBE Vector Graphic - Stroke");
		outerStroke("ADBE Vector Stroke Color").setValue(DuAEF.DuJS.Color.Colors.RAINBOX_RED);
		//unselect
		ctrlLayer.selected = false;
		//set Defaults
		var distance = DuAEF.DuAE.Layer.getDistance(layer,ctrlLayer);
		ctrlLayer.effect("Effector")(1).setValue(distance/4);
		ctrlLayer.effect("Effector")(2).setValue(distance*3/4);
	}

	//create effect
	if (effect == null)
	{
		effect = layer('ADBE Effect Parade').addProperty('ADBE Layer Control');
		effect.name = DuAEF.DuAE.Layer.newUniqueEffectName(prop.getProperty().name + ' Effector',layer);
	}

	//Set effect
	effect(1).setValue(ctrlLayer.index);

	//set expression
	prop.getProperty().expression = '//Duik.effector\n' +
				'var ctrl = null;\n' +
				'var result = value;\n' +
				'try { ctrl = effect("' + effect.name + '")(1) } catch (e) {}\n' +
				'if (ctrl && numKeys >= 2)\n' +
				'{\n' +
				'function p(l){ return l.toWorld(l.anchorPoint) };\n' +
				'try { var fx = ctrl.effect("Effector"); } catch (e) {}\n' +
				'if (fx)\n' +
				'{\n' +
				'var min = fx(1);\n' +
				'var max = fx(2);\n' +
				'var mode = fx(3);\n' +
				'var reverse = fx(4).value;\n' +
				'var t = 0;\n' +
				'var beginTime = key(1).time;\n' +
				'var endTime = key(numKeys).time;\n' +
				'var distance = length ( p(thisLayer), p(ctrl) );\n' +
				'if (mode == 1)\n' +
				'{\n' +
				'if (!reverse) t = linear(distance, min, max, endTime, beginTime);\n' +
				'else t = linear(distance, min, max, beginTime, endTime);\n' +
				'}\n' +
				'else\n' +
				'{\n' +
				'var mid = (min + max)/2;\n' +
				'if (!reverse)\n' +
				'{\n' +
				'if (distance > mid) t = linear(distance, mid, max, endTime, beginTime);\n' +
				'else t = linear(distance, min, mid, beginTime, endTime);\n' +
				'}\n' +
				'else\n' +
				'{\n' +
				'if (distance > mid) t = linear(distance, mid, max, beginTime, endTime);\n' +
				'else t = linear(distance, min, mid, endTime, beginTime);\n' +
				'}\n' +
				'}\n' +
				'result = valueAtTime(t);\n' +
				'}\n' +
				'}\n' +
				'result;\n';

	effector.effectorLayer = ctrlLayer;
	effector.effect = effect;

	return effector;
}

/**
* Adds a spring effect on the property
* @param {PropertyInfo} prop - The property to rig
*/
DuAEF.Duik.Automation.spring = function (prop)
{
	if (!prop) return;
	if (!prop.riggable) return;

	//search for one dimension effects, to know if we need a "bounce" checkbox
	var bounce = false;
	if (prop.dimensions == 1) bounce = true;

	//check if it's spatial
	var spatial = prop.getProperty().isSpatial;
	var layer = prop.layer;

	var effect = null;

	layer.selected = true;
	if (bounce) layer.applyPreset(DuAEF.Duik.PseudoEffects.ONED_SPRING);
	else if (spatial) layer.applyPreset(DuAEF.Duik.PseudoEffects.SPATIAL_SPRING);
	else layer.applyPreset(DuAEF.Duik.PseudoEffects.MULTID_SPRING);
	layer.selected = false;
	effect = layer.effect("Spring");
	effect.name = DuAEF.DuAE.Layer.newUniqueEffectName(prop.getProperty().parentProperty.name + ' Spring',layer);

	if (bounce)
	{
		prop.getProperty().expression = "//Duik.Spring\n" +
					'var fx = effect("' + effect.name + '")\n' +
					"damping = fx(2).value;\n" +
					"elasticity = fx(1).value;\n" +
					"speedLimit = 0.1;\n" +
					"bounce = fx(3).value;\n\n" +
					"if (numKeys > 1 && elasticity != 0 ){\n" +
					"if (nearestKey(time).index == 1) { value }\n" +
					"else {\n\n" +
					"if (length(velocity) <= speedLimit ) {\n\n" +
					"tempsClefProx = nearestKey(time).time;\n\n" +
					"if ( tempsClefProx <= time ) { tempsDebut = tempsClefProx }\n" +
					"else { tempsDebut = key(nearestKey(time).index-1).time }\n\n" +
					"temps = time - tempsDebut;\n\n" +
					"spring = velocityAtTime(tempsDebut-thisComp.frameDuration) * ( .15/elasticity * Math.sin(elasticity * temps * 2 * Math.PI) / Math.exp( temps * damping ) );\n" +
					"if (speedLimit > 0) spring = spring * (1-length(velocity)/speedLimit);\n" +
					"if (!bounce) valueAtTime(tempsDebut) + spring;\n\n" +
					"if (bounce &&  valueAtTime(tempsDebut-thisComp.frameDuration) >  valueAtTime(tempsDebut)) valueAtTime(tempsDebut) + Math.abs(spring);\n\n" +
					"if (bounce &&  valueAtTime(tempsDebut-thisComp.frameDuration) <  valueAtTime(tempsDebut)) valueAtTime(tempsDebut) - Math.abs(spring);\n\n" +
					"}\n" +
					"else { value }\n" +
					"}\n" +
					"}\n" +
					"else { value }";
	}
	else if (spatial)
	{
		var toWorldFunc = '';
		if (prop.getProperty().matchName == 'ADBE Position')
		{
			toWorldFunc = "function worldVelocity(temps) {\n" +
			"worldVelocityX = (thisLayer.toWorld(thisLayer.anchorPoint,temps)[0]-thisLayer.toWorld(thisLayer.anchorPoint,temps-.01)[0])*100;\n" +
			"worldVelocityY = (thisLayer.toWorld(thisLayer.anchorPoint,temps)[1]-thisLayer.toWorld(thisLayer.anchorPoint,temps-.01)[1])*100;\n" +
			"return [worldVelocityX,worldVelocityY];\n" +
			"}\n";
		}
		else
		{
			toWorldFunc = "function worldVelocity(temps) {\n" +
			"worldVelocityX = (thisLayer.toWorld(value,temps)[0]-thisLayer.toWorld(value,temps-.01)[0])*100;\n" +
			"worldVelocityY = (thisLayer.toWorld(value,temps)[1]-thisLayer.toWorld(value,temps-.01)[1])*100;\n" +
			"return [worldVelocityX,worldVelocityY];\n" +
			"}\n";
		}
		prop.getProperty().expression = "//Duik.spring\n" +
					'var fx = effect("' + effect.name + '")\n' +
					"damping = fx(2).value;\n" +
					"elasticity = fx(1).value;\n" +
					'simulation = fx(3).value;\n' +
					"speedLimit = 0.1;\n" +
					"if (damping == 0) damping = 0.01;\n" +
					"if (elasticity == 0) elasticity = 0.01;\n" +
					"retard = elasticity/damping;\n" +
					"poids = 1/damping/10;\n" +
					"precision = thisComp.frameDuration;\n" +
					toWorldFunc +
					"function worldSpeed(temps) {\n" +
					"return length(worldVelocity(temps));\n" +
					"}\n" +
					'if (simulation == 2)\n' +
					'{\n' +
						"tempsDebut = 0;\n" +
						"tempsRedemarrage = 0;\n" +
						"stop = false;\n" +
						"arrete = false;\n" +
						"for (i=timeToFrames(time);i>=0;i--) {\n" +
						"var instant = framesToTime(i);\n" +
						"var instantSuivant = instant-precision;\n" +
						"if (worldSpeed(instant) == 0 ) {\n" +
						"if (tempsRedemarrage == 0) tempsRedemarrage = instant;\n" +
						"if (worldSpeed(instantSuivant) !=0 ) {\n" +
						"tempsDebut = instantSuivant;\n" +
						"break;\n" +
						"}\n" +
						"}\n" +
						"}\n" +
						"temps = time-tempsDebut;\n" +
						"frameRedemarre = timeToFrames( time-tempsRedemarrage);\n" +
						"valeur = value\n" +
						"if ( frameRedemarre <= retard)\n" +
						"valeur = value - worldVelocity(time)*poids*(frameRedemarre/retard);\n" +
						"else\n" +
						"valeur = value - worldVelocity(time)*poids;\n" +
						"if (worldSpeed(time) == 0) {\n" +
						"spring = worldVelocity(tempsDebut) * ( .15/elasticity * Math.sin(elasticity * temps * 2 * Math.PI) / Math.exp( temps * damping ) );\n" +
						"valeur + spring;\n" +
						"}else{ valeur; }\n" +
					'}\n' +
					'else\n' +
					'{\n' +
						"if (numKeys > 1 && elasticity != 0 ){\n" +
						"if (nearestKey(time).index == 1) { value }\n" +
						"else {\n\n" +
						"if (length(velocity) <= speedLimit ) {\n\n" +
						"tempsClefProx = nearestKey(time).time;\n\n" +
						"if ( tempsClefProx <= time ) { tempsDebut = tempsClefProx }\n" +
						"else { tempsDebut = key(nearestKey(time).index-1).time }\n\n" +
						"temps = time - tempsDebut;\n\n" +
						"spring = velocityAtTime(tempsDebut-thisComp.frameDuration) * ( .15/elasticity * Math.sin(elasticity * temps * 2 * Math.PI) / Math.exp( temps * damping ) );\n" +
						"if (speedLimit > 0) spring = spring * (1-length(velocity)/speedLimit);\n" +
						"valueAtTime(tempsDebut) + spring;\n\n" +
						"}\n" +
						"else { value }\n" +
						"}\n" +
						"}\n" +
						"else { value }\n" +
					'}\n';

	}
	else
	{
		prop.getProperty().expression = "//Duik.Spring\r\n" +
					'var fx = effect("' + effect.name + '")\n' +
					"damping = fx(2).value;\n" +
					"elasticity = fx(1).value;\n" +
					"speedLimit = 0.1;\n" +
					"if (numKeys > 1 && elasticity != 0 ){\n" +
					"if (nearestKey(time).index == 1) { value }\n" +
					"else {\n\n" +
					"if (length(velocity) <= speedLimit ) {\n\n" +
					"tempsClefProx = nearestKey(time).time;\n\n" +
					"if ( tempsClefProx <= time ) { tempsDebut = tempsClefProx }\n" +
					"else { tempsDebut = key(nearestKey(time).index-1).time }\n\n" +
					"temps = time - tempsDebut;\n\n" +
					"spring = velocityAtTime(tempsDebut-thisComp.frameDuration) * ( .15/elasticity * Math.sin(elasticity * temps * 2 * Math.PI) / Math.exp( temps * damping ) );\n" +
					"if (speedLimit > 0) spring = spring * (1-length(velocity)/speedLimit);\n" +
					"valueAtTime(tempsDebut) + spring;\n\n" +
					"}\n" +
					"else { value }\n" +
					"}\n" +
					"}\n" +
					"else { value }";
	}
}

/**
* Adds a blink effect on the property
* @param {PropertyInfo} prop - The property to rig
*/
DuAEF.Duik.Automation.blink = function (prop)
{
	if (!prop) return;
	if (!prop.riggable) return;

	var dimensions = prop.dimensions;
	var layer = prop.layer;

	layer.selected = true;
	if (dimensions == 1) layer.applyPreset(DuAEF.Duik.PseudoEffects.ONED_BLINK);
	else if (dimensions == 2) layer.applyPreset(DuAEF.Duik.PseudoEffects.TWOD_BLINK);
	else if (dimensions == 3) layer.applyPreset(DuAEF.Duik.PseudoEffects.THREED_BLINK);
	else if (dimensions == 4) layer.applyPreset(DuAEF.Duik.PseudoEffects.COLOR_BLINK);
	layer.selected = false;

	var effect = layer.effect('Blink');
	effect.name = DuAEF.DuAE.Layer.newUniqueEffectName(prop.getProperty().name + ' Blink',layer);
	DuAEF.DuAE.Property.setValue(effect(1),prop.getProperty().value);

	prop.getProperty().expression = "//Duik.blink\n" +
		'var fx = effect("' + effect.name + '")\n' +
		"var phase = fx(3).value;\n" +
		"var timeOn = fx(4).value;\n" +
		"var offset = fx(5).value;\n" +
		"var valueA = fx(1).value;\n" +
		"var valueB = fx(2).value;\n" +
		"freq= timeToFrames(1)/phase;\n" +
		"var currentFrame = timeToFrames(time+offset/phase/100);\n" +
		"if (currentFrame%freq > freq*timeOn/100) valueB;\n" +
		"else valueA;";
}

/**
* Adds a move away effect on the layer
* @param {Layer} layer - The layer to rig
*/
DuAEF.Duik.Automation.moveAway = function (layer)
{
	if (layer == undefined) return;
	var effect = layer.Effects.addProperty("ADBE Slider Control");
	effect.name =  DuAEF.DuAE.Layer.newUniqueEffectName('Move away from parent',layer);

	layer.transform.position.expression = "//Duik.moveAway\n" +
						"if (thisLayer.hasParent)\n" +
						"{\n" +
						"thisWorldPos = thisLayer.toWorld(thisLayer.anchorPoint);\n" +
						"parentWorldPos = thisLayer.parent.toWorld(thisLayer.parent.anchorPoint);\n" +
						"depl = effect(\"" + effect.name  + "\")(1)\n" +
						"dist = length(parentWorldPos ,thisWorldPos )\n" +
						"coef = (dist+depl)/dist\n" +
						"newWorldPos = (thisWorldPos-parentWorldPos)*coef+parentWorldPos\n" +
						"thisLayer.parent.fromWorld(newWorldPos)\n" +
						"}\n" +
						"else\n" +
						"{\n" +
						"value\n" +
						"}\n";
}

/**
* Rigs the paint effects found on the layer to animate all the strokes as if there was only one
* @param {Layer} layer - The layer to rig
*/
DuAEF.Duik.Automation.paintRig = function (layer)
{
	if (layer == undefined) return;

	//if there's no paint effect
	var paintEffect = layer("ADBE Effect Parade")("ADBE Paint");
	if (paintEffect == null) return;

	//add effect
	var newName = DuAEF.DuAE.Layer.newUniqueEffectName('Paint Rig',layer);
	layer.selected = true;
	layer.applyPreset(DuAEF.Duik.PseudoEffects.PAINT_RIG);
	layer.selected = false;
	var effect = layer.effect('Paint Rig');
	effect.name = newName;

	//need to get the paint effect again after addProperty, After Effects bug.......
	var paintEffect = layer("Effects")("ADBE Paint");

	//the first diameter and color
	var defaultDiam = 0;
	var defaultCol = [0,0,0,0];

	//for each stroke
	var nbre = paintEffect.property(2).numProperties;
	for (var j=1;j<=nbre;j++)
	{
		var stroke = paintEffect.property(2).property(j);
		var propStart = stroke.property(4).property(1);
		var propEnd = stroke.property(4).property(2);
		var propCol = stroke.property(4).property(3);
		var propDiam = stroke.property(4).property(4);

		if (defaultDiam == 0)
		{
			defaultDiam = propDiam.value;
			effect(13).setValue(defaultDiam);
			effect(14).setValue(defaultDiam);
		}
		if (defaultCol[3] == 0)
		{
			defaultCol = propCol.value;
			effect(9).setValue(defaultCol);
			effect(10).setValue(defaultCol);
		}

		propStart.expression = '//Duik.PaintRig\n' +
					'var ctrl = effect("' + effect.name + '")(1);\n' +
					'var total = thisProperty.propertyGroup().propertyGroup().propertyGroup().numProperties;\n' +
					'var ind = total + 1 - thisProperty.propertyGroup().propertyGroup().propertyIndex\n' +
					'result = ctrl - ((100/total)*(ind-1));\n' +
					'result = result * total;\n' +
					'result;';

		propEnd.expression = '//Duik.PaintRig\n' +
					'var ctrl = effect("' + effect.name + '")(2);\n' +
					'var total = thisProperty.propertyGroup().propertyGroup().propertyGroup().numProperties;\n' +
					'var ind = total + 1 - thisProperty.propertyGroup().propertyGroup().propertyIndex;\n' +
					'result = ctrl - ((100/total)*(ind-1));\n' +
					'result = result * total;\n' +
					'result;';

		propDiam.expression = '//Duik.PaintRig\n' +
					'var fx = effect("' + effect.name + '");\n' +
					'var ctrlA = fx(13).value;\n' +
					'var ctrlB = fx(14).value;\n' +
					'var reverse = fx(6).value;\n' +
					'var interpolation =fx(5).value;\n' +
					'var mode = fx(4).value;\n' +
					'var total = thisProperty.propertyGroup().propertyGroup().propertyGroup().numProperties;\n' +
					'var ind = total + 1 - thisProperty.propertyGroup().propertyGroup().propertyIndex;\n' +
					'if (reverse)\n' +
					'{\n' +
					'var t = ctrlA;\n' +
					'ctrlA = ctrlB;\n' +
					'ctrlB = t;\n' +
					'}\n' +
					'var result = ctrlA;\n' +
					'if (mode == 2)\n' +
					'{\n' +
					'if (interpolation == 1) result = linear(ind,1,total,ctrlA,ctrlB);\n' +
					'else if (interpolation == 2) result = ease(ind,1,total,ctrlA,ctrlB);\n' +
					'else if (interpolation == 3) result = easeIn(ind,1,total,ctrlA,ctrlB);\n' +
					'else if (interpolation == 4) result = easeOut(ind,1,total,ctrlA,ctrlB);\n' +
					'}\n' +
					'else if (mode == 3)\n' +
					'{\n' +
					'if (ind < total /2)\n' +
					'{\n' +
					'if (interpolation == 1) result = linear(ind,1,total/2,ctrlA,ctrlB);\n' +
					'else if (interpolation == 2) result = ease(ind,1,total/2,ctrlA,ctrlB);\n' +
					'else if (interpolation == 3) result = easeIn(ind,1,total/2,ctrlA,ctrlB);\n' +
					'else if (interpolation == 4) result = easeOut(ind,1,total/2,ctrlA,ctrlB);\n' +
					'}\n' +
					'else\n' +
					'{\n' +
					'if (interpolation == 1) result = linear(ind,total/2,total,ctrlB,ctrlA);\n' +
					'else if (interpolation == 2) result = ease(ind,total/2,total,ctrlB,ctrlA);\n' +
					'else if (interpolation == 3) result = easeIn(ind,total/2,total,ctrlB,ctrlA);\n' +
					'else if (interpolation == 4) result = easeOut(ind,total/2,total,ctrlB,ctrlA);\n' +
					'}\n' +
					'}\n' +
					'result;';

		propCol.expression = '//Duik.PaintRig\n' +
					'var fx = effect("' + effect.name + '");\n' +
					'var ctrlA = fx(9).value;\n' +
					'var ctrlB = fx(10).value;\n' +
					'var reverse = fx(6).value;\n' +
					'var interpolation = fx(5).value;\n' +
					'var mode = fx(4).value;\n' +
					'var total = thisProperty.propertyGroup().propertyGroup().propertyGroup().numProperties;\n' +
					'var ind = total + 1 - thisProperty.propertyGroup().propertyGroup().propertyIndex;\n' +
					'if (reverse)\n' +
					'{\n' +
					'var t = ctrlA;\n' +
					'ctrlA = ctrlB;\n' +
					'ctrlB = t;\n' +
					'}\n' +
					'var result = ctrlA;\n' +
					'if (mode == 2)\n' +
					'{\n' +
					'if (interpolation == 1) result = linear(ind,1,total,ctrlA,ctrlB);\n' +
					'else if (interpolation == 2) result = ease(ind,1,total,ctrlA,ctrlB);\n' +
					'else if (interpolation == 3) result = easeIn(ind,1,total,ctrlA,ctrlB);\n' +
					'else if (interpolation == 4) result = easeOut(ind,1,total,ctrlA,ctrlB);\n' +
					'}\n' +
					'else if (mode == 3)\n' +
					'{\n' +
					'if (ind < total /2)\n' +
					'{\n' +
					'if (interpolation == 1) result = linear(ind,1,total/2,ctrlA,ctrlB);\n' +
					'else if (interpolation == 2) result = ease(ind,1,total/2,ctrlA,ctrlB);\n' +
					'else if (interpolation == 3) result = easeIn(ind,1,total/2,ctrlA,ctrlB);\n' +
					'else if (interpolation == 4) result = easeOut(ind,1,total/2,ctrlA,ctrlB);\n' +
					'}\n' +
					'else\n' +
					'{\n' +
					'if (interpolation == 1) result = linear(ind,total/2,total,ctrlB,ctrlA);\n' +
					'else if (interpolation == 2) result = ease(ind,total/2,total,ctrlB,ctrlA);\n' +
					'else if (interpolation == 3) result = easeIn(ind,total/2,total,ctrlB,ctrlA);\n' +
					'else if (interpolation == 4) result = easeOut(ind,total/2,total,ctrlB,ctrlA);\n' +
					'}\n' +
					'}\n' +
					'result;';
	}
}

/**
* Randomize tools
* @namespace
* @memberof DuAEF.Duik.Automation
*/
DuAEF.Duik.Automation.Randomize = {};

/**
* Randomizes the values at current time of the Properties
* @param {PropertyBase[]|PropertyInfo[]} props - The Properties
* @param {boolean} [fromCurrentVal] - true to offset the current value
* @param {float} xMin - X minimum value
* @param {float} xMax - X maximum value
* @param {float} [yMin] - Y minimum value
* @param {float} [yMax] - Y maximum value
* @param {float} [zMin] - Z minimum value
* @param {float} [zMax] - Z maximum value
*/
DuAEF.Duik.Automation.Randomize.properties = function (props,fromCurrentVal,xMin,xMax,yMin,yMax,zMin,zMax)
{
	if (props == undefined) throw "You must select the properties you want to randomize";
	if (props.length == 0) throw "You must select the properties you want to randomize";
	var x = (xMin != undefined && xMax != undefined && !isNaN(xMin) && !isNaN(xMax));
	var y = (yMin != undefined && yMax != undefined && !isNaN(yMin) && !isNaN(yMax));
	var z = (zMin != undefined && zMax != undefined && !isNaN(zMin) && !isNaN(zMax));

	for (var i = 0;i<props.length;i++)
	{
		var prop = props[i];
		if (prop instanceof PropertyInfo) prop = prop.getProperty();
		if (prop.propertyType == PropertyType.PROPERTY)
		{
			//Get containing comp
			var comp = DuAEF.DuAE.Property.getComp(prop);
			var dim = DuAEF.DuAE.Property.getDimensions(prop);
			var xval = 0;
			var yval = 0;
			var zval = 0;
			//X
			if (x) xval = DuAEF.DuJS.Math.random(xMin,xMax);
			else if (dim == 1) xval = prop.value;
			else xval = prop.value[0];
			//Y
			if (dim == 2 || dim == 3 && y) yval = DuAEF.DuJS.Math.random(yMin,yMax);
			else if (dim == 3 || dim == 2) yval = 0;
			//Z
			if (dim == 3 && z) zval = DuAEF.DuJS.Math.random(zMin,zMax);
			else if (dim == 3) zval = 0;
			//SET VALUE
			var val;
			if (dim == 1) val = xval;
			if (dim == 2) val = [xval,yval];
			if (dim == 3) val = [xval,yval,zval];
			if (fromCurrentVal) val = val + prop.value;
			prop.numKeys ? prop.setValueAtTime(comp.time,val) : prop.setValue(val);
		}
	}
}

/**
* Randomizes the values of the selected keys of the Properties
* @param {PropertyBase[]} props - The Properties
* @param {boolean} [fromCurrentVal] - true to offset the current value
* @param {float} xMin - X minimum value
* @param {float} xMax - X maximum value
* @param {float} [yMin] - Y minimum value
* @param {float} [yMax] - Y maximum value
* @param {float} [zMin] - Z minimum value
* @param {float} [zMax] - Z maximum value
*/
DuAEF.Duik.Automation.Randomize.selectedKeys = function (props,fromCurrentVal,xMin,xMax,yMin,yMax,zMin,zMax)
{
	if (props == undefined) throw "You must select the keyframes you want to randomize";
	if (props.length == 0) throw "You must select the keyframes you want to randomize";
	var x = (xMin != undefined && xMax != undefined && !isNaN(xMin) && !isNaN(xMax));
	var y = (yMin != undefined && yMax != undefined && !isNaN(yMin) && !isNaN(yMax));
	var z = (zMin != undefined && zMax != undefined && !isNaN(zMin) && !isNaN(zMax));
	for (var i = 0;i<props.length;i++)
	{
		var prop = props[i];
		if (prop instanceof PropertyInfo) prop = prop.getProperty();
		if (prop.propertyType == PropertyType.PROPERTY)
		{
			//Get containing comp and dimensions
			var comp = DuAEF.DuAE.Property.getComp(prop);
			var dim = DuAEF.DuAE.Property.getDimensions(prop);
			//loop through selected keyframes
			for (var j = 0 ; j < prop.selectedKeys.length; j++)
			{
				var key = prop.selectedKeys[j];
				var xval = 0;
				var yval = 0;
				var zval = 0;
				//X
				if (x) xval = DuAEF.DuJS.Math.random(xMin,xMax);
				else xval = 0;
				//Y
				if (dim == 2 || dim == 3 && y) yval = DuAEF.DuJS.Math.random(yMin,yMax);
				else if (dim == 3 || dim == 2) yval = 0;
				//Z
				if (dim == 3 && z) zval = DuAEF.DuJS.Math.random(zMin,zMax);
				else if (dim == 3) zval = 0;
				//SET VALUE
				var val;
				if (dim == 1) val = xval;
				if (dim == 2) val = [xval,yval];
				if (dim == 3) val = [xval,yval,zval];
				if (fromCurrentVal) val = val + prop.keyValue(key);
				prop.setValueAtKey(key,val);
			}
		}
	}
}

/**
* Randomizes the times of the selected keys of the Properties
* @param {PropertyBase[]} props - The Properties
* @param {boolean} [fromCurrentVal] - true to offset the current value
* @param {float} min - minimum time (in frames)
* @param {float} max - maximum time (in frames)
*/
DuAEF.Duik.Automation.Randomize.selectedKeyTimes = function (props,fromCurrentVal,min,max)
{
	if (props == undefined) throw "You must select the keyframes you want to randomize";
	if (props.length == 0) throw "You must select the keyframes you want to randomize";
	var x = (min != undefined && max != undefined && !isNaN(min) && !isNaN(max));
	if (!x) throw "You must define a randomizing range";

	//array to list keys to be removed
	var krKeys = [];


	for (var i = 0;i<props.length;i++)
	{
		var prop = props[i];
		if (prop instanceof PropertyInfo) prop = prop.getProperty();
		var krK = [];
		if (prop.propertyType == PropertyType.PROPERTY)
		{
			//Get containing comp and dimensions
			var comp = DuAEF.DuAE.Property.getComp(prop);
			var dim = DuAEF.DuAE.Property.getDimensions(prop);
			//loop through selected keyframes
			for (var j = 0 ; j < prop.selectedKeys.length; j++)
			{
				var key = prop.selectedKeys[j];
				var t = DuAEF.DuJS.Math.random(min,max)*comp.frameDuration;
				//SET VALUE
				if (fromCurrentVal) r += prop.keyTime(key);
				var oldKey = DuAEF.DuAE.Property.getKeyFrameAtIndex(prop,key);
				krK.push(prop.keyTime(key));
				DuAEF.DuAE.Property.setKey(prop,oldKey,t);
			}
		}
		krKeys.push(krK);
	}

	for (var i = 0 ; i < props.length ; i++)
	{
		var prop = props[i];
		if (prop instanceof PropertyInfo) prop = prop.getProperty();
		for (var j = 0 ; j < krKeys[i].length ; j++)
		{
			prop.removeKey(prop.nearestKeyIndex(krKeys[i][j]));
		}
	}
}

/**
* Randomizes the start times of the layers
* @param {Layer[]|LayerCollection} layers - The layers
* @param {boolean} [fromCurrentVal] - true to offset the current value
* @param {float} min - minimum time (in frames)
* @param {float} max - maximum time (in frames)
*/
DuAEF.Duik.Automation.Randomize.startTimes = function (layers,fromCurrentVal,min,max)
{
		if (layers == undefined) return;
		if (layers.length == 0 ) return;

		var it = new Iterator(layers);

		while (!it.atEnd)
		{
			it.next();
			var l = layers[it.current];
			var comp = l.containingComp;
			var startTime = DuAEF.DuJS.Math.random(min,max)*comp.frameDuration;
			if (fromCurrentVal) l.startTime = l.startTime + startTime;
			else l.startTime = startTime;
		}
	}

/**
* Randomizes the in points of the layers
* @param {Layer[]|LayerCollection} layers - The layers
* @param {boolean} [fromCurrentVal] - true to offset the current value
* @param {float} min - minimum time (in frames)
* @param {float} max - maximum time (in frames)
*/
DuAEF.Duik.Automation.Randomize.inPoints = function (layers,fromCurrentVal,min,max)
{
	if (layers == undefined) return;
	if (layers.length == 0 ) return;

	var it = new Iterator(layers);

	while (!it.atEnd)
	{
		it.next();
		var l = layers[it.current];
		var comp = l.containingComp;
		var inPoint = DuAEF.DuJS.Math.random(min,max)*comp.frameDuration;
		if (fromCurrentVal) l.inPoint = l.inPoint + inPoint;
		else l.inPoint = inPoint;
	}
}

/**
* Randomizes the out points of the layers
* @param {Layer[]|LayerCollection} layers - The layers
* @param {boolean} [fromCurrentVal] - true to offset the current value
* @param {float} min - minimum time (in frames)
* @param {float} max - maximum time (in frames)
*/
DuAEF.Duik.Automation.Randomize.outPoints = function (layers,fromCurrentVal,min,max)
{
	if (layers == undefined) return;
	if (layers.length == 0 ) return;

	var it = new Iterator(layers);

	for (var i = it.min; i<= it.max;i++)
	{
		it.next();
		var l = layers[it.current];
		var comp = l.containingComp;
		var outPoint = DuAEF.DuJS.Math.random(min,max)*comp.frameDuration;
		if (fromCurrentVal) l.outPoint = l.outPoint + outPoint;
		else l.outPoint = outPoint;
	}
}

/**
* Randomizes the indices of the layers
* @param {Layer[]|LayerCollection} layers - The layers
* @param {boolean} [fromCurrentVal] - true to offset the current value
* @param {float} min - minimum index
* @param {float} max - maximum index
*/
DuAEF.Duik.Automation.Randomize.indices = function (layers,fromCurrentVal,min,max)
{
	if (layers == undefined) return;
	if (layers.length == 0 ) return;

	var it = new Iterator(layers);

	while (!it.atEnd)
	{
		it.next();
		var l = layers[it.current];
		var index = parseInt(DuAEF.DuJS.Math.random(min,max));
		if (fromCurrentVal) index = l.index + index;
		if (index == l.index) continue;
		var comp = l.containingComp;
		if (index >= comp.numLayers) l.moveToEnd();
		else if (index < 2) l.moveToBeginning();
		else l.moveBefore(comp.layer(index));
	}
}

/**
* Camera tools
* @namespace
* @memberof DuAEF.Duik
*/
DuAEF.Duik.Camera = {};

/**
* Creates a new 2D Multiplane Camera
* @param {CompItem} [comp] - The containing comp. Ignored if layers are provided.
* @param {Layers[]|LayerCollection|null|undefined} [layers=comp.selectedLayers] - The layers to automatically link to the controllers.<br />
* By default, the selected layers will be used, and if there are no selected layers, three controllers will be created
* @return {Controller} The camera controller
*/
DuAEF.Duik.Camera.create2DCam = function(comp,layers)
{
	if (comp == undefined) comp = DuAEF.DuAE.Project.getActiveComp();
	if (layers == undefined) layers = comp.selectedLayers;
	var numLayers = 3;
	if (layers.length != 0)
	{
		layers = DuAEF.DuAE.Layer.sortByIndex(layers);
		numLayers = layers.length;
		comp = layers[0].containingComp;
	}
	var camIndex = Math.ceil(numLayers/2);

	var camCtrl;
	var camLayer;

	for (var i=1;i<=numLayers;i++)
	{
		var name = 'L' + DuAEF.DuJS.Number.convertToString(i,2);
		if (layers.length) name = name + ' | ' + layers[i-1].name;

		//creer les nuls et leurs zeros
		if (i == camIndex)
		{
			var camCtrl = DuAEF.Duik.Controller.create(comp,DuAEF.Duik.ControllerType.CAMERA);
			var camLayer = camCtrl.layer;
			//Creer un ctrl cam
			camLayer.name = DuAEF.DuAE.Comp.newUniqueLayerName(name + ' CAMERA',comp);
			//add a zero
			DuAEF.Duik.Rigging.addZero(camLayer);
			//add marker
			DuAEF.Duik.setDuikMarker(camLayer,"2D Camera Controller",DuAEF.Duik.LayerTypes.CONTROLLER);
		}
		else
		{
			var layer = app.project.activeItem.layers.addNull() ;
			layer.name = DuAEF.DuAE.Comp.newUniqueLayerName(name,comp,false);
			layer.shy = true;
			DuAEF.Duik.setDuikMarker(layer,"2D Camera",DuAEF.Duik.LayerTypes.TWOD_CAMERA_LAYER);
		}
	}

	//cam effect
	var effect = DuAEF.DuAE.Layer.addPseudoEffect(camLayer,DuAEF.Duik.PseudoEffects.TWOD_CAMERA,DuAEF.Duik.PseudoEffectsMatchNames.TWOD_CAMERA,"2D Camera");

	//cam rig
	var camZero = camLayer.parent;
	//tilt
	camZero.transform.rotation.expression = "//Duik.twoDCamera\n" +
	"thisComp.layer(\"" + camLayer.name + "\").effect(\"" + effect.name + "\")(4);";
	//zoom & truck in/out
	camZero.transform.scale.expression = "//Duik.twoDCamera\n" +
	"var zoom = thisComp.layer(\"" + camLayer.name + "\").effect(\"" + effect.name + "\")(2);\n" +
	"var truck = thisComp.layer(\"" + camLayer.name + "\").effect(\"" + effect.name + "\")(3);\n" +
	"value + [zoom,zoom] + [truck,truck];";
	//pan
	camZero.transform.position.expression = "//Duik.twoDCamera\n" +
	"thisComp.layer(\"" + camLayer.name + "\").effect(\"" + effect.name + "\")(1) + [thisComp.width/2,thisComp.height/2];";

	//expressions and sliders
	var numLayersAbove = camLayer.index-1;
	var numLayersUnder = numLayers - camLayer.index;
	for (var i=1;i<=numLayers;i++)
	{
		//if this is not the cam layer
		if (i != camLayer.index)
		{
			var layer = comp.layer(i);
			var zero = layer.parent;

			var slider = layer.Effects.addProperty("ADBE Slider Control");
			slider.name = 'Camera influence';
			(i<camLayer.index+1) ? slider(1).setValue((1+(numLayersAbove-i+1)*.2)*100) : slider(1).setValue(((1/(camIndex+1))*Math.abs(i-numLayers-2))*100) ;

			//truck
			layer.transform.anchorPoint.expression = '//Duik.twoDCamera\nvar camPosition = thisComp.layer("' + camLayer.name + '").transform.position.value;\nvalueAtTime(0) - camPosition * effect("Camera influence")(1) / 100';

			//tilt
			layer.transform.rotation.expression = '//Duik.twoDCamera\n' +
			'thisComp.layer("' + camLayer.name + '").effect("' + effect.name + '")(4);';

			//zoom & truck in/out
			layer.transform.scale.expression = "//Duik.twoDCamera\n" +
			"var zoom = thisComp.layer(\"" + camLayer.name + "\").effect(\"" + effect.name + "\")(2);\n" +
			"var truck = thisComp.layer(\"" + camLayer.name + "\").effect(\"" + effect.name + "\")(3);\n" +
			"var infl = thisComp.layer(\"" + layer.name + "\").effect(\"Camera influence\")(1);\n" +
			"value + [zoom,zoom] + [truck,truck]*infl/100;";

			//pan
			layer.transform.position.expression = "//Duik.twoDCamera\n" +
			"thisComp.layer(\"" + camLayer.name + "\").effect(\"" + effect.name + "\")(1) + [thisComp.width/2,thisComp.height/2];";
		}
	}

	// Parent layers
	if (layers.length)
	{
		for (var i = 0 ; i<layers.length;i++)
		{
			layers[i].parent = comp.layer(i+1);
		}
	}

	DuAEF.DuAE.Comp.unselectLayers();
	camLayer.selected = true;
}

/**
* Controllers
* @namespace
* @memberof DuAEF.Duik
*/
DuAEF.Duik.Controller = {};

/**
* Creates a new controller
* @param {CompItem} comp - The composition
* @param {DuAEF.Duik.ControllerType} [type=DuAEF.Duik.ControllerType.TRANSFORM] - The type of Controller
* @param {Layer} [layer] - The layer where to create the controller.
* @param {float}	[size] - The controller size, a percentage. By default, it will adjust automatically depending on comp size and DuAEF.Duik.controllerSizeHint
* @return {Controller} The controller
*/
DuAEF.Duik.Controller.create = function (comp,type,layer,size,color)
{
	if (comp == undefined) return;
	var ctrl = comp.layers.addShape();
	DuAEF.Duik.setDuikMarker(ctrl,"Controller",DuAEF.Duik.LayerTypes.CONTROLLER);

	var effect = null;

	if (type != DuAEF.Duik.ControllerType.SQUARE && type != DuAEF.Duik.ControllerType.SLIDER && type != DuAEF.Duik.ControllerType.DOUBLE_SLIDER && type != DuAEF.Duik.ControllerType.ANGLE)
	{
		//add effect
		effect = DuAEF.DuAE.Layer.addPseudoEffect(ctrl,DuAEF.Duik.PseudoEffects.CONTROLLER,DuAEF.Duik.PseudoEffectsMatchNames.CONTROLLER,'Controller');

		//create anchor
		var anchorGroup = ctrl("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
		anchorGroup.name = 'Anchor';
		var anchorContent = anchorGroup.property("ADBE Vectors Group");
		var centerCircle = anchorContent.addProperty("ADBE Vector Shape - Ellipse");
		centerCircle("ADBE Vector Ellipse Size").setValue([2,2]);
		var biggerCircle = anchorContent.addProperty("ADBE Vector Shape - Ellipse");
		biggerCircle("ADBE Vector Ellipse Size").setValue([10,10]);
		var star = anchorContent.addProperty("ADBE Vector Shape - Star");
		star("ADBE Vector Star Points").setValue(4);
		star("ADBE Vector Star Inner Radius").setValue(0);
		star("ADBE Vector Star Outer Radius").setValue(10);
		var stroke = anchorContent.addProperty("ADBE Vector Graphic - Stroke");
		stroke("ADBE Vector Stroke Color").expression = 'effect("Controller")(9)';
		stroke("ADBE Vector Stroke Width").expression = '100/content("Anchor").transform.scale[0]';
		stroke("ADBE Vector Stroke Line Cap").setValue(2);
		anchorGroup.transform.scale.expression = '[effect("Controller")(10),effect("Controller")(10)]';
	}
	else if (type == DuAEF.Duik.ControllerType.SLIDER)
	{
		//add effect
		effect = DuAEF.DuAE.Layer.addPseudoEffect(ctrl,DuAEF.Duik.PseudoEffects.CONTROLLER_SLIDER,DuAEF.Duik.PseudoEffectsMatchNames.CONTROLLER_SLIDER,'Slider');
	}
	else if (type == DuAEF.Duik.ControllerType.DOUBLE_SLIDER)
	{
		//add effect
		effect = DuAEF.DuAE.Layer.addPseudoEffect(ctrl,DuAEF.Duik.PseudoEffects.CONTROLLER_DOUBLE_SLIDER,DuAEF.Duik.PseudoEffectsMatchNames.CONTROLLER_DOUBLE_SLIDER,'Slider');
	}
	else if (type == DuAEF.Duik.ControllerType.ANGLE)
	{
		//add effect
		effect = DuAEF.DuAE.Layer.addPseudoEffect(ctrl,DuAEF.Duik.PseudoEffects.CONTROLLER_ANGLE,DuAEF.Duik.PseudoEffectsMatchNames.CONTROLLER_ANGLE,'Angle');
	}

	var iconGroup = ctrl("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
	iconGroup.name = 'Icon';
	var iconContent = iconGroup.property("ADBE Vectors Group");

	if (type != DuAEF.Duik.ControllerType.SQUARE && type != DuAEF.Duik.ControllerType.SLIDER && type != DuAEF.Duik.ControllerType.DOUBLE_SLIDER && type != DuAEF.Duik.ControllerType.ANGLE)
	{
		iconGroup.transform.scale.expression = '[effect("Controller")(4)*2,effect("Controller")(4)*2]';
		iconGroup.transform.position.expression = 'effect("Controller")(3)';
		iconGroup.transform.rotation.expression = 'effect("Controller")(5)';
		iconGroup.transform.opacity.expression = 'effect("Controller")(6)';
	}

	if (type == DuAEF.Duik.ControllerType.ROTATION)
	{
		var shape = iconContent.addProperty("ADBE Vector Shape - Group");
		var rotationShape = new Shape();
		rotationShape.vertices = [[-8, 0.3499755859375], [0, 8.3499755859375], [8, 0.3499755859375], [0, -7.6500244140625], [4.80000305175781, -11.8499755859375]];
		rotationShape.inTangents = [[0, 0], [-4.41830444335938, 0], [0, 4.4183349609375], [4.41830444335938, 0], [0, 0]];
		rotationShape.outTangents = [[0, 4.4183349609375], [4.41830444335938, 0], [0, -4.4183349609375], [0, 0], [0, 0]];
		rotationShape.closed = false;
		shape('ADBE Vector Shape').setValue(rotationShape);
		var stroke = iconContent.addProperty("ADBE Vector Graphic - Stroke");
		stroke("ADBE Vector Stroke Color").expression = 'effect("Controller")(2)';
		stroke("ADBE Vector Stroke Width").setValue(1.5);
		stroke("ADBE Vector Stroke Line Cap").setValue(2);

		if (!layer) ctrl.name = DuAEF.DuAE.Comp.newUniqueLayerName('C Rotation',comp);
	}
	else if (type == DuAEF.Duik.ControllerType.X_POSITION)
	{
		var shape = iconContent.addProperty("ADBE Vector Shape - Group");
		var xPosShape = new Shape();
		xPosShape.vertices = [[12.5158386230469, -0.320068359375], [6.05984497070313, -6.776123046875], [5.74093627929688, -6.914794921875], [5.42213439941406, -6.776123046875], [4.729736328125, -6.083740234375], [4.59104919433594, -5.764892578125], [4.729736328125, -5.446044921875], [9.067138671875, -1.108642578125], [-9.05496215820313, -1.108642578125], [-4.74685668945313, -5.416748046875], [-4.60865783691406, -5.734619140625], [-4.74685668945313, -6.052490234375], [-5.43826293945313, -6.743896484375], [-5.75605773925781, -6.882080078125], [-6.07395935058594, -6.743896484375], [-12.516357421875, -0.301513671875], [-12.6545562744141, 0.016357421875], [-12.516357421875, 0.334228515625], [-6.07395935058594, 6.776611328125], [-5.75605773925781, 6.914794921875], [-5.43826293945313, 6.776611328125], [-4.74685668945313, 6.085205078125], [-4.60865783691406, 5.767333984375], [-4.74685668945313, 5.449462890625], [-9.30496215820313, 0.891357421875], [9.28193664550781, 0.891357421875], [4.729736328125, 5.443603515625], [4.59104919433594, 5.762451171875], [4.729736328125, 6.081298828125], [5.42213439941406, 6.773681640625], [5.74093627929688, 6.912353515625], [6.05984497070313, 6.773681640625], [12.5158386230469, 0.317626953125], [12.654541015625, -0.001220703125]];
		xPosShape.inTangents = [[0.08349609375, 0.08349609375], [0, 0], [0.11090087890625, 0], [0.08351135253906, -0.08349609375], [0, 0], [0, -0.11083984375], [-0.08349609375, -0.08349609375], [0, 0], [0, 0], [0, 0], [0, 0.1103515625], [0.08299255371094, 0.0830078125], [0, 0], [0.11030578613281, 0], [0.0830078125, -0.0830078125], [0, 0], [0, -0.1103515625], [-0.0830078125, -0.0830078125], [0, 0], [-0.11039733886719, 0], [-0.08299255371094, 0.0830078125], [0, 0], [0, 0.12451171875], [0.08299255371094, 0.0830078125], [0, 0], [0, 0], [0, 0], [0, -0.11083984375], [-0.08349609375, -0.08349609375], [0, 0], [-0.11079406738281, 0], [-0.08349609375, 0.08349609375], [0, 0], [0, 0.11083984375]];
		xPosShape.outTangents = [[0, 0], [-0.08349609375, -0.08349609375], [-0.11079406738281, 0], [0, 0], [-0.08349609375, 0.08349609375], [0, 0.11083984375], [0, 0], [0, 0], [0, 0], [0.08299255371094, -0.0830078125], [0, -0.1103515625], [0, 0], [-0.08299255371094, -0.0830078125], [-0.11039733886719, 0], [0, 0], [-0.0830078125, 0.0830078125], [0, 0.1103515625], [0, 0], [0.0830078125, 0.0830078125], [0.11030578613281, 0], [0, 0], [0.08299255371094, -0.0830078125], [0, -0.1103515625], [0, 0], [0, 0], [0, 0], [-0.08349609375, 0.08349609375], [0, 0.12451171875], [0, 0], [0.08351135253906, 0.08349609375], [0.11090087890625, 0], [0, 0], [0.08349609375, -0.08349609375], [0, -0.11083984375]];
		xPosShape.closed = true;
		shape('ADBE Vector Shape').setValue(xPosShape);
		var stroke = iconContent.addProperty("ADBE Vector Graphic - Fill");
		stroke("ADBE Vector Fill Color").expression = 'effect("Controller")(2)';

		if (!layer) ctrl.name = DuAEF.DuAE.Comp.newUniqueLayerName('C X',comp);
	}
	else if (type == DuAEF.Duik.ControllerType.Y_POSITION)
	{
		var shape = iconContent.addProperty("ADBE Vector Shape - Group");
		var yPosShape = new Shape();
		yPosShape.vertices = [[0.32005310058594, 12.5158538818359], [6.776123046875, 6.05986022949219], [6.914794921875, 5.74095153808594], [6.776123046875, 5.42214965820313], [6.083740234375, 4.72975158691406], [5.764892578125, 4.591064453125], [5.446044921875, 4.72975158691406], [1.108642578125, 9.06715393066406], [1.108642578125, -9.05496215820313], [5.416748046875, -4.74685668945313], [5.734619140625, -4.60865783691406], [6.052490234375, -4.74685668945313], [6.743896484375, -5.43826293945313], [6.882080078125, -5.75605773925781], [6.743896484375, -6.07395935058594], [0.301513671875, -12.516357421875], [-0.01637268066406, -12.6545562744141], [-0.33424377441406, -12.516357421875], [-6.77662658691406, -6.07395935058594], [-6.91481018066406, -5.75605773925781], [-6.77662658691406, -5.43826293945313], [-6.08522033691406, -4.74685668945313], [-5.76734924316406, -4.60865783691406], [-5.44947814941406, -4.74685668945313], [-0.89137268066406, -9.30496215820313], [-0.89137268066406, 9.28195190429688], [-5.44361877441406, 4.72975158691406], [-5.76246643066406, 4.591064453125], [-6.08131408691406, 4.72975158691406], [-6.77369689941406, 5.42214965820313], [-6.91236877441406, 5.74095153808594], [-6.77369689941406, 6.05986022949219], [-0.31764221191406, 12.5158538818359], [0.001220703125, 12.6545562744141]];
		yPosShape.inTangents = [[-0.08348083496094, 0.08349609375], [0, 0], [0, 0.11079406738281], [0.08349609375, 0.08351135253906], [0, 0], [0.11083984375, 0], [0.08349609375, -0.08349609375], [0, 0], [0, 0], [0, 0], [-0.1103515625, 0], [-0.0830078125, 0.08299255371094], [0, 0], [0, 0.11039733886719], [0.0830078125, 0.0830078125], [0, 0], [0.11036682128906, 0], [0.0830078125, -0.0830078125], [0, 0], [0, -0.11030578613281], [-0.0830078125, -0.08299255371094], [0, 0], [-0.12451171875, 0], [-0.0830078125, 0.08299255371094], [0, 0], [0, 0], [0, 0], [0.11083984375, 0], [0.08349609375, -0.08349609375], [0, 0], [0, -0.11090087890625], [-0.08349609375, -0.08349609375], [0, 0], [-0.11085510253906, 0]];
		yPosShape.outTangents = [[0, 0], [0.08349609375, -0.08349609375], [0, -0.11079406738281], [0, 0], [-0.08349609375, -0.08349609375], [-0.11083984375, 0], [0, 0], [0, 0], [0, 0], [0.0830078125, 0.08299255371094], [0.1103515625, 0], [0, 0], [0.0830078125, -0.08299255371094], [0, -0.11038208007813], [0, 0], [-0.0830078125, -0.0830078125], [-0.1103515625, 0], [0, 0], [-0.0830078125, 0.0830078125], [0, 0.11032104492188], [0, 0], [0.0830078125, 0.08299255371094], [0.1103515625, 0], [0, 0], [0, 0], [0, 0], [-0.08349609375, -0.08349609375], [-0.12451171875, 0], [0, 0], [-0.08349609375, 0.08351135253906], [0, 0.11090087890625], [0, 0], [0.08351135253906, 0.08349609375], [0.11083984375, 0]];
		yPosShape.closed = true;
		shape('ADBE Vector Shape').setValue(yPosShape);
		var stroke = iconContent.addProperty("ADBE Vector Graphic - Fill");
		stroke("ADBE Vector Fill Color").expression = 'effect("Controller")(2)';

		if (!layer) ctrl.name = DuAEF.DuAE.Comp.newUniqueLayerName('C Y',comp);
	}
	else if (type == DuAEF.Duik.ControllerType.POSITION)
	{
		var shape = iconContent.addProperty("ADBE Vector Shape - Group");
		var posShape = new Shape();
		posShape.vertices = [[12.4787292480469, -0.23583984375], [7.58624267578125, -5.12841796875], [7.34503173828125, -5.23291015625], [7.10372924804688, -5.12841796875], [6.57843017578125, -4.60302734375], [6.47393798828125, -4.36181640625], [6.57843017578125, -4.12060546875], [9.663330078125, -1.03564453125], [1.05203247070313, -1.03564453125], [1.05203247070313, -9.6510009765625], [4.10723876953125, -6.59619140625], [4.34793090820313, -6.49169921875], [4.58865356445313, -6.59619140625], [5.11203002929688, -7.11962890625], [5.216552734375, -7.35986328125], [5.11203002929688, -7.60107421875], [0.234130859375, -12.47900390625], [-0.00656127929688, -12.58349609375], [-0.24725341796875, -12.47900390625], [-5.12525939941406, -7.60107421875], [-5.22966003417969, -7.35986328125], [-5.12525939941406, -7.11962890625], [-4.60176086425781, -6.59619140625], [-4.36105346679688, -6.49169921875], [-4.120361328125, -6.59619140625], [-0.94796752929688, -9.7681884765625], [-0.94796752929688, -1.03564453125], [-9.65106201171875, -1.03564453125], [-6.59596252441406, -4.0908203125], [-6.491455078125, -4.33154296875], [-6.59596252441406, -4.572265625], [-7.11935424804688, -5.095703125], [-7.36006164550781, -5.2001953125], [-7.60075378417969, -5.095703125], [-12.478759765625, -0.2177734375], [-12.583251953125, 0.02294921875], [-12.478759765625, 0.263671875], [-7.60075378417969, 5.1416015625], [-7.36006164550781, 5.24609375], [-7.11935424804688, 5.1416015625], [-6.59596252441406, 4.6181640625], [-6.491455078125, 4.37744140625], [-6.59596252441406, 4.13671875], [-9.76824951171875, 0.96435546875], [-0.94796752929688, 0.96435546875], [-0.94796752929688, 9.74560546875], [-4.11495971679688, 6.57861328125], [-4.35615539550781, 6.47412109375], [-4.59735107421875, 6.57861328125], [-5.12275695800781, 7.10400390625], [-5.22724914550781, 7.34521484375], [-5.12275695800781, 7.58642578125], [-0.23016357421875, 12.47900390625], [0.01104736328125, 12.58349609375], [0.25225830078125, 12.47900390625], [5.14483642578125, 7.58642578125], [5.24932861328125, 7.34521484375], [5.14483642578125, 7.10400390625], [4.61944580078125, 6.57861328125], [4.37823486328125, 6.47412109375], [4.13705444335938, 6.57861328125], [1.05203247070313, 9.66357421875], [1.05203247070313, 0.96435546875], [9.74533081054688, 0.96435546875], [6.57843017578125, 4.13134765625], [6.47393798828125, 4.37255859375], [6.57843017578125, 4.61376953125], [7.10372924804688, 5.13916015625], [7.34503173828125, 5.24365234375], [7.58624267578125, 5.13916015625], [12.4787292480469, 0.24658203125], [12.583251953125, 0.00537109375]];
		posShape.inTangents = [[0.0625, 0.0625], [0, 0], [0.08392333984375, 0], [0.0625, -0.0625], [0, 0], [0, -0.083984375], [-0.0625, -0.0625], [0, 0], [0, 0], [0, 0], [0, 0], [-0.083984375, 0], [-0.06301879882813, 0.0634765625], [0, 0], [0, 0.083984375], [0.06301879882813, 0.0634765625], [0, 0], [0.08401489257813, 0], [0.06298828125, -0.0625], [0, 0], [0, -0.083984375], [-0.06289672851563, -0.0625], [0, 0], [-0.09420776367188, 0], [-0.06298828125, 0.0634765625], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0.083984375], [0.06300354003906, 0.06298828125], [0, 0], [0.08399963378906, 0], [0.06289672851563, -0.06298828125], [0, 0], [0, -0.083984375], [-0.06300354003906, -0.06298828125], [0, 0], [-0.08399963378906, 0], [-0.06300354003906, 0.06298828125], [0, 0], [0, 0.09423828125], [0.06300354003906, 0.06298828125], [0, 0], [0, 0], [0, 0], [0, 0], [0.08399963378906, 0], [0.0625, -0.0625], [0, 0], [0, -0.083984375], [-0.0625, -0.0625], [0, 0], [-0.08401489257813, 0], [-0.0625, 0.0625], [0, 0], [0, 0.083984375], [0.0625, 0.0625], [0, 0], [0.08392333984375, 0], [0.0625, -0.0625], [0, 0], [0, 0], [0, 0], [0, 0], [0, -0.083984375], [-0.0625, -0.0625], [0, 0], [-0.083984375, 0], [-0.0625, 0.0625], [0, 0], [0, 0.083984375]];
		posShape.outTangents = [[0, 0], [-0.0625, -0.0625], [-0.083984375, 0], [0, 0], [-0.0625, 0.0625], [0, 0.083984375], [0, 0], [0, 0], [0, 0], [0, 0], [0.06301879882813, 0.0634765625], [0.08401489257813, 0], [0, 0], [0.06301879882813, -0.0625], [0, -0.083984375], [0, 0], [-0.06298828125, -0.0625], [-0.083984375, 0], [0, 0], [-0.06289672851563, 0.0634765625], [0, 0.083984375], [0, 0], [0.06300354003906, 0.0634765625], [0.08399963378906, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0.06300354003906, -0.06298828125], [0, -0.083984375], [0, 0], [-0.06300354003906, -0.06298828125], [-0.08399963378906, 0], [0, 0], [-0.06300354003906, 0.06298828125], [0, 0.083984375], [0, 0], [0.06289672851563, 0.06298828125], [0.08399963378906, 0], [0, 0], [0.06300354003906, -0.06298828125], [0, -0.083984375], [0, 0], [0, 0], [0, 0], [0, 0], [-0.0625, -0.0625], [-0.09469604492188, 0], [0, 0], [-0.0625, 0.0625], [0, 0.083984375], [0, 0], [0.0625, 0.0625], [0.083984375, 0], [0, 0], [0.0625, -0.0625], [0, -0.083984375], [0, 0], [-0.0625, -0.0625], [-0.083984375, 0], [0, 0], [0, 0], [0, 0], [0, 0], [-0.0625, 0.0625], [0, 0.0947265625], [0, 0], [0.0625, 0.0625], [0.08392333984375, 0], [0, 0], [0.0625, -0.0625], [0, -0.083984375]];
		posShape.closed = true;
		shape('ADBE Vector Shape').setValue(posShape);
		var stroke = iconContent.addProperty("ADBE Vector Graphic - Fill");
		stroke("ADBE Vector Fill Color").expression = 'effect("Controller")(2)';

		if (!layer) ctrl.name = DuAEF.DuAE.Comp.newUniqueLayerName('C Position',comp);
	}
	if (type == DuAEF.Duik.ControllerType.TRANSFORM)
	{
		var shape1 = iconContent.addProperty("ADBE Vector Shape - Group");
		var transformShape1 = new Shape();
		transformShape1.vertices = [[-11.066650390625, 0.0479736328125], [0.18746948242188, 11.302001953125], [11.441650390625, 0.0479736328125], [0.18746948242188, -11.2061767578125], [6.93994140625, -17.114501953125]];
		transformShape1.inTangents = [[0, 0], [-6.21542358398438, 0], [0, 6.2154541015625], [6.21548461914063, 0], [0, 0]];
		transformShape1.outTangents = [[0, 6.2154541015625], [6.21548461914063, 0], [0, -6.215576171875], [0, 0], [0, 0]];
		transformShape1.closed = false;
		shape1('ADBE Vector Shape').setValue(transformShape1);
		var shape2 = iconContent.addProperty("ADBE Vector Shape - Group");
		var transformShape2 = new Shape();
		transformShape2.vertices = [[0.0625, -7.545654296875], [0.0625, 7.5455322265625]];
		transformShape2.inTangents = [[0, 0], [0, 0]];
		transformShape2.outTangents = [[0, 0], [0, 0]];
		transformShape2.closed = false;
		shape2('ADBE Vector Shape').setValue(transformShape2);
		var shape3 = iconContent.addProperty("ADBE Vector Shape - Group");
		var transformShape3 = new Shape();
		transformShape3.vertices = [[7.54559326171875, 0], [-7.54559326171875, 0]];
		transformShape3.inTangents = [[0, 0], [0, 0]];
		transformShape3.outTangents = [[0, 0], [0, 0]];
		transformShape3.closed = false;
		shape3('ADBE Vector Shape').setValue(transformShape3);
		var stroke = iconContent.addProperty("ADBE Vector Graphic - Stroke");
		stroke("ADBE Vector Stroke Color").expression = 'effect("Controller")(2)';
		stroke("ADBE Vector Stroke Width").setValue(1.5);
		stroke("ADBE Vector Stroke Line Cap").setValue(2);

		if (!layer) ctrl.name = DuAEF.DuAE.Comp.newUniqueLayerName('C transform',comp);
	}
	else if (type == DuAEF.Duik.ControllerType.EYE)
	{
		var shape1 = iconContent.addProperty("ADBE Vector Shape - Group");
		var eyeShape1 = new Shape();
		eyeShape1.vertices = [[-16.5059204101563, 0.3309326171875], [16.5059509277344, 0.3309326171875]];
		eyeShape1.inTangents = [[9.71759033203125, -9.3309326171875], [-6.15141296386719, 8.6690673828125]];
		eyeShape1.outTangents = [[7.75308227539063, 7.74267578125], [-7.94126892089844, -8.66920471191406]];
		eyeShape1.closed = true;
		shape1('ADBE Vector Shape').setValue(eyeShape1);
		var shape2 = iconContent.addProperty("ADBE Vector Shape - Group");
		var eyeShape2 = new Shape();
		eyeShape2.vertices = [[2.90478515625, 2.90478515625], [-2.90478515625, 2.90478515625], [-2.90478515625, -2.9046630859375], [2.90478515625, -2.9046630859375]];
		eyeShape2.inTangents = [[1.60421752929688, -1.604248046875], [1.60427856445313, 1.6043701171875], [-1.60421752929688, 1.604248046875], [-1.60427856445313, -1.6043701171875]];
		eyeShape2.outTangents = [[-1.60427856445313, 1.6043701171875], [-1.60421752929688, -1.604248046875], [1.60427856445313, -1.6043701171875], [1.60421752929688, 1.604248046875]];
		eyeShape2.closed = true;
		shape2('ADBE Vector Shape').setValue(eyeShape2);
		var stroke = iconContent.addProperty("ADBE Vector Graphic - Fill");
		stroke("ADBE Vector Fill Color").expression = 'effect("Controller")(2)';

		if (!layer) ctrl.name = DuAEF.DuAE.Comp.newUniqueLayerName('C Eye',comp);
	}
	else if (type == DuAEF.Duik.ControllerType.CAMERA)
	{
		var shape1 = iconContent.addProperty("ADBE Vector Shape - Group");
		var camShape = new Shape();
		camShape.vertices = [[7.78106689453125, -11.2048645019531], [0.37507629394531, -11.2048645019531], [-1.12208557128906, -8.09188842773438], [-1.89707946777344, -9.25259399414063], [-6.99104309082031, -9.25259399414063], [-6.99104309082031, -4.15861511230469], [-4.88467407226563, -3.14591979980469], [-5.13864135742188, -2.09954833984375], [-5.13864135742188, -0.74296569824219], [-8.45230102539063, -4.04814147949219], [-8.82221984863281, -4.2044677734375], [-9.02810668945313, -4.1634521484375], [-9.34848022460938, -3.67823791503906], [-9.34848022460938, 5.26766967773438], [-9.02810668945313, 5.75288391113281], [-8.82221984863281, 5.79389953613281], [-8.45230102539063, 5.6375732421875], [-5.13864135742188, 2.32426452636719], [-5.13864135742188, 3.68898010253906], [-2.77058410644531, 6.0570068359375], [3.01792907714844, 6.0570068359375], [5.385986328125, 3.68898010253906], [5.385986328125, -2.09954833984375], [5.35285949707031, -2.42805480957031], [7.78106689453125, -3.79896545410156]];
		camShape.inTangents = [[2.04505920410156, 2.04513549804688], [2.045166015625, -2.04508972167969], [0.1282958984375, -1.13729858398438], [0.343017578125, 0.34303283691406], [1.40667724609375, -1.40669250488281], [-1.40667724609375, -1.40669250488281], [-0.76953125, -0.09449768066406], [0, -0.37754821777344], [0, 0], [0, 0], [0.14004516601563, 0], [0.06578063964844, -0.02436828613281], [0, -0.21397399902344], [0, 0], [-0.18881225585938, -0.08242797851563], [-0.06576538085938, 0], [-0.09828186035156, 0.107177734375], [0, 0], [0, 0], [-1.30706787109375, 0], [0, 0], [0, 1.30744934082031], [0, 0], [0.01513671875, 0.10833740234375], [-0.69538879394531, 0.69540405273438]];
		camShape.outTangents = [[-2.04507446289063, -2.04513549804688], [-0.87216186523438, 0.87214660644531], [-0.17568969726563, -0.42166137695313], [-1.40667724609375, -1.40669250488281], [-1.40667724609375, 1.40669250488281], [0.59068298339844, 0.59065246582031], [-0.15728759765625, 0.31680297851563], [0, 0], [0, 0], [-0.09828186035156, -0.107177734375], [-0.06576538085938, 0], [-0.18881225585938, 0.08241271972656], [0, 0], [0, 0.21397399902344], [0.06578063964844, 0.02436828613281], [0.14004516601563, 0], [0, 0], [0, 0], [0, 1.30744934082031], [0, 0], [1.30706787109375, 0], [0, 0], [0, -0.11250305175781], [0.88937377929688, -0.22248840332031], [2.04510498046875, -2.04513549804688]];
		camShape.closed = true;
		shape1('ADBE Vector Shape').setValue(camShape);
		var stroke = iconContent.addProperty("ADBE Vector Graphic - Fill");
		stroke("ADBE Vector Fill Color").expression = 'effect("Controller")(2)';

		if (!layer) ctrl.name = DuAEF.DuAE.Comp.newUniqueLayerName('C Camera',comp);
	}
	else if (type == DuAEF.Duik.ControllerType.HAND)
	{
		var shape1 = iconContent.addProperty("ADBE Vector Shape - Group");
		var handShape = new Shape();
		handShape.vertices = [[-2.68119812011719, -16.7185821533203], [-2.68119812011719, -6.20103454589844], [-3.5106201171875, -6.87979125976563], [-3.5106201171875, -15.3451690673828], [-5.46514892578125, -16.4479370117188], [-6.83721923828125, -15.0365142822266], [-6.83721923828125, -6.57102966308594], [-7.27908325195313, -2.08331298828125], [-9.7742919921875, -5.36949157714844], [-11.4263000488281, -6.1875], [-13.5, -4.13543701171875], [-13.0783996582031, -2.90132141113281], [-6.85746765136719, 5.30699157714844], [-5.20538330078125, 6.125], [5.93984985351563, 6.125], [7.47970581054688, 4.87457275390625], [8.710205078125, -1.61825561523438], [8.79170227050781, -2.56480407714844], [8.79170227050781, -10.5487518310547], [6.97669982910156, -12.34375], [5.68247985839844, -10.5487518310547], [5.68247985839844, -6.1875], [4.64437866210938, -6.1875], [4.64437866210938, -14.6528778076172], [2.82939147949219, -16.4479370117188], [1.46612548828125, -14.6528778076172], [1.46612548828125, -6.1875], [0.4970703125, -6.1875], [0.4970703125, -16.7050018310547], [-1.31791687011719, -18.5]];
		handShape.inTangents = [[0, -0.99331665039063], [0, 0], [0, 0], [0, 0], [1.00485229492188, 0], [0, -0.99331665039063], [0, 0], [0, 0], [0, 0], [0.64822387695313, 0], [0, -1.12187194824219], [-0.27630615234375, -0.35185241699219], [0, 0], [-0.64830017089844, 0], [0, 0], [-0.14645385742188, 0.72105407714844], [0, 0], [0, 0.32136535644531], [0, 0], [1.00485229492188, 0], [0, -0.99336242675781], [0, 0], [0, 0], [0, 0], [1.00494384765625, 0], [0, -0.99337768554688], [0, 0], [0, 0], [0, 0], [1.00494384765625, 0]];
		handShape.outTangents = [[0, 0], [0, 0], [0, 0], [0, -0.99337768554688], [-1.0037841796875, 0], [0, 0], [0, 0], [0, 0], [-0.38844299316406, -0.51301574707031], [-1.15025329589844, 0], [0, 0.44880676269531], [0, 0], [0.38853454589844, 0.51301574707031], [0, 0], [0.74624633789063, 0], [0, 0], [0.04949951171875, -0.30499267578125], [0, 0], [0, -0.99336242675781], [-1.0037841796875, 0], [0, 0], [0, 0], [0, 0], [0, -0.99337768554688], [-1.00379943847656, 0], [0, 0], [0, 0], [0, 0], [0, -0.99336242675781], [-1.00379943847656, 0]];
		handShape.closed = true;
		shape1('ADBE Vector Shape').setValue(handShape);
		var stroke = iconContent.addProperty("ADBE Vector Graphic - Fill");
		stroke("ADBE Vector Fill Color").expression = 'effect("Controller")(2)';

		if (!layer) ctrl.name = DuAEF.DuAE.Comp.newUniqueLayerName('C Hand',comp);
	}
	else if (type == DuAEF.Duik.ControllerType.HEAD)
	{
		var shape1 = iconContent.addProperty("ADBE Vector Shape - Group");
		var headShape1 = new Shape();
		headShape1.vertices = [[0.07601928710938, 4.5526123046875], [0.56736755371094, 4.49830627441406], [2.057373046875, 4.99415588378906], [2.75151062011719, 5.75994873046875], [2.7535400390625, 5.76361083984375], [2.92665100097656, 6.15760803222656], [3.485595703125, 7.86418151855469], [7.72793579101563, 8.93666076660156], [12.2799072265625, 7.73506164550781], [12.2053833007813, 7.41508483886719], [11.2237243652344, 6.51840209960938], [11.0206451416016, 6.49006652832031], [10.7710266113281, 6.26759338378906], [11.5906677246094, 3.20623779296875], [11.25732421875, 2.13850402832031], [11.1351928710938, 2.03802490234375], [10.8557434082031, 1.77583312988281], [10.8630828857422, 1.49192810058594], [2.74903869628906, -5.74658203125], [1.78193664550781, -5.72299194335938], [-6.7783203125, 4.7183837890625], [-1.06082153320313, 8.6998291015625], [-1.51547241210938, 7.1868896484375], [-1.24484252929688, 5.54035949707031]];
		headShape1.inTangents = [[-0.55696105957031, 0.12583923339844], [-0.16351318359375, 0], [-0.42343139648438, -0.30520629882813], [-0.17152404785156, -0.30897521972656], [-0.00068664550781, -0.00119018554688], [-0.04542541503906, -0.13873291015625], [0, 0], [-1.26594543457031, 0], [-0.27592468261719, 0.14794921875], [0, 0], [0.48114013671875, 0.06709289550781], [0, 0], [0.030517578125, 0.117919921875], [-0.29583740234375, 1.03759765625], [0.31387329101563, 0.25784301757813], [0, 0], [0, 0], [0, 0.09513854980469], [5.11787414550781, 0.00019836425781], [0.33038330078125, -0.01560974121094], [0, -5.89620971679688], [-3.58978271484375, -0.12089538574219], [0, 0], [-0.28395080566406, 0.49546813964844]];
		headShape1.outTangents = [[0.16314697265625, -0.036865234375], [0.53974914550781, 0], [0.28424072265625, 0.19630432128906], [0.00054931640625, 0.00119018554688], [0.06857299804688, 0.12416076660156], [0, 0], [1.52705383300781, 0.80026245117188], [2.49287414550781, 0], [0, 0], [-0.11029052734375, -0.4732666015625], [0, 0], [-0.12055969238281, -0.01675415039063], [-0.02224731445313, -0.08599853515625], [0.11137390136719, -0.390625], [0, 0], [0, 0], [0.00440979003906, -0.09413146972656], [0, -5.14309692382813], [-0.31462097167969, 0], [-5.17431640625, 0.24435424804688], [0, 3.22795104980469], [0, 0], [-0.16680908203125, -0.54611206054688], [0.28395080566406, -0.49546813964844]];
		headShape1.closed = true;
		shape1('ADBE Vector Shape').setValue(headShape1);
		var shape2 = iconContent.addProperty("ADBE Vector Shape - Group");
		var headShape2 = new Shape();
		headShape2.vertices = [[12.6515502929688, 9.70046997070313], [12.5136108398438, 9.10829162597656], [9.61198425292969, 10.0135955810547], [7.72348022460938, 10.1756134033203], [7.48377990722656, 10.1730346679688], [3.73471069335938, 9.40110778808594], [4.123046875, 10.5869445800781], [4.16423034667969, 10.7126007080078], [4.41374206542969, 10.9648895263672], [6.05886840820313, 11.5229797363281], [6.36839294433594, 11.9959411621094], [5.93084716796875, 12.3849792480469], [5.78929138183594, 12.3614044189453], [4.13058471679688, 11.7986450195313], [3.32719421386719, 10.9866790771484], [1.82598876953125, 6.43150329589844], [1.42034912109375, 5.91969299316406], [0.75732421875, 5.71040344238281], [0.49372863769531, 5.74131774902344], [-0.24122619628906, 6.29109191894531], [-0.37342834472656, 7.08253479003906], [1.14744567871094, 11.6554565429688], [4.58695983886719, 14.1050262451172], [10.8408813476563, 14.1362457275391], [10.8547058105469, 14.1362457275391], [12.0494689941406, 13.6215515136719], [12.1658477783203, 11.652587890625], [12.1540069580078, 11.6359405517578], [12.2690582275391, 10.8446807861328]];
		headShape2.inTangents = [[0.09844970703125, 0.42301940917969], [0, 0], [1.37258911132813, -0.236328125], [0.70187377929688, 0], [0.08065795898438, 0.00177001953125], [1.33784484863281, 0.54164123535156], [0, 0], [0, 0], [-0.11827087402344, -0.04013061523438], [0, 0], [0.02670288085938, -0.20907592773438], [0.21180725097656, -0.00009155273438], [0.04692077636719, 0.01605224609375], [0, 0], [0.12445068359375, 0.38002014160156], [0, 0], [0.19952392578125, 0.14932250976563], [0.23930358886719, 0], [0.08790588378906, -0.02090454101563], [0.15794372558594, -0.27578735351563], [-0.05113220214844, -0.26933288574219], [0, 0], [-1.54896545410156, -0.00772094726563], [0, 0], [0, 0], [-0.30189514160156, 0.33651733398438], [0.41867065429688, 0.58851623535156], [0, 0], [-0.23722839355469, 0.19879150390625]];
		headShape2.outTangents = [[0, 0], [-0.49571228027344, 0.23722839355469], [-0.54867553710938, 0.09452819824219], [-0.07907104492188, 0], [-1.12916564941406, -0.02476501464844], [0, 0], [0, 0], [0.03889465332031, 0.11871337890625], [0, 0], [0.19963073730469, 0.06777954101563], [-0.03012084960938, 0.23484802246094], [-0.04692077636719, 0], [0, 0], [-0.37858581542969, -0.12841796875], [0, 0], [-0.05796813964844, -0.17678833007813], [-0.1923828125, -0.13348388671875], [-0.08735656738281, 0], [-0.30906677246094, 0.07362365722656], [-0.13734436035156, 0.23970031738281], [0, 0], [0.51370239257813, 1.46122741699219], [0, 0], [0, 0], [0.45205688476563, 0], [0.50735473632813, -0.56571960449219], [0, 0], [-0.17930603027344, -0.25199890136719], [0.33305358886719, -0.27864074707031]];
		headShape2.closed = true;
		shape2('ADBE Vector Shape').setValue(headShape2);
		var shape3 = iconContent.addProperty("ADBE Vector Shape - Group");
		var headShape3 = new Shape();
		headShape3.vertices = [[6.95457458496094, 1.12509155273438], [9.45245361328125, 3.99214172363281], [6.95457458496094, 6.85928344726563], [4.08747863769531, 3.99214172363281]];
		headShape3.inTangents = [[-1.58345031738281, 0], [0, -1.58349609375], [1.58345031738281, 0], [0, 1.58349609375]];
		headShape3.outTangents = [[1.58345031738281, 0], [0, 1.58349609375], [-1.58345031738281, 0], [0, -1.58349609375]];
		headShape3.closed = true;
		shape3('ADBE Vector Shape').setValue(headShape3);
		var stroke = iconContent.addProperty("ADBE Vector Graphic - Fill");
		stroke("ADBE Vector Fill Color").expression = 'effect("Controller")(2)';

		if (!layer) ctrl.name = DuAEF.DuAE.Comp.newUniqueLayerName('C Head',comp);
	}
	else if (type == DuAEF.Duik.ControllerType.FOOT)
	{
		var shape1 = iconContent.addProperty("ADBE Vector Shape - Group");
		var footShape1 = new Shape();
		footShape1.vertices = [[6.88278198242188, -9.7200927734375], [3.90739440917969, -3.1824951171875], [-0.44120788574219, 5.78070068359375], [-3.75990295410156, 1.52886962890625], [-2.35670471191406, -5.4683837890625], [-4.10319519042969, -10.984130859375], [-1.69999694824219, -14.7761840820313], [3.56410217285156, -14.0867919921875]];
		footShape1.inTangents = [[-0.34330749511719, -2.06842041015625], [0.114501953125, -4.7113037109375], [3.20420837402344, 0.22979736328125], [-0.22880554199219, 1.72369384765625], [0, 3.3323974609375], [0.45779418945313, 2.06842041015625], [-1.71659851074219, 0], [-2.05990600585938, -1.37890625]];
		footShape1.outTangents = [[0.34330749511719, 2.068359375], [-0.11439514160156, 4.71136474609375], [-3.20419311523438, -0.22991943359375], [0.22889709472656, -1.72369384765625], [0, -3.3323974609375], [-0.45770263671875, -2.0684814453125], [1.71659851074219, 0], [2.05987548828125, 1.37896728515625]];
		footShape1.closed = true;
		shape1('ADBE Vector Shape').setValue(footShape1);
		var shape2 = iconContent.addProperty("ADBE Vector Shape - Group");
		var footShape2 = new Shape();
		footShape2.vertices = [[-3.22090148925781, -21.7741088867188], [-5.585205078125, -18.3458251953125], [-4.04840087890625, -15.9813842773438], [-1.5657958984375, -18.9368286132813]];
		footShape2.inTangents = [[0, 0], [-0.11819458007813, -1.773193359375], [0, 0], [-0.11820983886719, 3.0736083984375]];
		footShape2.outTangents = [[-1.65499877929688, 0.23651123046875], [0.11820983886719, 1.7733154296875], [0, 0], [0.11819458007813, -3.07366943359375]];
		footShape2.closed = true;
		shape2('ADBE Vector Shape').setValue(footShape2);
		var shape3 = iconContent.addProperty("ADBE Vector Shape - Group");
		var footShape3 = new Shape();
		footShape3.vertices = [[2.27139282226563, -18.6461791992188], [0.14349365234375, -19.7100830078125], [0.49819946289063, -16.7546997070313]];
		footShape3.inTangents = [[-0.35459899902344, 1.18218994140625], [0.35470581054688, -1.06402587890625], [-0.472900390625, 0]];
		footShape3.outTangents = [[0.35470581054688, -1.18212890625], [-0.35459899902344, 1.06390380859375], [0.47279357910156, 0]];
		footShape3.closed = true;
		shape3('ADBE Vector Shape').setValue(footShape3);
		var shape4 = iconContent.addProperty("ADBE Vector Shape - Group");
		var footShape4 = new Shape();
		footShape4.vertices = [[5.67475891113281, -17.3997802734375], [3.91279602050781, -18.6842041015625], [3.78520202636719, -15.959228515625]];
		footShape4.inTangents = [[-0.49983215332031, 1.0146484375], [0.48190307617188, -0.90777587890625], [-0.42739868164063, -0.0716552734375]];
		footShape4.outTangents = [[0.49983215332031, -1.01470947265625], [-0.48190307617188, 0.90789794921875], [0.42739868164063, 0.07183837890625]];
		footShape4.closed = true;
		shape4('ADBE Vector Shape').setValue(footShape4);
		var shape5 = iconContent.addProperty("ADBE Vector Shape - Group");
		var footShape5 = new Shape();
		footShape5.vertices = [[8.37980651855469, -15.9772338867188], [6.87852478027344, -16.8713989257813], [6.978759765625, -14.6873779296875]];
		footShape5.inTangents = [[-0.3236083984375, 0.8468017578125], [0.31723022460938, -0.76019287109375], [-0.34637451171875, -0.0255126953125]];
		footShape5.outTangents = [[0.32359313964844, -0.8468017578125], [-0.31721496582031, 0.76019287109375], [0.34637451171875, 0.02545166015625]];
		footShape5.closed = true;
		shape5('ADBE Vector Shape').setValue(footShape5);
		var stroke = iconContent.addProperty("ADBE Vector Graphic - Fill");
		stroke("ADBE Vector Fill Color").expression = 'effect("Controller")(2)';

		if (!layer) ctrl.name = DuAEF.DuAE.Comp.newUniqueLayerName('C Foot',comp);
	}
	else if (type == DuAEF.Duik.ControllerType.CLAWS)
	{
		var shape1 = iconContent.addProperty("ADBE Vector Shape - Group");
		var clawsShape1 = new Shape();
		clawsShape1.vertices = [[-7.32080078125, -4.333740234375], [-9.80509948730469, -1.18695068359375], [-9.80509948730469, 5.76904296875], [-5.16769409179688, 1.1317138671875], [-7.81759643554688, -1.683837890625]];
		clawsShape1.inTangents = [[0, 0], [0, 0], [-2.98109436035156, -0.828125], [0.82809448242188, 2.8155517578125], [0, 0]];
		clawsShape1.outTangents = [[0, 0], [0, 0], [2.981201171875, 0.828125], [-0.82810974121094, -2.8155517578125], [0, 0]];
		clawsShape1.closed = true;
		shape1('ADBE Vector Shape').setValue(clawsShape1);
		var shape2 = iconContent.addProperty("ADBE Vector Shape - Group");
		var clawsShape2 = new Shape();
		clawsShape2.vertices = [[-2.02090454101563, -14.5528564453125], [-3.67709350585938, -11.4060668945313], [-7.15510559082031, -6.10626220703125], [-2.18649291992188, -3.45623779296875], [-1.19279479980469, -10.9092407226563]];
		clawsShape2.inTangents = [[0, 0], [0, 0], [-0.91690063476563, -3.66741943359375], [-1.99610900878906, 1.24749755859375], [2.31869506835938, 1.98748779296875]];
		clawsShape2.outTangents = [[0, 0], [0, 0], [0.66239929199219, 2.6500244140625], [2.64990234375, -1.65618896484375], [0, 0]];
		clawsShape2.closed = true;
		shape2('ADBE Vector Shape').setValue(clawsShape2);
		var shape3 = iconContent.addProperty("ADBE Vector Shape - Group");
		var clawsShape3 = new Shape();
		clawsShape3.vertices = [[3.06401062011719, -14.5528564453125], [2.23580932617188, -10.9092407226563], [2.73269653320313, -2.95947265625], [7.86689758300781, -6.10626220703125], [4.72019958496094, -10.9092407226563]];
		clawsShape3.inTangents = [[0, 0], [0, 0], [-3.66999816894531, -3.05828857421875], [0.66250610351563, 3.47808837890625], [0, 0]];
		clawsShape3.outTangents = [[0, 0], [0, 0], [1.98750305175781, 1.65618896484375], [-0.66239929199219, -3.47796630859375], [0, 0]];
		clawsShape3.closed = true;
		shape3('ADBE Vector Shape').setValue(clawsShape3);
		var shape4 = iconContent.addProperty("ADBE Vector Shape - Group");
		var clawsShape4 = new Shape();
		clawsShape4.vertices = [[8.97689819335938, -3.45623779296875], [9.97061157226563, -0.80633544921875], [9.47380065917969, 6.31536865234375], [5.00199890136719, 2.83721923828125], [7.98320007324219, -0.80633544921875]];
		clawsShape4.inTangents = [[0, 0], [0, 0], [3.31240844726563, -2.981201171875], [-0.49679565429688, 1.987548828125], [0, 0]];
		clawsShape4.outTangents = [[0, 0], [0, 0], [-3.31239318847656, 2.9810791015625], [0.49690246582031, -1.98736572265625], [0, 0]];
		clawsShape4.closed = true;
		shape4('ADBE Vector Shape').setValue(clawsShape4);
		var shape5 = iconContent.addProperty("ADBE Vector Shape - Group");
		var clawsShape5 = new Shape();
		clawsShape5.vertices = [[-0.4873046875, 3.38055419921875], [2.30580139160156, 6.5460205078125], [5.65750122070313, 11.2012329101563], [-6.44589233398438, 11.2012329101563], [-4.58389282226563, 6.17364501953125]];
		clawsShape5.inTangents = [[-2.42070007324219, 0], [-1.48970031738281, -0.93096923828125], [1.86199951171875, -3.3516845703125], [2.32418823242188, 2.61480712890625], [-2.60690307617188, 1.1171875]];
		clawsShape5.outTangents = [[2.42060852050781, 0], [1.48960876464844, 0.93115234375], [-1.86209106445313, 3.3516845703125], [-2.97930908203125, -3.3516845703125], [2.42048645019531, -1.03729248046875]];
		clawsShape5.closed = true;
		shape5('ADBE Vector Shape').setValue(clawsShape5);
		var stroke = iconContent.addProperty("ADBE Vector Graphic - Fill");
		stroke("ADBE Vector Fill Color").expression = 'effect("Controller")(2)';

		if (!layer) ctrl.name = DuAEF.DuAE.Comp.newUniqueLayerName('C Claws',comp);
	}
	else if (type == DuAEF.Duik.ControllerType.HOOF)
	{
		var shape1 = iconContent.addProperty("ADBE Vector Shape - Group");
		var hoofShape1 = new Shape();
		hoofShape1.vertices = [[10.866455078125, -5.94781494140625], [0.00125122070313, -12.45849609375], [-10.8229522705078, -6.30657958984375], [-7.03684997558594, 11.4263305664063], [-4.93815612792969, 12.45849609375], [-3.32534790039063, 11.9097290039063], [-2.841552734375, 8.19818115234375], [-6.07394409179688, -3.9677734375], [0.00125122070313, -7.16497802734375], [6.07255554199219, -3.70172119140625], [2.90756225585938, 8.11767578125], [3.24736022949219, 11.845703125], [4.94076538085938, 12.45849609375], [6.97445678710938, 11.5062866210938]];
		hoofShape1.inTangents = [[2.40040588378906, 5.125], [4.89360046386719, 0], [1.92530822753906, -3.90972900390625], [-4.85060119628906, -6.30621337890625], [-0.82818603515625, 0], [-0.46730041503906, 0.3592529296875], [0.89019775390625, 1.15631103515625], [-1.49661254882813, 3.04046630859375], [-2.85989379882813, 0], [-1.03079223632813, -2.2010498046875], [3.48818969726563, -4.185546875], [-1.12161254882813, -0.9345703125], [-0.61720275878906, 0], [-0.50389099121094, 0.60504150390625]];
		hoofShape1.outTangents = [[-1.90959167480469, -4.07659912109375], [-4.95359802246094, 0], [-2.44389343261719, 4.96380615234375], [0.50540161132813, 0.65570068359375], [0.58781433105469, 0], [1.15669250488281, -0.89019775390625], [-3.52099609375, -4.57708740234375], [1.00099182128906, -2.03173828125], [2.82760620117188, 0], [1.50630187988281, 3.2154541015625], [-0.93360900878906, 1.12115478515625], [0.47459411621094, 0.3955078125], [0.78849792480469, 0], [4.83740234375, -5.80419921875]];
		hoofShape1.closed = true;
		shape1('ADBE Vector Shape').setValue(hoofShape1);
		var shape2 = iconContent.addProperty("ADBE Vector Shape - Group");
		var hoofShape2 = new Shape();
		hoofShape2.vertices = [[-10.4445953369141, -4.091796875], [-9.95089721679688, -4.515625], [-9.87429809570313, -4.50982666015625], [-7.89720153808594, -4.20562744140625], [-7.57009887695313, -4.00732421875], [-7.47920227050781, -3.63531494140625], [-7.78340148925781, -1.658203125], [-7.98170471191406, -1.33111572265625], [-8.27760314941406, -1.234375], [-8.35369873046875, -1.24017333984375], [-10.3307952880859, -1.54437255859375], [-10.7488098144531, -2.11468505859375]];
		hoofShape2.inTangents = [[0, 0], [-0.24270629882813, 0], [-0.02580261230469, -0.00384521484375], [0, 0], [-0.07859802246094, -0.10699462890625], [0.02000427246094, -0.13128662109375], [0, 0], [0.10700988769531, -0.07861328125], [0.10549926757813, 0], [0.02529907226563, 0.00384521484375], [0, 0], [-0.0419921875, 0.27288818359375]];
		hoofShape2.outTangents = [[0.0380859375, -0.24713134765625], [0.025390625, 0], [0, 0], [0.13090515136719, 0.0201416015625], [0.07820129394531, 0.10693359375], [0, 0], [-0.02009582519531, 0.13092041015625], [-0.08639526367188, 0.06298828125], [-0.02540588378906, 0], [0, 0], [-0.27290344238281, -0.04205322265625], [0, 0]];
		hoofShape2.closed = true;
		shape2('ADBE Vector Shape').setValue(hoofShape2);
		var shape3 = iconContent.addProperty("ADBE Vector Shape - Group");
		var hoofShape3 = new Shape();
		hoofShape3.vertices = [[-7.70234680175781, 3.169921875], [-9.65644836425781, 3.5947265625], [-9.76335144042969, 3.60601806640625], [-10.2516479492188, 3.21240234375], [-10.6764526367188, 1.25830078125], [-10.2941436767578, 0.6630859375], [-8.34004211425781, 0.23828125], [-8.233154296875, 0.22698974609375], [-7.74484252929688, 0.62060546875], [-7.32005310058594, 2.57470703125]];
		hoofShape3.inTangents = [[0.26950073242188, -0.05914306640625], [0, 0], [0.03509521484375, 0], [0.05130004882813, 0.23388671875], [0, 0], [-0.26950073242188, 0.05914306640625], [0, 0], [-0.03509521484375, 0], [-0.05130004882813, -0.23388671875], [0, 0]];
		hoofShape3.outTangents = [[0, 0], [-0.03610229492188, 0.00775146484375], [-0.22999572753906, 0], [0, 0], [-0.05859375, -0.27001953125], [0, 0], [0.03608703613281, -0.00775146484375], [0.23001098632813, 0], [0, 0], [0.05860900878906, 0.27001953125]];
		hoofShape3.closed = true;
		shape3('ADBE Vector Shape').setValue(hoofShape3);
		var shape4 = iconContent.addProperty("ADBE Vector Shape - Group");
		var hoofShape4 = new Shape();
		hoofShape4.vertices = [[-5.20234680175781, -6.921875], [-6.45675659179688, -5.36376953125], [-6.84684753417969, -5.17730712890625], [-7.15985107421875, -5.28759765625], [-8.71795654296875, -6.5419921875], [-8.79414367675781, -7.2451171875], [-7.53974914550781, -8.80322265625], [-7.14964294433594, -8.98980712890625], [-6.83665466308594, -8.87939453125], [-5.27854919433594, -7.625]];
		hoofShape4.inTangents = [[0.17289733886719, -0.21484375], [0, 0], [0.14649963378906, 0], [0.09230041503906, 0.07421875], [0, 0], [-0.17280578613281, 0.21484375], [0, 0], [-0.14649963378906, 0], [-0.09230041503906, -0.07421875], [0, 0]];
		hoofShape4.outTangents = [[0, 0], [-0.09909057617188, 0.12255859375], [-0.10990905761719, 0], [0, 0], [-0.21539306640625, -0.17327880859375], [0, 0], [0.09910583496094, -0.12255859375], [0.10989379882813, 0], [0, 0], [0.21539306640625, 0.17327880859375]];
		hoofShape4.closed = true;
		shape4('ADBE Vector Shape').setValue(hoofShape4);
		var shape5 = iconContent.addProperty("ADBE Vector Shape - Group");
		var hoofShape5 = new Shape();
		hoofShape5.vertices = [[10.0544586181641, -4.72412109375], [10.3503570556641, -4.62738037109375], [10.5486602783203, -4.30029296875], [10.8528594970703, -2.32318115234375], [10.4348602294922, -1.75286865234375], [8.45785522460938, -1.44866943359375], [8.38165283203125, -1.44287109375], [8.08575439453125, -1.53961181640625], [7.887451171875, -1.8671875], [7.58375549316406, -3.84417724609375], [8.00175476074219, -4.41412353515625], [9.97836303710938, -4.71832275390625]];
		hoofShape5.inTangents = [[-0.02540588378906, 0], [-0.08639526367188, -0.06298828125], [-0.02000427246094, -0.13092041015625], [0, 0], [0.27299499511719, -0.04205322265625], [0, 0], [0.02540588378906, 0], [0.08641052246094, 0.06298828125], [0.02011108398438, 0.13140869140625], [0, 0], [-0.27290344238281, 0.04205322265625], [0, 0]];
		hoofShape5.outTangents = [[0.10549926757813, 0], [0.10699462890625, 0.07861328125], [0, 0], [0.0419921875, 0.27288818359375], [0, 0], [-0.025390625, 0.00384521484375], [-0.10598754882813, 0], [-0.10690307617188, -0.07861328125], [0, 0], [-0.0419921875, -0.27252197265625], [0, 0], [0.025390625, -0.00384521484375]];
		hoofShape5.closed = true;
		shape5('ADBE Vector Shape').setValue(hoofShape5);
		var shape6 = iconContent.addProperty("ADBE Vector Shape - Group");
		var hoofShape6 = new Shape();
		hoofShape6.vertices = [[7.06625366210938, -5.17730712890625], [7.012451171875, -5.18017578125], [6.67655944824219, -5.36376953125], [5.42265319824219, -6.921875], [5.49885559082031, -7.625], [7.05696105957031, -8.87939453125], [7.37045288085938, -8.98980712890625], [7.42416381835938, -8.98681640625], [7.76005554199219, -8.80322265625], [9.01396179199219, -7.2451171875], [8.93775939941406, -6.5419921875], [7.37965393066406, -5.28759765625]];
		hoofShape6.inTangents = [[0.11370849609375, 0], [0.01811218261719, 0.001953125], [0.08349609375, 0.10345458984375], [0, 0], [-0.21539306640625, 0.17327880859375], [0, 0], [-0.11380004882813, 0], [-0.01811218261719, -0.001953125], [-0.08349609375, -0.10345458984375], [0, 0], [0.21539306640625, -0.17327880859375], [0, 0]];
		hoofShape6.outTangents = [[-0.01809692382813, 0], [-0.13179016113281, -0.01409912109375], [0, 0], [-0.17289733886719, -0.21533203125], [0, 0], [0.08929443359375, -0.07177734375], [0.01800537109375, 0], [0.13179016113281, 0.01409912109375], [0, 0], [0.17289733886719, 0.21533203125], [0, 0], [-0.08929443359375, 0.07177734375]];
		hoofShape6.closed = true;
		shape6('ADBE Vector Shape').setValue(hoofShape6);
		var shape7 = iconContent.addProperty("ADBE Vector Shape - Group");
		var hoofShape7 = new Shape();
		hoofShape7.vertices = [[10.4714660644531, 3.21240234375], [9.983154296875, 3.60601806640625], [9.87625122070313, 3.5947265625], [7.92216491699219, 3.169921875], [7.53985595703125, 2.57470703125], [7.96466064453125, 0.62060546875], [8.45295715332031, 0.22698974609375], [8.55935668945313, 0.23828125], [10.5139617919922, 0.6630859375], [10.8284606933594, 0.88128662109375], [10.8967590332031, 1.25830078125]];
		hoofShape7.inTangents = [[0, 0], [0.23001098632813, 0], [0.03610229492188, 0.00775146484375], [0, 0], [-0.05859375, 0.27001953125], [0, 0], [-0.22999572753906, 0], [-0.03559875488281, -0.00775146484375], [0, 0], [-0.07130432128906, -0.11126708984375], [0.02789306640625, -0.1298828125]];
		hoofShape7.outTangents = [[-0.05120849609375, 0.23388671875], [-0.03509521484375, 0], [0, 0], [-0.26950073242188, -0.05914306640625], [0, 0], [0.05130004882813, -0.23388671875], [0.03509521484375, 0], [0, 0], [0.12989807128906, 0.0283203125], [0.07170104980469, 0.1119384765625], [0, 0]];
		hoofShape7.closed = true;
		shape7('ADBE Vector Shape').setValue(hoofShape7);
		var stroke = iconContent.addProperty("ADBE Vector Graphic - Fill");
		stroke("ADBE Vector Fill Color").expression = 'effect("Controller")(2)';

		if (!layer) ctrl.name = DuAEF.DuAE.Comp.newUniqueLayerName('C Hoof',comp);
	}
	else if (type == DuAEF.Duik.ControllerType.SLIDER)
	{
		var shape1 = iconContent.addProperty("ADBE Vector Shape - Ellipse");
		shape1('ADBE Vector Ellipse Size').expression = 'c = (effect("Slider")(3))/5-2;\n[c, c]';
		var stroke = iconContent.addProperty("ADBE Vector Graphic - Fill");
		stroke("ADBE Vector Fill Color").expression = 'effect("Slider")(2)';

		iconGroup.transform.position.expression = '[value[0],0];';
		iconGroup.transform.opacity.expression = 'effect("Slider")(4)';
		//Set initial keyframe
		iconGroup.transform.position.setValueAtTime(0,[0,0]);

		//create anchor
		var anchorGroup = ctrl("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
		anchorGroup.name = 'Anchor';
		var anchorContent = anchorGroup.property("ADBE Vectors Group");
		var rectangle = anchorContent.addProperty("ADBE Vector Shape - Rect");
		rectangle("ADBE Vector Rect Size").expression = 'c = effect("Slider")(3)/100*20;\nx = effect("Slider")(8)+c;\n[x,c]';
		rectangle("ADBE Vector Rect Roundness").expression = 'effect("Slider")(3)/100*10';
		var stroke = anchorContent.addProperty("ADBE Vector Graphic - Stroke");
		stroke("ADBE Vector Stroke Color").expression = 'effect("Slider")(7)';
		stroke("ADBE Vector Stroke Width").expression = '100/content("Anchor").transform.scale[0]';
		stroke("ADBE Vector Stroke Line Cap").setValue(2);

		effect(18).expression = 'x = content("Icon").transform.position[0];\n' +
						'c = effect("Slider")(3)/100*20;\n' +
						'h = effect("Slider")(8)+c;\n' +
						'h = h-c;\n' +
						'h = h/2;\n' +
						'linear(x,-h,h,-100,100);';



		if (!layer) ctrl.name = DuAEF.DuAE.Comp.newUniqueLayerName('C Slider',comp);
	}
	else if (type == DuAEF.Duik.ControllerType.DOUBLE_SLIDER)
	{
		var shape1 = iconContent.addProperty("ADBE Vector Shape - Ellipse");
		shape1('ADBE Vector Ellipse Size').expression = 'c = (effect("Slider")(3))/5-2;\n[c, c]';
		var stroke = iconContent.addProperty("ADBE Vector Graphic - Fill");
		stroke("ADBE Vector Fill Color").expression = 'effect("Slider")(2)';

		iconGroup.transform.opacity.expression = 'effect("Slider")(4)';
		//Set initial keyframe
		iconGroup.transform.position.setValueAtTime(0,[0,0]);

		//create anchor
		var anchorGroup = ctrl("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
		anchorGroup.name = 'Anchor';
		var anchorContent = anchorGroup.property("ADBE Vectors Group");
		var rectangle = anchorContent.addProperty("ADBE Vector Shape - Rect");
		rectangle("ADBE Vector Rect Size").expression = 'c = effect("Slider")(3)/100*20;\nx = effect("Slider")(8)+c;\n[x,x]';
		rectangle("ADBE Vector Rect Roundness").expression = 'effect("Slider")(3)/100*10';
		var stroke = anchorContent.addProperty("ADBE Vector Graphic - Stroke");
		stroke("ADBE Vector Stroke Color").expression = 'effect("Slider")(7)';
		stroke("ADBE Vector Stroke Width").expression = '100/content("Anchor").transform.scale[0]';
		stroke("ADBE Vector Stroke Line Cap").setValue(2);

		effect(18).expression = 'x = content("Icon").transform.position[0];\n' +
						'c = effect("Slider")(3)/100*20;\n' +
						'h = effect("Slider")(8)+c;\n' +
						'h = h-c;\n' +
						'h = h/2;\n' +
						'linear(x,-h,h,-100,100);';
		effect(19).expression = 'x = content("Icon").transform.position[1];\n' +
						'c = effect("Slider")(3)/100*20;\n' +
						'h = effect("Slider")(8)+c;\n' +
						'h = h-c;\n' +
						'h = h/2;\n' +
						'linear(x,-h,h,-100,100);';
		effect(20).expression = '[effect("Slider")(18),effect("Slider")(19)]';

		if (!layer) ctrl.name = DuAEF.DuAE.Comp.newUniqueLayerName('C Slider',comp);
	}
	else if (type == DuAEF.Duik.ControllerType.ANGLE)
	{
		var shape1 = iconContent.addProperty("ADBE Vector Shape - Group");
		var angleShape = new Shape();
		angleShape.vertices = [[0, 0.25], [0, -24.5]];
		angleShape.inTangents = [[0, 0], [0, 0]];
		angleShape.outTangents = [[0, 0], [0, 0]];
		angleShape.closed = false;
		shape1('ADBE Vector Shape').setValue(angleShape);
		var stroke = iconContent.addProperty("ADBE Vector Graphic - Stroke");
		stroke("ADBE Vector Stroke Color").expression = 'effect("Angle")(2)';
		stroke("ADBE Vector Stroke Width").setValue(1.5);
		stroke("ADBE Vector Stroke Line Cap").setValue(2);

		iconGroup.transform.opacity.expression = 'effect("Angle")(4)';
		iconGroup.transform.scale.expression = '[effect("Angle")(3)*2,effect("Angle")(3)*2]';
		iconGroup.transform.rotation.setValueAtTime(0,0);

		//create anchor
		var anchorGroup = ctrl("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
		anchorGroup.name = 'Anchor';
		var anchorContent = anchorGroup.property("ADBE Vectors Group");
		var circle = anchorContent.addProperty("ADBE Vector Shape - Ellipse");
		circle("ADBE Vector Ellipse Size").expression = 'x = effect("Angle")(8);\n[x,x]';
		var stroke = anchorContent.addProperty("ADBE Vector Graphic - Stroke");
		stroke("ADBE Vector Stroke Color").expression = 'effect("Angle")(7)';
		stroke("ADBE Vector Stroke Width").expression = '100/content("Anchor").transform.scale[0]';
		stroke("ADBE Vector Stroke Line Cap").setValue(2);

		effect(18).expression = 'content("Icon").transform.rotation';

		if (!layer) ctrl.name = DuAEF.DuAE.Comp.newUniqueLayerName('C Angle',comp);
	}

	if (layer)
	{
		//center the controller and name it after the layer
		ctrl.transform.position.setValue(DuAEF.DuAE.Layer.getWorldPos(layer));
		var newName = layer.name;
		if (newName.indexOf(' | ') >= 0) newName = newName.substring(newName.indexOf(' | ') + 3);
		if (newName.indexOf('_') == 1 || newName.indexOf(' ') == 1) newName = newName.substring(2);
		newName = 'C | ' + newName;
		ctrl.name = DuAEF.DuAE.Comp.newUniqueLayerName(newName,comp);
	}

	var marker = new MarkerValue('Controller');
	marker.setParameters({duik:'controller'});
	ctrl.property('ADBE Marker').setValueAtTime(0,marker);

	DuAEF.Dugr.addLayerToGroup(ctrl,"Controllers");
	ctrl.guideLayer = true;
	ctrl = new Controller(ctrl,type);
	ctrl.setSize(size);
	ctrl.setColor(color);
	return ctrl;
}

/**
* Rigging tools
* @namespace
* @memberof DuAEF.Duik
*/
DuAEF.Duik.Rigging = {};

/**
* Adds a zero to a layer
* @param {Layer} layer - The layer
* @return {AVLayer} The zero, a null
*/
DuAEF.Duik.Rigging.addZero = function (layer)
{
	//create null object
	var zero = layer.containingComp.layers.addNull();
	DuAEF.Dugr.addLayerToGroup(zero,"Zeros");
	var layerparent = layer.parent;
	layer.parent = null;
	zero.position.setValue(layer.position.value);
	zero.rotation.setValue(layer.rotation.value);
	zero.name = "Zero | " + layer.name.slice(-24);
	layer.parent = zero;
	zero.scale.setValue(layer.scale.value);
	layer.scale.setValue([100,100,100]);

	DuAEF.Duik.setDuikMarker(zero,"Zero",DuAEF.Duik.LayerTypes.ZERO);

	//parent
	zero.parent = layerparent;

	//lock and hide
	zero.moveToEnd();
	zero.guideLayer = true;
	zero.shy = true;
	zero.enabled = false;
	zero.selected = false;
	zero.locked = true;
	return zero;
}

/**
* Adds an orientation constraint to a layer
* @param {Layer} layer - The layer
*/
DuAEF.Duik.Rigging.orientationConstraint = function (layer)
{
	var effect = DuAEF.DuAE.Layer.addPseudoEffect(layer,DuAEF.Duik.PseudoEffects.ORIENTATION,DuAEF.Duik.PseudoEffectsMatchNames.ORIENTATION,'Orientation constraint');

	layer.rotation.expression = '//Duik.orientationConstraint\n' +
						'function o(l)\n' +
						'{\n' +
						'var r = 0;\n' +
						'r += l.rotation;\n' +
						'while(l.hasParent)\n' +
						'{\n' +
						'l = l.parent;\n' +
						'r += l.rotation;\n' +
						'}\n' +
						'return r;\n' +
						'}\n' +
						'var result = value;\n' +
						'for (var i = 1 ; i <= thisLayer("Effects").numProperties ; i++)\n' +
						'{\n' +
						'var fx = effect(i) ;\n' +
						'if (fx.name.indexOf("Orientation constraint") == 0)\n' +
						'{\n' +
						'var l = null;\n' +
						'try { l = fx(1); } catch (e){}\n' +
						'if (l) result += o(l)*(fx(2).value/100);\n' +
						'}\n' +
						'}\n' +
						'result;';

}

/**
* Adds a position constraint to a layer
* @param {Layer} layer - The layer
*/
DuAEF.Duik.Rigging.positionConstraint = function (layer)
{
	var effect = DuAEF.DuAE.Layer.addPseudoEffect(layer,DuAEF.Duik.PseudoEffects.POSITION,DuAEF.Duik.PseudoEffectsMatchNames.POSITION,'Position constraint');

	layer.position.expression = '//Duik.positionConstraint\n' +
								'function p(l){return l.toWorld(l.anchorPoint);}\n' +
								'var result = value;\n' +
								'for (var i = 1 ; i <= thisLayer("Effects").numProperties ; i++)\n' +
								'{\n' +
								'var fx = effect(i) ;\n' +
								'if (fx.name.indexOf("Position constraint") == 0)\n' +
								'{\n' +
								'var l = null;\n' +
								'try { l = fx(1); } catch (e){}\n' +
								'if (l) result += p(l)*(fx(2).value/100);\n' +
								'}\n' +
								'}\n' +
								'result;';
}

/**
* Adds a path constraint to a layer
* @param {Layer} layer - The layer
* @param {Property|PropertyInfo} path - The path property
*/
DuAEF.Duik.Rigging.pathConstraint = function (layer,path)
{
	if (path instanceof PropertyInfo) path = path.getProperty();

	var effect = DuAEF.DuAE.Layer.addPseudoEffect(layer,DuAEF.Duik.PseudoEffects.PATH,DuAEF.Duik.PseudoEffectsMatchNames.PATH,'Path constraint');

	var l = DuAEF.DuAE.Property.getLayer(path);
	var pathExpr = DuAEF.DuAE.Property.getExpressionLink(path,true);

	var previous = layer.position.value;
	layer.position.expression = '//Duik.positionConstraint\n' +
								'var fx = effect("' + effect.name + '");\n' +
								'var l = thisComp.layer("' + l.name + '");\n' +
								'var p = ' + pathExpr + ';\n' +
								'var percent = fx(1)%100/100;\n' +
								'p.pointOnPath(percent, time)+l.position+value;';

	layer.position.setValue(previous - (layer.position.value-previous));
}

/**
* Adds a parent constraint to a layer
* @param {Layer} layer - The layer
*/
DuAEF.Duik.Rigging.parentConstraint = function (layer)
{
	var effect = DuAEF.DuAE.Layer.addPseudoEffect(layer,DuAEF.Duik.PseudoEffects.PARENT,DuAEF.Duik.PseudoEffectsMatchNames.PARENT,'Parent link');

	layer.position.expression = '//Duik.parent\n' +
							'function getParentTransform(l,origin,sF,eF)\n' +
							'{\n' +
							'var sT = framesToTime(sF);\n' +
							'var eT = framesToTime(eF);\n' +
							'var pos = l.fromWorld( origin , sT ) ;\n' +
							'var prevPos = l.toWorld( pos , sT );\n' +
							'var newPos =  l.toWorld( pos , eT );\n' +
							'return newPos - prevPos;\n' +
							'}\n' +
							'var result = valueAtTime(0);\n' +
							'var cF = 1;\n' +
							'while (cF <= timeToFrames())\n' +
							'{\n' +
							'for (var i = 1 ; i <= thisLayer("Effects").numProperties ; i++)\n' +
							'{\n' +
							'var fx = effect(i);\n' +
							'if (fx.name.indexOf("Parent link") != 0) continue;\n' +
							'if (!fx(4).value) continue;\n' +
							'try { var parentLayer = fx(1); } catch (e){ continue; }\n' +
							'if (parentLayer.index == index) continue;\n' +
							'var weight = fx(2).valueAtTime( framesToTime(cF) ) / 100;\n' +
							'if (weight == 0) continue;\n' +
							'result += getParentTransform( parentLayer , result , cF-1 , cF )*weight;\n' +
							'}\n' +
							'result += valueAtTime(framesToTime(cF)) - valueAtTime(framesToTime(cF-1));\n' +
							'cF++;\n' +
							'}\n' +
							'result;'

	layer.rotation.expression = '//Duik.parent\n' +
						'function o(l,t)\n' +
						'{\n' +
						'if (t == undefined) t = time;\n' +
						'var r = 0;\n' +
						'r += l.rotation.valueAtTime(t);\n' +
						'while(l.hasParent)\n' +
						'{\n' +
						'l = l.parent;\n' +
						'r += l.rotation.valueAtTime(t);\n' +
						'}\n' +
						'return r;\n' +
						'}\n' +
						'var result = value;\n' +
						'for (var i = 1 ; i <= thisLayer("Effects").numProperties ; i++)\n' +
						'{\n' +
						'var fx = effect(i) ;\n' +
						'if (fx.name.indexOf("Parent link") != 0) continue;\n' +
						'if (!fx(5).value) continue;\n' +
						'try { var l = fx(1); } catch (e){ continue; }\n' +
						'if (l.index == index) continue;\n' +
						'if ( fx(2).numKeys < 2 )\n' +
						'{\n' +
						'var w = fx(2).value/100;\n' +
						'if (w == 0) continue;\n' +
						'var P = o(l);\n' +
						'var oP = o(l,0);\n' +
						'result += (P - oP)*w;\n' +
						'}\n' +
						'else\n' +
						'{\n' +
						'var frame = timeToFrames(time);\n' +
						'for (var j = frame;j>=0;j--)\n' +
						'{\n' +
						'var t = framesToTime(j);\n' +
						'var prevT = framesToTime(j-1);\n' +
						'var w = fx(2).valueAtTime(t)/100;\n' +
						'var P = o(l,t);\n' +
						'var oP = o(l,prevT);\n' +
						'result += (P - oP)*w;\n' +
						'}\n' +
						'}\n' +
						'}\n' +
						'result;';

	if (layer.parent != null)
	{
		var comp = layer.containingComp;
		var time = comp.time;
		comp.time = 0;
		var parent = layer.parent;
		layer.parent = null;
		effect(1).setValue(parent.index);
		comp.time = time;
	}
}

/**
* Checks if the property can be used as parent with the connector
* @param {Property|PropertyInfo} prop - The property
* @return {int} 0 if the prop can not be used as parent, or the number of the dimensions of the property (4 = color)
*/
DuAEF.Duik.Rigging.connectorCheckParent = function (prop)
{
	if (!(prop instanceof PropertyInfo)) prop = new PropertyInfo(prop);
	if (prop.getProperty().propertyType != PropertyType.PROPERTY) return 0;

	//check dimensions
	var dim = DuAEF.DuAE.Property.getDimensions(prop);
	return dim;
}

/**
* Applies connector to the property
* @param {Property|PropertyInfo} childProp - The child property
* @param {Property|PropertyInfo} parentProp - The parent property
* @param {PropertyGroup|PropertyInfo|null} [parentEffect] - The effect of an already existing connector
* @param {float} [minValue] - The minimum value
* @param {float} [maxValue] - The maximum value
* @param {DuAEF.DuAE.Axis} [axis=DuAEF.DuAE.Axis.X] - The axis or channel to connect
* @param {DuAEF.DuAE.Types} [axis=DuAEF.DuAE.Types.VALUE] - The type
* @return {PropertyGroup} The controlling effect created
*/
DuAEF.Duik.Rigging.connector = function (childProp, parentProperty, parentEffect, minValue, maxValue, axis, type)
{
	if (minValue == undefined) minValue = null;
	if (maxValue == undefined) maxValue = null;
	if (axis == undefined) axis = DuAEF.DuAE.Axis.X;
	if (type == undefined) axis = DuAEF.DuAE.Types.VALUE;

	if (!(childProp instanceof PropertyInfo)) childProp = new PropertyInfo(childProp);
	var parentProp = parentProperty;
	if (!(parentProperty instanceof PropertyInfo)) parentProp = new PropertyInfo(parentProperty);

	if (!childProp.riggable) return null;

	var dim = DuAEF.Duik.Rigging.connectorCheckParent(parentProp);
	if (dim == 0) return null;

	var parentLayer = DuAEF.DuAE.Property.getLayer(parentProp);

	//effect
	if (parentEffect == undefined) parentEffect = null;

	if (parentEffect == null)
	{
		if (dim == 1) parentEffect = DuAEF.DuAE.Layer.addPseudoEffect(parentLayer,DuAEF.Duik.PseudoEffects.ONED_CONNECTOR,DuAEF.Duik.PseudoEffectsMatchNames.ONED_CONNECTOR,parentProp.getProperty().name + ' Connector');
		else if (dim == 2) parentEffect = DuAEF.DuAE.Layer.addPseudoEffect(parentLayer,DuAEF.Duik.PseudoEffects.TWOD_CONNECTOR,DuAEF.Duik.PseudoEffectsMatchNames.TWOD_CONNECTOR,parentProp.getProperty().name + ' Connector');
		else if (dim == 3) parentEffect = DuAEF.DuAE.Layer.addPseudoEffect(parentLayer,DuAEF.Duik.PseudoEffects.THREED_CONNECTOR,DuAEF.Duik.PseudoEffectsMatchNames.THREED_CONNECTOR,parentProp.getProperty().name + ' Connector');
		else if (dim == 4) parentEffect = DuAEF.DuAE.Layer.addPseudoEffect(parentLayer,DuAEF.Duik.PseudoEffects.COLOR_CONNECTOR,DuAEF.Duik.PseudoEffectsMatchNames.COLOR_CONNECTOR,parentProp.getProperty().name + ' Connector');
		if (dim != 4) parentEffect(3).setValue(100);
		else parentEffect(3).setValue(1);
	}

	if (!isNaN(minValue))
	{
		if (dim == 4)
		{
			if (app.project.bitsPerChannel == 8) minValue = minValue / 255;
			if (app.project.bitsPerChannel == 16) minValue = minValue / 32768;
			if (app.project.bitsPerChannel == 32 && minValue < 0) minValue = 0;
			if (app.project.bitsPerChannel == 32 && minValue > 1) minValue = 1;
		}
		parentEffect(2).setValue(minValue);
	}
	if (!isNaN(maxValue))
	{
		if (dim == 4)
		{
			if (app.project.bitsPerChannel == 8) maxValue = maxValue / 255;
			if (app.project.bitsPerChannel == 16) maxValue = maxValue / 32768;
			if (app.project.bitsPerChannel == 32 && maxValue < 0) maxValue = 0;
			if (app.project.bitsPerChannel == 32 && maxValue > 1) maxValue = 1;
		}
		parentEffect(3).setValue(maxValue);
	}

	if ( type == DuAEF.DuAE.Types.VELOCITY ) parentEffect(1).setValue(2);

	if (dim == 2)
	{
		if (axis == DuAEF.DuAE.Axis.Y ) parentEffect(4).setValue(2);
	}
	else if (dim == 3)
	{
		if (axis == DuAEF.DuAE.Axis.Y ) parentEffect(4).setValue(2);
		else if (axis == DuAEF.DuAE.Axis.Z ) parentEffect(4).setValue(3);
	}
	else if (dim == 4)
	{
		if (axis == DuAEF.DuAE.Axis.RED ) parentEffect(4).setValue(2);
		else if (axis == DuAEF.DuAE.Axis.GREEN ) parentEffect(4).setValue(3);
		else if (axis == DuAEF.DuAE.Axis.BLUE ) parentEffect(4).setValue(4);
		else if (axis == DuAEF.DuAE.Axis.ALPHA ) parentEffect(4).setValue(5);
		else if (axis == DuAEF.DuAE.Axis.HUE ) parentEffect(4).setValue(6);
		else if (axis == DuAEF.DuAE.Axis.SATURATION ) parentEffect(4).setValue(7);
		else if (axis == DuAEF.DuAE.Axis.VALUE ) parentEffect(4).setValue(8);
	}

	// the expression

	// check if the current comp is the same than the comp containing the masterProperty
	var parentComp = parentLayer.containingComp;
	var childComp = DuAEF.DuAE.Property.getComp(childProp);
	var comp = 'thisComp.';
	if (parentComp !== childComp) comp = 'comp("' + parentComp.name + '").';

	var expr = '//Duik.connector\n' +
				'var ctrlLayer = ' + comp + 'layer("' + parentLayer.name + '");\n' +
				'var ctrlValue = ctrlLayer' + DuAEF.DuAE.Property.getExpressionLink(parentProp.getProperty(),false,false) + ';\n' +
				'var ctrlEffect = ctrlLayer.effect("' + parentEffect.name + '");\n' +
				'var ctrlMin = ctrlEffect(2).value;\n' +
				'var ctrlMax = ctrlEffect(3).value;\n' +
				'var useVelocity = ctrlEffect(1).value == 2;\n' +
				'if (useVelocity) ctrlValue = ctrlValue.velocity;\n' +
				'else ctrlValue = ctrlValue.value;\n';
	if (dim == 2 || dim == 3)
	{
		expr += 'var axis = ctrlEffect(4).value-1;\n' +
				'ctrlValue = ctrlValue[axis];\n';
	}
	else if (dim == 4)
	{
		expr += 'var axis = ctrlEffect(4).value;\n' +
				'if (axis == 1) ctrlValue = ctrlValue[0];\n' +
				'else if (axis == 2) ctrlValue = ctrlValue[1];\n' +
				'else if (axis == 3) ctrlValue = ctrlValue[2];\n' +
				'else if (axis == 4) ctrlValue = ctrlValue[3];\n' +
				'else \n' +
				'{\n' +
				'ctrlValue = rgbToHsl(ctrlValue);\n' +
				'if (axis == 5) ctrlValue = ctrlValue[0];\n' +
				'else if (axis == 6) ctrlValue = ctrlValue[1];\n' +
				'else if (axis == 7) ctrlValue = ctrlValue[2];\n' +
				'}';
	}
	expr += 'if (numKeys >= 2)\n' +
			'{\n' +
			'var t = 0;\n' +
			'var beginTime = key(1).time;\n' +
			'var endTime = key(numKeys).time;\n' +
			'if (ctrlMin > ctrlMax)\n' +
			'{\n' +
			't = linear(ctrlValue, ctrlMin, ctrlMax, endTime, beginTime);\n' +
			'}\n' +
			'else\n' +
			'{\n' +
			't = linear(ctrlValue, ctrlMin, ctrlMax, beginTime, endTime);\n' +
			'}\n' +
			'valueAtTime(t);\n' +
			'}\n' +
			'else value;';

	childProp.getProperty().expression = expr;

	//Add expression to the parent
	if (parentProp.getProperty().expression == '' && dim != 4)
	{
		var parentExpr = '//Duik.connector.ctrl\n' +
					'var fx = effect("' + parentEffect.name + '");\n' +
					'var min = fx(2);\n' +
					'var max = fx(3);\n';
		if (dim == 1)
		{
			parentExpr += 'var useLimits = fx(11).value;\n' +
						'var snapping = fx(12).value;\n' +
						'var steps = fx(13).value;\n' +
						'var result = value;\n';
		}
		else
		{
			var originValue = parentProp.getProperty().value;
			parentExpr += 'var originValue = ' + originValue.toSource() + ';\n' +
						'var useLimits = fx(12).value;\n' +
						'var snapping = fx(13).value;\n' +
						'var steps = fx(14).value;\n' +
						'var axis = fx(4)-1;\n' +
						'var result = value[axis];\n';
		}
		parentExpr += 'if (useLimits)\n' +
					'{\n' +
					'if (result > max) result = max;\n' +
					'else if (result < min) result = min;\n' +
					'}\n' +
					'if (snapping)\n' +
					'{\n' +
					'var step = (max-min)/(steps-1);\n' +
					'result = Math.floor(result/step)*step;\n' +
					'}\n';
		if (dim != 1)
		{
			parentExpr += 'finalResult = [];\n' +
						'for (var i = 0; i < value.length ; i++)\n' +
						'{\n' +
						'if (i == axis) finalResult.push(result);\n' +
						'else if (useLimits) finalResult.push(originValue[i]);\n' +
						'else finalResult.push(value[i]);\n' +
						'}\n' +
						'result = finalResult;';
		}
		parentExpr += 'result;';

		parentProp.getProperty().expression = parentExpr;
	}

	return parentEffect;
}

/**
* Creates an IK and its controller on the layers/the structure.
* @param {Layer[]|Structure} layers - The layers, already parented or ordered from goal (at index 0) to root (including the goal)
* @param {Layer|Controller|null} [controller] - An already existing controller.
* @param {boolean} [forceBezier=false] - force the use of a bezier IK even with two layers
* @return {Controller|Controller[]} The controller of the IK. If the IK is a Bezier IK, returns an Array of Controller
*/
DuAEF.Duik.Rigging.ik = function (layers,controller,forceBezier)
{
	if (layers instanceof Structure) layers = layers.elements;
	if (forceBezier == undefined) forceBezier = false;
	if (layers.length < 1) return;

	//check if there is a controller in the selection
	if (controller == undefined)
	{
		for (var i = 0 ; i < layers.length ; i++)
		{
			var l = layers[i];
			if (DuAEF.Duik.isLayerType(l,DuAEF.Duik.LayerTypes.CONTROLLER))
			{
				controller = l;
				layers.splice(i,1);
				break;
			}
		}
	}

	//sort layers and parent them
	layers = DuAEF.DuAE.Layer.sortByParent(layers);
	DuAEF.DuAE.Layer.parentChain(layers);

	//check if the last one is a goal
	var withGoal = true;
	if(controller != undefined)
	{
		var l = layers[layers.length-1];
		//check position
		var cL = controller;
		if (controller instanceof Controller) cL = controller.layer;
		else controller = new Controller(controller);
		var distance = DuAEF.DuAE.Layer.getDistance(cL,l);
		if (distance > 10) withGoal = false;
	}
	var goal = null;
	if (withGoal) goal = layers.pop();

	if (layers.length == 1 && !forceBezier) controller = DuAEF.Duik.Rigging.oneLayerIK(layers[0],goal,controller);
	else if (layers.length == 2 && !forceBezier) controller = DuAEF.Duik.Rigging.twoLayerIK(layers[0],layers[1],goal,controller);
	else if (layers.length == 3 && !forceBezier) controller = DuAEF.Duik.Rigging.threeLayerIK(layers[0],layers[1],layers[2],goal,controller);
	else controller = DuAEF.Duik.Rigging.bezierIK(layers,goal,controller);

	return controller;
}

/**
* Creates a one-layer-ik on the layer
* @param {Layer} layer - The layer
* @param {Layer|null} [goal] - The goal layer, at the end of the IK
* @param {Layer|Controller|null} [controller] - The layer to use as a controller, can be automatically created.<br />
* Must be provided if goal is undefined
* @return {Controller} The controller created
*/
DuAEF.Duik.Rigging.oneLayerIK = function (layer,goal,controller)
{
	if (goal == undefined) goal = null;
	if (controller == undefined) controller = null;
	if (controller == null && goal == null) throw "You must provide either a goal layer or a controller";
	var comp = layer.containingComp;

	//Create controller
	if (controller == null)
	{
		controller = DuAEF.Duik.Controller.create(comp,DuAEF.Duik.ControllerType.TRANSFORM,goal);
	}
	if (!(controller instanceof Controller)) controller = new Controller(controller);

	//is right ?
	var ctrlPos = DuAEF.DuAE.Layer.getWorldPos(controller.layer);
	var layerPos = DuAEF.DuAE.Layer.getWorldPos(layer);

	var right = (ctrlPos[0] - layerPos[0]) < 0;

	//Add Effect
	var name = layer.name;
	if (goal != null) name = goal.name;
	var ikEffect = DuAEF.DuAE.Layer.addPseudoEffect(controller.layer,DuAEF.Duik.PseudoEffects.ONELAYER_IK,DuAEF.Duik.PseudoEffectsMatchNames.ONELAYER_IK,"IK | " + name);
	if (right) ikEffect(6).setValue(1);
	ikEffect(9).setValue(layer.index);

	if (DuAEF.DuAE.App.version >= 15 && controller.layer instanceof ShapeLayer)
	{
		var lineGroup = controller.layer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
		lineGroup.name = 'IK Line';
		var lineContent = lineGroup.property("ADBE Vectors Group");
		var shape = lineContent.addProperty("ADBE Vector Shape - Group");
		shape('ADBE Vector Shape').expression = 'var fx = effect("' + ikEffect.name + '");\n' +
			'var layer1 = null;\n' +
			'var result = [[0,0]];\n' +
			'if (fx(1).value && fx(12).value)\n' +
			'{\n' +
			'try{layer1 = fx(9);}catch(e){}\n' +
			'if (layer1!=null)\n' +
			'{\n' +
			'var l = layer1.toWorld(layer1.anchorPoint);\n' +
			'l = fromWorld(l);\n' +
			'result = [l,[0,0]];\n' +
			'}\n' +
			'}\n' +
			'createPath(result,[],[],false);';
		var stroke = lineContent.addProperty("ADBE Vector Graphic - Stroke");
		stroke("ADBE Vector Stroke Color").expression = 'effect("Controller")(2)-[0.2,0.2,0.2,0]';
		stroke("ADBE Vector Stroke Width").setValue(2);
		stroke("ADBE Vector Stroke Line Cap").setValue(2);
		stroke("ADBE Vector Stroke Dashes").addProperty("ADBE Vector Stroke Dash 1");
		stroke("ADBE Vector Stroke Dashes")("ADBE Vector Stroke Dash 1").setValue(5);
	}

	//Add Data
	var layerData = DuAEF.DuAE.Layer.addPseudoEffect(layer,DuAEF.Duik.PseudoEffects.IK,DuAEF.Duik.PseudoEffectsMatchNames.IK,"IK");
	layerData(1).setValue(controller.layer.index);
	//Expression
	var expr = '//Duik.oneLayerIK\n' +
				'var ctrl = null;\n' +
				'var result = value;\n' +
				'try { ctrl = effect("' + layerData.name + '")(1); } catch (e){ value };\n' +
				'if (ctrl != null)\n' +
				'{\n' +
				'var C = ctrl.toWorld( ctrl.anchorPoint );\n' +
				'var O =  thisLayer.toWorld( thisLayer.anchorPoint );\n' +
				'var fx = ctrl.effect("' + ikEffect.name + '");\n' +
				'W = fx(2).value/100;\n' +
				'FK = fx(3).value;\n' +
				'R = fx(6).value;\n' +
				'var useIK = fx(1).value;\n' +
				'var parentRot = fx(5).value;\n' +
				'result = value+FK;\n' +
				'if (useIK)\n' +
				'{\n' +
				'var vec = R == 1 ? O-C : C-O;\n' +
				'var layer = thisLayer;\n' +
				'if (layer.hasParent && parentRot) result += layer.parent.rotation.value;\n' +
				'while (layer.hasParent)\n' +
				'{\n' +
				'layer = layer.parent;\n' +
				'result = result - layer.rotation;\n' +
				'}\n' +
				'var angle = Math.atan2(vec[1], vec[0]);\n' +
				'angle = radiansToDegrees(angle);\n' +
				'angle = angle*W;\n' +
				'result += angle;\n' +
				'}\n' +
				'}\n' +
				'result;\n';

	DuAEF.DuAE.Property.setExpression(layer.transform.rotation,expr);

	if (goal != null)
	{
		var goalData = DuAEF.DuAE.Layer.addPseudoEffect(goal,DuAEF.Duik.PseudoEffects.IK,DuAEF.Duik.PseudoEffectsMatchNames.IK,"IK");
		goalData(1).setValue(controller.layer.index);
		expr = '//Duik.oneLayerIK.goal\n' +
			'var ctrl = null;\n' +
			'var result = value;\n' +
			'try { ctrl = effect("' + goalData.name + '")(1); } catch (e){ value };\n' +
			'if (ctrl != null)\n' +
			'{\n' +
			'var goal = ctrl.effect("' + ikEffect.name + '")(1).value;\n' +
			'result += ctrl.rotation.value;\n' +
			'if (goal)\n' +
			'{\n' +
			'var layer = thisLayer;\n' +
			'while (layer.hasParent)\n' +
			'{\n' +
			'layer = layer.parent;\n' +
			'result = result - layer.rotation;\n' +
			'}\n' +
			'}\n' +
			'}\n' +
			'result;';
		DuAEF.DuAE.Property.setExpression(goal.transform.rotation,expr);
	}

	return controller;
}

/**
* Creates a two-layer-ik on the layer
* @param {Layer} layer1 - The root layer
* @param {Layer} layer2 - The end layer
* @param {Layer|null} [goal] - The goal layer, at the end of the IK
* @param {Layer|Controller|null} [controller] - The layer to use as a controller, can be automatically created.<br />
* Must be provided if goal is undefined
* @return {Controller} The controller created
*/
DuAEF.Duik.Rigging.twoLayerIK = function (layer1,layer2,goal,controller)
{
	if (goal == undefined) goal = null;
	if (controller == undefined) controller = null;
	if (controller == null && goal == null) throw "You must provide either a goal layer or a controller";

	var comp = layer1.containingComp;

	//Create controller
	if (controller == null)
	{
		controller = DuAEF.Duik.Controller.create(comp,DuAEF.Duik.ControllerType.TRANSFORM,goal);
		goal.parent = null;
		controller.layer.transform.rotation.setValue(goal.transform.rotation.value);
		goal.parent = layer2;
	}
	if (!(controller instanceof Controller)) controller = new Controller(controller);

	//Check if clockwise and lengths

	//unparent
	var rootParent = layer1.parent;
	layer1.parent = null;
	var middleParent = layer2.parent;
	layer2.parent = null;
	var endParent = controller.layer.parent;
	controller.layer.parent = null;

	var upperLength = DuAEF.DuJS.Math.getLength(layer1.transform.position.value,layer2.transform.position.value);
	var lowerLength = DuAEF.DuJS.Math.getLength(layer2.transform.position.value,controller.layer.transform.position.value);
	var endPos = controller.layer.transform.position.value - layer1.transform.position.value;
	var middlePos = layer2.transform.position.value - layer1.transform.position.value;
	var coef = endPos[1]/endPos[0];

	var clockwise = false;
	if (middlePos[1] < middlePos[0]*coef && endPos[0] > 0) clockwise = true;
	if (middlePos[1] > middlePos[0]*coef && endPos[0] < 0) clockwise = true;

	//reparent
	layer1.parent = rootParent;
	layer2.parent = middleParent;
	controller.layer.parent = endParent;


	//add effect
	var name = layer2.name;
	if (goal != undefined) name = goal.name;
	var ikEffect = DuAEF.DuAE.Layer.addPseudoEffect(controller.layer,DuAEF.Duik.PseudoEffects.TWOLAYER_IK,DuAEF.Duik.PseudoEffectsMatchNames.TWOLAYER_IK,"IK | " + name);
	if (clockwise) ikEffect(12).setValue(1);

	//set layers
	ikEffect(17).setValue(layer1.index);
	ikEffect(18).setValue(layer2.index);
	if (goal != undefined) ikEffect(19).setValue(goal.index);

	//set lengths
	ikEffect(30).setValue(upperLength);
	ikEffect(31).setValue(lowerLength);

	//get some useful coordinates
	var goalPos = [0,0];
	if (goal != null)
	{
		goalPos = goal.transform.position.value;
	}
	else
	{
		ikEffect(26).expression = "thisComp.layer(" + layer2.index + ").fromWorld( thisComp.layer(" + controller.layer.index + ").position)";
		goalPos = ikEffect(26).value;
		ikEffect(26).expression = "";
	}
	DuAEF.DuAE.Property.setValue(ikEffect(26),goalPos);
	var rootAp = layer1.transform.anchorPoint.value.toSource();
	var middleAp = layer2.transform.anchorPoint.value.toSource();
	var middlePos = layer2.transform.position.value.toSource();

	//add expressions
	ikEffect(22).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
		'var layer1 = null;\n' +
		'var layer2 = null;\n' +
		'var result = 0;\n' +
		'try{layer1 = fx(17);layer2=fx(18);}catch(e){}\n' +
		'if (layer1!=null)\n' +
		'{\n' +
		'newLength = length(layer1.toWorld(layer1.anchorPoint),layer2.toWorld(layer2.anchorPoint));\n' +
		'result = newLength - fx(30).value;\n' +
		'}\n' +
		'result;';

	ikEffect(23).expression = 'var fx = effect("' + ikEffect.name + '"); (fx(22).value+fx(30).value)/fx(30).value*100;';

	ikEffect(24).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
		'var layer2 = null;\n' +
		'var result = 0;\n' +
		'try{layer2=fx(18);}catch(e){}\n' +
		'if (layer2!=null)\n' +
		'{\n' +
		'newLength = length(layer2.toWorld(fx(26).value),layer2.toWorld(layer2.anchorPoint));\n' +
		'result = newLength - fx(31).value;\n' +
		'}\n' +
		'result;';

	ikEffect(25).expression = 'var fx = effect("' + ikEffect.name + '"); (fx(24).value+fx(31).value)/fx(31).value*100;';

	ikEffect(26).expression = 'var result = value;\n' +
		'fx = effect("' + ikEffect.name + '");\n' +
		'layer1 = null;\n' +
		'try{layer1=fx(17)}catch(e){}\n' +
		'if (layer1 != null)\n' +
		'{\n' +
		'stretch = fx(8);\n' +
		'auto = fx(7).value;\n' +
		'IK = fx(1).value;\n' +
		'shrinkVal = fx(9).value/100;\n' +
		'function getWorldPos(L){\n' +
		'return L.toWorld(L.anchorPoint);\n' +
		'}\n' +
		'dist1 = fx(30).value;\n' +
		'dist2 = fx(31).value;\n' +
		'IKLength = dist1+dist2;\n' +
		'IKStretched = IKLength+stretch;\n' +
		'boneStretch = 0;\n' +
		'proportion = dist2/(IKLength);\n' +
		'posC = toWorld(anchorPoint);\n' +
		'posR = getWorldPos(layer1);\n' +
		'distC = length(posC,posR);\n' +
		'shrinkMax = IKLength*shrinkVal;\n' +
		'shrink = 0;\n' +
		'if (distC < IKStretched && IK) shrink = 1-distC/IKStretched;\n' +
		'boneStretch -= easeOut(shrink,0,shrinkMax)*proportion;\n' +
		'if (distC > IKStretched && auto && IK) boneStretch += (distC-IKLength)*proportion;\n' +
		'else boneStretch += stretch*proportion;\n' +
		'coef = 1;\n' +
		'dist2 != 0 ? coef = (dist2+boneStretch)/dist2 : coef = 1;\n' +
		'result = (' + goalPos.toSource() + ' -' + middleAp + ')*coef+' + middleAp + ';\n' +
		'}\n' +
		'result;';

	ikEffect(27).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
		'var layer2 = null;\n' +
		'var result = [0,0];\n' +
		'try{layer2=fx(18)}catch(e){}\n' +
		'if (layer2!=null)\n' +
		'{\n' +
		'result = layer2.toWorld(fx(26).value);\n' +
		'}\n' +
		'result;';

	ikEffect(32).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
		'var result = fx(30).value + fx(31).value;\n' +
		'var layer1 = null;\n' +
		'try{ layer1 = fx(17); } catch(e){}\n' +
		'if (layer1 != null)\n' +
		'{\n' +
		'result = length(layer1.toWorld(layer1.anchorPoint), toWorld(anchorPoint));\n' +
		'}\n' +
		'result;';

	ikEffect(34).expression = 'fx = effect("' + ikEffect.name + '");\n' +
		'var layer1 = null;\n' +
		'var layer2 = null;\n' +
		'var result = false;\n' +
		'try{layer1 = fx(17);layer2=fx(18);}catch(e){}\n' +
		'if (layer1!=null)\n' +
		'{\n' +
		'var a = layer1.toWorld(layer1.anchorPoint);\n' +
		'var b = layer2.toWorld(layer2.anchorPoint);\n' +
		'var c = layer2.toWorld(fx(26).value);\n' +
		'result = Math.abs(a[0] * (b[1] - c[1]) + b[0] * (c[1] - a[1]) + c[0] * (a[1] - b[1])) < 1000;\n' +
		'}\n' +
		'result;';

	//add controller visual feedback
	if (controller.layer instanceof ShapeLayer)
	{
		var ikGroup = controller.layer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
		ikGroup.name = 'IK';
		var ikContent = ikGroup.property("ADBE Vectors Group");
		var shape = ikContent.addProperty("ADBE Vector Shape - Group");
		var ikShape = new Shape();
		ikShape.vertices = [[-8, 16], [8, 16]];
		ikShape.inTangents = [[0, 0], [0, 0]];
		ikShape.outTangents = [[0, 0], [0, 0]];
		ikShape.closed = false;
		shape('ADBE Vector Shape').setValue(ikShape);
		var stroke = ikContent.addProperty("ADBE Vector Graphic - Stroke");
		stroke("ADBE Vector Stroke Color").expression = 'effect("Controller")(2)-[0.2,0.2,0.2,0]';
		stroke("ADBE Vector Stroke Width").setValue(2);
		stroke("ADBE Vector Stroke Line Cap").setValue(2);
		stroke("ADBE Vector Stroke Opacity").expression = 'var fx = effect("' + ikEffect.name + '");\n' +
			'if (fx(37).value) fx(34).value*100 else 0;';

		ikGroup.transform.scale.expression = '[effect("Controller")(4)*2,effect("Controller")(4)*2]';
		ikGroup.transform.position.expression = 'effect("Controller")(3)';
		ikGroup.transform.opacity.expression = 'effect("Controller")(6)';

		if (DuAEF.DuAE.App.version >= 15)
		{
			var lineGroup = controller.layer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
			lineGroup.name = 'IK Line';
			var lineContent = lineGroup.property("ADBE Vectors Group");
			var shape = lineContent.addProperty("ADBE Vector Shape - Group");
			shape('ADBE Vector Shape').expression = 'var fx = effect("' + ikEffect.name + '");\n' +
				'var layer1 = null;\n' +
				'var result = [[0,0]];\n' +
				'if (fx(1).value && fx(37).value)\n' +
				'{\n' +
				'try{layer1 = fx(17);}catch(e){}\n' +
				'if (layer1!=null)\n' +
				'{\n' +
				'var l = layer1.toWorld(layer1.anchorPoint);\n' +
				'l = fromWorld(l);\n' +
				'result = [l,[0,0]];\n' +
				'}\n' +
				'}\n' +
				'createPath(result,[],[],false);';
			var stroke = lineContent.addProperty("ADBE Vector Graphic - Stroke");
			stroke("ADBE Vector Stroke Color").expression = 'effect("Controller")(2)-[0.2,0.2,0.2,0]';
			stroke("ADBE Vector Stroke Width").setValue(2);
			stroke("ADBE Vector Stroke Line Cap").setValue(2);
			stroke("ADBE Vector Stroke Dashes").addProperty("ADBE Vector Stroke Dash 1");
			stroke("ADBE Vector Stroke Dashes")("ADBE Vector Stroke Dash 1").expression = 'var fx = effect("' + ikEffect.name + '");\n' +
				'if (fx(34).value) 0 else 5;';
		}
	}


	//setup layers
	var layer1Data = DuAEF.DuAE.Layer.addPseudoEffect(layer1,DuAEF.Duik.PseudoEffects.IK,DuAEF.Duik.PseudoEffectsMatchNames.IK,"IK");
	layer1Data(1).setValue(controller.layer.index);

	layer1.transform.rotation.expression = '//Duik.twoLayerIK\n' +
		'var controller = null;\n' +
		'var result = value;\n' +
		'try{controller=effect("' + layer1Data.name + '")(1)}catch(e){}\n' +
		'if (controller !=null)\n' +
		'{\n' +
		'var fx = controller.effect("' + ikEffect.name + '");\n' +
		'layer1 = thisLayer;\n' +
		'layer2 = null;\n' +
		'try{ layer2 = fx(18); }  catch (e){}\n' +
		'if (layer2 != null)\n' +
		'{\n' +
		'endPos = fx(26).value;\n' +
		'limit = fx(13).value;\n' +
		'FK = fx(3).value;\n' +
		'IKFK = fx(1).value;\n' +
		'cw = fx(12).value;\n' +
		'function getWorldPos(L){\n' +
		'return L.toWorld(L.anchorPoint);\n' +
		'}\n' +
		'function ik() {\n' +
		'A = getWorldPos(layer1);\n' +
		'B = getWorldPos(layer2);\n' +
		'C = layer2.toWorld(endPos);\n' +
		'E = getWorldPos(controller);\n' +
		'a = length(B,C);\n' +
		'b = length(E,A);\n' +
		'c = length(A,B);\n' +
		'x = (b*b + c*c - a*a )/(2*b);\n' +
		'alpha = Math.acos(clamp(x/c,-1,1));\n' +
		'D = E - A;\n' +
		'delta = Math.atan2(D[1],D[0]);\n' +
		'result = radiansToDegrees(delta - (cw ? 1 : -1)*alpha);\n' +
		'V = B - A;\n' +
		'adj1 = radiansToDegrees(Math.atan2(V[1],V[0]));\n' +
		'IK = result - adj1 + value;\n' +
		'if (IK < limit) IK+=360;\n' +
		'return IK;\n' +
		'}\n' +
		'result = IKFK ? ik() : FK;\n' +
		'}\n' +
		'}\n' +
		'result;';

	var layer2Data = DuAEF.DuAE.Layer.addPseudoEffect(layer2,DuAEF.Duik.PseudoEffects.IK,DuAEF.Duik.PseudoEffectsMatchNames.IK,"IK");
	layer2Data(1).setValue(controller.layer.index);


	layer2.transform.rotation.expression = '//Duik.twoLayerIK\n' +
		'var controller = null;\n' +
		'var result = value;\n' +
		'try{controller=effect("' + layer2Data.name + '")(1)}catch(e){}\n' +
		'if (controller !=null)\n' +
		'{\n' +
		'var fx = controller.effect("' + ikEffect.name + '");\n' +
		'layer1 = null;\n' +
		'layer2 = thisLayer;\n' +
		'try{ layer1 = fx(17); }  catch (e){}\n' +
		'if (layer1 != null)\n' +
		'{\n' +
		'endPos = fx(26).value;\n' +
		'FK = fx(4).value;\n' +
		'IKFK = fx(1).value;\n' +
		'cw = fx(12).value;\n' +
		'function getWorldPos(L){\n' +
		'return L.toWorld(L.anchorPoint);\n' +
		'}\n' +
		'function ik() {\n' +
		'A = getWorldPos(layer1);\n' +
		'B = getWorldPos(layer2);\n' +
		'C = layer2.toWorld(endPos);\n' +
		'E = getWorldPos(controller);\n' +
		'a = length(B,C);\n' +
		'b = length(E,A);\n' +
		'c = length(A,B);\n' +
		'x = (b*b + c*c - a*a )/(2*b);\n' +
		'alpha = Math.acos(clamp(x/c,-1,1));\n' +
		'y = b - x;\n' +
		'gamma = Math.acos(clamp(y/a,-1,1));\n' +
		'result = (cw ? 1 : -1)*radiansToDegrees(gamma + alpha);  V1 = B - A;\n' +
		'adj1 = radiansToDegrees(Math.atan2(V1[1],V1[0]));\n' +
		'V2 = C - B;\n' +
		'adj2 = radiansToDegrees(Math.atan2(V2[1],V2[0]));\n' +
		'IK = result +  adj1 - adj2 + value;\n' +
		'return IK;\n' +
		'}\n' +
		'result = IKFK ? ik() : FK;\n' +
		'}\n' +
		'}\n' +
		'result;\n';

	layer2.transform.position.expression = '//Duik.twoLayerIK.stretch\n' +
		'var ctrl = null;\n' +
		'var result = value;\n' +
		'try { ctrl = effect("' + layer2Data.name + '")(1); } catch (e){ value };\n' +
		'if (ctrl != null)\n' +
		'{\n' +
		'fx = ctrl.effect("' + ikEffect.name + '");\n' +
		'layer1 = null;\n' +
		'result = [211, 25];\n' +
		'try{layer1=fx(17)}catch(e){}\n' +
		'if (layer1 != null)\n' +
		'{\n' +
		'stretch = fx(8).value;\n' +
		'auto = fx(7).value;\n' +
		'IK = fx(1).value;\n' +
		'shrinkVal = fx(9).value/100;\n' +
		'function getWorldPos(L){\n' +
		'return L.toWorld(L.anchorPoint);\n' +
		'}\n' +
		'dist1 = fx(30).value;\n' +
		'dist2 = fx(31).value;\n' +
		'IKLength = dist1+dist2;\n' +
		'IKStretched = IKLength+stretch;\n' +
		'boneStretch = 0;\n' +
		'proportion = dist1/(IKLength);\n' +
		'posC = getWorldPos(ctrl);\n' +
		'posR = getWorldPos(layer1);\n' +
		'distC = length(posC,posR);\n' +
		'shrinkMax = IKLength*shrinkVal;\n' +
		'shrink = 0;\n' +
		'if (distC < IKStretched && IK) shrink = 1-distC/IKStretched;\n' +
		'boneStretch -= easeOut(shrink,0,shrinkMax)*proportion;\n' +
		'if (distC > IKStretched && auto && IK) boneStretch += (distC-IKLength)*proportion;\n' +
		'else boneStretch += stretch*proportion;\n' +
		'coef = 1;\n' +
		'dist1 != 0 ? coef = (dist1+boneStretch)/dist1 : coef = 1;\n' +
		'result = (' + middlePos + ' -' + rootAp + ')*coef+' + rootAp + ';\n' +
		'}\n' +
		'}\n' +
		'result;';

	if (goal != null)
	{
		var goalData = DuAEF.DuAE.Layer.addPseudoEffect(goal,DuAEF.Duik.PseudoEffects.IK,DuAEF.Duik.PseudoEffectsMatchNames.IK,"IK");
		goalData(1).setValue(controller.layer.index);

		var rotExpr = '//Duik.goal\n' +
			'var ctrl = null;\n' +
			'var result = value;\n' +
			'try { ctrl = effect("' + goalData.name + '")(1); } catch (e){};\n' +
			'if (ctrl != null)\n' +
			'{\n' +
			'var goal = ctrl.effect("' + ikEffect.name + '")(1).value;\n' +
			'result += ctrl.rotation.value;\n' +
			'if (goal)\n' +
			'{\n' +
			'var layer = thisLayer;\n' +
			'while (layer.hasParent)\n' +
			'{\n' +
			'layer = layer.parent;\n' +
			'result = result - layer.rotation;\n' +
			'}\n' +
			'}\n' +
			'}\n' +
			'result;';
		DuAEF.DuAE.Property.setExpression(goal.transform.rotation,rotExpr);

		goal.transform.position.expression = 'var ctrl = null;\n' +
			'var result = value;\n' +
			'try { ctrl = effect("' + goalData.name + '")(1); } catch (e){ value };\n' +
			'if (ctrl != null)\n' +
			'{\n' +
			'result = ctrl.effect("' + ikEffect.name + '")(26).value;\n' +
			'}\n' +
			'result;';
	}

	return controller;
}

/**
* Creates a three-layer-ik on the layer
* @param {Layer} layer1 - The root layer
* @param {Layer} layer2 - The middle layer
* @param {Layer} layer3 - The end layer
* @param {Layer|null} [goal] - The goal layer, at the end of the IK
* @param {Layer|Controller|null} [controller] - The layer to use as a controller, can be automatically created.<br />
* Must be provided if goal is undefined
* @return {Controller} The controller created
*/
DuAEF.Duik.Rigging.threeLayerIK = function (layer1,layer2,layer3,goal,controller)
{
	if (goal == undefined) goal = null;
	if (controller == undefined) controller = null;
	if (controller == null && goal == null) throw "You must provide either a goal layer or a controller";

	var comp = layer1.containingComp;

	//Create controller
	if (controller == null)
	{
		controller = DuAEF.Duik.Controller.create(comp,DuAEF.Duik.ControllerType.TRANSFORM,goal);
		goal.parent = null;
		controller.layer.transform.rotation.setValue(goal.transform.rotation.value);
		goal.parent = layer3;
	}
	if (!(controller instanceof Controller)) controller = new Controller(controller);

	//Check if clockwise and lengths

	//unparent
	var rootParent = layer1.parent;
	layer1.parent = null;
	var middleParent = layer2.parent;
	layer2.parent = null;
	var endParent = controller.layer.parent;
	controller.layer.parent = null;

	var upperLength = DuAEF.DuJS.Math.getLength(layer1.transform.position.value,layer2.transform.position.value);
	var lowerLength = DuAEF.DuAE.Layer.getDistance(layer3,controller.layer);
	var middleLength = DuAEF.DuAE.Layer.getDistance(layer3,layer2);
	var endPos = controller.layer.transform.position.value - layer1.transform.position.value;
	var middlePos = layer2.transform.position.value - layer1.transform.position.value;
	var coef = endPos[1]/endPos[0];

	var clockwise = false;
	if (middlePos[1] < middlePos[0]*coef && endPos[0] > 0) clockwise = true;
	if (middlePos[1] > middlePos[0]*coef && endPos[0] < 0) clockwise = true;

	//reparent
	layer1.parent = rootParent;
	layer2.parent = middleParent;
	controller.layer.parent = endParent;


	//add effect
	var name = layer3.name;
	if (goal != undefined) name = goal.name;
	var ikEffect = DuAEF.DuAE.Layer.addPseudoEffect(controller.layer,DuAEF.Duik.PseudoEffects.THREELAYER_IK,DuAEF.Duik.PseudoEffectsMatchNames.THREELAYER_IK,"IK | " + name);
	if (clockwise) ikEffect(13).setValue(1);

	//set layers
	ikEffect(18).setValue(layer1.index);
	ikEffect(19).setValue(layer2.index);
	ikEffect(20).setValue(layer3.index);
	if (goal != undefined) ikEffect(21).setValue(goal.index);

	//set lengths
	ikEffect(32).setValue(upperLength);
	ikEffect(33).setValue(middleLength);
	ikEffect(34).setValue(lowerLength);

	//get some useful coordinates
	var goalPos = [0,0];
	if (goal != null)
	{
		goalPos = goal.transform.position.value;
	}
	else
	{
		ikEffect(28).expression = "thisComp.layer(" + layer3.index + ").fromWorld( thisComp.layer(" + controller.layer.index + ").position)";
		goalPos = ikEffect(28).value;
		ikEffect(28).expression = "";
	}
	DuAEF.DuAE.Property.setValue(ikEffect(28),goalPos);
	var rootAp = layer1.transform.anchorPoint.value.toSource();
	var middleAp = layer2.transform.anchorPoint.value.toSource();
	var lowerAp = layer3.transform.anchorPoint.value.toSource();
	var middlePos = layer2.transform.position.value.toSource();
	var lowerPos = layer3.transform.position.value.toSource();

	//add expressions
	ikEffect(24).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
		'var layer1 = null;\n' +
		'var layer2 = null;\n' +
		'var result = 0;\n' +
		'try{layer1 = fx(18);layer2=fx(19);}catch(e){}\n' +
		'if (layer1!=null)\n' +
		'{\n' +
		'newLength = length(layer1.toWorld(layer1.anchorPoint),layer2.toWorld(layer2.anchorPoint));\n' +
		'result = newLength - fx(32).value;\n' +
		'}\n' +
		'result;';

	ikEffect(25).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
		'var layer1 = null;\n' +
		'var layer2 = null;\n' +
		'var result = 0;\n' +
		'try{layer1 = fx(19);layer2=fx(20);}catch(e){}\n' +
		'if (layer1!=null)\n' +
		'{\n' +
		'newLength = length(layer1.toWorld(layer1.anchorPoint),layer2.toWorld(layer2.anchorPoint));\n' +
		'result = newLength - fx(33).value;\n' +
		'}\n' +
		'result;';

	ikEffect(26).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
		'var layer2 = null;\n' +
		'var result = 0;\n' +
		'try{layer2=fx(20);}catch(e){}\n' +
		'if (layer2!=null)\n' +
		'{\n' +
		'newLength = length( fx(29).value , layer2.toWorld(layer2.anchorPoint));\n' +
		'result = newLength - fx(34).value;\n' +
		'}\n' +
		'result;';

	ikEffect(27).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
		'result = fx(24).value + fx(25).value + fx(26).value;\n' +
		'var o = fx(32).value + fx(33).value + fx(34).value;\n' +
		'result += o;\n' +
		'result = result / o * 100;';

	ikEffect(28).expression = 'var result = value;\n' +
		'fx = effect("' + ikEffect.name + '");\n' +
		'layer1 = null;\n' +
		'try{layer1=fx(18)}catch(e){}\n' +
		'if (layer1 != null)\n' +
		'{\n' +
		'stretch = fx(9).value;\n' +
		'auto = fx(8).value;\n' +
		'IK = fx(1).value;\n' +
		'shrinkVal = fx(10).value/100;\n' +
		'function getWorldPos(L){\n' +
		'return L.toWorld(L.anchorPoint);\n' +
		'}\n' +
		'var upperAP = ' + rootAp + ';\n' +
		'var middlePos = ' + middlePos + ';\n' +
		'var middleAP = ' + middleAp + ';\n' +
		'var lowerPos = ' + lowerPos + ';\n' +
		'var lowerAP = ' + lowerAp + ';\n' +
		'var zeroPos = ' + goalPos.toSource() + ';\n' +
		'dist1 = fx(32);\n' +
		'dist2 = fx(33);\n' +
		'dist3 = fx(34);\n' +
		'IKLength = dist1+dist2+dist3;\n' +
		'IKStretched = IKLength+stretch;\n' +
		'boneStretch = 0;\n' +
		'proportion = dist3/(IKLength);\n' +
		'posC = toWorld(anchorPoint);\n' +
		'posR = getWorldPos(layer1);\n' +
		'distC = length(posC,posR);\n' +
		'shrinkMax = IKLength*shrinkVal;\n' +
		'shrink = 0;\n' +
		'if (distC < IKStretched && IK) shrink = 1-distC/IKStretched;\n' +
		'boneStretch -= easeOut(shrink,0,shrinkMax)*proportion;\n' +
		'if (distC > IKStretched && auto && IK) boneStretch += (distC-IKLength)*proportion;\n' +
		'else boneStretch += stretch*proportion;\n' +
		'coef = 1;\n' +
		'dist3 != 0 ? coef = (dist3+boneStretch)/dist3 : coef = 1;\n' +
		'result = (middlePos-upperAP)*coef+upperAP;\n' +
		'}\n' +
		'result;';

	ikEffect(29).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
		'var layer3 = null;\n' +
		'var result = [0,0];\n' +
		'try{layer3=fx(20)}catch(e){}\n' +
		'if (layer3!=null)\n' +
		'{\n' +
		'result = layer3.toWorld(fx(28).value);\n' +
		'}\n' +
		'result;';

	ikEffect(35).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
		'var result = fx(33).value + fx(34).value + fx(35).value;\n' +
		'var layer1 = null;\n' +
		'try{ layer1 = fx(18); } catch(e){}\n' +
		'if (layer1 != null)\n' +
		'{\n' +
		'result = length(layer1.toWorld(layer1.anchorPoint), toWorld(anchorPoint));\n' +
		'}\n' +
		'result;';

	ikEffect(37).expression = 'fx = effect("' + ikEffect.name + '");\n' +
		'var layer1 = null;\n' +
		'var layer2 = null;\n' +
		'var layer3 = null;\n' +
		'var result = false;\n' +
		'try{layer1 = fx(18);layer2=fx(19);layer3=fx(20);}catch(e){}\n' +
		'if (layer1!=null)\n' +
		'{\n' +
		'var a = layer1.toWorld(layer1.anchorPoint);\n' +
		'var b = layer2.toWorld(layer2.anchorPoint);\n' +
		'var c = layer3.toWorld(layer3.anchorPoint);\n' +
		'result = Math.abs(a[0] * (b[1] - c[1]) + b[0] * (c[1] - a[1]) + c[0] * (a[1] - b[1])) < 10 ;\n' +
		'}\n' +
		'result;';

	//add controller visual feedback
	if (controller.layer instanceof ShapeLayer)
	{
		var ikGroup = controller.layer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
		ikGroup.name = 'IK';
		var ikContent = ikGroup.property("ADBE Vectors Group");
		var shape = ikContent.addProperty("ADBE Vector Shape - Group");
		var ikShape = new Shape();
		ikShape.vertices = [[-8, 16], [8, 16]];
		ikShape.inTangents = [[0, 0], [0, 0]];
		ikShape.outTangents = [[0, 0], [0, 0]];
		ikShape.closed = false;
		shape('ADBE Vector Shape').setValue(ikShape);
		var stroke = ikContent.addProperty("ADBE Vector Graphic - Stroke");
		stroke("ADBE Vector Stroke Color").expression = 'effect("Controller")(2)-[0.2,0.2,0.2,0]';
		stroke("ADBE Vector Stroke Width").setValue(2);
		stroke("ADBE Vector Stroke Line Cap").setValue(2);
		stroke("ADBE Vector Stroke Opacity").expression = 'var fx = effect("' + ikEffect.name + '");\n' +
			'fx(37).value*100;';

		ikGroup.transform.scale.expression = '[effect("Controller")(4)*2,effect("Controller")(4)*2]';
		ikGroup.transform.position.expression = 'effect("Controller")(3)';
		ikGroup.transform.opacity.expression = 'effect("Controller")(6)';

		if (DuAEF.DuAE.App.version >= 15)
		{
			var lineGroup = controller.layer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
			lineGroup.name = 'IK Line';
			var lineContent = lineGroup.property("ADBE Vectors Group");
			var shape = lineContent.addProperty("ADBE Vector Shape - Group");
			shape('ADBE Vector Shape').expression = 'var fx = effect("' + ikEffect.name + '");\n' +
				'var layer1 = null;\n' +
				'var result = [[0,0]];\n' +
				'if (fx(1).value && fx(40).value)\n' +
				'{\n' +
				'try{layer1 = fx(18);}catch(e){}\n' +
				'if (layer1!=null)\n' +
				'{\n' +
				'var l = layer1.toWorld(layer1.anchorPoint);\n' +
				'l = fromWorld(l);\n' +
				'result = [l,[0,0]];\n' +
				'}\n' +
				'}\n' +
				'createPath(result,[],[],false);';
			var stroke = lineContent.addProperty("ADBE Vector Graphic - Stroke");
			stroke("ADBE Vector Stroke Color").expression = 'effect("Controller")(2)-[0.2,0.2,0.2,0]';
			stroke("ADBE Vector Stroke Width").setValue(2);
			stroke("ADBE Vector Stroke Line Cap").setValue(2);
			stroke("ADBE Vector Stroke Dashes").addProperty("ADBE Vector Stroke Dash 1");
			stroke("ADBE Vector Stroke Dashes")("ADBE Vector Stroke Dash 1").expression = 'var fx = effect("' + ikEffect.name + '");\n' +
				'if (fx(37).value) 0 else 5;';
		}
	}

	//setup layers
	var layer1Data = DuAEF.DuAE.Layer.addPseudoEffect(layer1,DuAEF.Duik.PseudoEffects.IK,DuAEF.Duik.PseudoEffectsMatchNames.IK,"IK");
	layer1Data(1).setValue(controller.layer.index);

	layer1.transform.rotation.expression = '//Duik.threeLayerIK\n' +
		'var controller = null;\n' +
		'var result = value;\n' +
		'try{controller=effect("' + layer1Data.name + '")(1)}catch(e){}\n' +
		'if (controller !=null)\n' +
		'{\n' +
		'var fx = controller.effect("' + ikEffect.name + '");\n' +
		'layer1 = thisLayer;\n' +
		'layer2 = null;\n' +
		'layer3 = null;\n' +
		'try{ layer2 = fx(19); layer3 = fx(20); }  catch (e){}\n' +
		'if (layer1 != null)\n' +
		'{\n' +
		'endPos = fx(28).value;\n' +
		'FK = fx(3).value;\n' +
		'IKFK = fx(1).value;\n' +
		'cw = fx(13).value;\n' +
		'limit = fx(14).value;\n' +
		'function getWorldPos(layer){\n' +
		'return layer.toWorld(layer.anchorPoint);\n' +
		'}\n' +
		'function sq(result){\n' +
		'return result*result;\n' +
		'}\n' +
		'function getAngle(p1,p2){\n' +
		'var dist = p2-p1;\n' +
		'var angle = Math.atan2(dist[1],dist[0]);\n' +
		'return radiansToDegrees(angle);\n' +
		'}\n' +
		'function ik() {\n' +
		'var uPos = getWorldPos(layer1);\n' +
		'var mPos = getWorldPos(layer2);\n' +
		'var lPos = getWorldPos(layer3);\n' +
		'var zPos = layer3.toWorld(endPos);\n' +
		'var cPos = getWorldPos(controller);\n' +
		'var uLength = length(uPos,mPos);\n' +
		'var mLength = length(mPos,lPos);\n' +
		'var lLength = length(lPos,zPos);\n' +
		'var ikLength = length(uPos,cPos);\n' +
		'if (ikLength == 0) ikLength = 1;\n' +
		'var d1 = sq(mLength) - sq(ikLength) - sq(uLength-lLength);\n' +
		'var d2 = sq(ikLength) * (uLength+lLength);\n' +
		'var d3 = -sq(ikLength) * uLength * lLength;\n' +
		'var d4 = (-d2 - Math.sqrt( sq(d2) - 4*d1*d3 )) / (2*d1);\n' +
		'var baseA = Math.acos(clamp(ikLength/(2*d4),-1,1));\n' +
		'var upperA = cw ? -baseA : baseA ;\n' +
		'upperA = radiansToDegrees(upperA);\n' +
		'var uToC =getAngle(uPos,cPos);\n' +
		'var uToM =getAngle(uPos,mPos);\n' +
		'var ikResult = upperA + uToC - uToM;\n' +
		'if (ikResult < limit) ikResult +=360;\n' +
		'return ikResult;\n' +
		'}\n' +
		'IKFK ? result += ik() : result += FK;\n' +
		'}\n' +
		'}\n' +
		'result;';

	var layer2Data = DuAEF.DuAE.Layer.addPseudoEffect(layer2,DuAEF.Duik.PseudoEffects.IK,DuAEF.Duik.PseudoEffectsMatchNames.IK,"IK");
	layer2Data(1).setValue(controller.layer.index);

	layer2.transform.rotation.expression = '//Duik.threeLayerIK\n' +
		'var controller = null;\n' +
		'var result = value;\n' +
		'try{controller=effect("' + layer2Data.name + '")(1)}catch(e){}\n' +
		'if (controller !=null)\n' +
		'{\n' +
		'var fx = controller.effect("' + ikEffect.name + '");\n' +
		'layer1 = null;\n' +
		'layer2 = thisLayer;\n' +
		'layer3 = null;\n' +
		'try{ layer1 = fx(18); layer3 = fx(20); }  catch (e){}\n' +
		'if (layer1 != null)\n' +
		'{\n' +
		'endPos = fx(28).value;\n' +
		'FK = fx(4).value;\n' +
		'IKFK = fx(1).value;\n' +
		'cw = fx(13).value;\n' +
		'function getWorldPos(layer){\n' +
		'return layer.toWorld(layer.anchorPoint);\n' +
		'}\n' +
		'function sq(result){\n' +
		'return result*result;\n' +
		'}\n' +
		'function getAngle(p1,p2){\n' +
		'var dist = p2-p1;\n' +
		'var angle = Math.atan2(dist[1],dist[0]);\n' +
		'return radiansToDegrees(angle);\n' +
		'}\n' +
		'function ik() {\n' +
		'var uPos = getWorldPos(layer1);\n' +
		'var mPos = getWorldPos(layer2);\n' +
		'var lPos = getWorldPos(layer3);\n' +
		'var zPos = layer3.toWorld(endPos);\n' +
		'var cPos = getWorldPos(controller);\n' +
		'var uLength = length(uPos,mPos);\n' +
		'var mLength = length(mPos,lPos);\n' +
		'var lLength = length(lPos,zPos);\n' +
		'var ikLength = length(uPos,cPos);\n' +
		'if (ikLength == 0) ikLength = 1;\n' +
		'var d1 = sq(mLength) - sq(ikLength) - sq(uLength-lLength);\n' +
		'var d2 = sq(ikLength) * (uLength+lLength);\n' +
		'var d3 = -sq(ikLength) * uLength * lLength;\n' +
		'var d4 = (-d2 - Math.sqrt( sq(d2) - 4*d1*d3 )) / (2*d1);\n' +
		'var baseA = Math.acos(clamp(ikLength/(2*d4),-1,1));\n' +
		'var d5 = Math.sqrt( sq(ikLength) + sq(lLength) - 2*ikLength*lLength*Math.cos(baseA));\n' +
		'var middleA = Math.acos(clamp((sq(d5)-sq(uLength)-sq(mLength)) / (-2*uLength*mLength),-1,1));\n' +
		'middleA = cw ? -middleA : middleA ;\n' +
		'middleA = radiansToDegrees(middleA);\n' +
		'var uToM =getAngle(uPos,mPos);\n' +
		'var mToL =getAngle(mPos,lPos);\n' +
		'var ikResult = middleA + uToM - mToL +180;\n' +
		'return ikResult;\n' +
		'}\n' +
		'IKFK ? result += ik() : result += FK;\n' +
		'}\n' +
		'}\n' +
		'result;';

	layer2.transform.position.expression = '//Duik.threeLayerIK.stretch\n' +
		'var controller = null;\n' +
		'var result = value;\n' +
		'try { controller = effect("' + layer2Data.name + '")(1); } catch (e){ value };\n' +
		'if (controller != null)\n' +
		'{\n' +
		'fx = controller.effect("' + ikEffect.name + '");\n' +
		'layer1 = null;\n' +
		'try{layer1=fx(18)}catch(e){}\n' +
		'if (layer1 != null)\n' +
		'{\n' +
		'stretch = fx(9).value;\n' +
		'auto = fx(8).value;\n' +
		'IK = fx(1).value;\n' +
		'shrinkVal = fx(10).value/100;\n' +
		'function getWorldPos(L){\n' +
		'return L.toWorld(L.anchorPoint);\n' +
		'}\n' +
		'var upperAP = ' + rootAp + ';\n' +
		'var middlePos = ' + middlePos + ';\n' +
		'var middleAP = ' + middleAp + ';\n' +
		'var lowerPos = ' + lowerPos + ';\n' +
		'var lowerAP = ' + lowerAp + ';\n' +
		'var zeroPos = ' + goalPos.toSource() + ';\n' +
		'dist1 = length(upperAP,middlePos);\n' +
		'dist2 = length(middleAP,lowerPos);\n' +
		'dist3 = length(lowerAP,zeroPos);\n' +
		'IKLength = dist1+dist2+dist3;\n' +
		'IKStretched = IKLength+stretch;\n' +
		'boneStretch = 0;\n' +
		'proportion = dist1/(IKLength);\n' +
		'posC = getWorldPos(controller);\n' +
		'posR = getWorldPos(layer1);\n' +
		'distC = length(posC,posR);\n' +
		'shrinkMax = IKLength*shrinkVal;\n' +
		'shrink = 0;\n' +
		'if (distC < IKStretched && IK) shrink = 1-distC/IKStretched;\n' +
		'boneStretch -= easeOut(shrink,0,shrinkMax)*proportion;\n' +
		'if (distC > IKStretched && auto && IK) boneStretch += (distC-IKLength)*proportion;\n' +
		'else boneStretch += stretch*proportion;\n' +
		'coef = 1;\n' +
		'dist1 != 0 ? coef = (dist1+boneStretch)/dist1 : coef = 1;\n' +
		'result = (middlePos-upperAP)*coef+upperAP;\n' +
		'}\n' +
		'}\n' +
		'result;';


	var layer3Data = DuAEF.DuAE.Layer.addPseudoEffect(layer3,DuAEF.Duik.PseudoEffects.IK,DuAEF.Duik.PseudoEffectsMatchNames.IK,"IK");
	layer3Data(1).setValue(controller.layer.index);

	layer3.transform.rotation.expression = '//Duik.threeLayerIK\n' +
		'var controller = null;\n' +
		'var result = value;\n' +
		'try{controller=effect("' + layer3Data.name + '")(1)}catch(e){}\n' +
		'if (controller !=null)\n' +
		'{\n' +
		'var fx = controller.effect("' + ikEffect.name + '");\n' +
		'layer1 = null;\n' +
		'layer2 = null;\n' +
		'layer3 = thisLayer;\n' +
		'try{ layer1 = fx(18); layer2 = fx(19); }  catch (e){}\n' +
		'if (layer1 != null)\n' +
		'{\n' +
		'endPos = fx(28).value;\n' +
		'FK = fx(5).value;\n' +
		'IKFK = fx(1).value;\n' +
		'cw = fx(13).value;\n' +
		'function getWorldPos(layer){\n' +
		'return layer.toWorld(layer.anchorPoint);\n' +
		'}\n' +
		'function sq(result){\n' +
		'return result*result;\n' +
		'}\n' +
		'function getAngle(p1,p2){\n' +
		'var dist = p2-p1;\n' +
		'var angle = Math.atan2(dist[1],dist[0]);\n' +
		'return radiansToDegrees(angle);\n' +
		'}\n' +
		'function ik() {\n' +
		'var uPos = getWorldPos(layer1);\n' +
		'var mPos = getWorldPos(layer2);\n' +
		'var lPos = getWorldPos(layer3);\n' +
		'var zPos = fx(29).value;\n' +
		'var cPos = getWorldPos(controller);\n' +
		'var uLength = length(uPos,mPos);\n' +
		'var mLength = length(mPos,lPos);\n' +
		'var lLength = length(lPos,zPos);\n' +
		'var ikLength = length(uPos,cPos);\n' +
		'if (ikLength == 0) ikLength = 1;\n' +
		'var d1 = sq(mLength) - sq(ikLength) - sq(uLength-lLength);\n' +
		'var d2 = sq(ikLength) * (uLength+lLength);\n' +
		'var d3 = -sq(ikLength) * uLength * lLength;\n' +
		'var d4 = (-d2 - Math.sqrt( sq(d2) - 4*d1*d3 )) / (2*d1);\n' +
		'var baseA = Math.acos(clamp(ikLength/(2*d4),-1,1));\n' +
		'var d6 = Math.sqrt( sq(ikLength) + sq(uLength) - 2*ikLength*uLength*Math.cos(baseA));\n' +
		'var lowerA = Math.acos(clamp((sq(d6) - sq(lLength) - sq(mLength)) / (-2*lLength*mLength),-1,1));\n' +
		'lowerA = cw ? -lowerA : lowerA;\n' +
		'lowerA = radiansToDegrees(lowerA);\n' +
		'var mToL =getAngle(mPos,lPos);\n' +
		'var lToZ =getAngle(lPos,zPos);\n' +
		'var ikResult = lowerA + mToL - lToZ +180;\n' +
		'return ikResult;\n' +
		'}\n' +
		'IKFK ? result += ik() : result += FK;\n' +
		'}\n' +
		'}\n' +
		'result;';

	layer3.transform.position.expression = '//Duik.threeLayerIK.stretch\n' +
		'var controller = null;\n' +
		'var result = value;\n' +
		'try { controller = effect("' + layer3Data.name + '")(1); } catch (e){ value };\n' +
		'if (controller != null)\n' +
		'{\n' +
		'fx = controller.effect("' + ikEffect.name + '");\n' +
		'layer1 = null;\n' +
		'try{layer1=fx(18)}catch(e){}\n' +
		'if (layer1 != null)\n' +
		'{\n' +
		'stretch = fx(9).value;\n' +
		'auto = fx(8).value;\n' +
		'IK = fx(1).value;\n' +
		'shrinkVal = fx(10).value/100;\n' +
		'function getWorldPos(L){\n' +
		'return L.toWorld(L.anchorPoint);\n' +
		'}\n' +
		'var upperAP = ' + rootAp + ';\n' +
		'var middlePos = ' + middlePos + ';\n' +
		'var middleAP = ' + middleAp + ';\n' +
		'var lowerPos = ' + lowerPos + ';\n' +
		'var lowerAP = ' + lowerAp + ';\n' +
		'var zeroPos = ' + goalPos.toSource() + ';\n' +
		'dist1 = length(upperAP,middlePos);\n' +
		'dist2 = length(middleAP,lowerPos);\n' +
		'dist3 = length(lowerAP,zeroPos);\n' +
		'IKLength = dist1+dist2+dist3;\n' +
		'IKStretched = IKLength+stretch;\n' +
		'boneStretch = 0;\n' +
		'proportion = dist2/(IKLength);\n' +
		'posC = getWorldPos(controller);\n' +
		'posR = getWorldPos(layer1);\n' +
		'distC = length(posC,posR);\n' +
		'shrinkMax = IKLength*shrinkVal;\n' +
		'shrink = 0;\n' +
		'if (distC < IKStretched && IK) shrink = 1-distC/IKStretched;\n' +
		'boneStretch -= easeOut(shrink,0,shrinkMax)*proportion;\n' +
		'if (distC > IKStretched && auto && IK) boneStretch += (distC-IKLength)*proportion;\n' +
		'else boneStretch += stretch*proportion;\n' +
		'coef = 1;\n' +
		'dist2 != 0 ? coef = (dist2+boneStretch)/dist2 : coef = 1;\n' +
		'result = (middlePos-upperAP)*coef+upperAP;\n' +
		'}\n' +
		'}\n' +
		'result;';

	if (goal != null)
	{
		var goalData = DuAEF.DuAE.Layer.addPseudoEffect(goal,DuAEF.Duik.PseudoEffects.IK,DuAEF.Duik.PseudoEffectsMatchNames.IK,"IK");
		goalData(1).setValue(controller.layer.index);

		var rotExpr = '//Duik.goal\n' +
			'var ctrl = null;\n' +
			'var result = value;\n' +
			'try { ctrl = effect("' + goalData.name + '")(1); } catch (e){};\n' +
			'if (ctrl != null)\n' +
			'{\n' +
			'var goal = ctrl.effect("' + ikEffect.name + '")(1).value;\n' +
			'result += ctrl.rotation.value;\n' +
			'if (goal)\n' +
			'{\n' +
			'var layer = thisLayer;\n' +
			'while (layer.hasParent)\n' +
			'{\n' +
			'layer = layer.parent;\n' +
			'result = result - layer.rotation;\n' +
			'}\n' +
			'}\n' +
			'}\n' +
			'result;';

	DuAEF.DuAE.Property.setExpression(goal.transform.rotation,rotExpr);

	goal.transform.position.expression = 'var ctrl = null;\n' +
		'var result = value;\n' +
		'try { ctrl = effect("' + goalData.name + '")(1); } catch (e){ value };\n' +
		'if (ctrl != null)\n' +
		'{\n' +
		'result = ctrl.effect("' + ikEffect.name + '")(28).value;\n' +
		'}\n' +
		'result;';
	}

	return controller;
}

/**
* Creates a bezier ik on the layers
* @param {Layer[]} layers - The layers, ordered from root to end
* @param {Layer|null} [goal] - The goal layer, at the end of the IK
* @param {Layer|Controller|null} [controllers] - The layer to use as controller, can be automatically created.<br />
* Must be provided if goal is undefined.
* @return {Controller[]} The controllers [root,curve,end]
*/
DuAEF.Duik.Rigging.bezierIK = function (layers,goal,controller)
{
	if (goal == undefined) goal = null;
	if (controller == undefined) controller = null;
	if (controller == null && goal == null) throw "You must provide either a goal layer or a controller";

	var comp = layers[0].containingComp;

	//create controllers
	if (controller == null)
	{
		controller = DuAEF.Duik.Controller.create(comp,DuAEF.Duik.ControllerType.TRANSFORM,goal);
		goal.parent = null;
		if (goal) controller.layer.transform.rotation.setValue(goal.transform.rotation.value);
	}
	if (goal) goal.parent = controller.layer;

	//add effect
	var name = layers[0].name;
	var ikEffect = DuAEF.DuAE.Layer.addPseudoEffect(controller.layer,DuAEF.Duik.PseudoEffects.BEZIER_IK,DuAEF.Duik.PseudoEffectsMatchNames.BEZIER_IK,"IK | " + name);

	//create curve controller
	var curveController = DuAEF.Duik.Controller.create(comp,DuAEF.Duik.ControllerType.TRANSFORM,layers[0]);
	curveController.layer.name = curveController.layer.name + " | Curve";

	//add effect
	var curveEffect = DuAEF.DuAE.Layer.addPseudoEffect(curveController.layer,DuAEF.Duik.PseudoEffects.BEZIER_IK_CURVE,DuAEF.Duik.PseudoEffectsMatchNames.BEZIER_IK_CURVE,"Bezier IK");
	curveEffect(3).setValue(layers[0].index);
	curveEffect(4).setValue(curveController.layer.index);
	curveEffect(5).setValue(controller.layer.index);

	//useful positions
	var endPosition = DuAEF.DuAE.Layer.getWorldPos(controller.layer);
	if (goal != null) endPosition = DuAEF.DuAE.Layer.getWorldPos(goal);
	var rootPosition = DuAEF.DuAE.Layer.getWorldPos(layers[0]);
	curveController.layer.transform.position.setValue((endPosition+rootPosition)/2);
	var cOutPosition = (2*endPosition+rootPosition)/3;
	var cInPosition = (endPosition+2*rootPosition)/3;

	//add handles
	var handleInGroup = curveController.layer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
	handleInGroup.name = 'Handle In';
	handleInContent = handleInGroup.property("ADBE Vectors Group");
	var circle = handleInContent.addProperty("ADBE Vector Shape - Ellipse");
	circle("ADBE Vector Ellipse Size").setValue([25,25]);
	var fill = handleInContent.addProperty("ADBE Vector Graphic - Fill");
	fill("ADBE Vector Fill Color").expression = 'effect("Controller")(2)-[0.2,0.2,0.2,0]\n';
	handleInGroup.transform.scale.expression = '[effect("Controller")(4),effect("Controller")(4)]';
	handleInGroup.transform.position.expression = 'var fx = effect("' + curveEffect.name + '");\n' +
		'var root = null;\n' +
		'var curve = thisLayer;\n' +
		'var result = value;\n' +
		'if (fx(1).value)\n' +
		'{\n' +
		'try { root = fx(3) ;} catch(e){}\n' +
		'if (root != null)\n' +
		'{\n' +
		'var rootPos = root.toWorld(root.anchorPoint);\n' +
		'rootPos = fromWorld(rootPos);\n' +
		'result += rootPos/2;\n' +
		'}\n' +
		'}\n' +
		'result;';

	var handleOutGroup = curveController.layer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
	handleOutGroup.name = 'Handle Out';
	handleOutContent = handleOutGroup.property("ADBE Vectors Group");
	var circle = handleOutContent.addProperty("ADBE Vector Shape - Ellipse");
	circle("ADBE Vector Ellipse Size").setValue([25,25]);
	var fill = handleOutContent.addProperty("ADBE Vector Graphic - Fill");
	fill("ADBE Vector Fill Color").expression = 'effect("Controller")(2)-[0.2,0.2,0.2,0]\n';
	handleOutGroup.transform.scale.expression = '[effect("Controller")(4),effect("Controller")(4)]';
	handleOutGroup.transform.position.expression = 'var fx = effect("' + curveEffect.name + '");\n' +
		'var end = null;\n' +
		'var curve = thisLayer;\n' +
		'var result = value;\n' +
		'if (fx(1).value)\n' +
		'{\n' +
		'try { end = fx(5); } catch(e){}\n' +
		'if (end != null)\n' +
		'{\n' +
		'var endPos = end.toWorld(end.anchorPoint);\n' +
		'endPos = fromWorld(endPos);\n' +
		'result += endPos/2;\n' +
		'}\n' +
		'}\n' +
		'result;';

	//add line
	if (DuAEF.DuAE.App.version >= 15)
	{
		var lineGroup = curveController.layer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
		lineGroup.name = 'IK Line';
		var lineContent = lineGroup.property("ADBE Vectors Group");
		var shape = lineContent.addProperty("ADBE Vector Shape - Group");
		shape('ADBE Vector Shape').expression = 'var fx = effect("' + curveEffect.name + '");\n' +
			'var root = null;\n' +
			'var curve = thisLayer;\n' +
			'var end = null;\n' +
			'var result = [[0,0]];\n' +
			'if (fx(1).value)\n' +
			'{\n' +
			'try { root = fx(3) ; end = fx(5) } catch(e){}\n' +
			'if (root != null)\n' +
			'{\n' +
			'var r = root.toWorld(root.anchorPoint);\n' +
			'r = fromWorld(r);\n' +
			'var e = end.toWorld(end.anchorPoint);\n' +
			'e = fromWorld(e);\n' +
			'var t1 = content("Handle In").transform.position;\n' +
			'var t2 = content("Handle Out").transform.position;\n' +
			'result = [r,t1,t2,e];\n' +
			'}\n' +
			'}\n' +
			'createPath(result,[],[],false);';
		var stroke = lineContent.addProperty("ADBE Vector Graphic - Stroke");
		stroke("ADBE Vector Stroke Color").expression = 'effect("Controller")(2)-[0.2,0.2,0.2,0]';
		stroke("ADBE Vector Stroke Width").setValue(2);
		stroke("ADBE Vector Stroke Line Cap").setValue(2);
		stroke("ADBE Vector Stroke Dashes").addProperty("ADBE Vector Stroke Dash 1");
		stroke("ADBE Vector Stroke Dashes")("ADBE Vector Stroke Dash 1").setValue(5);
	}

	//setup layers
	var rootIndex = layers[0].index;
	var endIndex = controller.layer.index;
	var curveIndex = curveController.layer.index;
	var totalLength = DuAEF.DuJS.Math.getLength(rootPosition,cInPosition) + DuAEF.DuJS.Math.getLength(cOutPosition,cInPosition) + DuAEF.DuJS.Math.getLength(cOutPosition,endPosition);

	//un-parent
	for (var i = 1 ; i < layers.length ; i++)
	{
		layers[i].parent = null;
	}

	for (var i = 0 ; i < layers.length ; i++)
	{
		var layer = layers[i];
		//add effect
		var layerEffect = DuAEF.DuAE.Layer.addPseudoEffect(layer,DuAEF.Duik.PseudoEffects.BEZIER_IK_LAYER,DuAEF.Duik.PseudoEffectsMatchNames.BEZIER_IK_LAYER,"Bezier IK");
		layerEffect(3).setValue(rootIndex);
		layerEffect(4).setValue(curveIndex);
		layerEffect(5).setValue(endIndex);
		if (i < layers.length -1) layerEffect(6).setValue(layers[i+1].index);
		else layerEffect(6).setValue(controller.layer.index);

		//expressions

		//position
		if (i != 0)
		{
			var index = DuAEF.DuJS.Math.getLength(endPosition,layer.transform.position.value);
			index = index/totalLength;
			layer.transform.position.expression = '//Duik.bezierIK\n' +
				'var end = null;\n' +
				'var root = null;\n' +
				'var curve = null;\n' +
				'var result = value;\n' +
				'var thisFx = effect("' + layerEffect.name + '");\n' +
				'try{end=thisFx(5);curve=thisFx(4);root=thisFx(3);}catch(e){};\n' +
				'if(root !=null)\n' +
				'{\n' +
				'var ind = ' + index + ';\n' +
				'var fx = end.effect("' + ikEffect.name + '");\n' +
				'var offset = thisFx(1)/100;\n' +
				'var generalOffset = fx(2)/100;\n' +
				'var endPosition = end.toComp(end.anchorPoint);\n' +
				'var rootPosition = root.toComp(root.anchorPoint);\n' +
				'var curvePosition1 = curve.toComp(curve.content("Handle Out").transform.position);\n' +
				'var curvePosition2 = curve.toComp(curve.content("Handle In").transform.position);\n' +
				'var t = ind + generalOffset + offset;\n' +
				'var c = 3*(curvePosition1 - endPosition);\n' +
				'var b = 3*(curvePosition2 - curvePosition1) - c;\n' +
				'var a = rootPosition - endPosition - c - b;\n' +
				'result += ((a*t +b )*t + c)*t + endPosition ;\n' +
				'result -= ' + layer.transform.position.value.toSource() + ';\n' +
				'}\n' +
				'result;';
		}

		//rotation
		var expr = '//Duik.bezierIK\n' +
			'var c = null;\n' +
			'var result = value;\n' +
			'var thisFx = effect("' + layerEffect.name + '");\n' +
			'try{c = thisFx(5)}catch(e){}\n' +
			'if (c!=null)\n' +
			'{\n' +
			'var n = c;\n' +
			'try {n=thisFx(6); if (n.index == index) n=c}catch(e){}\n' +
			'var fx = c.effect("' + ikEffect.name + '");\n' +
			'var autoOrient = fx(1).value;\n' +
			'var C = n.toWorld(n.anchorPoint);\n' +
			'var O =  thisLayer.toWorld(thisLayer.anchorPoint);\n' +
			'var vec = O-C;\n' +
			'var angle = Math.atan2(vec[1], vec[0]);\n' +
			'var ik = radiansToDegrees(angle);\n' +
			'if (autoOrient==1) result += ik;\n';
		if (i == 0)
		{
			expr += 'var layer = thisLayer;\n' +
			'while(layer.hasParent)\n' +
			'{\n' +
			'layer = layer.parent;\n' +
			'result -= layer.transform.rotation;\n' +
			'}\n';
		}
		expr += '}\n' +
			'result;';

		DuAEF.DuAE.Property.setExpression(layer.transform.rotation,expr);
	}

	curveController.layer.selected = false;
	controller.layer.moveBefore(curveController.layer);

	return controller;
}

/**
* Bones
* @namespace
* @memberof DuAEF.Duik
*/
DuAEF.Duik.Bone = {};

/**
* Creates a stand alone bone in the comp
* @param {CompItem} comp - The containing composition
* @param {float}	[size] - The bone size, a percentage. By default, it will adjust automatically depending on comp size and DuAEF.Duik.boneSizeHint
* @param {DuAEF.Duik.BoneType} [type=DuAEF.Duik.BoneType.PIN] - The type
* @return {Bone} The bone
*/
DuAEF.Duik.Bone.createBone = function(comp,size,type)
{
	//create
	var bone = comp.layers.addShape();
	DuAEF.Duik.setDuikMarker(bone,"Bone",DuAEF.Duik.LayerTypes.BONE);
	//add effect
	var effect = DuAEF.DuAE.Layer.addPseudoEffect(bone,DuAEF.Duik.PseudoEffects.BONE,DuAEF.Duik.PseudoEffectsMatchNames.BONE,'Bone');

	function createIcon()
	{
		var iconGroup = bone("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
		iconGroup.name = 'Icon';
		iconContent = iconGroup.property("ADBE Vectors Group");

		if (type == DuAEF.Duik.BoneType.PIN)
		{
			var shape1 = iconContent.addProperty("ADBE Vector Shape - Group");
			var handleShape = new Shape();
			handleShape.vertices = [[24.6726379394531, -34.5], [34.6699981689453, -24.9618682861328], [26.9935607910156, -18.9175109863281], [25.2696228027344, -9.10385131835938], [9.27384948730469, -24.3648681640625], [18.9956817626953, -26.5480346679688]];
			handleShape.inTangents = [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]];
			handleShape.outTangents = [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]];
			handleShape.closed = true;
			shape1('ADBE Vector Shape').setValue(handleShape);
			var shape2 = iconContent.addProperty("ADBE Vector Shape - Group");
			var needleShape = new Shape();
			needleShape.vertices = [[13.7023773193359, -16], [5.47381591796875, -7.77142333984375], [0.75, 0], [8.06428527832031, -5.4857177734375], [16.2928619384766, -13.7142791748047]];
			needleShape.inTangents = [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]];
			needleShape.outTangents = [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]];
			needleShape.closed = true;
			shape2('ADBE Vector Shape').setValue(needleShape);
			var fill = iconContent.addProperty("ADBE Vector Graphic - Fill");
			fill("ADBE Vector Fill Color").expression = 'effect("Bone")(1).value';
		}
		else if (type == DuAEF.Duik.BoneType.VERTEX)
		{
			var rect = iconContent.addProperty("ADBE Vector Shape - Rect");
			rect("ADBE Vector Rect Size").setValue([30,30]);
			var fill = iconContent.addProperty("ADBE Vector Graphic - Fill");
			fill("ADBE Vector Fill Color").expression = 'effect("Bone")(1).value';

			bone.transform.scale.expression = '[value[0],value[0]];';
		}
		else if (type == DuAEF.Duik.BoneType.TANGENT)
		{
			var circle = iconContent.addProperty("ADBE Vector Shape - Ellipse");
			circle("ADBE Vector Ellipse Size").expression = '[20,20] * effect("Bone")(2).value/100';

			var line = iconContent.addProperty("ADBE Vector Shape - Group");
			line('ADBE Vector Shape').expression = "createPath([[0,0], -transform.position], [[0,0],[0,0]], [[0,0],[0,0]], false);";
			var pathStroke = iconContent.addProperty("ADBE Vector Graphic - Stroke");
			pathStroke.property("Color").expression = 'effect("Bone")(1)-[0.2,0.2,0.2,0]';
			pathStroke.property("Stroke Width").setValue(6);
			var fill = iconContent.addProperty("ADBE Vector Graphic - Fill");
			fill("ADBE Vector Fill Color").expression = 'effect("Bone")(1)-[0.2,0.2,0.2,0]';
		}

		if (type != DuAEF.Duik.BoneType.TANGENT) iconGroup.transform.scale.expression = '[effect("Bone")(2).value,effect("Bone")(2).value]';
	}

	function createAnchor()
	{
		var anchorGroup = bone("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
		anchorGroup.name = 'Anchor';
		var anchorContent = anchorGroup.property("ADBE Vectors Group");

		var centerCircle = anchorContent.addProperty("ADBE Vector Shape - Ellipse");
		centerCircle("ADBE Vector Ellipse Size").setValue([2,2]);
		var rect = anchorContent.addProperty("ADBE Vector Shape - Rect");
		rect("ADBE Vector Rect Size").setValue([12,12]);
		var stroke = anchorContent.addProperty("ADBE Vector Graphic - Stroke");
		stroke("ADBE Vector Stroke Color").setValue([0,0,0,1]);
	}

	if (type == DuAEF.Duik.BoneType.VERTEX) createAnchor();
	createIcon();
	if (type == DuAEF.Duik.BoneType.PIN) createAnchor();

	bone.guideLayer = true;

	//group
	DuAEF.Dugr.addLayerToGroup(bone,"Bones");

	bone = new Bone(bone);
	bone.setSize();
	bone.setColor();
	return bone;
}

/**
 * Gets Bones in the comp or the selection.
 * @memberof DuAEF.Duik.Bone
 * @param {CompItem}	comp	- The composition where to get the bones
 * @param {String} name - A name filter
 * @param {boolean} [selectedOnly=false] - Selected layers only
 * @return {Bone|null}	The bones.
 */
DuAEF.Duik.Bone.getBoneByName = function (comp,name,selectedOnly)
{
	if (selectedOnly == undefined) selectedOnly = false;

	var layers = [];
	if (selectedOnly) layers = comp.selectedLayers;
	else layers = comp.layers;

	if (layers.length == 0) return null;

	var it = new Iterator(layers);

	it.do( function (layer)
	{
		if (DuAEF.Duik.isLayerType(layer,DuAEF.Duik.LayerTypes.BONE))
		{
			if (name == layer.name) return new Bone(layer);
		}
	});

	return null;
}

/**
* Links the property to a bone
* @param {Property|PropertyInfo} prop - The property
* @param {float}	[size] - The bone size, a percentage. By default, it will adjust automatically depending on comp size and DuAEF.Duik.boneSizeHint
* @param {Layer} bone - An already existing bone
* @return {Bone|Bone[]} The bone(s) created. An Array if prop is a Shape
*/
DuAEF.Duik.Bone.addBone = function (prop,size,bone)
{
	if (bone == undefined) bone == null;

	var propInfo;
	if (prop instanceof PropertyInfo)
	{
		propInfo = prop;
		prop = propInfo.getProperty();
	}
	else propInfo = new PropertyInfo(prop);

	try { prop.matchName; } catch (e) {return bone;}

	if (prop.matchName == "ADBE FreePin3 PosPin Atom")
	{
		prop = prop.position;
		if (!prop.canSetExpression) return bone;
		propInfo = new PropertyInfo(prop);
	}

	if (prop.propertyValueType != PropertyValueType.TwoD_SPATIAL && prop.propertyValueType != PropertyValueType.ThreeD_SPATIAL && prop.propertyValueType != PropertyValueType.ThreeD  && prop.propertyValueType != PropertyValueType.TwoD && prop.propertyValueType != PropertyValueType.SHAPE)
	{
		return bone;
	}

	if (prop.propertyValueType == PropertyValueType.SHAPE && DuAEF.DuAE.App.version < 15) return bone;


	var layer = DuAEF.DuAE.Property.getLayer(prop);
	var comp = layer.containingComp;

	//create effect function
	function createControl(l,name)
	{
		//check if an effect already exists
		var effect = null;

		for (var i = 1; i <= layer('ADBE Effect Parade').numProperties ; i++)
		{
			var fx = layer('ADBE Effect Parade').property(i);
			if (fx.matchName == DuAEF.Duik.PseudoEffectsMatchNames.BONE_LINKER && fx.name == name )
			{
				effect = fx;
				break;
			}
		}
		if (effect == null)
		{
			effect = DuAEF.DuAE.Layer.addPseudoEffect(l,DuAEF.Duik.PseudoEffects.BONE_LINKER,DuAEF.Duik.PseudoEffectsMatchNames.BONE_LINKER);
			effect.name = name;
		}
		return effect;
	}

	if (prop.propertyValueType == PropertyValueType.SHAPE)
	{
		var pathPath = DuAEF.DuAE.Property.getExpressionLink(prop,true);
		var pathPoints = prop.value.vertices;
		var pathInTangents = prop.value.inTangents;
		var pathOutTangents = prop.value.outTangents;
		var nullSet = [];
		var nullSetIn = [];
		var nullSetOut = [];

		var bones = [];

		//For each path point
		for (var i = 0; i < pathPoints.length; i++)
		{
			var nullName = 'B | ' + layer.name + " | " + prop.parentProperty.name + " - " + i;
			var nullNameIn = 'B | ' + layer.name + " | " + prop.parentProperty.name + " | In - " + i;
			var nullNameOut = 'B | ' + layer.name + " | " + prop.parentProperty.name + " | Out - " + i;

			var newBone = DuAEF.Duik.Bone.getBoneByName(comp,nullName);
			var newBoneIn = DuAEF.Duik.Bone.getBoneByName(comp,nullNameIn);
			var newBoneOut = DuAEF.Duik.Bone.getBoneByName(comp,nullNameOut);

			// Get names of nulls that don't exist yet and create them
			if(newBone == null)
			{
				//Create nulls
				newBone = DuAEF.Duik.Bone.createBone(comp,size,DuAEF.Duik.BoneType.VERTEX);
				newBone.layer.name = nullName;
				newBone.layer.label = 11;
			}

			// Set position using layer space transforms, then remove expressions
			newBone.layer.position.setValue(pathPoints[i]);
			newBone.layer.position.expression = "var srcLayer = thisComp.layer(\"" + layer.name + "\"); \r" +
										"var srcPath = " + pathPath + ".points()[" + i + "]; \r" +
										"srcLayer.toComp(srcPath);";
			newBone.layer.position.setValue(newBone.layer.position.value);
			newBone.layer.position.expression = '';


			if (newBoneOut == null)
			{
				var newBoneOut = DuAEF.Duik.Bone.createBone(comp,size,DuAEF.Duik.BoneType.TANGENT);
				newBoneOut.layer.parent = newBone.layer;
				newBoneOut.layer.name = nullNameOut;
				newBoneOut.layer.label = 14;
				newBoneOut.layer.position.setValue(pathOutTangents[i]);
			}

			if (newBoneIn == null)
			{
				var newBoneIn = DuAEF.Duik.Bone.createBone(comp,size,DuAEF.Duik.BoneType.TANGENT);
				newBoneIn.layer.parent = newBone.layer;
				newBoneIn.layer.name = nullNameIn;
				newBoneIn.layer.label = 14;
				newBone.layer.moveBefore(newBoneIn.layer);
				newBoneIn.layer.position.setValue(pathInTangents[i]);
			}


			//add effect
			var effectName = 'B | ' + prop.parentProperty.name + " - " + i;
			var effect = createControl(layer,effectName);
			effect(1).setValue(newBone.layer.index);
			var effectNameIn = 'B | ' + prop.parentProperty.name + " | In - " + i;
			var effectIn = createControl(layer,effectNameIn);
			effectIn(1).setValue(newBoneIn.layer.index);
			var effectNameOut = 'B | ' + prop.parentProperty.name + " | Out - " + i;
			var effectOut = createControl(layer,effectNameOut);
			effectOut(1).setValue(newBoneOut.layer.index);

			nullSet.push(effectName);
			nullSetIn.push(effectNameIn);
			nullSetOut.push(effectNameOut);

			bones.push(newBone);
			bones.push(newBoneIn);
			bones.push(newBoneOut);
		}

		prop.expression = "var nullLayerNames = [\"" + nullSet.join("\",\"") + "\"]; \r" +
						"var nullLayerNamesIn = [\"" + nullSetIn.join("\",\"") + "\"]; \r" +
						"var nullLayerNamesOut = [\"" + nullSetOut.join("\",\"") + "\"]; \r" +
						"var origPath = thisProperty; \r" +
						"var origPoints = origPath.points(); \r" +
						"var origInTang = origPath.inTangents(); \r" +
						"var origOutTang = origPath.outTangents(); \r" +
						"var getNullLayers = []; \r" +
						"var getNullLayersIn = []; \r" +
						"var getNullLayersOut = []; \r" +
						"for (var i = 0; i < nullLayerNames.length; i++){ \r" +
						"    try{  \r" +
						"        getNullLayers.push(effect(nullLayerNames[i])(1)); \r" +
						"        getNullLayersIn.push(effect(nullLayerNamesIn[i])(1)); \r" +
						"        getNullLayersOut.push(effect(nullLayerNamesOut[i])(1)); \r" +
						"    } catch(err) { \r" +
						"        getNullLayers.push(null); \r" +
						"    }} \r" +
						"for (var i = 0; i < getNullLayers.length; i++){ \r" +
						"    if (getNullLayers[i] != null && getNullLayers[i].index != thisLayer.index){ \r" +
						"        origPoints[i] = fromCompToSurface(getNullLayers[i].toComp(getNullLayers[i].anchorPoint));  \r" +
						"        origInTang[i] = fromCompToSurface(getNullLayersIn[i].toComp(getNullLayersIn[i].anchorPoint)) - origPoints[i];  \r" +
						"        origOutTang[i] = fromCompToSurface(getNullLayersOut[i].toComp(getNullLayersOut[i].anchorPoint)) - origPoints[i];  \r" +
						"    }} \r" +
						"createPath(origPoints,origInTang,origOutTang,origPath.isClosed());";

		return bones;
	}
	else
	{
		//add effect
		var effectName = 'B | ' + prop.parentProperty.name + ' - ' + prop.propertyIndex;
		var effect = createControl(layer,effectName);

		if (effect(1).value != 0 && effect(1).value != layer.index ) bone = new Bone(comp.layer(effect(1).value));
		prop = propInfo.getProperty();

		//create bone
		if (bone == null)
		{
			bone = DuAEF.Duik.Bone.createBone(comp,size,DuAEF.Duik.BoneType.PIN);
			bone.layer.moveBefore(layer);
			//rename bone
			var name = "B | " + layer.name;
			if (prop.parentProperty != undefined)  name += " | " + prop.parentProperty.name;
			if (name.length > 32) name = name.substr(0,29) + "...";
			bone.layer.name = DuAEF.DuAE.Comp.newUniqueLayerName(name,comp,false);
		}

		//move the bone to the prop : use an expression to get its world position
		prop.expression = "";
		posLink = DuAEF.DuAE.Property.getExpressionLink(prop,true);

		if (!(layer instanceof ShapeLayer))
		{
			bone.layer.position.expression = "thisComp.layer(\"" + layer.name + "\").toWorld(" + posLink + ")";
			bone.layer.position.setValue(bone.layer.position.value);
			bone.layer.position.expression = "";
		}
		else
		{
			bone.layer.position.setValue(prop.value);
		}

		effect(1).setValue(bone.layer.index);
		effect(2).expression = 'try { effect("' + effect.name + '")(1).effect("Bone")(1) } catch (e){}';

		//add expression
		if (layer instanceof ShapeLayer)
		{
			prop.expression = '//Duik.bone\n' +
			 				'var l = null;\n' +
							'try {l = effect("' + effect.name + '")(1)} catch (e) {};\n' +
							'var result = value;\n' +
							'if (l != null) { result = l.toWorld(l.anchorPoint); }\n' +
							'result;';
		}
		else
		{
			prop.expression = '//Duik.bone\n' +
			 				'var l = null;\n' +
							'try {l = effect("' + effect.name + '")(1)} catch (e) {};\n' +
							'var result = value;\n' +
							'if (l != null) {\n' +
							'result = l.toWorld(l.anchorPoint);\n' +
							'result = fromWorld(result);\n' +
							'}\n' +
							'result;';
		}

		return bone;
	}
}
