/**
 * The Open Animation library
 * @namespace
 * @requires yaml.jsxinc
 * @requires json.jsxinc
 * @category OA
 */
var OA = {};

// === PRIVATE ===

OA._d = function(val, defaultVal) {
    return typeof val !== 'undefined' ? val : defaultVal;
}

OA._jstype = function( value ) {
    var type = typeof value;
    type = type.toLowerCase();

    if (type == 'object') {
        try {
            type = value === null ? 'null' : Object.prototype.toString.call(value).match(/^\[object (.*)\]$/)[1];
        } catch (e) {}
    }

    return type;
}

OA._keyframeSorter = function(kA, kB) {
    return kA.time - kB.time;
}

OA._g = function(data, key, defaultValue) {
    defaultValue = OA._d(defaultValue, null);
    var keys = key.split('/');
    var val = data;
    for (var i = 0; i < keys.length; i++) {
        if (typeof val[keys[i]] === 'undefined') return defaultValue;
        val = val[keys[i]];
    }
    return val;
}

OA._s = function(data, key, value) {
    var keys = key.split('/');
    var numKeys = keys.length;
    var v = data;
    for (var i = 0; i < numKeys-1; i++) {
        v[keys[i]] = OA._d(v[keys[i]], {});
        v = v[keys[i]];
    }
    v[keys[numKeys-1]] = value;
    return data;
}

OA._h = function(data, key) {
    var keys = key.split('/');
    var val = data;
    for (var i = 0; i < keys.length; i++) {
        if (typeof data[keys[i]] === 'undefined') return false;
        val = data[keys[i]];
    }
    return true;
}

OA._clamp = function(values, min, max) {
    min = OA._d(min, 0);
    max = OA._d(max, 0);
    if (max < min) {
        var t = max;
        max = min;
        min = t;
    }

    var isArray = true;
    var result = [];
    if (!(values instanceof Array)) {
        isArray = false;
        values = [values];
    }
    for (var i = 0, num = values.length; i < num; i++) {
        var v = values[i];
        if (v < min) v = min;
        if (v > max) v = max;
        result.push(v);
    }
    if (isArray) return result;
    else return result[0];
}

// === PUBLIC ===

/**
 * Interpolation modes
 * @enum {string}
 */
OA.InterpolationMode = {
    AUTO: 'auto',
    HOLD: 'hold',
    LINEAR: 'linear',
    BEZIER: 'bezier',
    EXPONENTIAL: 'exp',
    GAUSSIAN: 'gaussian',
    LOGARITHMIC: 'logarithmic',
    LOGISTIC: 'logistic'
}

/**
 * Functions to interpolate values
 * @namespace
 */
OA.Interpolation = {}

/**
 * Linear (extra/inter)polation
 * @param {Number} value The variable
 * @param {Number} [min=0] The minimum input value
 * @param {Number} [max=1] The maximum input value
 * @param {Number} [targetMin=0] The minimum output value
 * @param {Number} [targetMax=1] The maximum output value
 * @param {Boolean} [extrapolate=true] Whether to extrapolate outside the target.
 * @returns {Number}
 */
OA.Interpolation.linear = function(value, min, max, targetMin, targetMax, extrapolate) { 
    extrapolate = OA._d(extrapolate, true);
    min =  OA._d(min, 0);
    max =  OA._d(max, 1);
    targetMin =  OA._d(targetMin, 0);
    targetMax =  OA._d(targetMax, 1);
    extrapolate =  OA._d(extrapolate, true);

    // Handle stupid values
    if (min == targetMin && max == targetMax) return value;
    if (min == max) return value;
    if (targetMin == targetMax) return targetMin;
    if (value == min) return targetMin;
    if (value == max) return targetMax;

    var result = targetMin + (value - min) / (max - min) * (targetMax - targetMin);
    if (!extrapolate) result = OA._clamp(result, targetMin, targetMax);
    return result;
};

/**
 * Interpolates a value with a bezier curve.
 * @param {number} t The value to interpolate
 * @param {number} [tMin=0] The minimum value of the initial range
 * @param {number} [tMax=1] The maximum value of the initial range
 * @param {number} [value1=0] The minimum value of the interpolated result
 * @param {number} [value2=1] The maximum value of the interpolated result
 * @param {number[]} [bezierPoints=[0.33,0.0,0.66,1.0]] an Array of 4 coordinates wihtin the [0.0, 1.0] range which describes the BÃ©zier interpolation.<br />
 * [ outTangentX, outTangentY, inTangentX, inTangentY ]
 * @return {number} the value.
 */
OA.Interpolation.bezier = function(t, tMin, tMax, value1, value2, bezierPoints) {
    tMin =  OA._d(tMin, 0);
    tMax =  OA._d(tMax, 1);
    value1 =  OA._d(value1, 0);
    value2 =  OA._d(value2, 1);
    bezierPoints =  OA._d(bezierPoints, [0.33,0.0,0.66,1.0]);

    if (arguments.length !== 5 && arguments.length !== 6) return (value1+value2)/2;
    var a = value2 - value1;
    var b = tMax - tMin;
    if (b == 0) return (value1+value2)/2;
    var c = OA._clamp((t - tMin) / b, 0, 1);
    if (!(bezierPoints instanceof Array) || bezierPoints.length !== 4) bezierPoints = [0.33,0.0,0.66,1];
    return a * h(c, bezierPoints) + value1;

    function h(f, g) {
        var x = 3 * g[0];
        var j = 3 * (g[2] - g[0]) - x;
        var k = 1 - x - j;
        var l = 3 * g[1];
        var m = 3 * (g[3] - g[1]) - l;
        var n = 1 - l - m;
        var d = f;
        for (var i = 0; i < 5; i++) {
            var z = d * (x + d * (j + d * k)) - f;
            if (Math.abs(z) < 1e-3) break;
            d -= z / (x + d * (2 * j + 3 * k * d));
        }
        return d * (l + d * (m + d * n));
    }
}

/**
 * Interpolates and extrapolates a value with an exponential function.
 * @param {number} t The value to interpolate
 * @param {number} [tMin=0] The minimum value of the initial range
 * @param {number} [tMax=1] The maximum value of the initial range
 * @param {number} [value1=0] The minimum value of the interpolated result
 * @param {number} [value2=1] The maximum value of the interpolated result
 * @param {number} [rate=1] The raising speed in the range [0, inf].
 * @return {number} the value.
 */
OA.Interpolation.exponential = function(t, tMin, tMax, vMin, vMax, rate) {
	tMin = OA._d(tMin, 0);
    tMax = OA._d(tMax, 1);
    vMin = OA._d(vMin, 0);
    vMax = OA._d(vMax, 1);
    rate = OA._d(rate, 1);
   
    if (rate == 0) return OA.Interpolation.linear(t, tMin, tMax, vMin, vMax);

    // handle tMax < tMin
    var rev = false;
    if (tMax < tMin) {
        var temp = tMax;
        tMax = tMin;
        tMin = temp;
        rev = true;
    }

	// Offset t to be in the range 0-Max
	tMax = ( tMax - tMin ) * rate;
	t = ( t - tMin ) * rate;
	// Compute the max
	var m = Math.exp(tMax);
	// Compute current value
	t = Math.exp(t);
	var result = OA.Interpolation.linear(t, 1, m, vMin, vMax);
    if (rev) result = OA.Interpolation.linear(result, vMin, vMax, vMax, vMin);
    return result;
}

/**
 * Interpolates a value with a gaussian function.
 * @function
 * @param {number} t The value to interpolate
 * @param {number} [tMin=0] The minimum value of the initial range
 * @param {number} [tMax=1] The maximum value of the initial range
 * @param {number} [value1=0] The minimum value of the interpolated result
 * @param {number} [value2=1] The maximum value of the interpolated result
 * @param {number} [rate=0] The raising speed in the range [-1.0, 1.0].
 * @return {number} the value.
 */
OA.Interpolation.gaussian = function( t, tMin, tMax, value1, value2, rate ) {
    tMin = OA._d(tMin, 0);
    tMax = OA._d(tMax, 1);
    value1 = OA._d(value1, 0);
    value2 = OA._d(value2, 1);
    rate = OA._d(rate, 0);

    // handle tMax < tMin
    var rev = false;
    if (tMax < tMin) {
        var temp = tMax;
        tMax = tMin;
        tMin = temp;
        rev = true;
    }

    // fix small bump at first value
    if (t != tMin)
    {
        var newValue1 = OA.Interpolation.gaussian( tMin, tMin, tMax, value1, value2, rate );
        var offset = newValue1 - value1;
        value1 = value1 - offset;
    }
	if (rate < 0) rate = rate*10;
	rate = OA.Interpolation.linear(t, tMin, tMax, 0.25, rate);
	var r = ( 1 - rate );
    var fwhm = (tMax-tMin) * r;
    var center = tMax;
	if (t >= tMax) {
        if (rev) return value1;
        return value2;
    }
    if (fwhm === 0 && t == center) {
        if (rev) return value1;
        return value2;
    }
    else if (fwhm === 0) {
        if (rev) return value2;
        return value1;
    }
	
    var exp = -4 * Math.LN2;
    exp *= Math.pow((t - center),2);
    exp *= 1/ Math.pow(fwhm, 2);
    var result = Math.pow(Math.E, exp);
	result = result * (value2-value1) + value1;

    if (rev) result = OA.Interpolation.linear( result, value1, value2, value2, value1);

    return result;
}

/**
 * Interpolates and extrapolates a value with a logarithmic function.
 * @function
 * @param {number} t The value to interpolate
 * @param {number} [tMin=0] The minimum value of the initial range
 * @param {number} [tMax=1] The maximum value of the initial range
 * @param {number} [value1=0] The minimum value of the interpolated result
 * @param {number} [value2=1] The maximum value of the interpolated result
 * @param {number} [rate=1] The raising speed in the range [0, inf].
 * @return {number} the value.
 */
OA.Interpolation.logarithmic = function(t, tMin, tMax, vMin, vMax, rate) {
    tMin = OA._d(tMin, 0);
    tMax = OA._d(tMax, 1);
    vMin = OA._d(vMin, 0);
    vMax = OA._d(vMax, 1);
    rate = OA._d(rate, 1);
    
    if (rate == 0) return OA.Interpolation.linear(t, tMin, tMax, vMin, vMax);

    // handle tMax < tMin
    var rev = false;
    if (tMax < tMin) {
        var temp = tMax;
        tMax = tMin;
        tMin = temp;
        rev = true;
    }

    // Offset t to be in the range 0-Max
    tMax = ( tMax - tMin ) * rate + 1;
    t = ( t - tMin ) * rate + 1;
    if (t <= 1) {
        if (rev) return vMax;
        return vMin;
    } 
    // Compute the max
    var m = Math.log(tMax);
    // Compute current value
    var v = Math.log(t);
    var result = OA.Interpolation.linear(v, 0, m, vMin, vMax);
    if (rev) result = OA.Interpolation.linear(result, vMin, vMax, vMax, vMin);
    return result;
}

/**
 * Interpolates and extrapolates a value with a logistic (sigmoid) function.
 * @function
 * @param {number} t The value to interpolate
 * @param {number} [tMin=0] The minimum value of the initial range
 * @param {number} [tMax=1] The maximum value of the initial range
 * @param {number} [value1=0] The minimum value of the interpolated result
 * @param {number} [value2=1] The maximum value of the interpolated result
 * @param {number} [rate=1] The raising speed in the range [0, inf].
 * @param {number} [tMid] The t value at which the interpolated value should be half way. By default, (tMin+tMax)/2
 * @return {number} the value
 */
OA.Interpolation.logistic = function( t, tMin, tMax, value1, value2, rate, tMid ) {
    tMin = OA._d(tMin, 0);
    tMax = OA._d(tMax, 1);
    value1 = OA._d(value1, 0);
    value2 = OA._d(value2, 1);
    rate = OA._d(rate, 1);
    tMid = OA._d(tMid, (tMin+tMax)/2);

    if (rate == 0) return OA.Interpolation.linear(t, tMin, tMax, value1, value2);
    t = DuMath.logistic( t, tMid, tMin, tMax, rate);
    
    // Scale to actual min/max
    var m = DuMath.logistic( tMin, tMid, tMin, tMax, rate);
    var M = DuMath.logistic( tMax, tMid, tMin, tMax, rate);

    return OA.Interpolation.linear( t, m, M, value1, value2);
}

/**
 * Math related methods
 * @namespace
 */
OA.Math = {}

/**
 * The logistic function (sigmoid)
 * @param {Number} value The value
 * @param {Number} [midValue=0] The midpoint value, at which the function returns max/2
 * @param {Number} [min=0] The minimum return value
 * @param {Number} [max=1] The maximum return value
 * @param {Number} [rate=1] The logistic growth rate or steepness of the function
 * @return {Number} The result in the range [min, max] (excluding min and max)
 */
OA.Math.logistic = function(value, midValue, min, max, rate) {
    if (!isdef( midValue )) midValue = 0;
    if (!isdef( min )) min = 0;
    if (!isdef( max )) max = 1;
    if (!isdef( rate )) rate = 1;
    var exp = -rate * (value - midValue);
    var result = 1 / (1 + Math.pow(Math.E, exp));
    return result * (max - min) + min;
}

/**
 * Compares two numbers
 * @param {Number|Number[]} value1 - The first value
 * @param {Number|Number[]} value2 - The second value
 * @param {int} [floatPrecision=-1] - The precision for (float) number comparison, number of decimals. Set to -1 to not use.
 * @return {boolean} true if the two values are equal
 */
OA.Math.equals = function(value1, value2, floatPrecision) {
    floatPrecision = OA._d(floatPrecision, -1);

    if (OA._jstype(value1) === 'array' || OA._jstype(value2) === 'array') {
        if (value1.length != value2.length) return false;
    }
    else {
        value1 = [value1];
        value2 = [value2];
    }
    

    for (var i = 0; i < value1.length; i++)
    {
        var item1 = value1[i];
        var item2 = value2[i];
        if (OA._jstype(item1) !== OA._jstype(item2)) return false;
        if (OA._jstype(item1) === 'array') return OA.Math.equals(item1, item2, floatPrecision);
        if (OA._jstype(item1) !== 'number') return false;

        if (floatPrecision >= 0) {
            var mul = Math.pow(10, floatPrecision);
            var num1 = Math.round(item1 * mul) / mul;
            var num2 = Math.round(item2 * mul) / mul;
            if (num1 != num2) return false;
        } else  if (item1 != item2) return false;
    }

    return true;
}

/**
 * Checks if the direction changes (if the point is at an extreme value). If the values have multiple dimensions, checks each axis individually.
 * @param {Number|Number[]} previousValue The value just before the point.
 * @param {Number|Number[]} point The point to check.
 * @param {Number|Number[]} nextValue The value just after the point.
 * @param {int} [precision=1] The precision for floating point comparisons; number of decimals.
 * @return {Boolean} 
 */
OA.Math.isExtremePoint = function(previousValue, point, nextValue, precision) {
    precision = OA._d(precision);
    if (OA._jstype(previousValue) !== 'array') previousValue = [previousValue];
    if (OA._jstype(point) !== 'array') point = [point];
    if (OA._jstype(nextValue) !== 'array') nextValue = [nextValue];

    for (var i = 0, n = point.length; i < n; i++) {
		var p = point[i];
		var pv = previousValue[i];
		var nx = nextValue[i];
		if (OA.Math.equals(p, pv, precision) && OA.Math.equals(p, nx, precision)) continue;
        // Get the dif
        var pDif = p-pv;
        var nDif = p-nx;
        // If the sign is the same, this is an extreme
        if (pDif >= 0 && nDif >= 0) return true;
        if (pDif <= 0 && nDif <= 0) return true;
		// If one of the two is 0, this is an extreme
        if (OA.Math.equals(pDif, 0.0, precision)) return true;
        if (OA.Math.equals(nDif, 0.0, precision)) return true;
    }
	return false;
}

/**
 * Checks if the point is an inflexion point.
 * @param {Number|Number[]} previousVelocity The derivative (speed) of a point just before the point.
 * @param {Number|Number[]} pointVelocity The derivative (speed) at the point to check.
 * @param {Number|Number[]} nextVelocity The derivative (speed) of a point just after the point.
 * @return {Boolean} 
 */
OA.Math.isInflexionPoint = function(previousVelocity, pointVelocity, nextVelocity) {
    if (OA._jstype(previousVelocity) !== 'array') previousVelocity = [previousVelocity];
    if (OA._jstype(pointVelocity) !== 'array') pointVelocity = [pointVelocity];
    if (OA._jstype(nextVelocity) !== 'array') nextVelocity = [nextVelocity];

    for (var i = 0, n = pointVelocity.length; i < n; i++) {
		var p = pointVelocity[i];
		var pv = previousVelocity[i];
		var nx = nextVelocity[i];
		if (p == pv && p == nx) continue;
		if ( p >= pv && p >= nx) return true;
		if ( p <= pv && p <= nx) return true;
    }
	return false;
}

/**
 * Measures the vector length between two points
 * @param {int[]} value1 - The first value
 * @param {int[]} value2 - The second value
 * @return {float} The length
 */
OA.Math.length = function(value1, value2) {
    if (typeof value1 !== typeof value2) {
        return null;
    }
    if (value1.length > 0) {
        var result = 0;
        for (var dim = 0; dim < value1.length; dim++) {
            result += (value1[dim] - value2[dim]) * (value1[dim] - value2[dim]);
        }
        result = Math.sqrt(result);
        return result;
    } else return Math.abs(value1 - value2);
}

// === OAInterpolation ===

/**
 * Creates an interpolation.
 * @class
 * @classdesc The description of an interpolation to be used between two keyframes.
 * @param {OA.InterpolationMode} [mode=OA.InterpolationMode.LINEAR] The mode/function to be used.
 * @param {float} [influence=0] The influence (X Coordinate) relative to the associated Keyframe time, a positive float.<br>
 * @category OA
 */
function OAInterpolation(mode) {
    /**
     * The mode.
     * @name mode
     * @memberof OAInterpolation
     * @type {OA.InterpolationMode}
     */
    this.mode = OA._d( mode, OA.InterpolationMode.LINEAR );
    /**
     * The rate/influence, according to the interpolation mode.<br>
     * With BÃ©zier interpolation, this is the X coordinate of the control point.
     * @name x
     * @memberof OAInterpolation
     * @type {float}
     */
    this.x = 0;
    if (this.mode == OA.InterpolationMode.EXPONENTIAL) this.x = 1;
    if (this.mode == OA.InterpolationMode.GAUSSIAN) this.x = 0;
    if (this.mode == OA.InterpolationMode.LOGARITHMIC) this.x = 1;
    if (this.mode == OA.InterpolationMode.LOGISTIC) this.x = 1;
    if (this.mode == OA.InterpolationMode.BEZIER) this.x = 1/3;
    /**
     * The additionnal value, used with Logistic (in this case it's the medium time) and BÃ©zier (Y coordinate of the control point) interpolations.
     * @name y
     * @memberof OAInterpolation
     * @type {float}
     */
    this.y = 0;
    if (this.mode == OA.InterpolationMode.LOGISTIC) this.y = 0.5;
    /**
     * Any other Data.<br>
     * This may be useful to store other information from any application.<br>
     * Be careful, for this data to be saved to OA files it needs to be serializable as a JSON string.<br>
     * You should only use <code>getMeta()</code> and <code>setMeta</code> to change these values.
     * @name meta
     * @memberof OAInterpolation
     * @type {object}
     */
    this.meta = {};
}

/**
 * Creates a js object containing this interpolation data.<br/>
 * This object could then be exported to JSON for example.
 * @return {Object} the JS Object
 */
OAInterpolation.prototype.toObject = function() {
    var data = {
        'mode': this.mode,
        'x': this.x,
        'y': this.y,
        'meta': this.meta
    };

    return data;
}

/**
 * Gets some metadata
 * @param {string} key The key. It can be an URL-like string to get subkeys
 * @param {*} [defaultValue=null] A default value to be returned if the key is not found
 * @return {*} The value
 */
OAInterpolation.prototype.getMeta = function( key, defaultValue ) {
    return OA._g(this.meta, key, defaultValue);
}

/**
 * Sets some metadata
 * @param {string} key The key. It can be an URL-like string to get subkeys
 * @param {*} value The new value. The value must be serializable as a JSON string.
 */
OAInterpolation.prototype.setMeta = function( key, value ) {
    this.meta = OA._s(this.meta, key, value);
}

/**
 * Checks if the metadata exists
 * @param {string} key The key. It can be an URL-like string to get subkeys
 * @return {Boolean}
 */
OAInterpolation.prototype.hasMeta = function( key ) {
    return OA._h(this.meta, key);
}

// === OAKeyframe ===

/**
 * Creates a keyframe.
 * @class
 * @classdesc An animation Keyframe.
 * @param {float} [value=0] The value.
 * @param {float} [time=0] The time.
 * @param {OAInterpolation} [inInterpolation] The in Interplation. Auto by default.
 * @param {OAInterpolation} [outInterpolation] The out Interplation. Linear by default.
 * @category OA
 */
function OAKeyframe(value, time, inInterpolation, outInterpolation) {
    /**
     * The time.
     * @name time
     * @memberof OAKeyframe
     * @type {float}
     */
    this.time = OA._d(time, 0);
    /**
     * The value.
     * @name value
     * @memberof OAKeyframe
     * @type {float}
     */
    this.value = OA._d(value, 0);
    /**
     * The in interpolation. Can only be "AUTO", "LINEAR" or "BEZIER"
     * @name inInterpolation
     * @memberof OAKeyframe
     * @type {OAInterpolation}
     */
    this.inInterpolation = OA._d(inInterpolation, new OAInterpolation(OA.InterpolationMode.AUTO));
    /**
     * The otu interpolation.
     * @name outInterpolation
     * @memberof OAKeyframe
     * @type {OAInterpolation}
     */
    this.outInterpolation =  OA._d(outInterpolation, new OAInterpolation());
    /**
     * Any other Data.<br>
     * This may be useful to store other information from any application.<br>
     * Be careful, for this data to be saved to OA files it needs to be serializable as a JSON string.<br>
     * You should only use <code>getMeta()</code> and <code>setMeta</code> to change these values.
     * @name meta
     * @memberof OAInterpolation
     * @type {object}
     */
    this.meta = {};
}

/**
 * Interpolates the value towards the other key
 * @param {float} time The time
 * @param {OAKeyframe} otherKey The other keyframe
 * @return {float} The interpolated value
 */
OAKeyframe.prototype.interpolate = function(time, otherKey) {
    var minTime = this.time;
    var maxTime = otherKey.time;
    var valueA = this.value;
    var valueB = otherKey.value;

    // Interpolation always go forward in time
    if (maxTime < minTime) return otherKey.interpolate(time, this);
    // Handle stupid values
    if (maxTime == minTime) return valueA;
    if (time >= maxTime) return valueB;
    if (time <= minTime) return valueA;

    var outI = this.outInterpolation;
    var inI = otherKey.inInterpolation;

    // Hold is easy
    if (outI.mode == OA.InterpolationMode.HOLD) return valueA;

    // Adjustments
    if (inI.mode != OA.InterpolationMode.AUTO || inI.mode != OA.InterpolationMode.LINEAR || inI.mode != OA.InterpolationMode.BEZIER) {
        inI.mode = OA.InterpolationMode.AUTO;
    }
    if (inI.mode == OA.InterpolationMode.AUTO) {
        inI.mode = outI.mode;
    }
    if (outI.mode == OA.InterpolationMode.LINEAR && inI.mode == OA.InterpolationMode.BEZIER) {
        outI.mode = OA.Interpolation.BEZIER;
        outI.x = 0;
        outI.y = 0;
    }
    if (outI.mode == OA.InterpolationMode.BEZIER && inI.mode == OA.InterpolationMode.LINEAR) {
        inI.mode = OA.Interpolation.BEZIER;
        inI.x = 0;
        inI.y = 0;
    }

    // Compute
    if (outI.mode == OA.InterpolationMode.LINEAR) {
        return OA.Interpolation.linear(time, minTime, maxTime, valueA, valueB, false);
    }

    if (outI.mode == OA.InterpolationMode.BEZIER) {
        // Get BÃ©zier control points
        outY = OA.Interpolation.linear(valueA+outI.y, valueA, valueB, 0, 1);
        inY = OA.Interpolation.linear(valueB-inI.y, valueA, valueB, 0, 1);
        return OA.Interpolation.bezier(time, minTime, maxTime, valueA, valueB, [
            outI.x, outY,
            1-inI.x, inY
        ]);
    }

    if (outI.mode == OA.InterpolationMode.EXPONENTIAL) {
        return OA.Interpolation.exponential(time, minTime, maxTime, valueA, valueB, outI.x);
    }

    if (outI.mode == OA.InterpolationMode.GAUSSIAN) {
        return OA.Interpolation.gaussian(time, minTime, maxTime, valueA, valueB, outI.x);
    }

    if (outI.mode == OA.InterpolationMode.LOGARITHMIC) {
        return OA.Interpolation.logarithmic(time, minTime, maxTime, valueA, valueB, outI.x);
    }

    if (outI.mode == OA.InterpolationMode.LOGISTIC) {
        return OA.Interpolation.logistic(time, minTime, maxTime, valueA, valueB, outI.x, outI.y);
    }

    return valueA; 
}

/**
 * Creates a js object containing this keyframe data.<br/>
 * This object could then be exported to JSON for example.
 * @return {Object} the JS Object
 */
OAKeyframe.prototype.toObject = function() {
    var data = {
        'time': this.time,
        'value': this.value,
        'inInterpolation': this.inInterpolation.toObject(),
        'outInterpolation': this.outInterpolation.toObject(),
        'meta': this.meta
    };

    return data;
}

/**
 * Gets some metadata
 * @param {string} key The key. It can be an URL-like string to get subkeys
 * @param {*} [defaultValue=null] A default value to be returned if the key is not found
 * @return {*} The value
 */
OAKeyframe.prototype.getMeta = function( key, defaultValue ) {
    return OA._g(this.meta, key, defaultValue);
}

/**
 * Sets some metadata
 * @param {string} key The key. It can be an URL-like string to get subkeys
 * @param {*} value The new value. The value must be serializable as a JSON string.
 */
OAKeyframe.prototype.setMeta = function( key, value ) {
    this.meta = OA._s(this.meta, key, value);
}

/**
 * Checks if the metadata exists
 * @param {string} key The key. It can be an URL-like string to get subkeys
 * @return {Boolean}
 */
OAKeyframe.prototype.hasMeta = function( key ) {
    return OA._h(this.meta, key);
}

// === OAProperty ===

/**
 * Creates an animated property. In OpenAnimation, all properties are single-dimension properties. Multi-dimensionnal properties are {@link OAGroup}.
 * @class
 * @classdesc An animated property.
 * @param {string} [name=""] A name for the property.
 * @param {OAKeyframe[]} [keys=[]] The keyframes.
 * @param {string} [id] A unique identifier, useful when saving the animation and load it later for example. If omitted, a new ID will be automatically generated.
 * @param {float} [value=0] The value to be used if there is no keyframe
 * @category OA
 */
function OAProperty(name, keys, id, value) {
    /**
     * The name of the property
     * @name name
     * @memberof OAProperty
     * @type {string}
     */
    this.name = OA._d(name, "");
    /**
     * A Unique identifier
     * @name id
     * @memberof OAProperty
     * @type {string}
     */
    this.id = OA._d(id, new Date().getTime());
    /**
     * The keyframes
     * @name keys
     * @memberof OAProperty
     * @type {OAKeyframe[]}
     */
    this.keys = OA._d(keys, []).sort(OA._keyframeSorter);
    /**
     * The duration of the animation. Times and durations are expressed in seconds.
     * @name duration
     * @memberof OAProperty
     * @type {float}
     */
    this.duration = 0;
    if (this.keys.length > 0) this.duration = this.keys[this.keys.length-1].time;
    /**
     * The value to be used if there is no keyframe
     * @name value
     * @memberof OAProperty
     * @type {float}
     */
    this.value = OA._d(value, 0);
    /**
     * Any other Data.<br>
     * This may be useful to store other information from any application.<br>
     * Be careful, for this data to be saved to OA files it needs to be serializable as a JSON string.<br>
     * You should only use <code>getMeta()</code> and <code>setMeta</code> to change these values.
     * @example
     * {
     *      "application": {
     *           "name": "After Effects",
     *           "version": "23.3"
     *       } 
     * }
     * @name meta
     * @memberof OAInterpolation
     * @type {object}
     */
    this.meta = {};
}

/**
 * Inserts a new keyframe in the animation. If a key with the same time exists it is replaced.
 * @param {OAKeyframe} newKey
 * @return {int} the index of the new key
 */
OAProperty.prototype.addKey = function( newKey ) {
    for (var k = 0; k < this.keys.length; k++) {
        var key = this.keys[k];
        if (key.time == newKey.time) {
            this.keys[k] = newKey;
            return k;
        }
        if (key.time > newKey.time) break;
    }
    this.keys.splice(k, 0, newKey);
    return k;
}

/**
 * Sets a linear keyframe per frame.
 * @param {float} [frameDuration=0.04] The duration of a single frame.
 * @param {string} [name] The name of the new OAProperty. If omitted, will be the same as the current property.
 * @param {string} [id] The id of the new OAProperty. If omitted, will be the same as the current property.
 * @return {OAProperty} The new OAProperty.
 */
OAProperty.prototype.bake = function(frameDuration, name, id) {
    frameDuration = OA._d(frameDuration, .04);
    id = OA._d(id, this.id);
    name = OA._d(name, this.name);
    
    var keys = [];
    for (var time = this.keys[0].time; time <= this.duration; time += frameDuration) {
        var key = new OAKeyframe(
            this.getValue(time),
            time,
            new OAInterpolation()
        );
        keys.push(key);
    }

    var result = new OAProperty(name, keys, id);
    sresult.clean();
    return result; 
}

/**
 * Creates a new OAProperty with less keyframes (but the animation may be a bit different, depending on the options) <br>
 * @param {float} [frameDuration=0.04] The duration of a single frame. Lower values increase the precision of the analysis of the motion.
 * @param {string} [name] The name of the new OAProperty. If omitted, will be the same as the current property.
 * @param {string} [id] The id of the new OAProperty. If omitted, will be the same as the current property.
 * @return {OAProperty} The new OAProperty.
 */
OAProperty.prototype.simplify = function(frameDuration, name, id) {
    frameDuration = OA._d(frameDuration, .04);
    id = OA._d(id, this.id);
    name = OA._d(name, this.name);

    // Get the values and times
    // The extremes
    var extremeKeys = [];
    var extremeValuesAround = [];
    var maxVelocity = 0;

    // The inflexions
    var inflexionKeys = [];
    var inflexionSpeeds = [];

    // First and last points if they're not extremes
    var startValue = null;
    var endValue = null;

    // Max amplitude of the values (to adjust precision later)
    var amplitude = 0;

    var startTime = this.keys[0].time;
    var endTime = this.keys[this.keys.length-1].time;

    for (var time = startTime; time <= endTime; time += frameDuration) {
        var currentValue = this.getValue(time);
        var nextValue = this.getValue(time + frameDuration);
        var prevValue = this.getValue(time - frameDuration);
        var currentVelocity = this.getVelocity(time);
        var nextVelocity = this.getVelocity(time + frameDuration);
        var prevVelocity = this.getVelocity(time - frameDuration);

        if (currentVelocity > maxVelocity) maxVelocity = currentVelocity;

        // Get values and times
        // Extremes
        if (OA.Math.isExtremePoint(prevValue, currentValue, nextValue, 2 )) {
            // Get amplitude
            for (var i = 0, n = extremeKeys.length; i < n; i++) {
                var length = OA.Math.length(currentValue, extremeKeys[i].value);
                if (length > amplitude) amplitude = length;
            }
            // Add to extremes
            var oaKey = new OAKeyframe(currentValue, time, new OAInterpolation(OA.InterpolationMode.BEZIER), new OAInterpolation(OA.InterpolationMode.BEZIER));
            extremeKeys.push(oaKey);
            extremeValuesAround.push([prevValue, nextValue]);
        }
        // Inflexions
        else if (OA.Math.isInflexionPoint(prevVelocity, currentVelocity, nextVelocity)) {
            var oaKey = new OAKeyframe(currentValue, time, new OAInterpolation(OA.InterpolationMode.BEZIER), new OAInterpolation(OA.InterpolationMode.BEZIER));
            inflexionKeys.push(oaKey);
            speed = currentVelocity;
            inflexionSpeeds.push(speed);
        }
        // Start value
        else if (time == startTime) startValue = currentValue;
        // End value
        else if (time >= endTime) {
            endValue = currentValue;
            break;
        }
    }

    // Adjust the precision for comparisons
    var comparisonPrecision = amplitude / 50;

    // Add extreme keyframes
    var result = new OAProperty(name, extremeKeys, id);
    result.clean();

    // Reset original interpolation if there are keyframes at the same time (+- a half frameDuration)
    for (var i = 0; i < result.keys.length; i++) {
        var newKey = result.keys[i];
        var time = newKey.time;
        for (var k = 0; k < this.keys.length; k++) {
            /*var originalkey = this.keys[i];
            if ( Math.abs(originalkey.time - time) > frameDuration/2 ) continue;

            // Check the current offsets
            var prevOffset = OA.Math.length( result.getValue(time-frameDuration), extremeValuesAround[i][0] );
            var nextOffset = OA.Math.length( result.getValue(time+frameDuration), extremeValuesAround[i][1] );

            // Reset original interpolation
            newKey.inInterpolation = originalkey.inInterpolation;
            newKey.outInterpolation = originalkey.outInterpolation;
            this.keys[i] = newKey;

            // Check if it's better!
            var newPrevOffset = OA.Math.length( result.getValue(time-frameDuration), extremeValuesAround[i][0] );
            var newNextOffset = OA.Math.length( result.getValue(time+frameDuration), extremeValuesAround[i][1] );

            // Nope, restore to default bezier
            if (newPrevOffset > prevOffset) {
                newKey.inInterpolation = new OAInterpolation(OA.InterpolationMode.BEZIER);
            }
            if (newNextOffset > nextOffset) {
                newKey.outInterpolation = new OAInterpolation(OA.InterpolationMode.BEZIER);
            }
            this.keys[i] = newKey;

            // Play with the Bezier tangents to improve
            // IN
            if (newKey.inInterpolation.mode == OA.InterpolationMode.BEZIER) {
                var currentTangent = newKey.inInterpolation.x;
                var prevOffset = OA.Math.length( result.getValue(time-frameDuration), extremeValuesAround[i][0] );
                var prevTestOffset = Number.POSITIVE_INFINITY;

                if (prevOffset > comparisonPrecision) {
                    var prevTangent = 0;
                    newKey.inInterpolation.x = 0;
                    while( newKey.inInterpolation.x <= 100 ) {
                        // Test
                        this.keys[i] = newKey;
                        var testPrevOffset = OA.Math.length( result.getValue(time-frameDuration), extremeValuesAround[i][0] );
                        // Restore previous if we've gone too far
                        if (testPrevOffset > prevTestOffset) {
                            newKey.inInterpolation.x = prevTangent;
                            break;
                        }
                        prevTestOffset = testPrevOffset;
                        prevTangent = newKey.inInterpolation.x;
                        newKey.inInterpolation.x += .1;
                    }

                    // Check the new offset
                    this.keys[i] = newKey;
                    var testPrevOffset = OA.Math.length( result.getValue(time-frameDuration), extremeValuesAround[i][0] );
                    // If it's not better, restore
                    if (testPrevOffset > prevOffset) {
                        newKey.inInterpolation.x = currentTangent;
                    }
                }

                this.keys[i] = newKey;
            }
            // OUT
            if (newKey.outInterpolation.mode == OA.InterpolationMode.BEZIER) {
                var currentTangent = newKey.outInterpolation.x;
                var nextOffset = OA.Math.length( result.getValue(time+frameDuration), extremeValuesAround[i][1] );
                var prevTestOffset = Number.POSITIVE_INFINITY;

                if (nextOffset > comparisonPrecision) {
                    var prevTangent = 0;
                    newKey.outInterpolation.x = 0;
                    while( newKey.outInterpolation.x <= 100 ) {
                        // Test
                        this.keys[i] = newKey;
                        var testNextOffset = OA.Math.length( result.getValue(time+frameDuration), extremeValuesAround[i][1] );
                        // Restore previous if we've gone too far
                        if (testNextOffset > prevTestOffset) {
                            newKey.outInterpolation.x = prevTangent;
                            break;
                        }
                        prevTestOffset = testNextOffset;
                        prevTangent = newKey.outInterpolation.x;
                        newKey.outInterpolation.x += .1;
                    }

                    // Check the new offset
                    this.keys[i] = newKey;
                    var testNextOffset = OA.Math.length( result.getValue(time+frameDuration), extremeValuesAround[i][1] );
                    // If it's not better, restore
                    if (testNextOffset > nextOffset) {
                        newKey.outInterpolation.x = currentTangent;
                    }
                }

                this.keys[i] = newKey;
            }*/
        }
    }

    // Set inflexion values
    /*for (var i = 0, n = inflexionKeys.length; i < n; i++) {
        var key = inflexionKeys[i];
        var time = key.time;
        var value = key.value;
        // Compare value to set the key frame
        var currentValue = result.getValue(time);
        // Already close to the current curve, no need to add a keyframe
        if (OA.Math.length(value, currentValue) <= comparisonPrecision) continue;
        // Set the new keyframe
        var keyIndex = this.addKey(key);
        // set speed
        if (keyIndex > 0) {
            var prevTime = this.keys[keyIndex-1].time;
            var duration = time-prevTime;
            key.inInterpolation.y = inflexionSpeeds[i] * key.inInterpolation.x * duration;
        }
        if (keyIndex < this.keys.length-1) {
            var nextTime = this.keys[keyIndex+1].time;
            var duration = nextTime-time;
            key.outInterpolation.y = inflexionSpeeds[i] * key.outInterpolation.x * duration;
        }
        this.keys[keyIndex] = key;
    }*/

    if (startValue !== null) {
        result.addKey(new OAKeyframe(
            startValue,
            startTime
        ));
    }
    if (endValue !== null) {
        result.addKey(new OAKeyframe(
            endValue,
            endTime
        ));
    }

    // Clean
    result.clean();
    return result;
}

/**
 * Removes all unneeded keyframes from the property.<br>
 * @param {int} [precision=1] - The precision for float number comparison, number of decimals. Set to -1 to not use.
 */
OAProperty.prototype.clean = function(precision) {
    precision = OA._d(precision, 1);

    // No keys, nothing to do
    if (this.keys.length == 0) return;
    // Single key, set value and remove key
    if (this.keys.length == 1) {
        this.value = this.keys[0].value;
        this.keys = [];
        return;
    }
    for (var k = this.keys.length -1; k >= 0; k--) {
        var key = this.keys[k];
        var cV = key.value;
        var pV = this.getValue(key.time - .05);
        if (!OA.Math.equals(cV, pV, precision)) continue;
        var nV = this.getValue(key.time + .05);
        if (!OA.Math.equals(cV, nV, precision)) continue;
        // Remove key
        this.keys.splice(k, 1);
    }
}

/**
 * Creates a js object containing this property data.<br/>
 * This object could then be exported to JSON for example.
 * @return {Object} the JS Object
 */
OAProperty.prototype.toObject = function() {
    var data = {
        'id': this.id,
        'name': this.name,
        'keys': [],
        'duration': this.duration,
        'type': 'property',
        'meta': this.meta
    };

    for(var i = 0; i < this.keys.length; i++ ) {
        data['keys'].push( this.keys[i].toObject() );
    }

    return data;
}

/**
 * Creates a JSON string representing this property
 * @return {string} the JSON document
 */
OAProperty.prototype.toJson = function( ) {
    var data  = this.toObject();
    return JSON.stringify(data, null, 4);
}

/**
 * Exports the current property to an oa file
 * @param {File|string} file The file.
 * @return {File} the file.
 */
OAProperty.prototype.toFile = function ( file ) {
    if (!(file instanceof File)) file = new File(file);
    file.encoding = 'UTF-8';
    var data = this.toJson( );

    if (!file.open('w')) return file;
    file.write(data);
    file.close();

    return file;
}

/**
 * Gets the value at a given time
 * @param {float} time The time
 * @return {float} The value
 */
OAProperty.prototype.getValue = function(time) {
    // No keyframes
    if (this.keys.length == 0) return this.value;
    // Single keyframe
    if (this.keys.length == 1) return this.keys[0].value;
    
    // Extrapolation
    // After duration or last frame
    if (time > this.duration || time >= this.keys[this.keys.length-1].time) return this.keys[this.keys.length-1].value;
    // Before first frame
    if (time <= this.keys[0].time) return this.keys[0].value;
    
    // Interpolation
    for (var k = this.keys.length-1; k >= 0; k--) {
        var key = this.keys[k];
        if (time == key.time) return key.value;
        if (time < key.time) continue;

        return key.interpolate(time,  this.keys[k+1]);
    }

    // For safety - We should not arrive here!
    return this.value;
}

/**
 * Gets the velocity at a given time
 * @param {float} time The time
 * @return {float} The velocity
 */
OAProperty.prototype.getVelocity = function(time) {
    var v1 = this.getValue(time-.005);
    var v2 = this.getValue(time+.005);
    return (v2-v1)*100;
}

/**
 * Gets some metadata
 * @param {string} key The key. It can be an URL-like string to get subkeys
 * @param {*} [defaultValue=null] A default value to be returned if the key is not found
 * @return {*} The value
 */
OAProperty.prototype.getMeta = function( key, defaultValue ) {
    return OA._g(this.meta, key, defaultValue);
}

/**
 * Sets some metadata
 * @param {string} key The key. It can be an URL-like string to get subkeys
 * @param {*} value The new value. The value must be serializable as a JSON string.
 */
OAProperty.prototype.setMeta = function( key, value ) {
    this.meta = OA._s(this.meta, key, value);
}

/**
 * Checks if the metadata exists
 * @param {string} key The key. It can be an URL-like string to get subkeys
 * @return {Boolean}
 */
OAProperty.prototype.hasMeta = function( key ) {
    return OA._h(this.meta, key);
}

// === OAGroup ===

/**
 * Creates a group of properties.
 * @class
 * @classdesc A group of properties.
 * @param {string} [name=""] A name for the property.
 * @param {string} [id] A unique identifier, useful when saving the animation and load it later for example. If omitted, a new ID will be automatically generated.
 * @category OA
 */
function OAGroup(name, id) {
    /**
     * The name of the property
     * @name name
     * @memberof OAProperty
     * @type {string}
     */
    this.name = OA._d(name, "");
    /**
     * The child properties.
     * @name properties
     * @memberof OAGroup
     * @type {OAProperty[]}
     */
    this.properties = [];
    /**
     * A Unique identifier
     * @name id
     * @memberof OAProperty
     * @type {string}
     */
    this.id = OA._d(id, new Date().getTime());
    /**
     * Any other Data.<br>
     * This may be useful to store other information from any application.<br>
     * Be careful, for this data to be saved to OA files it needs to be serializable as a JSON string.<br>
     * You should only use <code>getMeta()</code> and <code>setMeta</code> to change these values.
     * @example
     * {
     *      "application": {
     *           "name": "After Effects",
     *           "version": "23.3"
     *       } 
     * }
     * @name meta
     * @memberof OAInterpolation
     * @type {object}
     */
    this.meta = {};
}

/**
 * Creates a js object containing this group data.<br/>
 * This object could then be exported to JSON for example.
 * @return {Object} the JS Object
 */
OAGroup.prototype.toObject = function() {
    var data = {
        'properties': [],
        'id': this.id,
        'name': this.name,
        'type': 'group',
        'meta': this.meta
    };

    for(var i = 0; i < this.properties.length; i++ ) {
        data['properties'].push( this.properties[i].toObject() );
    }

    return data;
}

/**
 * Creates a JSON string representing this group
 * @return {string} the JSON document
 */
OAGroup.prototype.toJson = function( ) {
    var data  = this.toObject();
    return JSON.stringify(data, null, 4);
}

/**
 * Exports the current group to an oa file
 * @param {File|string} file The file.
 * @return {File} the file.
 */
OAGroup.prototype.toFile = function ( file ) {
    if (!(file instanceof File)) file = new File(file);
    file.encoding = 'UTF-8';
    var data = this.toJson( );

    if (!file.open('w')) return file;
    file.write(data);
    file.close();

    return file;
}

/**
 * Gets some metadata
 * @param {string} key The key. It can be an URL-like string to get subkeys
 * @param {*} [defaultValue=null] A default value to be returned if the key is not found
 * @return {*} The value
 */
OAGroup.prototype.getMeta = function( key, defaultValue ) {
    return OA._g(this.meta, key, defaultValue);
}

/**
 * Sets some metadata
 * @param {string} key The key. It can be an URL-like string to get subkeys
 * @param {*} value The new value. The value must be serializable as a JSON string.
 */
OAGroup.prototype.setMeta = function( key, value ) {
    this.meta = OA._s(this.meta, key, value);
}

/**
 * Checks if the metadata exists
 * @param {string} key The key. It can be an URL-like string to get subkeys
 * @return {Boolean}
 */
OAGroup.prototype.hasMeta = function( key ) {
    return OA._h(this.meta, key);
}
