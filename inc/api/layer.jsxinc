/**
 * Layers related tools.
 * @namespace
 * @category Duik
 */
Duik.Layer = {};

/**
 * The types of layers used by Duik
 * @enum {string}
 */
Duik.Layer.Type = {
    NONE: DuAELayer.Type.NONE,
    BONE: 'Bone',
    PIN: 'Pin',
    CONTROLLER: 'Ctrl',
    CONTROLLER_BG: 'CBg',
    ZERO: 'Zero',
    IK: 'IK',
    NULL: DuAELayer.Type.NULL,
    LOCATOR: 'Loc',
    EFFECTOR: 'Fctr',
    AUDIO: 'Aud',
    MOTION_TRAIL: 'Trail',
    CEL: 'Cel',
    X_SHEET: 'X-Sheet',
    ART: 'Art',
    SOLID: DuAELayer.Type.SOLID,
    ADJUSTMENT: DuAELayer.Type.ADJUSTMENT
}

/**
 * Checks if a string is one of the prefixes used to identify layer types in their names
 * @param {string} prefix The string to check
 * @return {bool} True if the string is one of the predefined prefixes.
 */
Duik.Layer.isTypePrefix = function( prefix ) {
    for (i in Duik.Layer.Type) {
        if (prefix == Duik.Layer.Type[i]) return true;
    }
    return false;
}

/**
 * Checks if the layer is one of the types created by duik.
 * @param {Layer} layer - The layer to check
 * @param {Duik.Layer.Type} layerType - The type of layer
 * @return {Boolean}
 */
Duik.Layer.isType = function(layer, layerType) {
    return DuAELayer.isType(layer, layerType);
}

/**
 * Gets the type of the layer
 * @param {Layer} [layer] The layer. If omitted, will check the first selected bone of the current comp
 * @returns {Duik.Layer.Type} The type
 */
Duik.Layer.type = function(layer) {
    return DuAELayer.type(layer);
}

/**
 * Sets the type of the layer
 * @param {Duik.Layer.Type} type The type
 * @param {Layer[]|LayerCollection|DuList.<Layer>|Layer} [layers=DuAEComp.getSelectedLayers()] The layer. If omitted, will use all selected layers in the comp
 */
Duik.Layer.setType = function(type, layers) {
    layers = def(layers, DuAEComp.getSelectedLayers());
    layers = new DuList(layers);
    if (layers.length() == 0) return;

    DuAELayer.setType(type, layers);

    for (var i = 0, n = layers.length(); i < n; i++) {
        var layer = layers.at(i);
        var name = Duik.Layer.sanitizeName(layer);

        Duik.Layer.rename(layer, name, type);

        // Remove groups
        DuAETag.removeGroup(layer, i18n._("Controller"));
        DuAETag.removeGroup(layer, i18n._("Bone"));
        DuAETag.removeGroup(layer, i18n._("Pin"));
        DuAETag.removeGroup(layer, i18n._("Zero"));
        DuAETag.removeGroup(layer, i18n._("Locator"));
        DuAETag.removeGroup(layer, i18n._("Effector"));
        DuAETag.removeGroup(layer, i18n._("Audio spectrum"));
        DuAETag.removeGroup(layer, i18n._("Motion trail"));
        DuAETag.removeGroup(layer, i18n._("Celluloid"));
        DuAETag.removeGroup(layer, i18n._("X-Sheet"));

        if (type == Duik.Layer.Type.BONE) {
            DuAETag.addGroup(layer, i18n._("Bone"));
            layer.label = 7;
            layer.guideLayer = true;
            layer.quality = LayerQuality.DRAFT;
        } else if (type == Duik.Layer.Type.PIN) {
            layer.guideLayer = true;
            DuAETag.addGroup(layer, i18n._("Pin"));
        } else if (type == Duik.Layer.Type.CONTROLLER) {
            DuAETag.addGroup(layer, i18n._("Controller"));
            layer.guideLayer = true;
            layer.label = 9;
            if (Duik.Controller.draft) ctrl.quality = LayerQuality.DRAFT;
        } else if (type == Duik.Layer.Type.CONTROLLER_BG) {
            DuAETag.addGroup(layer, i18n._("Controller"));
            layer.guideLayer = true;
            if (Duik.Controller.draft) ctrl.quality = LayerQuality.DRAFT;
        } else if (type == Duik.Layer.Type.ZERO) {
            DuAETag.addGroup(layer, i18n._("Zero"));
            layer.guideLayer = true;
        } else if (type == Duik.Layer.Type.IK) {
            layer.guideLayer = true;
        } else if (type == Duik.Layer.Type.LOCATOR) {
            layer.guideLayer = true;
            DuAETag.addGroup(layer, i18n._("Locator"));
        } else if (type == Duik.Layer.Type.EFFECTOR) {
            DuAETag.addGroup(layer, i18n._("Effector"));
            layer.guideLayer = true;
            layer.label = 9;
        } else if (type == Duik.Layer.Type.AUDIO) {
            DuAETag.addGroup(layer, i18n._("Audio spectrum"));
            layer.guideLayer = true;
            layer.label = 9;
        } else if (type == Duik.Layer.Type.MOTION_TRAIL) {
            DuAETag.addGroup(layer, i18n._("Motion trail"));
        } else if (type == Duik.Layer.Type.CEL) {
            DuAETag.addGroup(layer, i18n._("Celluloid"));
        } else if (type == Duik.Layer.Type.X_SHEET) {
            DuAETag.addGroup(layer, i18n._("X-Sheet"));
        }
    }
}

/**
 * Gets all layers of the specified type
 * @param {Duik.Layer.Type} type The type
 * @param {Boolean} [selectedOnly=true] Whether to get only the selected layers or all of them
 * @param {CompItem} [comp=DuAEProject.getActiveComp()] The comp
 * @param {bool} [notSelectedOnly=false] Get only the not selected layers
 * @returns {Layer[]} The layers of the specified type.
 */
Duik.Layer.get = function(type, selectedOnly, comp, notSelectedOnly) {
    comp = def(comp, DuAEProject.getActiveComp());
    selectedOnly = def(selectedOnly, true);
    notSelectedOnly = def(notSelectedOnly, false);
    if (!comp) return [];

    var layers = [];
    if (selectedOnly) layers = comp.selectedLayers;
    else layers = comp.layers;

    if (layers.length == 0) return [];

    layers = new DuList(layers);
    var bones = [];
    layers.do(function(layer) {
        if (layer.selected && notSelectedOnly) return;
        
        if (Duik.Layer.isType(layer, type)) bones.push(layer);
        else if (type == Duik.Layer.Type.CONTROLLER && Duik.Layer.isType(layer, Duik.Layer.Type.CONTROLLER_BG)) bones.push(layer);
    });
    return bones;
}

/**
 * Selects all the layers of the given type (and deselects others)
 * @param {Duik.Layer.Type} type The type
 * @param {CompItem} [comp=DuAEProject.getActiveComp()] The comp
 */
Duik.Layer.select = function(type, comp) {
    comp = def(comp, DuAEProject.getActiveComp());
    if (!comp) return;

    for (var i = 1, n = comp.numLayers; i <= n; i++) {
        var layer = comp.layer(i);
        if (layer.locked) continue;
        layer.selected = Duik.Layer.isType(layer, type);
    }
}

/**
 * Show/hides all the layers of the given type
 * @param {Duik.Layer.Type} type The type
 * @param {CompItem} [comp=DuAEProject.getActiveComp()] The comp
 * @param {bool} [notSelectedOnly=false] Hides only the layers which are not selected
 */
Duik.Layer.toggleVisibility = function(type, comp, notSelectedOnly) {
    notSelectedOnly = def(notSelectedOnly, false);
    var layers = Duik.Layer.get(type, false, comp, notSelectedOnly);
    if (layers.length == 0) return;
    var enabled = !layers[0].enabled;
    for (var i = 0, n = layers.length; i < n; i++) {
        layers[i].enabled = enabled;
    }
}

// Low-level undocumented
// Returns the part to use in a layer name with side and location 
Duik.Layer.sideName = function(side, location) {
    var n = '';

    if (location == OCO.Location.NONE && side == OCO.Side.NONE) return n;

    if (location != OCO.Location.NONE) {
        if (location == OCO.Location.FRONT)
            n += i18n._p("layer name", "Fr"); /// TRANSLATORS: Short for Front, must be short enough to be used as a tag in layer names
        else if (location == OCO.Location.BACK)
            n += i18n._p("layer name", "Bk"); /// TRANSLATORS: Short for Back, must be short enough to be used as a tag in layer names
        else if (location == OCO.Location.TAIL)
            n += i18n._p("layer name", "Tl"); /// TRANSLATORS: Short for Tail, must be short enough to be used as a tag in layer names
        else if (location == OCO.Location.MIDDLE)
            n += i18n._p("layer name", "Md"); /// TRANSLATORS: Short for Middle, must be short enough to be used as a tag in layer names
        else if (location == OCO.Location.ABOVE)
            n += i18n._p("layer name", "Ab"); /// TRANSLATORS: Short for Above, must be short enough to be used as a tag in layer names
        else if (location == OCO.Location.UNDER)
            n += i18n._p("layer name", "Un"); /// TRANSLATORS: Short for Under, must be short enough to be used as a tag in layer names

        if (side != OCO.Side.NONE) n += '.';
    }

    if (side != OCO.Side.NONE) {
        if (side == OCO.Side.LEFT)
            n += i18n._p("layer name", "L"); /// TRANSLATORS: Short for Left, must be short enough to be used as a tag in layer names
        else if (side == OCO.Side.RIGHT)
            n += i18n._p("layer name", "R"); /// TRANSLATORS: Short for Right, must be short enough to be used as a tag in layer names
    }

    return n;
}

/**
 * Checks the side of the layer
 * @param {Layer} [layer] The layer. If omitted, will check the first selected bone of the current comp
 * @returns {OCO.Side}
 */
Duik.Layer.side = function(layer) {
    layer = def(layer, DuAEComp.getActiveLayer());
    if (!layer) return OCO.Side.NONE;

    if (DuGR.inGroups(layer, [ i18n._("Left")])) return OCO.Side.LEFT;
    if (DuGR.inGroups(layer, [ i18n._("Right")])) return OCO.Side.RIGHT;
    return OCO.Side.NONE;
}

/**
 * Sets the side of the layer
 * @param {OCO.Side} side The side
 * @param {Layer[]|LayerCollection|DuList.<Layer>|Layer} [layers=DuAEComp.getSelectedLayers()] The layer. If omitted, will use all selected layers in the comp
 */
Duik.Layer.setSide = function(side, layers) {
    layers = def(layers, DuAEComp.getSelectedLayers());
    layers = new DuList(layers);
    if (layers.length() == 0) return;

    for (var i = 0, n = layers.length(); i < n; i++) {
        var layer = layers.at(i);
        Duik.Layer.sanitizeName(layer);

        var currentSide = Duik.Layer.side(layer);
        if (currentSide == side) continue;
        var currentLocation = Duik.Layer.location(layer);

        if (currentSide == OCO.Side.LEFT) DuAETag.removeGroup(layer, i18n._("Left"));
        else if (currentSide == OCO.Side.RIGHT) DuAETag.removeGroup(layer, i18n._("Right"));

        // Add new
        if (side == OCO.Side.RIGHT) DuAETag.addGroup(layer, i18n._("Right"));
        else if (side == OCO.Side.LEFT) DuAETag.addGroup(layer, i18n._("Left"));

        // Update name
        var currentSideName = Duik.Layer.sideName(currentSide, currentLocation);
        var newSideName = Duik.Layer.sideName(side, currentLocation);
        var name = layer.name.split(' | ');
        if (name.length >= 4) name[3] = name[3].replace(currentSideName, newSideName);
        else if (name.length == 3) name.push(newSideName);
        // Remove the third block if it's empty
        if (DuString.trimNumbers(name[3]) == "") name.splice(3,1);
        // Rename
        Duik.Layer.rename(layer, name.join(' | '));//*/
    }
}

/**
 * Checks the location of the layer
 * @param {Layer} [layer=DuAEComp.getActiveLayer] The layer. If omitted, will check the first selected bone of the current comp
 * @returns {OCO.Location}
 */
Duik.Layer.location = function(layer) {
    layer = def(layer, DuAEComp.getActiveLayer());
    if (!layer) return OCO.Location.NONE;

    if (DuGR.inGroups(layer, [ i18n._("Front")])) return OCO.Location.FRONT;
    if (DuGR.inGroups(layer, [ i18n._("Back")])) return OCO.Location.BACK;
    if (DuGR.inGroups(layer, [ i18n._("Middle")])) return OCO.Location.MIDDLE;
    if (DuGR.inGroups(layer, [ i18n._("Under")])) return OCO.Location.UNDER;
    if (DuGR.inGroups(layer, [ i18n._("Above")])) return OCO.Location.ABOVE;
    if (DuGR.inGroups(layer, [ i18n._("Tail")])) return OCO.Location.TAIL;
    return OCO.Side.NONE;
}

/**
 * Sets the location of the layer
 * @param {OCO.Side} side The side
 * @param {Layer[]|LayerCollection|DuList.<Layer>|Layer} [layers=DuAEComp.getSelectedLayers()] The layer. If omitted, will use all selected layers in the comp
 */
Duik.Layer.setLocation = function(location, layers) {
    layers = def(layers, DuAEComp.getSelectedLayers());
    layers = new DuList(layers);
    if (layers.length() == 0) return;

    for (var i = 0, n = layers.length(); i < n; i++) {
        var layer = layers.at(i);
        Duik.Layer.sanitizeName(layer);

        var currentLocation = Duik.Layer.location(layer);
        if (currentLocation == location) continue;

        var currentSide = Duik.Layer.side(layer);

        if (currentLocation == OCO.Location.FRONT) DuAETag.removeGroup(layer, i18n._("Front"));
        else if (currentLocation == OCO.Location.BACK) DuAETag.removeGroup(layer, i18n._("Back"));
        else if (currentLocation == OCO.Location.TAIL) DuAETag.removeGroup(layer, i18n._("Tail"));
        else if (currentLocation == OCO.Location.MIDDLE) DuAETag.removeGroup(layer, i18n._("Middle"));
        else if (currentLocation == OCO.Location.ABOVE) DuAETag.removeGroup(layer, i18n._("Above"));
        else if (currentLocation == OCO.Location.UNDER) DuAETag.removeGroup(layer, i18n._("Under"));
        
        // Add new
        if (location == OCO.Location.FRONT)
            DuAETag.addGroup(layer, i18n._("Front"));
        else if (location == OCO.Location.BACK)
            DuAETag.addGroup(layer, i18n._("Back"));
        else if (location == OCO.Location.TAIL)
            DuAETag.addGroup(layer, i18n._("Tail"));
        else if (location == OCO.Location.MIDDLE)
            DuAETag.addGroup(layer, i18n._("Middle"));
        else if (location == OCO.Location.ABOVE)
            DuAETag.addGroup(layer, i18n._("Above"));
        else if (location == OCO.Location.UNDER)
            DuAETag.addGroup(layer, i18n._("Under"));

        // Update name
        var currentSideName = Duik.Layer.sideName(currentSide, currentLocation);
        var newSideName = Duik.Layer.sideName(currentSide, location);
        var name = layer.name.split(' | ');
        if (name.length >= 4) name[3] = name[3].replace(currentSideName, newSideName);
        else if (name.length == 3) name.push(newSideName);
        // Remove the third block if it's empty
        if (DuString.trimNumbers(name[3]) == "") name.splice(3,1);
        Duik.Layer.rename(layer, name.join(' | '));//*/
    }
}

/**
 * Checks the character name this layer belongs to
 * @param {Layer} [layer=DuAEComp.getActiveLayer] The layer. If omitted, will check the first selected bone of the current comp
 * @returns {strng}
 */
Duik.Layer.characterName = function(layer) {
    layer = def(layer, DuAEComp.getActiveLayer());
    if (!layer) return '';

    // Split
    var name = layer.name.split(' | ');
    if (name.length <= 1) return '';
    if (name[1] == '-') return '';

    // Must be in the corresponding group
    if (!DuGR.inGroups(layer, [name[1]])) return '';
    return name[1];
}

/**
 * Sets the character name of the bone layer
 * @param {string} characterName The character name.
 * @param {Layer[]|LayerCollection|DuList.<Layer>|Layer} [layers=DuAEComp.getSelectedLayers()] The layer. If omitted, will use all selected layers in the comp
 */
Duik.Layer.setCharacterName = function(characterName, layers) {
    layers = def(layers, DuAEComp.getSelectedLayers());
    layers = new DuList(layers);
    if (layers.length() == 0) return;

    for (var i = 0, n = layers.length(); i < n; i++) {
        var layer = layers.at(i);
        var name = Duik.Layer.sanitizeName(layer);

        // Split
        var name = name.split(' | ');
        if (name.length <= 1) continue;
        DuAETag.removeGroup(layer, name[1]);
        name[1] = characterName;
        Duik.Layer.rename(layer, name.join(' | '));
        if (characterName != '-' && characterName != '') DuAETag.addGroup(layer, characterName);
    }
}

/**
 * Checks the limb name this layer belongs to
 * @param {Layer} [layer=DuAEComp.getActiveLayer] The layer. If omitted, will check the first selected bone of the current comp
 * @returns {DuColor}
 */
Duik.Layer.limbName = function(layer) {
    layer = def(layer, DuAEComp.getActiveLayer());
    if (!layer) return '';

    // Split
    var name = layer.name.split(' | ');
    if (name.length <= 2) return '';

    return name[2];
}

/**
 * Sets the limb name of the bone layer
 * @param {string} limbName The limb name.
 * @param {Layer[]|LayerCollection|DuList.<Layer>|Layer} [layers=DuAEComp.getSelectedLayers()] The layer. If omitted, will use all selected layers in the comp
 */
Duik.Layer.setLimbName = function(limbName, layers) {
    layers = def(layers, DuAEComp.getSelectedLayers());
    layers = new DuList(layers);
    if (layers.length() == 0) return;

    for (var i = 0, n = layers.length(); i < n; i++) {
        var layer = layers.at(i);
        var name = Duik.Layer.sanitizeName(layer);

        // Split
        var name = name.split(' | ');
        if (name.length <= 2) continue;
        name[2] = limbName;
        Duik.Layer.rename(layer, name.join(' | '));
    }
}

/**
 * Renames a layer.
 * @param {Layer} layer The layer to rename
 * @param {string} name The new name
 * @param {string} [newPrefix] If provided, will replace the prefix in the new name (or add it if there's no prefix yet)
 * @returns {string} The actual new name (a number may be added).
 */
Duik.Layer.rename = function(layer, name, newPrefix) {
    newPrefix = def(newPrefix, '');
    var newName = name;
    if (newPrefix != '') {
        var newName = newName.split(' | ');
        if (newName.length == 1) newName = newPrefix + ' | ' + newName[0];
        else {
            // the first one is a prefix
            if (Duik.Layer.isTypePrefix(newName[0])) newName[0] = newPrefix;
            // enough parameters, the first one should be a prefix
            else if (newName.length >= 4) newName[0] = newPrefix;
            // insert the new prefix
            else newName.unshift(newPrefix);
            // Keep side
            newName = newName.join(' | ');
        }
    }

    // Temporarily rename the layer just in case it already has the same name
    var oldName = layer.name;
    layer.name = '** Duik Temp Name **';
    layer.name = DuAEComp.newUniqueLayerName(newName, layer.containingComp);
    newName = layer.name;

    app.project.autoFixExpressions(oldName, newName);

    return newName;
}

/**
 * Copies the attributes from a layer to another layer.
 * @param {Layer|Layer[]|LayerCollection|DuList.<Layer>} to The layer to set up
 * @param {Layer} from The source layer
 * @param {Duik.Layer.Type} type The type of the layer to set up
 */
Duik.Layer.copyAttributes = function(to, from, type) {
    to = new DuList(to);
    var side = Duik.Layer.side(from);
    var location = Duik.Layer.location(from);
    var characterName = Duik.Layer.characterName(from);
    var limbName = Duik.Layer.limbName(from);
    type = def(type, Duik.Layer.Type.NONE);

    for (var i = 0, n = to.length(); i < n; i++) {
        var layer = to.at(i);
        Duik.Layer.setAttributes(layer, type, limbName, side, location, characterName);
        Duik.Layer.rename(layer, from.name, type);
    }
}

/**
 * Sets all the attributes of the layer at once; use this method to prepare a layer which doesn't have a proper Duik name yet.
 * @param {Layer|Layer[]|LayerCollection|DuList.<Layer>} layer The layer to set up
 * @param {Duik.Layer.Type} type The type
 * @param {string} [limbName] The name of the limb/layer
 * @param {OCO.Side} [side=OCO.Side.NONE] The side
 * @param {OCO.Location} [location=OCO.Location.NONE] The location
 * @param {string} [characterName="-"] The name of the character
 */
Duik.Layer.setAttributes = function(layer, type, limbName, side, location, characterName) {
    layer = new DuList(layer);
    side = def(side, OCO.Side.NONE);
    location = def(location, OCO.Location.NONE);
    characterName = def(characterName, '');
    for (var i = 0, n = layer.length(); i < n; i++) {
        var l = layer.at(i);
        var lmb = limbName;
        if (lmb == '') lmb = Duik.Layer.limbName(l);
        if (lmb == '') lmb = l.name;
        // Dummy name first
        l.name = '- | - | -';
        Duik.Layer.setType(type, l);
        Duik.Layer.setSide(side, l);
        Duik.Layer.setLocation(location, l);
        Duik.Layer.setCharacterName(characterName, l);
        Duik.Layer.setLimbName(lmb, l);
    }
}

/**
 * Sets default name to a layer so it can be correctly managed by Duik, and checks the groups/tags.
 * @param {Layer} [layer=DuAEComp.getActiveLayer] The layer. If omitted, will check the first selected layer of the current comp
 * @returns {string} The new name of the layer
 */
Duik.Layer.sanitizeName = function(layer) {
    layer = def(layer, DuAEComp.getActiveLayer());
    if (!layer) return '';

    var oldName = layer.name;

    var name = layer.name.split(' | ');
    // That's OK, but let's check the groups too
    if (name.length >= 3) {
        // Character / Group
        if (name[1] != '-' && name[1] != '') DuAETag.addGroup(layer, name[1]);
        // Adjust count
        // Consider the last one is the side
        while (name.length >= 5) {
            name[2] = name[2] + '_' + name[3];
            name.splice(3, 1);
        }
        layer.name = name.join(' | ');
        // Side
        if (name.length == 4) {
            var n = DuString.trimNumbers(name[3]);
            // Side group
            if (DuString.endsWith(n, i18n._p("layer name", "L"))) /// TRANSLATORS: Short for Left, must be short enough to be used as a tag in layer names
                DuAETag.addGroup(layer, i18n._("Left"));
            else if (DuString.endsWith(n, i18n._p("layer name", "R"))) /// TRANSLATORS: Short for Right, must be short enough to be used as a tag in layer names
                DuAETag.addGroup(layer, i18n._("Right"));
            // Location group
            if (DuString.startsWith(n, i18n._p("layer name", "Fr"))) /// TRANSLATORS: Short for Front, must be short enough to be used as a tag in layer names
                DuAETag.addGroup(layer, i18n._("Front"));
            else if (DuString.startsWith(n, i18n._p("layer name", "Bk"))) /// TRANSLATORS: Short for Back, must be short enough to be used as a tag in layer names
                DuAETag.addGroup(layer, i18n._("Back"));
            else if (DuString.startsWith(n, i18n._p("layer name", "Tl"))) /// TRANSLATORS: Short for Tail, must be short enough to be used as a tag in layer names
                DuAETag.addGroup(layer, i18n._("Tail"));
            else if (DuString.startsWith(n, i18n._p("layer name", "Md"))) /// TRANSLATORS: Short for Middle, must be short enough to be used as a tag in layer names
                DuAETag.addGroup(layer, i18n._("Middle"));
            else if (DuString.startsWith(n, i18n._p("layer name", "Ab"))) /// TRANSLATORS: Short for Above, must be short enough to be used as a tag in layer names
                DuAETag.addGroup(layer, i18n._("Above"));
            else if (DuString.startsWith(n, i18n._p("layer name", "Un"))) /// TRANSLATORS: Short for Under, must be short enough to be used as a tag in layer names
                DuAETag.addGroup(layer, i18n._("Under"));
        }
        // Everything should be good to go
        return layer.name;
    }

    // Let's rename that
    // Type prefix
    var type = Duik.Layer.type(layer);
    // (Try to) Find a limb & character name
    var limbName = '';
    var characterName = '-';
    if (name.length == 1) {
        limbName = DuString.trimNumbers(name[0]);
    } else {
        limbName = DuString.trimNumbers(name[1]);
        if (name[0].length > 3) characterName = DuString.trimNumbers(name[0]);
    }

    // Check if there are location/side info in limbname
    var limbArr = DuString.split(limbName, ["_","-", ".", " "]);
    var side = "";
    var loc = "";
    var foundSide = false;
    var foundLoc = false;
    for (var i = limbArr.length-1; i >= 0; i--) {
        var test = limbArr[i];
        if (!foundSide) {
            if (test == i18n._p("layer name", "L")) {
                side = test;
                foundSide = true;
                DuAETag.addGroup(layer, i18n._("Left"));
                limbArr.splice(i, 1);
                continue;
            }
            if (test == i18n._p("layer name", "R")) {
                side = test;
                foundSide = true;
                DuAETag.addGroup(layer, i18n._("Right"));
                limbArr.splice(i, 1);
                continue;
            }
        }
        if (!foundLoc) {
            if (test == i18n._p("layer name", "Fr")) {
                side = test;
                foundLoc = true;
                DuAETag.addGroup(layer, i18n._("Front"));
                limbArr.splice(i, 1);
                continue;
            }
            if (test == i18n._p("layer name", "Bk")) {
                side = test;
                foundLoc = true;
                DuAETag.addGroup(layer, i18n._("Back"));
                limbArr.splice(i, 1);
                continue;
            }
            if (test == i18n._p("layer name", "Tl")) {
                side = test;
                foundLoc = true;
                DuAETag.addGroup(layer, i18n._("Tail"));
                limbArr.splice(i, 1);
                continue;
            }
            if (test == i18n._p("layer name", "Md")) {
                side = test;
                foundLoc = true;
                DuAETag.addGroup(layer, i18n._("Middle"));
                limbArr.splice(i, 1);
                continue;
            }
            if (test == i18n._p("layer name", "Ab")) {
                side = test;
                foundLoc = true;
                DuAETag.addGroup(layer, i18n._("Above"));
                limbArr.splice(i, 1);
                continue;
            }
            if (test == i18n._p("layer name", "Un")) {
                side = test;
                foundLoc = true;
                DuAETag.addGroup(layer, i18n._("Under"));
                limbArr.splice(i, 1);
                continue;
            }
        }
        if (foundSide && foundLoc) break;
    }

    if (foundSide || foundLoc) limbName = limbArr.join(" ");

    // New name
    var newName = type + ' | ' + characterName + ' | ' + limbName;
    if (foundLoc && foundSide) newName += ' | ' + loc + "." + side;
    else if (foundLoc) newName += ' | ' + loc;
    else if (foundSide) newName += ' | ' + side;
    layer.name = newName;

    app.project.autoFixExpressions(oldName, layer.name);

    return layer.name;
}

/**
 * Toggles the edit mode on selected layers
 * @param {Layer[]|LayerCollection|DuList.<Layer>|Layer} [layers=DuAEComp.getSelectedLayers()] The layer. If omitted, will use all selected layers in the comp
 */
Duik.Layer.unlink = function(layers) {
    layers = def(layers, DuAEComp.getSelectedLayers());
    layers = new DuList(layers);
    if (layers.length() == 0) return;

    DuAE.beginUndoGroup( i18n._("Toggle edit mode"));
    DuAEProject.setProgressMode(true);

    for (var i = 0, n = layers.length(); i < n; i++) {
        DuAELayer.toggleEditMode(layers.at(i));
    }

    DuAEProject.setProgressMode(false);
    DuAE.endUndoGroup();
}