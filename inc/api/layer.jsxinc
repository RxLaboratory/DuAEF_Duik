/**
 * Layers related tools.
 * @namespace
 * @category Duik
 */
Duik.Layer = {};

// Low-level
Duik.Layer.sanitizing = false;

/**
 * The types of layers used by Duik
 * @enum {string}
 */
Duik.Layer.Type = {
    NONE: DuAELayer.Type.NONE,
    BONE: '☍',
    PIN: '⚲',
    CONTROLLER: '✋',
    CONTROLLER_BG: '✋Bg',
    ZERO: '⛒',
    IK: 'IK',
    NULL: DuAELayer.Type.NULL,
    LOCATOR: '✜',
    EFFECTOR: '☉',
    AUDIO: 'Aud',
    MOTION_TRAIL: 'Trail',
    CEL: 'Cel',
    X_SHEET: 'X-Sheet',
    ART: 'Art',
    SOLID: DuAELayer.Type.SOLID,
    ADJUSTMENT: DuAELayer.Type.ADJUSTMENT
}

/**
 * The regular expressions used to validate names
 * @enum {RegExp}
 */
Duik.Layer.NameRegExp = {
    DUIK_NAME: /^([^≪≫|\[\]]+)?(?:\s*[≪|])?\s*([^≪≫|\[\]]+)?(?:\s*[|]\s*)?([^≪≫|\[\]]+)\s*(?:\s*[≫])?\s*\[?([a-zA-Z.]+)?\]?\s*(\d*)$/,
    SIMPLE: /^([^≪≫|\[\]\-_\/\\]+)\s*(?:[|\-_\/\\])\s*([^≪≫|\[\]]+)$/,
    LOCATION:/\[(.*)\]/,
    MAIN_NAME:/≪\s*([^≪≫\[\]]+)\s*≫/
}

/**
 * Checks if a string is one of the prefixes used to identify layer types in their names
 * @param {string} prefix The string to check
 * @return {bool} True if the string is one of the predefined prefixes.
 */
Duik.Layer.isTypePrefix = function( prefix ) {
    for (var typ in Duik.Layer.Type) {
        if (!Duik.Layer.Type.hasOwnProperty(typ)) continue;
        if (prefix == Duik.Layer.Type[typ]) return true;
        if (prefix.toLowerCase() == Duik.Layer.Type[typ].toLowerCase()) return true;
    }
    return false;
}

/**
 * Checks if the layer is one of the types created by duik.
 * @param {Layer} layer - The layer to check
 * @param {Duik.Layer.Type} layerType - The type of layer
 * @return {Boolean}
 */
Duik.Layer.isType = function(layer, layerType) {
    return DuAELayer.isType(layer, layerType);
}

/**
 * Gets the type of the layer
 * @param {Layer} [layer] The layer. If omitted, will check the first selected layer of the current comp
 * @returns {Duik.Layer.Type} The type
 */
Duik.Layer.type = function(layer) {
    return DuAELayer.type(layer);
}

/**
 * Sets the type of the layer
 * @param {Duik.Layer.Type} type The type
 * @param {Layer[]|LayerCollection|DuList.<Layer>|Layer} [layers=DuAEComp.getSelectedLayers()] The layer. If omitted, will use all selected layers in the comp
 */
Duik.Layer.setType = function(type, layers) {

    layers = def(layers, DuAEComp.getSelectedLayers());
    layers = new DuList(layers);
    if (layers.length() == 0) return;

    DuAELayer.setType(type, layers);

    for (var i = 0, n = layers.length(); i < n; i++) {
        var layer = layers.at(i);

        var name = Duik.Layer.sanitizeName(layer);
        if (name != '') {
            var nameArr = name.split("≪");
            nameArr[0] = type + " ";
            name = nameArr.join("≪");
            DuAELayer.rename(layer, name);
        }
        
        // Remove groups
        DuAETag.removeGroup(layer, i18n._("Controller"));
        DuAETag.removeGroup(layer, i18n._("Bone"));
        DuAETag.removeGroup(layer, i18n._("Pin"));
        DuAETag.removeGroup(layer, i18n._("Zero"));
        DuAETag.removeGroup(layer, i18n._("Locator"));
        DuAETag.removeGroup(layer, i18n._("Effector"));
        DuAETag.removeGroup(layer, i18n._("Audio spectrum"));
        DuAETag.removeGroup(layer, i18n._("Motion trail"));
        DuAETag.removeGroup(layer, i18n._("Celluloid"));
        DuAETag.removeGroup(layer, i18n._("X-Sheet"));

        if (type == Duik.Layer.Type.BONE) {
            DuAETag.addGroup(layer, i18n._("Bone"));
            layer.label = 7;
            layer.guideLayer = true;
            layer.quality = LayerQuality.DRAFT;
        } else if (type == Duik.Layer.Type.PIN) {
            layer.guideLayer = true;
            DuAETag.addGroup(layer, i18n._("Pin"));
        } else if (type == Duik.Layer.Type.CONTROLLER) {
            DuAETag.addGroup(layer, i18n._("Controller"));
            layer.guideLayer = true;
            layer.label = 9;
            if (Duik.Controller.layerMode == Duik.Controller.LayerMode.DRAFT_SHAPE) layer.quality = LayerQuality.DRAFT;
        } else if (type == Duik.Layer.Type.CONTROLLER_BG) {
            DuAETag.addGroup(layer, i18n._("Controller"));
            layer.guideLayer = true;
            if (Duik.Controller.draft) ctrl.quality = LayerQuality.DRAFT;
        } else if (type == Duik.Layer.Type.ZERO) {
            DuAETag.addGroup(layer, i18n._("Zero"));
            layer.guideLayer = true;
        } else if (type == Duik.Layer.Type.IK) {
            layer.guideLayer = true;
        } else if (type == Duik.Layer.Type.LOCATOR) {
            layer.guideLayer = true;
            DuAETag.addGroup(layer, i18n._("Locator"));
        } else if (type == Duik.Layer.Type.EFFECTOR) {
            DuAETag.addGroup(layer, i18n._("Effector"));
            layer.guideLayer = true;
            layer.label = 9;
        } else if (type == Duik.Layer.Type.AUDIO) {
            DuAETag.addGroup(layer, i18n._("Audio spectrum"));
            layer.guideLayer = true;
            layer.label = 9;
        } else if (type == Duik.Layer.Type.MOTION_TRAIL) {
            DuAETag.addGroup(layer, i18n._("Motion trail"));
        } else if (type == Duik.Layer.Type.CEL) {
            DuAETag.addGroup(layer, i18n._("Celluloid"));
        } else if (type == Duik.Layer.Type.X_SHEET) {
            DuAETag.addGroup(layer, i18n._("X-Sheet"));
        }
    }
}

/**
 * Gets all layers of the specified type
 * @param {Duik.Layer.Type} type The type
 * @param {Boolean} [selectedOnly=true] Whether to get only the selected layers or all of them
 * @param {CompItem} [comp=DuAEProject.getActiveComp()] The comp
 * @param {bool} [notSelectedOnly=false] Get only the not selected layers
 * @returns {Layer[]} The layers of the specified type.
 */
Duik.Layer.get = function(type, selectedOnly, comp, notSelectedOnly) {
    comp = def(comp, DuAEProject.getActiveComp());
    selectedOnly = def(selectedOnly, true);
    notSelectedOnly = def(notSelectedOnly, false);
    if (!comp) return [];

    var layers = [];
    if (selectedOnly) layers = comp.selectedLayers;
    else layers = comp.layers;

    if (layers.length == 0) return [];

    layers = new DuList(layers);
    var bones = [];
    layers.do(function(layer) {
        if (layer.selected && notSelectedOnly) return;
        
        if (Duik.Layer.isType(layer, type)) bones.push(layer);
        else if (type == Duik.Layer.Type.CONTROLLER && Duik.Layer.isType(layer, Duik.Layer.Type.CONTROLLER_BG)) bones.push(layer);
    });
    return bones;
}

/**
 * Selects all the layers of the given type (and deselects others)
 * @param {Duik.Layer.Type} type The type
 * @param {CompItem} [comp=DuAEProject.getActiveComp()] The comp
 */
Duik.Layer.select = function(type, comp) {
    comp = def(comp, DuAEProject.getActiveComp());
    if (!comp) return;

    for (var i = 1, n = comp.numLayers; i <= n; i++) {
        var layer = comp.layer(i);
        if (layer.locked) continue;
        layer.selected = Duik.Layer.isType(layer, type);
    }
}

/**
 * Show/hides all the layers of the given type
 * @param {Duik.Layer.Type} type The type
 * @param {CompItem} [comp=DuAEProject.getActiveComp()] The comp
 * @param {bool} [notSelectedOnly=false] Hides only the layers which are not selected
 */
Duik.Layer.toggleVisibility = function(type, comp, notSelectedOnly) {
    notSelectedOnly = def(notSelectedOnly, false);
    var layers = Duik.Layer.get(type, false, comp, notSelectedOnly);
    if (layers.length == 0) return;
    var enabled = !layers[0].enabled;
    for (var i = 0, n = layers.length; i < n; i++) {
        layers[i].enabled = enabled;
    }
}

// Low-level undocumented
// Returns the part to use in a layer name with side and location 
Duik.Layer.sideName = function(side, location) {
    var n = '';

    if (location == OCO.Location.NONE && side == OCO.Side.NONE) return n;

    if (location != OCO.Location.NONE) {
        if (location == OCO.Location.FRONT)
            n += i18n._p("layer name", "Fr"); /// TRANSLATORS: Short for Front, must be short enough to be used as a tag in layer names
        else if (location == OCO.Location.BACK)
            n += i18n._p("layer name", "Bk"); /// TRANSLATORS: Short for Back, must be short enough to be used as a tag in layer names
        else if (location == OCO.Location.TAIL)
            n += i18n._p("layer name", "Tl"); /// TRANSLATORS: Short for Tail, must be short enough to be used as a tag in layer names
        else if (location == OCO.Location.MIDDLE)
            n += i18n._p("layer name", "Md"); /// TRANSLATORS: Short for Middle, must be short enough to be used as a tag in layer names
        else if (location == OCO.Location.ABOVE)
            n += i18n._p("layer name", "Ab"); /// TRANSLATORS: Short for Above, must be short enough to be used as a tag in layer names
        else if (location == OCO.Location.UNDER)
            n += i18n._p("layer name", "Un"); /// TRANSLATORS: Short for Under, must be short enough to be used as a tag in layer names

        if (side != OCO.Side.NONE) n += '.';
    }

    if (side != OCO.Side.NONE) {
        if (side == OCO.Side.LEFT)
            n += i18n._p("layer name", "L"); /// TRANSLATORS: Short for Left, must be short enough to be used as a tag in layer names
        else if (side == OCO.Side.RIGHT)
            n += i18n._p("layer name", "R"); /// TRANSLATORS: Short for Right, must be short enough to be used as a tag in layer names
    }

    return n;
}

/**
 * Checks the side of the layer
 * @param {Layer} [layer] The layer. If omitted, will check the first selected bone of the current comp
 * @returns {OCO.Side}
 */
Duik.Layer.side = function(layer) {
    layer = def(layer, DuAEComp.getActiveLayer());
    if (!layer) return OCO.Side.NONE;

    if (DuGR.inGroups(layer, [ i18n._("Left")])) return OCO.Side.LEFT;
    if (DuGR.inGroups(layer, [ i18n._("Right")])) return OCO.Side.RIGHT;
    return OCO.Side.NONE;
}

/**
 * Sets the side of the layer
 * @param {OCO.Side} side The side
 * @param {Layer[]|LayerCollection|DuList.<Layer>|Layer} [layers=DuAEComp.getSelectedLayers()] The layer. If omitted, will use all selected layers in the comp
 */
Duik.Layer.setSide = function(side, layers) {
    layers = def(layers, DuAEComp.getSelectedLayers());
    layers = new DuList(layers);
    if (layers.length() == 0) return;

    for (var i = 0, n = layers.length(); i < n; i++) {
        var layer = layers.at(i);
        var name = Duik.Layer.sanitizeName(layer);

        var currentSide = Duik.Layer.side(layer);
        if (currentSide == side) continue;
        var currentLocation = Duik.Layer.location(layer);

        if (currentSide == OCO.Side.LEFT) DuAETag.removeGroup(layer, i18n._("Left"));
        else if (currentSide == OCO.Side.RIGHT) DuAETag.removeGroup(layer, i18n._("Right"));

        // Add new
        if (side == OCO.Side.RIGHT) DuAETag.addGroup(layer, i18n._("Right"));
        else if (side == OCO.Side.LEFT) DuAETag.addGroup(layer, i18n._("Left"));

        // Update name
        if (name != '') {

            var newSideName = Duik.Layer.sideName(side, currentLocation);

            var match = name.match(Duik.Layer.NameRegExp.LOCATION);
            if (match) {
                name = name.replace(match[1], newSideName);
            }
            else {
                name = DuString.trimNumbers(name);
                name += " [" + newSideName + "]";
            }
           
            DuAELayer.rename(layer, name);
        }
    }
}

/**
 * Checks the location of the layer
 * @param {Layer} [layer=DuAEComp.getActiveLayer] The layer. If omitted, will check the first selected bone of the current comp
 * @returns {OCO.Location}
 */
Duik.Layer.location = function(layer) {
    layer = def(layer, DuAEComp.getActiveLayer());
    if (!layer) return OCO.Location.NONE;

    if (DuGR.inGroups(layer, [ i18n._("Front")])) return OCO.Location.FRONT;
    if (DuGR.inGroups(layer, [ i18n._("Back")])) return OCO.Location.BACK;
    if (DuGR.inGroups(layer, [ i18n._("Middle")])) return OCO.Location.MIDDLE;
    if (DuGR.inGroups(layer, [ i18n._("Under")])) return OCO.Location.UNDER;
    if (DuGR.inGroups(layer, [ i18n._("Above")])) return OCO.Location.ABOVE;
    if (DuGR.inGroups(layer, [ i18n._("Tail")])) return OCO.Location.TAIL;
    return OCO.Side.NONE;
}

/**
 * Sets the location of the layer
 * @param {OCO.Side} side The side
 * @param {Layer[]|LayerCollection|DuList.<Layer>|Layer} [layers=DuAEComp.getSelectedLayers()] The layer. If omitted, will use all selected layers in the comp
 */
Duik.Layer.setLocation = function(location, layers) {
    layers = def(layers, DuAEComp.getSelectedLayers());
    layers = new DuList(layers);
    if (layers.length() == 0) return;

    for (var i = 0, n = layers.length(); i < n; i++) {
        var layer = layers.at(i);
        var name = Duik.Layer.sanitizeName(layer);

        var currentLocation = Duik.Layer.location(layer);
        if (currentLocation == location) continue;

        var currentSide = Duik.Layer.side(layer);

        if (currentLocation == OCO.Location.FRONT) DuAETag.removeGroup(layer, i18n._("Front"));
        else if (currentLocation == OCO.Location.BACK) DuAETag.removeGroup(layer, i18n._("Back"));
        else if (currentLocation == OCO.Location.TAIL) DuAETag.removeGroup(layer, i18n._("Tail"));
        else if (currentLocation == OCO.Location.MIDDLE) DuAETag.removeGroup(layer, i18n._("Middle"));
        else if (currentLocation == OCO.Location.ABOVE) DuAETag.removeGroup(layer, i18n._("Above"));
        else if (currentLocation == OCO.Location.UNDER) DuAETag.removeGroup(layer, i18n._("Under"));
        
        // Add new
        if (location == OCO.Location.FRONT)
            DuAETag.addGroup(layer, i18n._("Front"));
        else if (location == OCO.Location.BACK)
            DuAETag.addGroup(layer, i18n._("Back"));
        else if (location == OCO.Location.TAIL)
            DuAETag.addGroup(layer, i18n._("Tail"));
        else if (location == OCO.Location.MIDDLE)
            DuAETag.addGroup(layer, i18n._("Middle"));
        else if (location == OCO.Location.ABOVE)
            DuAETag.addGroup(layer, i18n._("Above"));
        else if (location == OCO.Location.UNDER)
            DuAETag.addGroup(layer, i18n._("Under"));

        // Update name
        if (name != '') {
            var newSideName = Duik.Layer.sideName(currentSide, location);

            var match = name.match(Duik.Layer.NameRegExp.LOCATION);
            if (match) {
                name = name.replace(match[1], newSideName);
            }
            else {
                name = DuString.trimNumbers(name);
                name += " [" + newSideName + "]";
            }
           
            DuAELayer.rename(layer, name);
        }
    }
}

/**
 * Checks the character name this layer belongs to
 * @param {Layer} [layer=DuAEComp.getActiveLayer] The layer. If omitted, will check the first selected bone of the current comp
 * @returns {strng}
 */
Duik.Layer.groupName = function(layer) {
    layer = def(layer, DuAEComp.getActiveLayer());
    if (!layer) return '';

    // Split
    var name = layer.name;
    var match = name.match( Duik.Layer.NameRegExp.MAIN_NAME );
    if (!match) return '';
    if (!match[1]) return '';

    var group = match[1].split("|");
    if (group.length < 2) return '';
    group = DuString.trim(group[0]);

    // Must be in the corresponding group
    if (!DuGR.inGroups(layer, [group])) return '';
    return group;
}

/**
 * Sets the character name of the bone layer
 * @param {string} characterName The character name.
 * @param {Layer[]|LayerCollection|DuList.<Layer>|Layer} [layers=DuAEComp.getSelectedLayers()] The layer. If omitted, will use all selected layers in the comp
 */
Duik.Layer.setGroupName = function(newGroup, layers) {
    layers = def(layers, DuAEComp.getSelectedLayers());
    layers = new DuList(layers);
    if (layers.length() == 0) return;

    layers.do( function(layer) {
        var name = Duik.Layer.sanitizeName(layer);
        var oldGroup = Duik.Layer.groupName(layer);
        if (oldGroup != '') DuAETag.removeGroup(layer,oldGroup);
        if (newGroup != '-' && newGroup != '') DuAETag.addGroup(layer, newGroup);

        if (name != '') {
            var nArr = [newGroup];
            var match = name.match( Duik.Layer.NameRegExp.MAIN_NAME );
            if (match && match[1]) {
                var n = match[1].split("|");
                if (n.length < 2) nArr.push( DuString.trim(n[0]) );
                else nArr.push( DuString.trim(n[1]) );

                n = nArr.join(" | ")  + " ";
                name = name.replace( match[1], n);
                DuAELayer.rename(layer, name);
            }
        }
    });
}

/**
 * Checks the limb name this layer belongs to
 * @param {Layer} [layer=DuAEComp.getActiveLayer] The layer. If omitted, will check the first selected bone of the current comp
 * @returns {DuColor}
 */
Duik.Layer.name = function(layer) {

    layer = def(layer, DuAEComp.getActiveLayer());
    if (!layer) return '';

    // Split
    var name = layer.name;
    var match = name.match( Duik.Layer.NameRegExp.MAIN_NAME );
    if (!match) return name;
    if (!match[1]) return '';

    var n = match[1].split("|");
    if (n.length < 2) return DuString.trim( n[0] );
    return DuString.trim( n[1] );
}

/**
 * Sets the limb name of the bone layer
 * @param {string} limbName The limb name.
 * @param {Layer[]|LayerCollection|DuList.<Layer>|Layer} [layers=DuAEComp.getSelectedLayers()] The layer. If omitted, will use all selected layers in the comp
 */
Duik.Layer.setName = function(newName, layers) {
    layers = def(layers, DuAEComp.getSelectedLayers());
    layers = new DuList(layers);
    if (layers.length() == 0) return;

    layers.do( function(layer) {
        var name = Duik.Layer.sanitizeName(layer);

        if (name != '') {
            var match = name.match( Duik.Layer.NameRegExp.MAIN_NAME );
            var nArr = [];
            if (match && match[1]) {
                var n = match[1].split("|");
                if ( n.length > 1 ) nArr.push( DuString.trim(n[0]) );
                nArr.push( newName );
                n = nArr.join(" | ") + " ";
                name = name.replace( match[1], n);
                DuAELayer.rename(layer, name);
            }
        }
    });
}

/**
 * Copies the attributes from a layer to another layer.
 * @param {Layer|Layer[]|LayerCollection|DuList.<Layer>} to The layer to set up
 * @param {Layer} from The source layer
 * @param {Duik.Layer.Type} type The type of the layer to set up
 */
Duik.Layer.copyAttributes = function(to, from, type) {
    to = new DuList(to);
    var side = Duik.Layer.side(from);
    var location = Duik.Layer.location(from);
    var characterName = Duik.Layer.groupName(from);
    var limbName = Duik.Layer.name(from);
    type = def(type, Duik.Layer.Type.NONE);

    for (var i = 0, n = to.length(); i < n; i++) {
        var layer = to.at(i);
        //DuAELayer.rename(layer, from.name);
        Duik.Layer.setAttributes(layer, type, limbName, side, location, characterName);
    }
}

/**
 * Sets all the attributes of the layer at once; use this method to prepare a layer which doesn't have a proper Duik name yet.
 * @param {Layer|Layer[]|LayerCollection|DuList.<Layer>} layer The layer to set up
 * @param {Duik.Layer.Type} type The type
 * @param {string} [limbName] The name of the limb/layer
 * @param {OCO.Side} [side=OCO.Side.NONE] The side
 * @param {OCO.Location} [location=OCO.Location.NONE] The location
 * @param {string} [characterName="-"] The name of the character
 */
Duik.Layer.setAttributes = function(layer, type, name, side, location, groupName) {
    layer = new DuList(layer);
    side = def(side, OCO.Side.NONE);
    location = def(location, OCO.Location.NONE);
    groupName = def(groupName, '');
    for (var i = 0, n = layer.length(); i < n; i++) {
        var l = layer.at(i);
        var newName = name;
        if (newName == '') newName = Duik.Layer.name(l);
        if (newName == '') newName = l.name;
        Duik.Layer.setType(type, l);
        Duik.Layer.setSide(side, l);
        Duik.Layer.setLocation(location, l);
        Duik.Layer.setGroupName(groupName, l);
        Duik.Layer.setName(newName, l);
    }
}

/**
 * Sets default name to a layer so it can be correctly managed by Duik, and checks the groups/tags.
 * @param {Layer} [layer=DuAEComp.getActiveLayer] The layer. If omitted, will check the first selected layer of the current comp
 * @returns {string} The new name of the layer
 */
Duik.Layer.sanitizeName = function(layer) {
    layer = def(layer, DuAEComp.getActiveLayer());
    if (!layer) return '';

    if (Duik.Layer.sanitizing) return '';
    Duik.Layer.sanitizing = true;

    var oldName = layer.name;

    // Name : " Type ≪ Group | Name ≫ [Location] number"

    // We need to get: the type, the group, the name, the location, the side, and maybe a number
    var typeStr = '';
    var groupStr = '';
    var nameStr = '';
    var locStr = '';
    var sideStr = '';

    // Match to see what we get!
    var n = layer.name;
    var match = n.match(Duik.Layer.NameRegExp.SIMPLE);

    function checkType(testStr) {
        var testStrL = testStr.toLowerCase();
        
        var t = "";

        if (Duik.Layer.isTypePrefix(testStr)) t = testStr;
        // Try with common prefixes
        else if (testStrL == "c" || testStrL == "ctrl" || testStrL == "controller") t = Duik.Layer.Type.CONTROLLER;
        else if (testStrL == "cbg" || testStrL == "bgc") t = Duik.Layer.Type.CONTROLLER_BG;
        else if (testStrL == "b" || testStrL == "bone") t = Duik.Layer.Type.BONE;
        else if (testStrL == "pin") t = Duik.Layer.Type.PIN;
        else if (testStrL == "zero") t = Duik.Layer.Type.ZERO;
        else if (testStrL == "ik") t = Duik.Layer.Type.IK;
        else if (testStrL == "null") t = Duik.Layer.Type.NULL;
        else if (testStrL == "loc" || testStrL == "locator") t = Duik.Layer.Type.LOCATOR;
        else if (testStrL == "effctr" || testStrL == "fctr" || testStrL == "effector") t = Duik.Layer.Type.EFFECTOR;
        else if (testStrL == "aud" || testStrL == "audio") t = Duik.Layer.Type.AUDIO;
        else if (testStrL == "mt" || testStrL == "trail") t = Duik.Layer.Type.MOTION_TRAIL;
        else if (testStrL == "sol" || testStrL == "solid") t = Duik.Layer.Type.SOLID;
        else if (testStrL == "fx" || testStrL == "adj" || testStrL == "adjustment") t = Duik.Layer.Type.ADJUSTMENT;

        return t;
    }

    // It's a simple name
    if (match) {
        // Check the first part
        var g1 = DuString.trim( match[1] );
        var g2 = DuString.trim( match[2] );

        typeStr = checkType(g1);

        // Nothing, it's the group
        if (typeStr == "") {
            groupStr = g1;
            nameStr = g2;
        }
        // Check the second part
        else {
            match = g2.match(Duik.Layer.NameRegExp.SIMPLE);
            g1 = DuString.trim( match[1] );
            g2 = DuString.trim( match[2] );
            if (g2 == "") nameStr = g1;
            else {
                nameStr = g2;
                groupStr = g1;
            }
        }
    }
    else {
        // Try with Duik name
        match = n.match(Duik.Layer.NameRegExp.DUIK_NAME)
        if (match) {
            var g1 = DuString.trim( match[1] );
            var g2 = DuString.trim( match[2] );
            var g3 = DuString.trim( match[3] );

            locStr = DuString.trim( match[4] );
            numStr = DuString.trim( match[5] );

            if (g3 != "") {
                typeStr = g1;
                groupStr = g2;
                nameStr = g3;
            }
            else if (g2 != "") {
                typeStr = g1;
                nameStr = g2;
            }
            else {
                nameStr = g1;
            }
        }
        else {
            nameStr = n;
        }
    }

    // Remove number from Name
    nameStr = DuString.trimNumbers(nameStr);

    var leftSuffix = i18n._p("layer name", "L"); /// TRANSLATORS: Short for Left, must be short enough to be used as a tag in layer names
    var rightSuffix = i18n._p("layer name", "R"); /// TRANSLATORS: Short for Right, must be short enough to be used as a tag in layer names
    var frontSuffix = i18n._p("layer name", "Fr"); /// TRANSLATORS: Short for Front, must be short enough to be used as a tag in layer names
    var backSuffix = i18n._p("layer name", "Bk"); /// TRANSLATORS: Short for Back, must be short enough to be used as a tag in layer names
    var tailSuffix = i18n._p("layer name", "Tl"); /// TRANSLATORS: Short for Tail, must be short enough to be used as a tag in layer names
    var midSuffix = i18n._p("layer name", "Md"); /// TRANSLATORS: Short for Middle, must be short enough to be used as a tag in layer names
    var aboveSuffix = i18n._p("layer name", "Ab"); /// TRANSLATORS: Short for Above, must be short enough to be used as a tag in layer names
    var underSuffix = i18n._p("layer name", "Un"); /// TRANSLATORS: Short for Under, must be short enough to be used as a tag in layer names

    leftSuffixTest = leftSuffix.toLowerCase();
    rightSuffixTest = rightSuffix.toLowerCase();
    frontSuffixTest = frontSuffix.toLowerCase();
    backSuffixTest = backSuffix.toLowerCase();
    tailSuffixTest = tailSuffix.toLowerCase();
    midSuffixTest = midSuffix.toLowerCase();
    aboveSuffixTest = aboveSuffix.toLowerCase();
    underSuffixTest = underSuffix.toLowerCase();

    // Check the location

    function checkLoc(locArray) {
        var side = "";
        var loc = "";
        var foundSide = false;
        var foundLoc = false;

        // Adjust the groups
        DuAETag.removeGroup(layer, i18n._("Left"));
        DuAETag.removeGroup(layer, i18n._("Right"));
        DuAETag.removeGroup(layer, i18n._("Front"));
        DuAETag.removeGroup(layer, i18n._("Back"));
        DuAETag.removeGroup(layer, i18n._("Tail"));
        DuAETag.removeGroup(layer, i18n._("Middle"));
        DuAETag.removeGroup(layer, i18n._("Above"));
        DuAETag.removeGroup(layer, i18n._("Under"));

        for (var i = locArray.length-1; i >= 0; i--) {
            var test = locArray[i].toLowerCase();
            if (!foundSide) {
                if (test == leftSuffixTest) { 
                    side = leftSuffix;
                    foundSide = true;
                    DuAETag.addGroup(layer, i18n._("Left"));
                    locArray.splice(i, 1);
                    continue;
                }
                if (test == rightSuffixTest) { 
                    side = rightSuffix;
                    foundSide = true;
                    DuAETag.addGroup(layer, i18n._("Right"));
                    locArray.splice(i, 1);
                    continue;
                }
            }
            if (!foundLoc) {
                if (test == frontSuffixTest) { 
                    loc = frontSuffix;
                    foundLoc = true;
                    DuAETag.addGroup(layer, i18n._("Front"));
                    locArray.splice(i, 1);
                    continue;
                }
                if (test == backSuffixTest) { 
                    loc = backSuffix;
                    foundLoc = true;
                    DuAETag.addGroup(layer, i18n._("Back"));
                    locArray.splice(i, 1);
                    continue;
                }
                if (test == tailSuffixTest) { 
                    loc = tailSuffix;
                    foundLoc = true;
                    DuAETag.addGroup(layer, i18n._("Tail"));
                    locArray.splice(i, 1);
                    continue;
                }
                if (test == midSuffixTest) { 
                    loc = midSuffix;
                    foundLoc = true;
                    DuAETag.addGroup(layer, i18n._("Middle"));
                    locArray.splice(i, 1);
                    continue;
                }
                if (test == aboveSuffixTest) { 
                    loc = aboveSuffix;
                    foundLoc = true;
                    DuAETag.addGroup(layer, i18n._("Above"));
                    locArray.splice(i, 1);
                    continue;
                }
                if (test == underSuffixTest) { 
                    loc = underSuffix;
                    foundLoc = true;
                    DuAETag.addGroup(layer, i18n._("Under"));
                    locArray.splice(i, 1);
                    continue;
                }
            }
            if (foundSide && foundLoc) break;
        }
        if (foundSide && foundLoc) locStr = loc + '.' + side;
        else if (foundSide) locStr = side;
        else if (foundLoc) locStr = loc;

        return locArray.join(" ");
    }

    if (locStr == "") {
        var nameArr = DuString.split(nameStr, ["_","-", ".", " ", "|"]);
        var nameStr = checkLoc(nameArr);
    }
    else {
        var locArr = locStr.split('.');
        checkLoc(locArr);
    }

    // Check the type
    if (typeStr == "") {
        var nameArr = DuString.split(nameStr, ["_","-", ".", " ", "|"]);
        for (var i = nameArr.length-1; i >= 0; i--) {
            var t = checkType(nameArr[i]);
            if (t != "") {
                typeStr = t;
                nameArr.splice(i, 1);
                break;
            }
        }
        nameStr = nameArr.join(" ");
    }

    // Set the group
    if (groupStr != "") DuAETag.addGroup(layer, groupStr);

    // Build the new Name
    var newName = typeStr;
    if (newName != "") newName += " ";
    newName += " ≪ ";
    if (groupStr) newName += groupStr + " | ";
    newName += nameStr + " ≫";
    if (locStr) newName += " [" + locStr + "]";

    DuAELayer.rename(layer, newName);
    Duik.Layer.setType(typeStr, layer, true);

    Duik.Layer.sanitizing = false;

    return layer.name;
}

/**
 * Toggles the edit mode on selected layers
 * @param {Layer[]|LayerCollection|DuList.<Layer>|Layer} [layers=DuAEComp.getSelectedLayers()] The layer. If omitted, will use all selected layers in the comp
 */
Duik.Layer.unlink = function(layers) {
    layers = def(layers, DuAEComp.getSelectedLayers());
    layers = new DuList(layers);
    if (layers.length() == 0) return;

    DuAE.beginUndoGroup( i18n._("Toggle edit mode"));
    DuAEProject.setProgressMode(true);

    for (var i = 0, n = layers.length(); i < n; i++) {
        DuAELayer.toggleEditMode(layers.at(i));
    }

    DuAEProject.setProgressMode(false);
    DuAE.endUndoGroup();
}