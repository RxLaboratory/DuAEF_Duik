/**
 * Pin related tools.
 * @namespace
 */
Duik.Pin = {}

/**
 * The shapes/type/icon of the pins
 * @enum {int}
 * @readonly
*/
Duik.Pin.Type = {
    PIN: 1,
	VERTEX: 2,
	TANGENT: 3,
	BEND_PIN: 4,
	ADVANCED_PIN: 5,
	STANDARD: 6
}

/**
	* Creates a stand alone pin in the comp
	* @param {CompItem} [comp=DuAEProject.getActiveComp()] - The containing composition
	* @param {Duik.Pin.Type} [type=Duik.Pin.Type.PIN] - The type
	* @return {ShapeLayer} The pin
*/
Duik.Pin.create = function( comp, size, type )
{
	comp = def(comp, DuAEProject.getActiveComp());
	if (!comp) return;
	type = def(type, Duik.Pin.Type.PIN);
	
	//create
	var pinLayer = comp.layers.addShape();
    var tag = DuAETag.set( pinLayer );
    DuAETag.addGroup( boneLayer, tr( "Pin" ), tag );
    DuAETag.setValue( boneLayer, DuAETag.Key.DUIK_TYPE, Duik.LayerType.PIN, tag );
	//add effect
    var effect = Duik.PseudoEffect.PIN.apply( pinLayer );

	function createIcon()
	{
		var iconGroup = pinLayer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
		iconGroup.name = 'Icon';
		iconContent = iconGroup.property("ADBE Vectors Group");

		if (type == Duik.Pin.Type.PIN)
		{
			var shape1 = iconContent.addProperty("ADBE Vector Shape - Group");
			var handleShape = new Shape();
			handleShape.vertices = [[24.6726379394531, -34.5], [34.6699981689453, -24.9618682861328], [26.9935607910156, -18.9175109863281], [25.2696228027344, -9.10385131835938], [9.27384948730469, -24.3648681640625], [18.9956817626953, -26.5480346679688]];
			handleShape.inTangents = [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]];
			handleShape.outTangents = [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]];
			handleShape.closed = true;
			shape1('ADBE Vector Shape').setValue(handleShape);
			var shape2 = iconContent.addProperty("ADBE Vector Shape - Group");
			var needleShape = new Shape();
			needleShape.vertices = [[13.7023773193359, -16], [5.47381591796875, -7.77142333984375], [0.75, 0], [8.06428527832031, -5.4857177734375], [16.2928619384766, -13.7142791748047]];
			needleShape.inTangents = [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]];
			needleShape.outTangents = [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]];
			needleShape.closed = true;
			shape2('ADBE Vector Shape').setValue(needleShape);
			var fill = iconContent.addProperty("ADBE Vector Graphic - Fill");
			fill("ADBE Vector Fill Color").expression = 'effect("' + effect.name + '")(1).value';
		}
		else if (type == Duik.Pin.Type.VERTEX)
		{
			var rect = iconContent.addProperty("ADBE Vector Shape - Rect");
			rect("ADBE Vector Rect Size").setValue([30,30]);
			var fill = iconContent.addProperty("ADBE Vector Graphic - Fill");
			fill("ADBE Vector Fill Color").expression = 'effect("' + effect.name + '")(1).value';

			pinLayer.transform.scale.expression = '[value[0],value[0]];';
			pinLayer.label = 11;
		}
		else if (type == Duik.Pin.Type.TANGENT)
		{
			var circle = iconContent.addProperty("ADBE Vector Shape - Ellipse");
			circle("ADBE Vector Ellipse Size").expression = '[20,20] * effect("' + effect.name + '")(2).value/100';

			var line = iconContent.addProperty("ADBE Vector Shape - Group");
			line('ADBE Vector Shape').expression = "if (active && hasParent) createPath([[0,0], -transform.position], [[0,0],[0,0]], [[0,0],[0,0]], false); else value;";
			var pathStroke = iconContent.addProperty("ADBE Vector Graphic - Stroke");
			pathStroke.property("Color").expression = 'effect("' + effect.name + '")(1)-[0.2,0.2,0.2,0]';
			pathStroke.property("Stroke Width").setValue(3);
			pathStroke.property('Stroke Width').expression = '3 * effect("Bone")(2).value/100';
			var fill = iconContent.addProperty("ADBE Vector Graphic - Fill");
			fill("ADBE Vector Fill Color").expression = 'effect("' + effect.name + '")(1)-[0.2,0.2,0.2,0]';

			pinLayer.label = 14;
		}
		else if (type == Duik.Pin.Type.STANDARD)
		{
			var shape1 = iconContent.addProperty("ADBE Vector Shape - Group");
			var shape = new Shape();
			shape.vertices = [[0.2703857421875, -10.5538482666016], [11.4765472412109, 0.65220642089844], [0.2703857421875, 11.8582611083984], [-10.9355621337891, 0.65220642089844]];
			shape.inTangents = [[-6.17909240722656, 0], [0, -6.17901611328125], [6.1790771484375, 0], [0, 6.17901611328125]];
			shape.outTangents = [[6.1790771484375, 0], [0, 6.17901611328125], [-6.17909240722656, 0], [0, -6.17901611328125]];
			shape.closed = true;
			shape1('ADBE Vector Shape').setValue(shape);
			var shape2 = iconContent.addProperty("ADBE Vector Shape - Group");
			shape = new Shape();
			shape.vertices = [[0.2703857421875, -15.5193634033203], [-15.9010772705078, 0.65220642089844], [0.2703857421875, 16.8237762451172], [16.4420623779297, 0.65220642089844], [0.2703857421875, -15.5193634033203]];
			shape.inTangents = [[0, 0], [0, -8.93150329589844], [-8.93147277832031, 0], [0, 8.93121337890625], [8.93145751953125, 0]];
			shape.outTangents = [[-8.93121337890625, 0], [0, 8.93150329589844], [8.93145751953125, 0], [0, -8.93119812011719], [0, 0]];
			shape.closed = true;
			shape2('ADBE Vector Shape').setValue(shape);
			var shape3 = iconContent.addProperty("ADBE Vector Shape - Group");
			shape = new Shape();
			shape.vertices = [[28.7600555419922, -2.48275756835938], [28.7600555419922, -27.2133636474609], [2.48275756835938, -27.2133636474609], [2.48275756835938, -36], [-2.48275756835938, -36], [-2.48275756835938, -27.2133636474609], [-28.2195281982422, -27.2133636474609], [-28.2195281982422, -2.48275756835938], [-36, -2.48275756835938], [-36, 2.48275756835938], [-28.2195281982422, 2.48275756835938], [-28.2195281982422, 29.7664337158203], [-2.48275756835938, 29.7664337158203], [-2.48275756835938, 36], [2.48275756835938, 36], [2.48275756835938, 29.7664337158203], [28.7600555419922, 29.7664337158203], [28.7600555419922, 2.48275756835938], [36, 2.48275756835938], [36, -2.48275756835938]];
 			shape.inTangents = [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]];
 			shape.outTangents = [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]];
			shape.closed = true;
			shape3('ADBE Vector Shape').setValue(shape);
			var shape4 = iconContent.addProperty("ADBE Vector Shape - Group");
			shape = new Shape();
			shape.vertices = [[23.7945251464844, -2.48275756835938], [20.2498931884766, -2.48275756835938], [20.2498931884766, 2.48275756835938], [23.7945251464844, 2.48275756835938], [23.7945251464844, 24.8009185791016], [2.48275756835938, 24.8009185791016], [2.48275756835938, 20.25], [-2.48275756835938, 20.25], [-2.48275756835938, 24.8009185791016], [-23.2539978027344, 24.8009185791016], [-23.2539978027344, 2.48275756835938], [-20.2501220703125, 2.48275756835938], [-20.2501220703125, -2.48275756835938], [-23.2539978027344, -2.48275756835938], [-23.2539978027344, -22.2478485107422], [-2.48275756835938, -22.2478485107422], [-2.48275756835938, -20.25], [2.48275756835938, -20.25], [2.48275756835938, -22.2478485107422], [23.7945251464844, -22.2478485107422]];
			shape.inTangents = [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]];
			shape.outTangents = [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]];
			shape.closed = true;
			shape4('ADBE Vector Shape').setValue(shape);
			var fill = iconContent.addProperty("ADBE Vector Graphic - Fill");
			fill("ADBE Vector Fill Color").expression = 'effect("' + effect.name + '")(1).value';
		}
		else if (type == Duik.Pin.Type.BEND_PIN)
		{
			var shape1 = iconContent.addProperty("ADBE Vector Shape - Group");
			var shape = new Shape();
			shape.vertices = [[24.6918487548828, -32.3074645996094], [27.4668579101563, -34.735595703125], [27.6161193847656, -36.9832763671875], [25.3684844970703, -37.1325988769531], [16.9230041503906, -29.7416839599609], [21.1616668701172, -29.7416839599609], [28.3293762207031, -22.573974609375], [21.1616668701172, -15.4062652587891], [13.9939727783203, -22.573974609375], [12.4011383056641, -24.1667938232422], [10.8083190917969, -22.573974609375], [13.0908355712891, -16.1052703857422], [5.19584655761719, -8.21017456054688], [0.09928894042969, 0.17431640625], [7.99076843261719, -5.744140625], [15.9123687744141, -13.6656799316406], [21.1616668701172, -12.2206268310547], [31.5150299072266, -22.573974609375]];
			shape.inTangents = [[3.97663879394531, 1.44660949707031], [0, 0], [0.57929992675781, 0.661865234375], [0.66340637207031, -0.5802001953125], [0, 0], [0, 0], [0, -3.9525146484375], [3.95243835449219, 0], [0, 3.95249938964844], [0.87956237792969, 0], [0, -0.879638671875], [-1.42462158203125, -1.77384948730469], [0, 0], [0, 0], [0, 0], [0, 0], [-1.9171142578125, 0], [0, 5.70864868164063]];
			shape.outTangents = [[0, 0], [0.66181945800781, -0.57942199707031], [-0.57931518554688, -0.661865234375], [0, 0], [0, 0], [3.95243835449219, 0], [0, 3.95249938964844], [-3.95242309570313, 0], [0, -0.879638671875], [-0.87954711914063, 0], [0, 2.44679260253906], [0, 0], [0, 0], [0, 0], [0, 0], [1.54153442382813, 0.91191101074219], [5.70867919921875, 0], [0, -4.46971130371094]];
			shape.closed = true;
			shape1('ADBE Vector Shape').setValue(shape);
			var fill = iconContent.addProperty("ADBE Vector Graphic - Fill");
			fill("ADBE Vector Fill Color").expression = 'effect("' + effect.name + '")(1).value';
		}
		else if (type == Duik.Pin.Type.ADVANCED_PIN)
		{
			var shape1 = iconContent.addProperty("ADBE Vector Shape - Group");
			var shape = new Shape();
			shape.vertices = [[36.9113311767578, -21.8011779785156], [22.4264221191406, -36.2860717773438], [26.1573944091797, -38.9977874755859], [29.1459503173828, -41.6127471923828], [29.3066864013672, -44.0333862304688], [26.8860931396484, -44.1941986083984], [20.2904205322266, -38.4219360351563], [17.5042877197266, -36.3568572998047], [34.4856109619141, -19.3755035400391], [34.4856109619141, -12.0968322753906], [27.2068786621094, -12.0968322753906], [10.2255554199219, -29.0781707763672], [10.2255554199219, -36.3568572998047], [7.79981994628906, -38.7825164794922], [7.79981994628906, -26.6525115966797], [15.5674438476563, -18.8851013183594], [6.01890563964844, -9.3365478515625], [0.53018188476563, -0.306884765625], [9.02890014648438, -6.68075561523438], [18.4002380371094, -16.0521545410156], [24.7813110351563, -9.67117309570313], [30.8462371826172, -7.16258239746094], [36.9113311767578, -9.67117309570313]];
			shape.inTangents = [[3.34449768066406, 3.34451293945313], [0, 0], [0, 0], [0, 0], [0.62388610839844, 0.71278381347656], [0.71446228027344, -0.62484741210938], [0, 0], [0, 0], [0, 0], [2.00682067871094, -2.00686645507813], [2.00682067871094, 2.00686645507813], [0, 0], [-2.0068359375, 2.00688171386719], [0, 0], [-3.344482421875, -3.34449768066406], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [-2.19621276855469, 0], [-1.67231750488281, 1.67234802246094]];
			shape.outTangents = [[0, 0], [0, 0], [0, 0], [0.71273803710938, -0.62400817871094], [-0.6239013671875, -0.71278381347656], [0, 0], [0, 0], [0, 0], [2.0068359375, 2.00686645507813], [-2.0068359375, 2.00686645507813], [0, 0], [-2.0068359375, -2.00688171386719], [0, 0], [-3.344482421875, 3.34449768066406], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [1.67182922363281, 1.67268371582031], [2.19622802734375, 0], [3.34449768066406, -3.34449768066406]];
			shape.closed = true;
			shape1('ADBE Vector Shape').setValue(shape);
			var fill = iconContent.addProperty("ADBE Vector Graphic - Fill");
			fill("ADBE Vector Fill Color").expression = 'effect("' + effect.name + '")(1).value';
		}


		if (type != Duik.Pin.Type.TANGENT) iconGroup.transform.scale.expression = '[effect("' + effect.name + '")(2).value,effect("' + effect.name + '")(2).value]';
	}

	function createAnchor()
	{
		var anchorGroup = pinLayer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
		anchorGroup.name = 'Anchor';
		var anchorContent = anchorGroup.property("ADBE Vectors Group");

		var centerCircle = anchorContent.addProperty("ADBE Vector Shape - Ellipse");
		centerCircle("ADBE Vector Ellipse Size").setValue([2,2]);
		var rect = anchorContent.addProperty("ADBE Vector Shape - Rect");
		rect("ADBE Vector Rect Size").setValue([12,12]);
		var stroke = anchorContent.addProperty("ADBE Vector Graphic - Stroke");
		stroke("ADBE Vector Stroke Color").setValue([0,0,0,1]);
	}

	if (type == Duik.Pin.Type.VERTEX) createAnchor();
	createIcon();
	if (type == Duik.Pin.Type.PIN || type == Duik.Pin.Type.BEND_PIN || type == Duik.Pin.Type.ADVANCED_PIN || type == Duik.Pin.Type.STANDARD) createAnchor();

	pinLayer.guideLayer = true;
	pinLayer.quality = LayerQuality.DRAFT;

	//bone = new Bone(pinLayer);
	//bone.setSize();
	//bone.setColor();
	return pinLayer;
}


//low-level undocumented function
//creates an effect to control a shape vertex and tangents
Duik.Pin.createPathVertexControl = function( layer, name, fixVertex, fixIn, fixOut)
{
    fixVertex = def(fixVertex, false);
    fixIn = def(fixIn, false);
    fixOut = def(fixOut, false);

    var vertexLayerIndex = Duik.PseudoEffect.PATH_PIN.props["Control Layers"]["Vertex"].index;
    var inTangentLayerIndex = Duik.PseudoEffect.PATH_PIN.props["Control Layers"]["In Tangent"].index;
    var outTangentLayerIndex = Duik.PseudoEffect.PATH_PIN.props["Control Layers"]["Out Tangent"].index;
    var vertexIndex = Duik.PseudoEffect.PATH_PIN.props["Vertex"].index;
    var inTangentIndex = Duik.PseudoEffect.PATH_PIN.props["Tangents"]["In tangent"].index;
    var outTangentIndex = Duik.PseudoEffect.PATH_PIN.props["Tangents"]["Out tangent"].index;

    var vertexExp = [ DuAEExpression.Id.PIN,
        'var l = null;',
		'try {l = thisProperty.propertyGroup()(' + vertexLayerIndex + ')} catch (e) {};',
		'var result = value;',
		'if (l != null) {',
		'result = l.toWorld(l.anchorPoint);'
    ].join('\n');
	if (!(layer instanceof ShapeLayer)) vertexExp += 'result = fromWorld(result);\n';
	vertexExp +='}\nresult;'

	var inExp = [ DuAEExpression.Id.PIN,
		'var l = null;',
		'var fx = thisProperty.propertyGroup();',
		'try {l = fx(' + inTangentLayerIndex + ')} catch (e) {};',
		'var result = value + fx(' + vertexIndex + ');',
		'if (l != null) {',
		'result = l.toWorld(l.anchorPoint);'
    ].join('\n');
	if (!(layer instanceof ShapeLayer)) inExp += 'result = fromWorld(result);\n';
	inExp +='}\nresult;'

	var outExp = [ DuAEExpression.Id.PIN,
		'var l = null;',
		'var fx = thisProperty.propertyGroup();',
		'try {l = fx(' + outTangentLayerIndex + ')} catch (e) {};',
		'var result = value + fx(' + vertexIndex + ');',
		'if (l != null) {',
		'result = l.toWorld(l.anchorPoint);'
    ].join('\n');
	if (!(layer instanceof ShapeLayer)) outExp += 'result = fromWorld(result);\n';
	outExp +='}\nresult;';

	//check if an effect already exists
	var effect = null;

	for (var i = 1, n = layer('ADBE Effect Parade').numProperties; i <= n ; i++)
	{
		var fx = layer('ADBE Effect Parade').property(i);
		if (fx.matchName == Duik.PseudoEffect.PATH_PIN.matchName && fx.name == name)
		{
			effect = fx;
			if (fixVertex) effect( vertexIndex ).expression = vertexExp;
			if (fixIn) effect( inTangentIndex ).expression = inExp;
			if (fixOut) effect( outTangentIndex ).expression = outExp;
			break;
		}
	}
	if (effect == null)
	{
		effect =Duik.PseudoEffect.PATH_PIN.apply(layer);
		//expressions
		effect( vertexIndex ).expression = vertexExp;

		effect( inTangentIndex ).expression = inExp;

		effect( outTangentIndex ).expression = outExp;

		effect.name = name;
	}
	return effect;
}

/**
 * Gets a Pin layer in the comp or the selection.
 * @param {CompItem}	comp	- The composition where to get the bones
 * @param {string} name - A name filter
 * @param {Boolean} [selectedOnly=false] - Selected layers only
 * @return {Layer|null}	The pin layer.
 */
Duik.Pin.getByName = function (comp,name,selectedOnly)
{
    selectedOnly = def(selectedOnly, false);

	var layers = [];
	if (selectedOnly) layers = comp.selectedLayers;
	else layers = comp.layers;

	if (layers.length == 0) return null;

	var it = new DuList(layers);

	it.do( function (layer)
	{
		if ( Duik.isLayerType( layer, Duik.LayerType.PIN ) )
		{
			if (name == layer.name) return layer;
		}
	});

	return null;
}

/**
	* Links the path to bones<br />
	* Works with After Effects CC2018 (15.0) and newer only
	* @param {Property|DuAEProperty} prop - The path property
	* @param {bool} [tangents=true] - True to create bones for the tangents
	* @param {bool} [createPinLayers=true] - True to create layers, false to only create a controller effect
	* @return {DuAEProperty[]} The pin effects created.
*/
Duik.Pin.rigPath = function( pathProp, tangents, createPinLayers )
{
    var pins = [];

    tangents = def(tangents, true);
    createPinLayers = def(createPinLayers, true);

    if (DuAE.version.version < 15) return pins;

    // Gets the path
    pathProp = new DuAEProperty( pathProp ).pathProperty();
    if (!pathProp) return pins;
    var prop = pathProp.getProperty();

    var layer = pathProp.layer();
    var comp = layer.containingComp;

    var pathExpressionLink = pathProp.expressionLink();
    var vertices = pathProp.verticesToComp;
    var inTangents = prop.value.inTangents;
    var outTangents = prop.value.outTangents;

    // Indices of the effect we're going to need
    var vertexLayerIndex = Duik.PseudoEffect.PATH_PIN.props["Control Layers"]["Vertex"].index;
    var inTangentLayerIndex = Duik.PseudoEffect.PATH_PIN.props["Control Layers"]["In Tangent"].index;
    var outTangentLayerIndex = Duik.PseudoEffect.PATH_PIN.props["Control Layers"]["Out Tangent"].index;
    var vertexIndex = Duik.PseudoEffect.PATH_PIN.props["Vertex"].index;
    var inTangentIndex = Duik.PseudoEffect.PATH_PIN.props["Tangents"]["In tangent"].index;
    var outTangentIndex = Duik.PseudoEffect.PATH_PIN.props["Tangents"]["Out tangent"].index;

    // For each vertex
    for (var i = 0, n = vertices.length; i < n; i++)
    {
        var pinName = 'P | ' + layer.name + ' | ' + prop.parentProperty.name + " - " + i;

        // Add effect
        var effectName = 'P | ' + prop.parentProperty.name + " - " + i;
        var effect = Duik.Pin.createPathVertexControl(layer, effectName);
        effect( vertexIndex ).setValue([verticesCoordinates[i][0],verticesCoordinates[i][1]]);
		effect( outTangentIndex ).setValue(pathOutTangents[i]);
		effect( inTangentIndex ).setValue(pathInTangents[i]);

        pins.push( effect );

        if (createPinLayers)
        {
            var pinLayer = Duik.Pin.getByName( comp, pinName);

            // Create
            if (pinLayer == null)
            {
                pinLayer = Duik.Pin.create( comp, Duik.Pin.Type.VERTEX );
                pinLayer.name = pinName;
            }
            
            effect( vertexLayerIndex ).setValue(pinLayer.layer.index);
			pinLayer.layer.position.setValue(vertices[i]);

			if (tangents)
			{
				var pinNameIn = 'P | ' + layer.name + " | " + prop.parentProperty.name + " | In - " + i;
				var pinNameOut = 'P | ' + layer.name + " | " + prop.parentProperty.name + " | Out - " + i;

				var pinLayerIn = Duik.Pin.getByName(comp,pinNameIn);
				var pinLayerOut = Duik.Pin.getByName(comp,pinNameOut);

				if (pinLayerOut === null)
				{
					var pinLayerOut = Duik.Pin.create(comp, Duik.Pin.Type.TANGENT);
					pinLayerOut.parent = pinLayer;
					pinLayerOut.name = pinNameOut;
					pinLayerOut.position.setValue(outTangents[i]);
				}

				if (pinLayerIn === null)
				{
					var pinLayerIn = Duik.Pin.create(comp, Duik.Pin.Type.TANGENT);
					pinLayerIn.layer.parent = pinLayer;
					pinLayerIn.layer.name = pinNameIn;
					pinLayer.moveBefore(pinLayerIn);
					pinLayerIn.position.setValue(inTangents[i]);
				}

				effect( inTangentLayerIndex ).setValue(pinLayerIn.index);
				effect( outTangentLayerIndex ).setValue(pinLayerOut.index);
			}
        }
    }

    var exp = "";

	if (layer instanceof ShapeLayer) exp = [ DuAEExpression.Id.PIN,
		'var origPath = thisProperty;',
		'var origPoints = origPath.points();',
		'var origInTang = origPath.inTangents();',
		'var origOutTang = origPath.outTangents();',
		'var closed = origPath.isClosed();',
		'var fxName = "B | " + origPath.propertyGroup().name;',
		'var numPoints = 0;',
		DuAEExpression.Library.get(['Matrix','isLayer','getGroupTransformMatrix']),
		'var matrix = getGroupTransformMatrix( thisProperty ).inverse();',
		'',
		'for (var i = 1, num = thisLayer("Effects").numProperties ; i <= num; i++)',
		'{',
		'    var fx = effect(i);',
		'    if (fx.name.indexOf(fxName) == 0)',
		'    {',
		'        origPoints[numPoints] = matrix.applyToPoint( fromWorld(fx( ' + vertexIndex + ' )) );',
		'        origInTang[numPoints] = fx( ' + inTangentIndex + ' )-fx( ' + vertexIndex + ' );',
		'        origOutTang[numPoints] = fx( ' + outTangentIndex + ' )-fx( ' + vertexIndex + ' );',
		'        numPoints++;',
		'    }',
		'}',
		'createPath(origPoints,origInTang,origOutTang,closed);'
	].join('\n');

	else exp = [ DuAEExpression.Id.PIN,
		'var origPath = thisProperty;',
		'var origPoints = origPath.points();',
		'var origInTang = origPath.inTangents();',
		'var origOutTang = origPath.outTangents();',
		'var closed = origPath.isClosed();',
		'var fxName = "B | " + origPath.propertyGroup().name;',
		'var numPoints = 0;',
		'for (var i = 1, num = thisLayer("Effects").numProperties ; i <= num; i++)',
		'{',
		'var fx = effect(i);',
		'if (fx.name.indexOf(fxName) == 0)',
		'{',
		'origPoints[numPoints] = fx(' + vertexIndex + ');',
		'origInTang[numPoints] = fx(' + inTangentIndex + ')-fx(1);',
		'origOutTang[numPoints] = fx(' + outTangentIndex + ')-fx(1);',
		'numPoints++;',
		'}',
		'}',
		'createPath(origPoints,origInTang,origOutTang,closed);'
	].join('\n');

	prop.expression = exp;

	return pins;
}

/**
 * Links the path to the given layers.
 * @param {PropertyGroup|DuAEProperty} pathProp The path property (either an "ADBE Vector Shape - Group" or an "ADBE Mask Atom")
 * @param {Layer[]} layers The layers to link
 */
Duik.Pin.linkPathToLayers = function ( pathProp, layers )
{
    // Only >= CC2018
    if ( DuAE.version.version < 15 ) return;

    // Add the controls to the path
    var pins = Duik.Pin.rigPath( pathProp, true, false );

    // The FX indices we're going to need
    var vertexLayerIndex = Duik.PseudoEffect.PATH_PIN.props["Control Layers"]["Vertex"].index;

    // Link the controls to the layers
    for (var i = 0, n = pins.length; i < n; i++ )
    {
        // Finished, we don't have any more layer to link!
        if (layers.length == i) return;

        var fx = pins[i];
        fx( vertexLayerIndex ).setValue( layers[i].index );
    }
}