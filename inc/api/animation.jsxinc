/**
 * The animator's toolkit.
 * @namespace
 */
Duik.Animation = {};

// low-level undocumented list
// The animations which have been copied by Duik.Animation.copy()
Duik.Animation.copied = [];

/**
 * The list of animation functions
 */
Duik.CmdLib['Animation'] = [];

Duik.CmdLib['Animation']["Select Keyframes"] = "Duik.Animation.selectKeyframes()";
/**
 * Selects the keyframes in the comp
 * @param {CompItem} [comp=DuAEProject.getActiveComp] The composition
 * @param {Boolean} [selectedLayers=false] Set to true to get the keyframes only on the selected layers instead of all the layers.
 * @param {Boolean} [controllersOnly=true] Set to false to get the keyframes from all types of layers instead of just the controllers.
 * @param {float[]} [range] The time range to select the keyframes, [in, out]. If omitted, will use the work area of the composition.
 * @param {string[]} [propertyMatchNames=[]] The list of matchnames to select only keyframes of a specific type. If empty, will select all types of keyframes.
 */
Duik.Animation.selectKeyframes = function( comp, selectedLayers, controllersOnly, range, propertyMatchNames )
{
    comp = def(comp, DuAEProject.getActiveComp() );
    if(!comp) return;
    selectedLayers = def( selectedLayers, false );
    controllersOnly = def( controllersOnly, true );
    range = def( range, [comp.workAreaStart, comp.workAreaStart + comp.workAreaDuration ] );
    propertyMatchNames = def( propertyMatchNames, [
        'ADBE Position',
        'ADBE Vector Position',
        'ADBE Position_0',
        'ADBE Position_1',
        'ADBE Position_2',
        'ADBE Rotate Z',
        'ADBE Rotate Y',
        'ADBE Rotate X',
        'ADBE Orientation',
        'ADBE Vector Rotation',
        'ADBE Scale',
        'ADBE Vector Scale',
        'ADBE Opacity',
        'ADBE Vector Group Opacity',
        'ADBE Mask Parade',
        'ADBE Effect Parade'
    ]);
    propertyMatchNames = new DuList(propertyMatchNames);

    DuAE.beginUndoGroup(DuScriptUI.String.SELECT_KEYFRAMES, false);
    DuAEProject.setProgressMode(true);

    //get layers
    var layers = [];
    if ( !selectedLayers )
    {
        if ( !controllersOnly ) layers = comp.layers;
        else layers = Duik.Controller.get( false, comp );
    }
    else
    {
        if ( !controllersOnly ) layers = comp.selectedLayers;
        else layers = Duik.Controller.get( true, comp );
    }

    if (layers.length == 0)
    {
        DuAEProject.setProgressMode(false);
        DuAE.endUndoGroup(DuScriptUI.String.SELECT_KEYFRAMES);
        return;
    }

    //unselect all previously selected keyframes
	DuAEComp.unselectProperties();

    // A filter to get properties
    function filterProps( prop )
    {
        if ( propertyMatchNames.length() == 0) return true;
        return propertyMatchNames.indexOf( prop.matchName ) >= 0;
    }

    //get all properties
    layers = new DuList(layers);
    layers.do(function (layer)
    {
        var props = DuAEProperty.getProps(layer,filterProps);
        props = new DuList(props);
        props.do(function(prop)
        {
            prop.selectKeys( range[0], range[1]);
        });
    });

    DuAEProject.setProgressMode(false);
    DuAE.endUndoGroup(DuScriptUI.String.SELECT_KEYFRAMES);
};

Duik.CmdLib['Animation']["Copy"] = "Duik.Animation.copy()";
/**
 * Copies the currently selected keyframes, which can then be pasted with {@link Duik.Animation.paste}.
 * @param {CompItem} [comp=DuAEProject.getActiveComp] The composition
 * @returns {DuAELayerAnimation[]} The list of animations which have been copied.
 */
Duik.Animation.copy = function( comp )
{
    comp = def(comp, DuAEProject.getActiveComp() );
    if(!comp) return;

    var layers = comp.selectedLayers;
    if (layers.length == 0) return;

    copiedAnim = [];

    for (var i = 0 ; i < layers.length ; i++)
    {
        copiedAnim.push(DuAELayer.getAnim( layers[i],true ));
    }
    //get the first keyframe time to offset when pasting
    copiedAnim.firstKeyFrameTime = DuAELayer.firstKeyFrameTime(layers, true);

    Duik.Animation.copied = copiedAnim;

    return copiedAnim;
};

Duik.CmdLib['Animation']["Paste"] = "Duik.Animation.paste()";
Duik.CmdLib['Animation']["Paste Reversed"] = "Duik.Animation.paste( undefined, false, false, true )";
Duik.CmdLib['Animation']["Paste Offset"] = "Duik.Animation.paste( undefined, false, true )";
Duik.CmdLib['Animation']["Paste Replace"] = "Duik.Animation.paste( undefined, true )";
/**
 * Pastes the animation previously copied by {@link Duik.Animation.copy} to the selected properties.
 * @param {CompItem} [comp] The composition.
 * @param {Boolean} [replace=false] - Whether to completely erase and replace the current animation
 * @param {Boolean} [offset=false] - Whether to offset the animation from the current value
 * @param {Boolean} [reverse=false] - Whether to reverse the animation
 * @param {string[]} [matchNames=[]] A filter to apply only on specific property types
 */
Duik.Animation.paste = function( comp, replace, offset, reverse )
{
    DuIO.Animation.paste( comp, Duik.Animation.copied, replace, offset, reverse );
};

Duik.CmdLib['Animation']["Interpolator"] = "Duik.Animation.interpolator()";
/**
 * Control the selected keyframes with advanced but easy-to-use keyframe interpolation driven by an effect.
 * @param {PropertyBase[]|DuList.<PropertyBase>|PropertyBase} [props] The properties to interpolate. The selected properties in the active comp if omitted.
 * @param {PropertyGroup} [effect] The pseudo effect to use if it already exists.
 * @returns {PropertyGroup} The pseudo-effect
 */
Duik.Animation.interpolator = function( props, effect )
{
    props = def(props, DuAEComp.getSelectedProps() );
    props = new DuList(props);
    if (props.length() == 0) return null;

    var p = props.at(0);
    p = new DuAEProperty(p);
    var ctrlLayer = p.layer;

    DuAE.beginUndoGroup(DuScriptUI.String.INTERPOLATOR, false);

    // Add the effect
    if (!effect)
    {
        effect = Duik.PseudoEffect.INTERPOLATOR.apply( ctrlLayer, DuScriptUI.String.INTERPOLATOR + ' | ' + p.name );
    }

    // Indices
    var i = Duik.PseudoEffect.INTERPOLATOR.props;

    // Defaults
    effect( i['Type'].index ).setValue(4);

    // The Expression
    var exp = [ DuAEExpression.Id.INTERPOLATOR,
        'var fx = thisComp.layer("' + ctrlLayer.name + '").effect("' + effect.name + '");',
        'var iType = fx(' + i['Type'].index + ').value;',
        'var iRate = fx(' + i['Rate'].index + ').value;',
        '',
        'var isIn = fx(' + i['In Extrapolation and loop']['Before keys'].index + ');',
        'var inType = fx(' + i['In Extrapolation and loop']['Type'].index + ').value;',
        'var inInStill = fx(' + i['In Extrapolation and loop']['During still parts'].index + ').value;',
        'var inNumKeyframes = fx(' + i['In Extrapolation and loop']['Number of keys'].index + ').value;',
        'var inDamping = fx(' + i['In Extrapolation and loop']['Damping'].index + ').value;',
        'var isOut = fx(' + i['Out Extrapolation and loop']['After keys'].index + ');',
        'var outType = fx(' + i['Out Extrapolation and loop']['Type'].index + ').value;',
        'var outNumKeyframes = fx(' + i['Out Extrapolation and loop']['Number of keys'].index + ').value;',
        'var outInStill = fx(' + i['Out Extrapolation and loop']['During still parts'].index + ').value;',
        'var elasticity = fx(' + i['Out Extrapolation and loop']['Elasticity'].index + ').value;',
        'var outDamping = fx(' + i['Out Extrapolation and loop']['Damping'].index + ').value;',
        '',
        'elasticity /= 10;',
        'outDamping /= 10;',
        'inDamping /= 10;',
        'if (!isOut.value) outInStill = false;',
        'if (!isIn.value) inInStill = false;',
        '',
        DuAEExpression.Library.get([
            'isStill',
            'lastActiveTime',
            'nextActiveTime',
            'continueOut',
            'continueIn',
            'cycleOut',
            'cycleIn',
            'pingPongOut',
            'pingPongIn',
            'bezierInterpolation',
            'gaussianInterpolation',
            'linearExtrapolation',
            'logisticInterpolation',
            'logInterpolation',
            'expInterpolation',
            'overshoot',
            'bounce'
        ]),
        '',
        'var result = value;',
        '',
        'function iAtTime( t )',
        '{',
        '  // Needed keyframes',
        '	var pKey = getPrevKey(t, thisProperty);',
        '	var nKey = getNextKey(t, thisProperty);',
        '	',
        '	if (!pKey || !nKey) return value;',
        '	',
        '	if (iType == 1) // None',
        '	{',
        '	  return valueAtTime(t);',
        '	}',
        '	else if (iType == 2) // Linear ',
        '	{',
        '	  return linear(',
        '			t,',
        '			pKey.time,',
        '			nKey.time,',
        '			pKey.value,',
        '			nKey.value',
        '		);',
        '	}',
        '	else if (iType == 3) // Bezier',
        '	{',
        '	  var bUseAdvanced = fx(' + i['Bezier options']['Use advanced options'].index + ').value;',
        '	    ',
        '    if (bUseAdvanced)',
        '    {',
        '      var bInI = fx(' + i['Bezier options']['Advanced']['In Influence'].index + ').value/100;',
        '      var bInV = fx(' + i['Bezier options']['Advanced']['In Velocity'].index + ').value/100;',
        '      var bOutI = fx(' + i['Bezier options']['Advanced']['Out Influence'].index + ').value/100;',
        '      var bOutV = fx(' + i['Bezier options']['Advanced']['Out Velocity'].index + ').value/100;',
        '      ',
        '      return bezierInterpolation(',
        '        t,',
        '        pKey.time,',
        '        nKey.time,',
        '        pKey.value,',
        '        nKey.value,',
        '        [bInI, bInV, 1 - bOutI, 1 - bOutV]',
        '      );',
        '    }',
        '    else',
        '    {',
        '      var bRatio = fx(' + i['Bezier options']['In/Out Ratio'].index + ').value / 100;',
        '      var bIn = linear(iRate, 0, 10, 0.0, 1.0) * bRatio;',
        '      var bOut = linear(iRate, 0, 10, 0.0, 1.0) * (1-bRatio);',
        '      bOut = 1 - bOut;',
        '      ',
        '      return bezierInterpolation(',
        '        t,',
        '        pKey.time,',
        '        nKey.time,',
        '        pKey.value,',
        '        nKey.value,',
        '        [bIn, 0, bOut, 1]',
        '      );',
        '    }',
        '	}',
        '	else if (iType == 4) // Gaussian ',
        '	{',
        '	  iRate = linear(iRate, 1, 30, -1, 1);',
        '	  return gaussianInterpolation(',
        '	    t,',
        '	    pKey.time,',
        '      nKey.time,',
        '      pKey.value,',
        '      nKey.value,',
        '      iRate',
        '	  );',
        '	}',
        '	else if (iType == 5) // Logistic',
        '	{',
        '	  var midRatio = fx(' + i['Logistic options']['Mid point'].index + ') / 100;',
        '	  var mid = pKey.time + ( nKey.time - pKey.time ) * midRatio;',
        '	  return logisticInterpolation(',
        '	    t,',
        '	    pKey.time,',
        '	    nKey.time,',
        '	    pKey.value,',
        '	    nKey.value,',
        '	    iRate,',
        '	    mid',
        '	  );',
        '	}',
        '	else if (iType == 6) // Logarithmic',
        '	{',
        '	  return logInterpolation(',
        '	    t,',
        '	    pKey.time,',
        '	    nKey.time,',
        '	    pKey.value,',
        '	    nKey.value,',
        '	    iRate',
        '	  );',
        '	}',
        '	else if (iType == 7) // Exponential ',
        '	{',
        '       iRate = linearExtrapolation(iRate, 0, 30, 0, 10);',
        '	    return expInterpolation(',
        '	        t,',
        '	        pKey.time,',
        '	        nKey.time,',
        '	        pKey.value,',
        '	        nKey.value,',
        '	        iRate',
        '	    );',
        '	}',
        '	',
        '	return -1;',
        '}',
        '',
        'function i() {',
        '	if (numKeys < 2) return value;',
        '',
        '	// Needed keyframes',
        '	var pKey = getPrevKey(time, thisProperty);',
        '	var nKey = getNextKey(time, thisProperty);',
        '	',
        '	// Extrapolation during still parts',
        '	if ( isStill( time, 0 ) )',
        '	{',
        '	  var inVal = value;',
        '	  var outVal = value;',
        '	  // In Extrapolation',
        '	  if (inInStill || !pKey)',
        '	  {',
        '	    var inTime = nextActiveTime(isIn, time);',
        '	    var nextKey = getNextKey(time, thisProperty);',
        '	    ',
        '	    if (inType == 3) inVal = cycleIn(inTime, inNumKeyframes, true, iAtTime, inDamping);',
        '			else if (inType == 4) inVal = cycleIn(inTime, inNumKeyframes, false, iAtTime, inDamping);',
        '			else if (inType == 5) inVal = pingPongIn(inTime, inNumKeyframes, iAtTime, inDamping);',
        '			else if (inType == 2 && isIn.value) {',
        '				if (iType == 1) inVal = continueIn(inTime, inDamping); // None',
        '				else if (iType == 2 && nextKey) // Linear ',
        '				{',
        '				    var firstVelocity = (nextKey.value - iAtTime(nextKey.time + 0.01)) * 100;',
        '  					var timeSpent = nextKey.time - time;',
        '  					var damp = Math.exp(timeSpent * inDamping);',
        '  					inVal = (timeSpent * firstVelocity)/damp + nextKey.value;',
        '				} else if (iType == 3 && nextKey) // Bezier',
        '				{',
        '					var bUseAdvanced = fx(' + i['Bezier options']['Use advanced options'].index + ').valueAtTime(nKey.time);',
        '					if (!bUseAdvanced) inVal = value;',
        '					else',
        '					{',
        '					  var bInV = fx(' + i['Bezier options']['Advanced']['In Velocity'].index + ').valueAtTime(nKey.time) / 100;',
        '  					if (bInV == 0) inVal = value;',
        '  					else ',
        '  					{',
        '  					  var firstVelocity = (iAtTime(nextKey.time + 0.01) - nextKey.value) * 100;',
        '    					var timeSpent = nextKey.time - time;',
        '    					var damp = Math.exp(timeSpent * inDamping);',
        '    					inVal = (-timeSpent * firstVelocity) / damp + nextKey.value;',
        '  					}',
        '					}',
        '				} else if (iType == 4) // Gaussian',
        '				{',
        '					inVal = value;',
        '				} else if (iType == 5 && nextKey) // Logistic',
        '				{',
        '					var previousKey = nextKey;',
        '					if (previousKey.index < numKeys)',
        '					{',
        '					  nextKey = key(previousKey.index + 1);',
        '  					var midRatio = fx(' + i['Logistic options']['Mid point'].index + ') / 100;',
        '  					var mid = previousKey.time + (nextKey.time - previousKey.time) * midRatio;',
        '  					inVal = logisticInterpolation(',
        '  						time,',
        '  						previousKey.time,',
        '  						nextKey.time,',
        '  						previousKey.value,',
        '  						nextKey.value,',
        '  						iRate,',
        '  						mid',
        '  					);',
        '  					var timeSpent = previousKey.time - time;',
        '  					var damp = Math.exp(timeSpent * inDamping);',
        '  					inVal = (inVal-value)/damp + value;',
        '					}',
        '				} else if (iType == 6) // Log',
        '				{',
        '					inVal = value;',
        '				} else if (iType == 7 && nextKey) // Exp ',
        '				{',
        '					var previousKey = nextKey;',
        '					if (previousKey.index < numKeys)',
        '					{',
        '					  var nextKey = key(previousKey.index + 1);',
        '  					inVal = expInterpolation(',
        '  						time,',
        '  						previousKey.time,',
        '  						nextKey.time,',
        '  						previousKey.value,',
        '  						nextKey.value,',
        '  						iRate',
        '  					);',
        '  					var timeSpent = previousKey.time - time;',
        '  					var damp = Math.exp(timeSpent * inDamping);',
        '  					inVal = (inVal-value)/damp + value;',
        '					}',
        '				}',
        '			}',
        '	  }',
        '	  // Out Extrapolation',
        '	  if (outInStill || !nKey)',
        '	  {',
        '	    var outTime = lastActiveTime(isOut, time);',
        '	    var prevKey = getPrevKey(time, thisProperty);',
        '	    ',
        '			if (outType == 3) outVal = cycleOut(outTime, outNumKeyframes, true, iAtTime, outDamping);',
        '			else if (outType == 4) outVal = cycleOut(outTime, outNumKeyframes, false, iAtTime, outDamping);',
        '			else if (outType == 5) outVal = pingPongOut(outTime, outNumKeyframes, iAtTime, outDamping);',
        '			else if (outType == 2 && isOut.value) {',
        '				if (iType == 1) outVal = continueOut(outTime, outDamping); // None',
        '				else if (iType == 2 && prevKey) // Linear ',
        '				{',
        '					var lastVelocity = (prevKey.value - iAtTime(prevKey.time - 0.01)) * 100;',
        '					var timeSpent = time - prevKey.time;',
        '					var damp = Math.exp(timeSpent * outDamping);',
        '					outVal = prevKey.value + (timeSpent * lastVelocity)/damp;',
        '				} else if (iType == 3 && prevKey) // Bezier',
        '				{',
        '					var bUseAdvanced = fx(' + i['Bezier options']['Use advanced options'].index + ').valueAtTime(pKey.time);',
        '					if (!bUseAdvanced) outVal = value;',
        '					else ',
        '					{',
        '					  var bOutV = fx(' + i['Bezier options']['Advanced']['Out Velocity'].index + ').valueAtTime(pKey.time) / 100;',
        '  					if (bOutV == 0) outVal = value;',
        '  					else',
        '  					{',
        '  					  var lastVelocity = ( prevKey.value - iAtTime(prevKey.time - 0.01)) * 100;',
        '    					var timeSpent = time - prevKey.time;',
        '    					var damp = Math.exp(timeSpent * outDamping);',
        '    					outVal = prevKey.value + (timeSpent * lastVelocity)/damp;',
        '  					}',
        '					}',
        '				} else if (iType == 4) // Gaussian',
        '				{',
        '					outVal = value;',
        '				} else if (iType == 5 && prevKey) // Logistic',
        '				{',
        '				  var nextKey = prevKey;',
        '				  if (nextKey.index > 0)',
        '				  {',
        '				    prevKey = key(nextKey.index - 1);',
        '  					var midRatio = fx(' + i['Logistic options']['Mid point'].index + ') / 100;',
        '  					var mid = prevKey.time + (nextKey.time - prevKey.time) * midRatio;',
        '  					outVal = logisticInterpolation(',
        '  						time,',
        '  						prevKey.time,',
        '  						nextKey.time,',
        '  						prevKey.value,',
        '  						nextKey.value,',
        '  						iRate,',
        '  						mid',
        '  					);',
        '  					var timeSpent = time - nextKey.time;',
        '  					var damp = Math.exp(timeSpent * outDamping);',
        '  					outVal = (outVal-value)/damp + value;',
        '				  }',
        '					',
        '				} else if (iType == 6 && prevKey) // Log',
        '				{',
        '					var nextKey = prevKey;',
        '				  if (nextKey.index > 0)',
        '				  {',
        '				    prevKey = key(nextKey.index - 1);',
        '				    outVal = logInterpolation(',
        '  						time,',
        '  						prevKey.time,',
        '  						nextKey.time,',
        '  						prevKey.value,',
        '  						nextKey.value,',
        '  						iRate',
        '  					);',
        '  					var timeSpent = time - nextKey.time;',
        '  					var damp = Math.exp(timeSpent * outDamping);',
        '  					outVal = (outVal-value)/damp + value;',
        '				  }',
        '				} else if (iType == 7 && prevKey) // Exp ',
        '				{',
        '					var nextKey = prevKey;',
        '				  if (nextKey.index > 0)',
        '				  {',
        '				    prevKey = key(nextKey.index - 1);',
        '				    outVal = expInterpolation(',
        '  						time,',
        '  						prevKey.time,',
        '  						nextKey.time,',
        '  						prevKey.value,',
        '  						nextKey.value,',
        '  						iRate',
        '  					);',
        '  					var timeSpent = time - nextKey.time;',
        '  					var damp = Math.exp(timeSpent * outDamping);',
        '  					outVal = (outVal-value)/damp + value;',
        '				  }',
        '				}',
        '			}',
        '			else if (outType == 6 && isOut.value) outVal = overShoot(time, elasticity, outDamping, iAtTime );',
        '			else if (outType == 7 && isOut.value) outVal = bounce(time, elasticity, outDamping, iAtTime );',
        '	  }',
        '	  ',
        '	  if (!pKey) return inVal;',
        '	  if (!nKey) return outVal;',
        '	  ',
        '	  // Blend',
        '	  if (inInStill && outInStill)',
        '	  {',
        '	    // Blend',
        '	    return ease( time, pKey.time, nKey.time, outVal, inVal);',
        '	  }',
        '	  if (inInStill) return inVal;',
        '	  if (outInStill) return outVal;',
        '	  return value;',
        '	}',
        '',
        '	return iAtTime(time);',
        '}',
        '',
        'if (fx.enabled) result = i();',
        'result;'//*/
        ].join('\n');

    // Add expressions
    props.do(function (prop)
    {
        prop = new DuAEProperty(prop);
        // Only for riggable props (no recursion)
        if (prop.riggable())
            prop.setExpression( exp, false );
    });

    DuAE.endUndoGroup(DuScriptUI.String.INTERPOLATOR);

    return effect;
};

Duik.CmdLib['Animation']["Add roving key"] = "Duik.Animation.addRovingKey()";
/**
 * Adds a roving key to the properties at current time
 * @param {Bool} [animatedProps=true] Set to false to add a key to all selected properties, instead of all animated properties.
 * @param {Bool} [selectedLayers=true] Set to false to add a key to all layers instead of just the selection.
 */
Duik.Animation.addRovingKey = function(animatedProps, selectedLayers)
{
    animatedProps = def(animatedProps, true);
    selectedLayers = def(selectedLayers, true);

    DuAE.beginUndoGroup(DuScriptUI.String.ROVING, false);

    var props;
    if (animatedProps) props = DuAEComp.getAnimatedProps(undefined, undefined, undefined, selectedLayers);
    else props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.addKey('roving');
    });

    DuAE.endUndoGroup(DuScriptUI.String.ROVING);
};

Duik.CmdLib['Animation']["Set roving"] = "Duik.Animation.setRoving()";
/**
 * Sets the selected keyframes to roving
 */
Duik.Animation.setRoving = function() {
    var props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    DuAE.beginUndoGroup(DuScriptUI.String.ROVING, false);

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.setInterpolation('roving', undefined, undefined, undefined, true);
    });

    DuAE.endUndoGroup(DuScriptUI.String.ROVING);
};

Duik.CmdLib['Animation']["Add linear key"] = "Duik.Animation.addLinearKey()";
/**
 * Adds a linear key to the properties at current time
 * @param {Bool} [animatedProps=true] Set to false to add a key to all selected properties, instead of all animated properties.
 * @param {Bool} [selectedLayers=true] Set to false to add a key to all layers instead of just the selection.
 */
Duik.Animation.addLinearKey = function(animatedProps, selectedLayers)
{
    animatedProps = def(animatedProps, true);
    selectedLayers = def(selectedLayers, true);

    DuAE.beginUndoGroup(DuScriptUI.String.LINEAR, false);

    var props;
    if (animatedProps) props = DuAEComp.getAnimatedProps(undefined, undefined, undefined, selectedLayers);
    else props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.addKey(KeyframeInterpolationType.LINEAR);
    });

    DuAE.endUndoGroup(DuScriptUI.String.LINEAR);
};

Duik.CmdLib['Animation']["Set linear"] = "Duik.Animation.setLinear()";
/**
 * Sets the selected keyframes to linear
 */
Duik.Animation.setLinear = function() {
    var props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    DuAE.beginUndoGroup(DuScriptUI.String.LINEAR, false);

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.setInterpolation(KeyframeInterpolationType.LINEAR, undefined, undefined, undefined, true);
    });

    DuAE.endUndoGroup(DuScriptUI.String.LINEAR);
};

Duik.CmdLib['Animation']["Add Ease In key"] = "Duik.Animation.addEaseInKey()";
/**
 * Adds an Ease In key to the properties at current time
 * @param {Bool} [animatedProps=true] Set to false to add a key to all selected properties, instead of all animated properties.
 * @param {Bool} [selectedLayers=true] Set to false to add a key to all layers instead of just the selection.
 */
Duik.Animation.addEaseInKey = function(animatedProps, selectedLayers)
{
    animatedProps = def(animatedProps, true);
    selectedLayers = def(selectedLayers, true);

    DuAE.beginUndoGroup(DuScriptUI.String.EASE_IN, false);

    var props;
    if (animatedProps) props = DuAEComp.getAnimatedProps(undefined, undefined, undefined, selectedLayers);
    else props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.addKey(KeyframeInterpolationType.BEZIER, KeyframeInterpolationType.LINEAR );
    });

    DuAE.endUndoGroup(DuScriptUI.String.EASE_IN);
};

Duik.CmdLib['Animation']["Set ease in"] = "Duik.Animation.setEaseIn()";
/**
 * Sets the selected keyframes to ease in
 */
Duik.Animation.setEaseIn = function() {
    var props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    DuAE.beginUndoGroup(DuScriptUI.String.EASE_IN, false);

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.setInterpolation(KeyframeInterpolationType.BEZIER, KeyframeInterpolationType.LINEAR, undefined, undefined, true);
    });

    DuAE.endUndoGroup(DuScriptUI.String.EASE_IN);
};

Duik.CmdLib['Animation']["Add Ease Out key"] = "Duik.Animation.addEaseOutKey()";
/**
 * Adds an Ease Out key to the properties at current time
 * @param {Bool} [animatedProps=true] Set to false to add a key to all selected properties, instead of all animated properties.
 * @param {Bool} [selectedLayers=true] Set to false to add a key to all layers instead of just the selection.
 */
Duik.Animation.addEaseOutKey = function(animatedProps, selectedLayers)
{
    animatedProps = def(animatedProps, true);
    selectedLayers = def(selectedLayers, true);

    DuAE.beginUndoGroup(DuScriptUI.String.EASE_OUT, false);

    var props;
    if (animatedProps) props = DuAEComp.getAnimatedProps(undefined, undefined, undefined, selectedLayers);
    else props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.addKey(KeyframeInterpolationType.LINEAR, KeyframeInterpolationType.BEZIER );
    });

    DuAE.endUndoGroup(DuScriptUI.String.EASE_OUT);
};

Duik.CmdLib['Animation']["Set ease out"] = "Duik.Animation.setEaseOut()";
/**
 * Sets the selected keyframes to ease out
 */
Duik.Animation.setEaseOut = function() {
    var props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    DuAE.beginUndoGroup(DuScriptUI.String.EASE_OUT, false);

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.setInterpolation(KeyframeInterpolationType.LINEAR, KeyframeInterpolationType.BEZIER, undefined, undefined, true);
    });

    DuAE.endUndoGroup(DuScriptUI.String.EASE_OUT);
};

Duik.CmdLib['Animation']["Add Easy Ease key"] = "Duik.Animation.addEasyEaseKey()";
/**
 * Adds an Easy Ease key to the properties at current time
 * @param {Bool} [animatedProps=true] Set to false to add a key to all selected properties, instead of all animated properties.
 * @param {Bool} [selectedLayers=true] Set to false to add a key to all layers instead of just the selection.
 */
Duik.Animation.addEasyEaseKey = function(animatedProps, selectedLayers)
{
    animatedProps = def(animatedProps, true);
    selectedLayers = def(selectedLayers, true);

    DuAE.beginUndoGroup(DuScriptUI.String.EASY_EASE, false);

    var props;
    if (animatedProps) props = DuAEComp.getAnimatedProps(undefined, undefined, undefined, selectedLayers);
    else props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.addKey(KeyframeInterpolationType.BEZIER, KeyframeInterpolationType.BEZIER );
    });

    DuAE.endUndoGroup(DuScriptUI.String.EASY_EASE);
};

Duik.CmdLib['Animation']["Set easy ease"] = "Duik.Animation.setEasyEase()";
/**
 * Sets the selected keyframes to easy ease
 */
Duik.Animation.setEasyEase = function() {
    var props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    DuAE.beginUndoGroup(DuScriptUI.String.EASY_EASE, false);

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.setInterpolation(KeyframeInterpolationType.BEZIER, KeyframeInterpolationType.BEZIER, undefined, undefined, true);
    });

    DuAE.endUndoGroup(DuScriptUI.String.EASY_EASE);
};

Duik.CmdLib['Animation']["Add Continuous key"] = "Duik.Animation.addContinuousKey()";
/**
 * Adds a Continuous key to the properties at current time
 * @param {Bool} [animatedProps=true] Set to false to add a key to all selected properties, instead of all animated properties.
 * @param {Bool} [selectedLayers=true] Set to false to add a key to all layers instead of just the selection.
 */
Duik.Animation.addContinuousKey = function(animatedProps, selectedLayers)
{
    animatedProps = def(animatedProps, true);
    selectedLayers = def(selectedLayers, true);

    DuAE.beginUndoGroup(DuScriptUI.String.CONTINUOUS, false);

    var props;
    if (animatedProps) props = DuAEComp.getAnimatedProps(undefined, undefined, undefined, selectedLayers);
    else props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.addKey('continuous');
    });

    DuAE.endUndoGroup(DuScriptUI.String.CONTINUOUS);
};

Duik.CmdLib['Animation']["Set continuous"] = "Duik.Animation.setContinuous()";
/**
 * Sets the selected keyframes to continuous
 */
Duik.Animation.setContinuous = function() {
    var props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    DuAE.beginUndoGroup(DuScriptUI.String.CONTINUOUS, false);

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.setInterpolation('continuous', undefined, undefined, undefined, true);
    });

    DuAE.endUndoGroup(DuScriptUI.String.CONTINUOUS);
};

Duik.CmdLib['Animation']["Add Hold key"] = "Duik.Animation.addHoldKey()";
/**
 * Adds a Hold key to the properties at current time
 * @param {Bool} [animatedProps=true] Set to false to add a key to all selected properties, instead of all animated properties.
 * @param {Bool} [selectedLayers=true] Set to false to add a key to all layers instead of just the selection.
 */
Duik.Animation.addHoldKey = function(animatedProps, selectedLayers)
{
    animatedProps = def(animatedProps, true);
    selectedLayers = def(selectedLayers, true);

    DuAE.beginUndoGroup(DuScriptUI.String.HOLD, false);

    var props;
    if (animatedProps) props = DuAEComp.getAnimatedProps(undefined, undefined, undefined, selectedLayers);
    else props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.addKey(KeyframeInterpolationType.HOLD);
    });

    DuAE.endUndoGroup(DuScriptUI.String.HOLD);
};

Duik.CmdLib['Animation']["Set hold"] = "Duik.Animation.setHold()";
/**
 * Sets the selected keyframes to hold
 */
Duik.Animation.setHold = function() {
    var props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    DuAE.beginUndoGroup(DuScriptUI.String.HOLD, false);

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.setInterpolation(KeyframeInterpolationType.HOLD, undefined, undefined, undefined, true);
    });

    DuAE.endUndoGroup(DuScriptUI.String.HOLD);
};

/**
 * Sets the ease values on the selected keyframes
 * @param {float} easeIn The in ease
 * @param {float} easeOut The out ease
 */
Duik.Animation.setEase = function( easeIn, easeOut ) {
    var props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    DuAE.beginUndoGroup(DuScriptUI.String.SET_EASE, false);

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.setEase(easeIn, easeOut);
    });

    DuAE.endUndoGroup(DuScriptUI.String.SET_EASE);
}

/**
 * Sets the velocity values on the selected keyframes
 * @param {float} vIn The in velocity
 * @param {float} vOut The out velocity
 */
Duik.Animation.setVelocity = function( vIn, vOut ) {
    var props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    DuAE.beginUndoGroup(DuScriptUI.String.SET_VELOCITY, false);

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.setEase(undefined, undefined, vIn, vOut, true);
    });

    DuAE.endUndoGroup(DuScriptUI.String.SET_VELOCITY);
}

/**
 * Sets the selected keyframes spatial interpolation
 */
Duik.Animation.setSpatialInterpolation = function( inType, outType) {
    var props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    outType = def(outType, inType);

    DuAE.beginUndoGroup(DuScriptUI.String.SPATIAL_INTERPOLATION, false);

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.setSpatialInterpolation( inType, outType, true );
    });

    DuAE.endUndoGroup(DuScriptUI.String.SPATIAL_INTERPOLATION);
};

Duik.CmdLib['Animation']["Set spatial linear"] = "Duik.Animation.setSpatialLinear()";
/**
 * Sets the selected keyframes spatial interpolation to linear
 */
Duik.Animation.setSpatialLinear = function() {
    Duik.Animation.setSpatialInterpolation(KeyframeInterpolationType.LINEAR);
};

Duik.CmdLib['Animation']["Set spatial bezier in"] = "Duik.Animation.setSpatialBezierIn()";
/**
 * Sets the selected keyframes spatial interpolation to linear
 */
Duik.Animation.setSpatialBezierIn = function() {
    Duik.Animation.setSpatialInterpolation(KeyframeInterpolationType.BEZIER, KeyframeInterpolationType.LINEAR);
};

Duik.CmdLib['Animation']["Set spatial bezier out"] = "Duik.Animation.setSpatialBezierOut()";
/**
 * Sets the selected keyframes spatial interpolation to linear
 */
Duik.Animation.setSpatialBezierOut = function() {
    Duik.Animation.setSpatialInterpolation(KeyframeInterpolationType.LINEAR, KeyframeInterpolationType.BEZIER);
};

Duik.CmdLib['Animation']["Set spatial bezier"] = "Duik.Animation.setSpatialBezier()";
/**
 * Sets the selected keyframes spatial interpolation to linear
 */
Duik.Animation.setSpatialBezier = function() {
    Duik.Animation.setSpatialInterpolation(KeyframeInterpolationType.BEZIER, KeyframeInterpolationType.BEZIER);
};

Duik.CmdLib['Animation']["Fix spatial interpolation"] = "Duik.Animation.fixSpatialInterpolation()";
/**
 * Sets the selected keyframes spatial interpolation to linear
 */
Duik.Animation.fixSpatialInterpolation = function() {
    var props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    DuAE.beginUndoGroup(DuScriptUI.String.SPATIAL_INTERPOLATION, false);

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.fixSpatialInterpolation( undefined, true );
    });

    DuAE.endUndoGroup(DuScriptUI.String.SPATIAL_INTERPOLATION);
};

/**
 * Adds a key to the properties at current time, tweening according to the previous and next keyframe
 * @param {float} [tweenRatio=0.5] The value ratio for tweening: 0.0 is the value of the previous key, 1.0 is the value of the next key. Note that this value can be < 0 and > 1.0 if you wish.
 * @param {Bool} [animatedProps=true] Set to false to add a key to all selected properties, instead of all animated properties.
 * @param {Bool} [selectedLayers=true] Set to false to add a key to all layers instead of just the selection.
 */
Duik.Animation.tween = function(tweenRatio, animatedProps, selectedLayers) {
    tweenRatio = def(tweenRatio, 0.5);
    animatedProps = def(animatedProps, true);
    selectedLayers = def(selectedLayers, true);

    var props;
    if (animatedProps) props = DuAEComp.getAnimatedProps(undefined, undefined, undefined, selectedLayers);
    else props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    DuAE.beginUndoGroup(DuScriptUI.String.TWEEN, false);

    props.do(function(prop) {
        var numKeys = prop.numKeys(false);
        if (numKeys == 0) return;
        // Current time
        var time = prop.comp.time;
        // Values
        var nKey = prop.nearestKeyAtTime(time);
        var pKey;
        // There's a keyframe at the current time, remove it and try again
        if (nKey._time == time && nKey._index != 0 && nKey._index != numKeys) {
            prop.removeKey(nKey);
            nKey = prop.nearestKeyAtTime(time);
        }
        // Get the previous key
        if (nKey._time < time) {
            // It's the last one; ignore
            if (nKey._index == numKeys) return;
            pKey = nKey;
            nKey = prop.keyAtIndex(nKey._index + 1);
        }
        else {
            // It's the first one; just set a new key at current time
            if (nKey._index == 0) return;
            pKey = prop.keyAtIndex(nKey._index - 1);
        }
    
        // Interpolate the value and set the new key
        var newValue = DuMath.linear(tweenRatio, 0.0, 1.0, pKey.value, nKey.value);
        prop.setValueAtTime( newValue, time);
    });

    DuAE.endUndoGroup(DuScriptUI.String.TWEEN, false);
};

Duik.CmdLib['Animation']["Split keys"] = "Duik.Animation.splitKeys()";
/**
 * Splits the selected keyframes into couple of keyframes with the same values
 * @param {int} [duration=2] The number of frames between the two keyframes.
 * @param {DuAE.TimeAlignment} [alignment = DuAE.TimeAlignment.CENTER] How to align the new keyframes according to the current time.
 */
Duik.Animation.splitKeys = function( duration, alignment ) {
    var props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    alignment = def(alignment, DuAE.TimeAlignment.CENTER);
    duration = def(duration, 2);

    if (isNaN(duration)) duration  = 2;
    if (duration < 1) duration = 1;
    duration = Math.abs(duration);

    DuAE.beginUndoGroup(DuScriptUI.String.SPLIT_KEYS, false);

    // When modifying properties, keys are deselected. Let's keep the list.
    var selectedKeys = [];
    props.do(function(prop) {
        selectedKeys.push(prop.selectedKeys());
    });

    props.do(function(prop) {
        if (prop.isGroup()) return;
        var d = prop.comp.frameDuration * duration;
        // For each selected keyframe
        var keys = selectedKeys[props.current];
        for (var i=keys.length-1; i >= 0; i--) {
            var key = prop.keyAtIndex(keys[i]);

            var pKey, nKey;

            if (alignment == DuAE.TimeAlignment.CENTER) {
                prop.removeKey(key);

                var pD = -d/2;
                var nD = d/2;
                // Snap!
                if (duration % 2 == 1) {
                    pD += prop.comp.frameDuration / 2;
                    nD += prop.comp.frameDuration / 2;
                }

                pKey = key._clone();
                pKey._time += pD;
                prop.setKey(pKey, 0);

                nKey = key._clone();
                nKey._time += nD;
                nKey._index++;

                prop.setKey(nKey, 0);
            }
            else if (alignment == DuAE.TimeAlignment.IN_POINT) {
                nKey = key._clone();
                nKey._time += d;
                nKey._index++;
                prop.setKey(nKey, 0);

                pKey = key._clone();
            }
            else {
                nKey = key._clone();
                nKey._index++;

                pKey = key._clone();
                pKey._time -= d;
                prop.setKey(pKey, 0);
            }

            // Adjust spatial interpolation
            prop.setSpatialTangentsAtKey( pKey, prop.keyInSpatialTangent(pKey), [0,0]);
            prop.setSpatialTangentsAtKey( nKey, [0,0], prop.keyOutSpatialTangent(nKey));
        }
    });

    DuAE.endUndoGroup(DuScriptUI.String.SPLIT_KEYS);
};

Duik.CmdLib['Animation']["Freeze pose"] = "Duik.Animation.freezePose()";
/**
 * Freezes the pose; copies the previous keyframe to the current time.
 * @param {Bool} [animatedProps=true] Set to false to add a key to all selected properties, instead of all animated properties.
 * @param {Bool} [selectedLayers=true] Set to false to add a key to all layers instead of just the selection.
 * @param {Bool} [useNextPose=false] If true, will freeze the next pose instead of the previous one (copies the next keyframe to the current time).
 */
Duik.Animation.freezePose = function(animatedProps, selectedLayers, useNextPose) {
    useNextPose = def(useNextPose, false);
    animatedProps = def(animatedProps, true);
    selectedLayers = def(selectedLayers, true);

    var props;
    if (animatedProps) props = DuAEComp.getAnimatedProps(undefined, undefined, undefined, selectedLayers);
    else props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    DuAE.beginUndoGroup(DuScriptUI.String.FREEZE_POSE, false);

    props.do(function(prop) {
        if (prop.isGroup()) return;
        // Get the previous keyframe (or next)
        var time = prop.comp.time;
        var key = prop.nearestKeyAtTime( time );
        // Adjust
        if (useNextPose && key._time <= time) {
            if (key._index == prop.numKeys()) return;
            key = prop.keyAtIndex( key._index + 1);
        }
        else if (!useNextPose && key._time >= time) {
            if (key._index == 1) return;
            key = prop.keyAtIndex( key._index - 1);
        }
        key._time = 0;
        // Set new key
        prop.setKey(key, time);
        // Adjust spatial interpolation
        prop.setSpatialTangentsAtKey( key._index, prop.keyInSpatialTangent(key._index), [0,0]);
        prop.setSpatialTangentsAtKey( key._index + 1, [0,0], prop.keyOutSpatialTangent(key._index + 1));
    });
    
    DuAE.endUndoGroup(DuScriptUI.String.FREEZE_POSE);
};

Duik.CmdLib['Animation']["Cel onion skin"] = "Duik.Animation.celOnionSkin()";
/**
 * (De)activates or updates the onion skin of a Duik cel animation comp.
 * @param {Boolean} [enabled=true] If omitted, will try to get it from the existing cels.
 * @param {int} [frames=5] The duration (in frames) of the onion skin. If omitted, will try to get it from the existing cels.
 * @param {int} [exposure=2] The animation exposure. If omitted, will try to get it from the existing cels.
 * @param {float} [inOpacity=50] The in opacity. If omitted, will try to get it from the existing cels.
 * @param {float} [outOpacity=50] The out opacity. If omitted, will try to get it from the existing cels.
 */
Duik.Animation.celOnionSkin = function( enabled, frames, exposure, inOpacity, outOpacity) {

    frames = def(frames, -1);
    exposure = def(exposure, -1);
    inOpacity = def(inOpacity, -1);
    outOpacity = def(outOpacity, -1);

    if (isNaN(frames)) frames = 5;

    if (isNaN(exposure)) exposure = 2;

    if (inOpacity == 0 && outOpacity == 0) enabled = false;

    var comp = DuAEProject.getActiveComp();
    if (!comp) return;

    var layers = comp.selectedLayers;
    if (layers.length == 0) layers = comp.layers;
    layers = new DuList(layers);

    DuAE.beginUndoGroup(DuScriptUI.String.ONION_SKIN, false);
    
    // TODO Get/Set settings to the layer if enabled
    layers.do(function(layer) {

        var tag = DuAETag.get(layer);

        // Try to get parameters from the layer tags
        if (typeof enabled === 'undefined') enabled = DuAETag.getValue( layer, DuAETag.Key.DUIK_CEL_ONION_SKIN_ENABLED, DuAETag.Type.BOOL, tag );
        if (enabled === null) enabled = true;

        if (frames < 1) frames = DuAETag.getValue( layer, DuAETag.Key.DUIK_CEL_ONION_SKIN_FRAMES, DuAETag.Type.INT, tag );
        if (frames === null) frames = 5;

        if (exposure < 1) exposure = DuAETag.getValue( layer, DuAETag.Key.DUIK_CEL_EXPOSURE, DuAETag.Type.INT, tag );
        if (exposure === null) exposure = 2;

        if (inOpacity < 0) inOpacity = DuAETag.getValue( layer, DuAETag.Key.DUIK_CEL_ONION_SKIN_IN, DuAETag.Type.FLOAT, tag );
        if (inOpacity === null) inOpacity = 50;

        if (outOpacity < 0) outOpacity = DuAETag.getValue( layer, DuAETag.Key.DUIK_CEL_ONION_SKIN_OUT, DuAETag.Type.FLOAT, tag );
        if (outOpacity === null) outOpacity = 50;

        for (var i = 1 ; i <= layer.Effects.numProperties ; i++)
        {
            var paint = layer.effect(i);
            if (!paint) continue;
            if (paint.matchName != "ADBE Paint") continue;
            if (paint.name.indexOf(DuScriptUI.String.CELLULOID) < 0) continue;
            for (var j = 1 ; j <= paint.property("ADBE Paint Group").numProperties ; j++)
            {
                var stroke = paint.property("ADBE Paint Group")(j);
                if (stroke.matchName != "ADBE Paint Atom") continue;

                var inPoint = stroke.property("ADBE Paint Duration").value[0];
                var duration = stroke.property("ADBE Paint Duration").value[1];

                //adjust exposure
                if (stroke.name.indexOf("#Duik") < 0)
                {
                    duration = exposure*comp.frameDuration;
                    stroke.property("ADBE Paint Duration").setValue([inPoint,duration]);
                    stroke.name = stroke.name + " #Duik";
                }

                DuAETag.setValue( layer, DuAETag.Key.DUIK_CEL_ONION_SKIN_ENABLED, enabled, tag );

                if (enabled)
                {
                    //stroke.property("ADBE Paint Transfer Mode") : blending mode
                    var outPoint = duration + inPoint;
                    var opacity = stroke.property("ADBE Paint Properties").property("ADBE Paint Opacity");
                    //if keyframes (already activated)
                    if (opacity.numKeys > 0)
                    {
                        if (stroke.name.indexOf("#Out") >= 0 && stroke.name.indexOf("#In") < 0)
                        {
                            outPoint = opacity.keyTime(2) - layer.startTime;
                        }
                        else if (stroke.name.indexOf("#Out") < 0 && stroke.name.indexOf("#In") >= 0)
                        {
                            inPoint = opacity.keyTime(3) - layer.startTime;
                        }
                        else if (stroke.name.indexOf("#Out") >= 0 && stroke.name.indexOf("#In") >= 0)
                        {
                            inPoint = opacity.keyTime(3) - layer.startTime;
                            outPoint = opacity.keyTime(5) - layer.startTime;
                        }

                        //remove keys
                        while (opacity.numKeys>0)
                        {
                            opacity.removeKey(1);
                        }
                        opacity.setValue(100);
                        stroke.name = stroke.name.replace(/ #Out/g,"");
                        stroke.name = stroke.name.replace(/ #In/g,"");

                        // Set tags
                        DuAETag.setValue( layer, DuAETag.Key.DUIK_CEL_ONION_SKIN_FRAMES, frames, tag );
                        DuAETag.setValue( layer, DuAETag.Key.DUIK_CEL_EXPOSURE, exposure, tag );
                        DuAETag.setValue( layer, DuAETag.Key.DUIK_CEL_ONION_SKIN_IN, inOpacity, tag );
                        DuAETag.setValue( layer, DuAETag.Key.DUIK_CEL_ONION_SKIN_OUT, outOpacity, tag );
                    }

                    //set duration
                    if (outOpacity > 0 && inOpacity <= 0)
                    {
                        duration = outPoint - inPoint + frames*comp.frameDuration;
                        stroke.property("ADBE Paint Duration").setValue([inPoint,duration]);
                    }
                    else if (outOpacity <= 0 && inOpacity > 0)
                    {
                        duration = outPoint - inPoint + frames*comp.frameDuration;
                        stroke.property("ADBE Paint Duration").setValue([inPoint-frames*comp.frameDuration,duration]);
                    }
                    else
                    {
                        duration = outPoint - inPoint + 2*frames*comp.frameDuration;
                        stroke.property("ADBE Paint Duration").setValue([inPoint-frames*comp.frameDuration,duration]);
                    }


                    //add keyframes
                    if (outOpacity > 0)
                    {
                        opacity.setValueAtTime(outPoint-comp.frameDuration+layer.startTime,100);
                        opacity.setValueAtTime(outPoint+layer.startTime,outOpacity);
                        opacity.setValueAtTime(outPoint + frames*comp.frameDuration+layer.startTime,0);
                        stroke.name = stroke.name + " #Out";
                    }
                    if (inOpacity > 0)
                    {
                        opacity.setValueAtTime(inPoint+layer.startTime,100);
                        opacity.setValueAtTime(inPoint-frames*comp.frameDuration+layer.startTime,0);
                        opacity.setValueAtTime(inPoint-comp.frameDuration+layer.startTime,inOpacity);
                        stroke.name = stroke.name + " #In";
                    }

                }
                else
                {
                    var opacity = stroke.property("ADBE Paint Properties").property("ADBE Paint Opacity");
                    if (opacity.numKeys > 0)
                    {
                        inPoint = 0;
                        outPoint = 1;
                        if (stroke.name.indexOf("#Out") >= 0 && stroke.name.indexOf("#In") < 0)
                        {
                            inPoint = stroke.property("ADBE Paint Duration").value[0];
                            outPoint = opacity.keyTime(2);
                        }
                        else if (stroke.name.indexOf("#Out") < 0 && stroke.name.indexOf("#In") >= 0)
                        {
                            outPoint = stroke.property("ADBE Paint Duration").value[0] + stroke.property("ADBE Paint Duration").value[1];
                            inPoint = opacity.keyTime(3);
                        }
                        else if (stroke.name.indexOf("#Out") >= 0 && stroke.name.indexOf("#In") >= 0)
                        {
                            inPoint = opacity.keyTime(3);
                            outPoint = opacity.keyTime(5);
                        }


                        while (opacity.numKeys>0)
                        {
                            opacity.removeKey(1);
                        }
                        opacity.setValue(100);
                        //set duration
                        var o = outPoint-inPoint;
                        var i = inPoint;
                        if (stroke.name.indexOf("#Out") >= 0 && stroke.name.indexOf("#In") < 0) o = o-layer.startTime;
                        else if (stroke.name.indexOf("#Out") < 0) o = o + layer.startTime;
                        if (stroke.name.indexOf("#In") >= 0) i = i-layer.startTime;

                        stroke.property("ADBE Paint Duration").setValue([i,o]);

                        stroke.name = stroke.name.replace(/ #In/g,"");
                        stroke.name = stroke.name.replace(/ #Out/g,"");
                    }
                }
            }
        }

        //deselect
        while(layer.selectedProperties.length > 0)
        {
            layer.selectedProperties[0].selected = false;
        }
    });

    DuAE.endUndoGroup(DuScriptUI.String.ONION_SKIN);
};

Duik.CmdLib['Animation']["New Cel"] = "Duik.Animation.newCel()";
/**
 * Creates a new cel for a Duik cel animation
 * @param {Boolean} [createNewLayer=false] Set to true to create the cel on a new layer
 */
Duik.Animation.newCel = function( createNewLayer ) {
    var comp = DuAEProject.getActiveComp();
    if (!comp) return;

    createNewLayer = def(createNewLayer, false);

    var layer = null;

    if (!createNewLayer) {
        layer = Duik.Layer.get( Duik.Layer.Type.CEL, true, comp );
        if (layer.length == 0) layer = Duik.Layer.get( Duik.Layer.Type.CEL, false, comp );
        if (layer.length > 0) layer = layer[0];
        else layer = null;
    }

    DuAE.beginUndoGroup(DuScriptUI.String.NEW_CEL, false);

    if (!layer) {
        layer = comp.layers.addSolid( [0,0,0], DuScriptUI.String.CELLULOID, comp.width, comp.height, comp.pixelAspect, comp.duration );
        Duik.Layer.setType(Duik.Layer.Type.CEL, layer);
    }

    var first = true;
	for (var i = 1 ; i <= layer('ADBE Effect Parade').numProperties ; i++)
	{
		if (layer.effect(i).matchName == 'ADBE Paint')
		{
			first = false;
			break;
		}
	}

	var newName = DuAELayer.newUniqueEffectName(DuScriptUI.String.CELLULOID,layer);
	var paint = layer('ADBE Effect Parade').addProperty('ADBE Paint');
	paint.name = newName;

	if (first) paint.property('ADBE Paint On Transparent').setValue(true);

    DuAE.endUndoGroup(DuScriptUI.String.NEW_CEL);
};

Duik.CmdLib['Animation']["Previous Cel"] = "Duik.Animation.previousCel()";
/**
 * Goes to the previous frame in a Duik cel animation
 * @param {int} [exposure=2] The animation exposure
 */
Duik.Animation.previousCel = function(exposure) {
    var comp = DuAEProject.getActiveComp();
    if (!comp) return;

    exposure = def(exposure,2);
    if (isNaN(exposure)) exposure = 2;
    if (exposure < 1) exposure = 1;

    comp.time = comp.time - comp.frameDuration * exposure;

    Duik.Animation.celOnionSkin();
};

Duik.CmdLib['Animation']["Next Cel"] = "Duik.Animation.nextCel()";
/**
 * Goes to the next frame in a Duik cel animation
 * @param {int} [exposure=2] The animation exposure
 */
Duik.Animation.nextCel = function(exposure) {
    var comp = DuAEProject.getActiveComp();
    if (!comp) return;

    exposure = def(exposure,2);
    if (isNaN(exposure)) exposure = 2;
    if (exposure < 1) exposure = 1;

    comp.time = comp.time + comp.frameDuration * exposure;

    Duik.Animation.celOnionSkin();
};

Duik.CmdLib['Animation']["Snap keys"] = "Duik.Animation.snapKeys()";
/**
 * Snaps selected (or all) keyframes to the closest frames if they're in between.
 */
Duik.Animation.snapKeys = function() {
    var props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    var selected = true;
    if (props.length() == 0) {
        var comp = DuAEProject.getActiveComp();
        if (!comp) return;
        if (comp.selectedLayers.length > 0) props = new DuList(comp.selectedLayers);
        else props = new DuList(comp.layers);
        selected = false;
    }

    if (props.length() == 0) return;

    DuAE.beginUndoGroup(DuScriptUI.String.SNAP_KEYS, false);

    // When modifying properties, keys are deselected. Let's keep the list.
    var selectedKeys = [];
    if (selected) {
        props.do(function(prop) {
            selectedKeys.push(prop.selectedKeys());
        });
    }

    props.do(function(prop) {
        prop = new DuAEProperty(prop);
        prop.snapKeys(selectedKeys[props.current]);
    });

    DuAE.endUndoGroup(DuScriptUI.String.SNAP_KEYS);
}

Duik.CmdLib['Animation']["Sync keys"] = "Duik.Animation.syncKeys()";
/**
 * Syncs the selected keyframes; moves them to the current time.< br />
 * If multiple keyframes are selected for the same property, they're offset to the current time, keeping the animation.
 */
Duik.Animation.syncKeys = function() {
    var props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length() == 0) return;

    DuAE.beginUndoGroup(DuScriptUI.String.SYNC, false);

    // When modifying properties, keys are deselected. Let's keep the list.
    var selectedKeys = [];
    props.do(function(prop) {
        selectedKeys.push(prop.selectedKeys());
    });

    props.do(function(prop) {
        if (prop.isGroup()) return;
        var keys = selectedKeys[props.current];
        if (keys.length == 0) return;
        // Get offset
        var fKey = prop.keyAtIndex( keys[0] );
        var offset = fKey._time - prop.comp.time;
        // Move key
        for (var k = 0; k < keys.length; k++) {
            var key = prop.keyAtIndex( keys[k] );
            prop.removeKey( key );
            prop.setKey(key, -offset);
        }
    });

    DuAE.endUndoGroup(DuScriptUI.String.SYNC);
}

Duik.CmdLib['Animation']["Sequence layers"] = "Duik.Animation.sequenceLayers()";
/**
 * Sequences selected layers.
 * @param {int} [duration=24] The transition duration, in frames
 * @param {Bool} [moveLayers=true] If set to false, the layer are not moved, and the in or out points are changed instead (layers are "cut")
 * @param {Bool} [useInPoints=true] If moveLayers is false, setting this to false changes the out points instead of the in points (cuts the end instead of the start).
 * @param {Bool} [reverse=false] Set to true to reverse the order.
 * @param {function} [interpolation=DuInterpolation.linear] An interpolation function, taking 4 arguments in the form <code>i(value, min, max, targetMin, targetMax)</code>
 */
Duik.Animation.sequenceLayers = function(duration, moveLayers, useInPoints, reverse, interpolation) {
    var comp = DuAEProject.getActiveComp();
    if (!comp) return;
    var layers = comp.selectedLayers;
    if (layers.length == 0) layers = comp.layers;
    layers = new DuList(layers);
    if (layers.length() == 0) return;

    duration = def(duration, 24);
    moveLayers = def(moveLayers, true);
    useInPoints = def(useInPoints, true);
    reverse = def(reverse, false);
    interpolation = def(interpolation, DuMath.linear);

    DuAE.beginUndoGroup(DuScriptUI.String.SEQUENCE, false);

    var n = layers.length();
    var startTime = comp.time;
    duration = duration * comp.frameDuration;
    var endTime = startTime + duration;

    for (var i = 0; i < n; i++) {
        var layer = layers.at(i);
        var s = reverse ? 0 : n-1;
        var e = reverse ? n-1 : 0;
        newTime = interpolation(i, s, e, startTime, endTime);
        if (moveLayers) layer.startTime = newTime - (layer.inPoint - layer.startTime);
        else if (useInPoints) {
            var out = layer.outPoint;
            if (newTime >= layer.outPoint) newTime = layer.outPoint - comp.frameDuration;
            layer.inPoint = newTime;
            layer.outPoint = out;
        }
        else {
            if (newTime <= layer.inPoint) newTime = layer.inPoint + comp.frameDuration;
            layer.outPoint = newTime;
        }
    }//*/

    DuAE.endUndoGroup(DuScriptUI.String.SEQUENCE);
}

Duik.CmdLib['Animation']["Sequence keys"] = "Duik.Animation.sequenceKeys()";
/**
 * Sequences selected keyframes.
 * @param {int} [duration=24] The transition duration, in frames
 * @param {Bool} [reverse=false] Set to true to reverse the order.
 * @param {function} [interpolation=DuInterpolation.linear] An interpolation function, taking 4 arguments in the form <code>i(value, min, max, targetMin, targetMax)</code>
 */
Duik.Animation.sequenceKeys = function(duration, reverse, interpolation) {
    var props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length() == 0) return;

    DuAE.beginUndoGroup(DuScriptUI.String.SEQUENCE, false);

    var comp = props.at(0).comp;

    // Get animations
    var selectedKeys = [];
    props.do(function(prop) {
        var keys = prop.selectedKeys();
        if (keys.length == 0) return;
        var p = {};
        p.prop = prop;
        p.anim = prop.animation(true);
        selectedKeys.push(p);
    });

    var n = selectedKeys.length;
    var startTime = comp.time;
    duration = duration * comp.frameDuration;
    var endTime = startTime + duration;

    for (var i = 0; i < n; i++) {
        var prop = selectedKeys[i].prop;
        var anim = selectedKeys[i].anim;
        var s = reverse ? 0 : n-1;
        var e = reverse ? n-1 : 0;

        // New time
        newTime = interpolation(i, s, e, startTime, endTime);
        var offset = newTime - anim.startTime;

        // remove keyframes
        for (var k = anim.keys.length -1; k >= 0; k--)
        {
            prop.removeKey( anim.keys[k] );
        }
        
        prop.setAnim(anim, offset);
    }

    DuAE.endUndoGroup(DuScriptUI.String.SEQUENCE);
}

Duik.CmdLib['Animation']["X-Sheet"] = "Duik.Animation.xSheet()";
/**
 * Adjusts the exposure of the animation.
 * @param {Bool} [autoCompute=false] (Try to) auto-compute the best values..
 */
Duik.Animation.xSheet = function( autoCompute ) {
    var comp = DuAEProject.getActiveComp();
    if (!comp) return;

    autoCompute = def(autoCompute, false);

    var props = DuAEComp.getSelectedProps();
    props = new DuList(props);

    DuAE.beginUndoGroup(DuScriptUI.String.X_SHEET, false);

    DuAEComp.setUniqueLayerNames(undefined, comp);

    var ok = false;
    var pe = Duik.PseudoEffect.X_SHEET;
    var exp = "";

    if (props.length() > 0) {
        var effect = null;
        props.do(function(prop) {
            if (!prop.riggable()) return;
            var layer = prop.layer;

            // add effect
            if (effect == null) {
                effect = pe.apply(layer);
                exp = [ DuAEExpression.Id.X_SHEET,
                    'var fx = thisComp.layer("' + layer.name + '").effect("' + effect.name + '");',
                    'var mode = fx(' + pe.props['Mode'].index + ');',
                    'var frameDuration = fx(' + pe.props['Frame duration'].index + ').value;',
                    'var xSheet = fx(' + pe.props['X-sheet'].index + ');',
                    'var result = value;',
                    'function getValAtKey(prop)',
                    '{',
                    'if (prop.numKeys > 0)',
                    '{',
                    'var k = prop.nearestKey(time);',
                    'if (k.time > time && k.index > 1) k = prop.key(k.index-1);',
                    'return valueAtTime(k.time);',
                    '}',
                    'else return value;',
                    '}',
                    'if (mode == 1)',
                    '{',
                    'frameDuration = Math.round(frameDuration);',
                    'timef = timeToFrames(time);',
                    'result = valueAtTime(framesToTime( timef - timef%frameDuration ))',
                    '}',
                    'else if (mode == 2) result = getValAtKey(xSheet);',
                    'else if (mode == 3) result = getValAtKey(thisLayer.marker);',
                    'else result = getValAtKey(thisComp.marker);',
                    'result;'
                ].join('\n');
            }
            prop.setExpression(exp, false);
            ok = true;
        });
    }
    if (!ok) {
        var newName = DuAEComp.newUniqueLayerName(DuScriptUI.String.X_SHEET,comp);
        var layer = DuAEComp.addAdjustmentLayer(comp);
		layer.name = newName;
        Duik.Layer.setType(Duik.Layer.Type.X_SHEET, layer);

        effect = pe.apply(layer);
        var effectName = effect.name;

        var timeWarp = layer('ADBE Effect Parade').addProperty('ADBE Timewarp');
		timeWarp(1).setValue(1);
		timeWarp(2).setValue(2);
        timeWarp(4).expression = [ DuAEExpression.Id.X_SHEET,
            'var fx = effect("' + effectName + '")',
            'var mode = fx(' + pe.props['Mode'].index + ');',
            'var frameDuration = fx(' + pe.props['Frame duration'].index + ').value;',
            'var xSheet = fx(' + pe.props['X-sheet'].index + ');',
            'var result = timeToFrames(time);',
            'function getValAtKey(prop)',
            '{',
            'if (prop.numKeys > 0)',
            '{',
            'var k = prop.nearestKey(time);',
            'if (k.time > time && k.index > 1) k = prop.key(k.index-1);',
            'return timeToFrames(k.time);',
            '}',
            'else return timeToFrames(time);',
            '}',
            'if (mode == 1)',
            '{',
            'frameDuration = Math.round(frameDuration);',
            'timef = timeToFrames(time);',
            'result = timef - timef%frameDuration;',
            '}',
            'else if (mode == 2) result = getValAtKey(xSheet);',
            'else if (mode == 3) result = getValAtKey(thisLayer.marker);',
            'else result = getValAtKey(thisComp.marker);',
            'result;'
        ].join('\n');
    }

    if (autoCompute && props.length() > 0) {
        //detect limit
        var averageSpeed = DuAEProperty.getAverageSpeed(props);
        if (averageSpeed > 0)
        {
            var precision = averageSpeed*2.5;
            var frames = comp.duration / comp.frameDuration;
            //set Keyframes
            var step = 0;
            effect(pe.props['X-sheet'].index).addKey(0);
            for (var frame = 0 ; frame < frames ; frame++)
            {
                var time = frame * comp.frameDuration;

                var maxSpeed = 0;
                props.do(function(prop) {
                    var speedTest = prop.speedAtTime(time);
                    if (speedTest > maxSpeed) maxSpeed = speedTest;
                });

                step += maxSpeed;

                if (step >= precision && averageSpeed > 0)
                {
                    step = 0;
                    effect(pe.props['X-sheet'].index).addKey(time);
                }
            }
            effect(pe.props['Mode'].index).setValue(2);
        }
    }

    DuAE.endUndoGroup(DuScriptUI.String.X_SHEET);
}