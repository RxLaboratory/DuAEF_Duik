/**
 * The animator's toolkit.
 * @namespace
 */
Duik.Animation = {};

// low-level undocumented list
// The animations which have been copied by Duik.Animation.copy()
Duik.Animation.copied = [];

/**
 * The list of animation functions
 */
Duik.CmdLib['Animation'] = [];

Duik.CmdLib['Animation']["Select Keyframes"] = "Duik.Animation.selectKeyframes()";
/**
 * Selects the keyframes in the comp
 * @param {CompItem} [comp=DuAEProject.getActiveComp] The composition
 * @param {Boolean} [selectedLayers=false] Set to true to get the keyframes only on the selected layers instead of all the layers.
 * @param {Boolean} [controllersOnly=true] Set to false to get the keyframes from all types of layers instead of just the controllers.
 * @param {float[]} [range] The time range to select the keyframes, [in, out]. If omitted, will use the work area of the composition.
 * @param {string[]} [propertyMatchNames=[]] The list of matchnames to select only keyframes of a specific type. If empty, will select all types of keyframes.
 */
Duik.Animation.selectKeyframes = function( comp, selectedLayers, controllersOnly, range, propertyMatchNames )
{
    comp = def(comp, DuAEProject.getActiveComp() );
    if(!comp) return;
    selectedLayers = def( selectedLayers, false );
    controllersOnly = def( controllersOnly, true );
    range = def( range, [comp.workAreaStart, comp.workAreaStart + comp.workAreaDuration ] );
    propertyMatchNames = def( propertyMatchNames, [
        'ADBE Position',
        'ADBE Vector Position',
        'ADBE Position_0',
        'ADBE Position_1',
        'ADBE Position_2',
        'ADBE Rotate Z',
        'ADBE Rotate Y',
        'ADBE Rotate X',
        'ADBE Orientation',
        'ADBE Vector Rotation',
        'ADBE Scale',
        'ADBE Vector Scale',
        'ADBE Opacity',
        'ADBE Vector Group Opacity',
        'ADBE Mask Parade',
        'ADBE Effect Parade'
    ]);
    propertyMatchNames = new DuList(propertyMatchNames);

    DuAE.beginUndoGroup(DuScriptUI.String.SELECT_KEYFRAMES, false);
    DuAEProject.setProgressMode(true);

    //get layers
    var layers = [];
    if ( !selectedLayers )
    {
        if ( !controllersOnly ) layers = comp.layers;
        else layers = Duik.Controller.get( false, comp );
    }
    else
    {
        if ( !controllersOnly ) layers = comp.selectedLayers;
        else layers = Duik.Controller.get( true, comp );
    }

    if (layers.length == 0)
    {
        DuAEProject.setProgressMode(false);
        DuAE.endUndoGroup(DuScriptUI.String.SELECT_KEYFRAMES);
        return;
    }

    //unselect all previously selected keyframes
	DuAEComp.unselectProperties();

    // A filter to get properties
    function filterProps( prop )
    {
        if ( propertyMatchNames.length() == 0) return true;
        return propertyMatchNames.indexOf( prop.matchName ) >= 0;
    }

    //get all properties
    layers = new DuList(layers);
    layers.do(function (layer)
    {
        var props = DuAEProperty.getProps(layer,filterProps);
        props = new DuList(props);
        props.do(function(prop)
        {
            prop.selectKeys( range[0], range[1]);
        });
    });

    DuAEProject.setProgressMode(false);
    DuAE.endUndoGroup(DuScriptUI.String.SELECT_KEYFRAMES);
};

Duik.CmdLib['Animation']["Copy"] = "Duik.Animation.copy()";
/**
 * Copies the currently selected keyframes, which can then be pasted with {@link Duik.Animation.paste}.
 * @param {CompItem} [comp=DuAEProject.getActiveComp] The composition
 * @returns {DuAELayerAnimation[]} The list of animations which have been copied.
 */
Duik.Animation.copy = function( comp )
{
    comp = def(comp, DuAEProject.getActiveComp() );
    if(!comp) return;

    var layers = comp.selectedLayers;
    if (layers.length == 0) return;

    copiedAnim = [];

    for (var i = 0 ; i < layers.length ; i++)
    {
        copiedAnim.push(DuAELayer.getAnim( layers[i],true ));
    }
    //get the first keyframe time to offset when pasting
    copiedAnim.firstKeyFrameTime = DuAELayer.firstKeyFrameTime(layers, true);

    Duik.Animation.copied = copiedAnim;

    return copiedAnim;
};

Duik.CmdLib['Animation']["Paste"] = "Duik.Animation.paste()";
Duik.CmdLib['Animation']["Paste Reversed"] = "Duik.Animation.paste( undefined, false, false, true )";
Duik.CmdLib['Animation']["Paste Offset"] = "Duik.Animation.paste( undefined, false, true )";
Duik.CmdLib['Animation']["Paste Replace"] = "Duik.Animation.paste( undefined, true )";
/**
 * Pastes the animation previously copied by {@link Duik.Animation.copy} to the selected properties.
 * @param {CompItem} [comp] The composition.
 * @param {Boolean} [replace=false] - Whether to completely erase and replace the current animation
 * @param {Boolean} [offset=false] - Whether to offset the animation from the current value
 * @param {Boolean} [reverse=false] - Whether to reverse the animation
 * @param {string[]} [matchNames=[]] A filter to apply only on specific property types
 */
Duik.Animation.paste = function( comp, replace, offset, reverse )
{
    DuIO.Animation.paste( comp, Duik.Animation.copied, replace, offset, reverse );
};

Duik.CmdLib['Animation']["Interpolator"] = "Duik.Animation.interpolator()";
/**
 * Control the selected keyframes with advanced but easy-to-use keyframe interpolation driven by an effect.
 * @param {PropertyBase[]|DuList.<PropertyBase>|PropertyBase} [props] The properties to interpolate. The selected properties in the active comp if omitted.
 * @param {PropertyGroup} [effect] The pseudo effect to use if it already exists.
 * @returns {PropertyGroup} The pseudo-effect
 */
Duik.Animation.interpolator = function( props, effect )
{
    props = def(props, DuAEComp.getSelectedProps() );
    props = new DuList(props);
    if (props.length() == 0) return null;

    var p = props.at(0);
    p = new DuAEProperty(p);
    var ctrlLayer = p.layer;

    DuAE.beginUndoGroup(DuScriptUI.String.INTERPOLATOR, false);

    // Add the effect
    if (!effect)
    {
        effect = Duik.PseudoEffect.INTERPOLATOR.apply( ctrlLayer, DuScriptUI.String.INTERPOLATOR + ' | ' + p.name );
    }

    // Indices
    var i = Duik.PseudoEffect.INTERPOLATOR.props;

    // Defaults
    effect( i['Type'].index ).setValue(4);

    // The Expression
    var exp = [ DuAEExpression.Id.INTERPOLATOR,
        'var fx = thisComp.layer("' + ctrlLayer.name + '").effect("' + effect.name + '");',
        'var iType = fx(' + i['Type'].index + ').value;',
        'var iRate = fx(' + i['Rate'].index + ').value;',
        '',
        'var isIn = fx(' + i['In Extrapolation and loop']['Before keys'].index + ');',
        'var inType = fx(' + i['In Extrapolation and loop']['Type'].index + ').value;',
        'var inInStill = fx(' + i['In Extrapolation and loop']['During still parts'].index + ').value;',
        'var inNumKeyframes = fx(' + i['In Extrapolation and loop']['Number of keys'].index + ').value;',
        'var inDamping = fx(' + i['In Extrapolation and loop']['Damping'].index + ').value;',
        'var isOut = fx(' + i['Out Extrapolation and loop']['After keys'].index + ');',
        'var outType = fx(' + i['Out Extrapolation and loop']['Type'].index + ').value;',
        'var outNumKeyframes = fx(' + i['Out Extrapolation and loop']['Number of keys'].index + ').value;',
        'var outInStill = fx(' + i['Out Extrapolation and loop']['During still parts'].index + ').value;',
        'var elasticity = fx(' + i['Out Extrapolation and loop']['Elasticity'].index + ').value;',
        'var outDamping = fx(' + i['Out Extrapolation and loop']['Damping'].index + ').value;',
        '',
        'elasticity /= 10;',
        'outDamping /= 10;',
        'inDamping /= 10;',
        'if (!isOut.value) outInStill = false;',
        'if (!isIn.value) inInStill = false;',
        '',
        DuAEExpression.Library.get([
            'isStill',
            'lastActiveTime',
            'nextActiveTime',
            'continueOut',
            'continueIn',
            'cycleOut',
            'cycleIn',
            'pingPongOut',
            'pingPongIn',
            'bezierInterpolation',
            'gaussianInterpolation',
            'linearExtrapolation',
            'logisticInterpolation',
            'logInterpolation',
            'expInterpolation',
            'overshoot',
            'bounce'
        ]),
        '',
        'var result = value;',
        '',
        'function iAtTime( t )',
        '{',
        '  // Needed keyframes',
        '	var pKey = getPrevKey(t, thisProperty);',
        '	var nKey = getNextKey(t, thisProperty);',
        '	',
        '	if (!pKey || !nKey) return value;',
        '	',
        '	if (iType == 1) // None',
        '	{',
        '	  return valueAtTime(t);',
        '	}',
        '	else if (iType == 2) // Linear ',
        '	{',
        '	  return linear(',
        '			t,',
        '			pKey.time,',
        '			nKey.time,',
        '			pKey.value,',
        '			nKey.value',
        '		);',
        '	}',
        '	else if (iType == 3) // Bezier',
        '	{',
        '	  var bUseAdvanced = fx(' + i['Bezier options']['Use advanced options'].index + ').value;',
        '	    ',
        '    if (bUseAdvanced)',
        '    {',
        '      var bInI = fx(' + i['Bezier options']['Advanced']['In Influence'].index + ').value/100;',
        '      var bInV = fx(' + i['Bezier options']['Advanced']['In Velocity'].index + ').value/100;',
        '      var bOutI = fx(' + i['Bezier options']['Advanced']['Out Influence'].index + ').value/100;',
        '      var bOutV = fx(' + i['Bezier options']['Advanced']['Out Velocity'].index + ').value/100;',
        '      ',
        '      return bezierInterpolation(',
        '        t,',
        '        pKey.time,',
        '        nKey.time,',
        '        pKey.value,',
        '        nKey.value,',
        '        [bInI, bInV, 1 - bOutI, 1 - bOutV]',
        '      );',
        '    }',
        '    else',
        '    {',
        '      var bRatio = fx(' + i['Bezier options']['In/Out Ratio'].index + ').value / 100;',
        '      var bIn = linear(iRate, 0, 10, 0.0, 1.0) * bRatio;',
        '      var bOut = linear(iRate, 0, 10, 0.0, 1.0) * (1-bRatio);',
        '      bOut = 1 - bOut;',
        '      ',
        '      return bezierInterpolation(',
        '        t,',
        '        pKey.time,',
        '        nKey.time,',
        '        pKey.value,',
        '        nKey.value,',
        '        [bIn, 0, bOut, 1]',
        '      );',
        '    }',
        '	}',
        '	else if (iType == 4) // Gaussian ',
        '	{',
        '	  iRate = linear(iRate, 1, 30, -1, 1);',
        '	  return gaussianInterpolation(',
        '	    t,',
        '	    pKey.time,',
        '      nKey.time,',
        '      pKey.value,',
        '      nKey.value,',
        '      iRate',
        '	  );',
        '	}',
        '	else if (iType == 5) // Logistic',
        '	{',
        '	  var midRatio = fx(' + i['Logistic options']['Mid point'].index + ') / 100;',
        '	  var mid = pKey.time + ( nKey.time - pKey.time ) * midRatio;',
        '	  return logisticInterpolation(',
        '	    t,',
        '	    pKey.time,',
        '	    nKey.time,',
        '	    pKey.value,',
        '	    nKey.value,',
        '	    iRate,',
        '	    mid',
        '	  );',
        '	}',
        '	else if (iType == 6) // Logarithmic',
        '	{',
        '	  return logInterpolation(',
        '	    t,',
        '	    pKey.time,',
        '	    nKey.time,',
        '	    pKey.value,',
        '	    nKey.value,',
        '	    iRate',
        '	  );',
        '	}',
        '	else if (iType == 7) // Exponential ',
        '	{',
        '       iRate = linearExtrapolation(iRate, 0, 30, 0, 10);',
        '	    return expInterpolation(',
        '	        t,',
        '	        pKey.time,',
        '	        nKey.time,',
        '	        pKey.value,',
        '	        nKey.value,',
        '	        iRate',
        '	    );',
        '	}',
        '	',
        '	return -1;',
        '}',
        '',
        'function i() {',
        '	if (numKeys < 2) return value;',
        '',
        '	// Needed keyframes',
        '	var pKey = getPrevKey(time, thisProperty);',
        '	var nKey = getNextKey(time, thisProperty);',
        '	',
        '	// Extrapolation during still parts',
        '	if ( isStill( time, 0 ) )',
        '	{',
        '	  var inVal = value;',
        '	  var outVal = value;',
        '	  // In Extrapolation',
        '	  if (inInStill || !pKey)',
        '	  {',
        '	    var inTime = nextActiveTime(isIn, time);',
        '	    var nextKey = getNextKey(time, thisProperty);',
        '	    ',
        '	    if (inType == 3) inVal = cycleIn(inTime, inNumKeyframes, true, iAtTime, inDamping);',
        '			else if (inType == 4) inVal = cycleIn(inTime, inNumKeyframes, false, iAtTime, inDamping);',
        '			else if (inType == 5) inVal = pingPongIn(inTime, inNumKeyframes, iAtTime, inDamping);',
        '			else if (inType == 2 && isIn.value) {',
        '				if (iType == 1) inVal = continueIn(inTime, inDamping); // None',
        '				else if (iType == 2 && nextKey) // Linear ',
        '				{',
        '				    var firstVelocity = (nextKey.value - iAtTime(nextKey.time + 0.01)) * 100;',
        '  					var timeSpent = nextKey.time - time;',
        '  					var damp = Math.exp(timeSpent * inDamping);',
        '  					inVal = (timeSpent * firstVelocity)/damp + nextKey.value;',
        '				} else if (iType == 3 && nextKey) // Bezier',
        '				{',
        '					var bUseAdvanced = fx(' + i['Bezier options']['Use advanced options'].index + ').valueAtTime(nKey.time);',
        '					if (!bUseAdvanced) inVal = value;',
        '					else',
        '					{',
        '					  var bInV = fx(' + i['Bezier options']['Advanced']['In Velocity'].index + ').valueAtTime(nKey.time) / 100;',
        '  					if (bInV == 0) inVal = value;',
        '  					else ',
        '  					{',
        '  					  var firstVelocity = (iAtTime(nextKey.time + 0.01) - nextKey.value) * 100;',
        '    					var timeSpent = nextKey.time - time;',
        '    					var damp = Math.exp(timeSpent * inDamping);',
        '    					inVal = (-timeSpent * firstVelocity) / damp + nextKey.value;',
        '  					}',
        '					}',
        '				} else if (iType == 4) // Gaussian',
        '				{',
        '					inVal = value;',
        '				} else if (iType == 5 && nextKey) // Logistic',
        '				{',
        '					var previousKey = nextKey;',
        '					if (previousKey.index < numKeys)',
        '					{',
        '					  nextKey = key(previousKey.index + 1);',
        '  					var midRatio = fx(' + i['Logistic options']['Mid point'].index + ') / 100;',
        '  					var mid = previousKey.time + (nextKey.time - previousKey.time) * midRatio;',
        '  					inVal = logisticInterpolation(',
        '  						time,',
        '  						previousKey.time,',
        '  						nextKey.time,',
        '  						previousKey.value,',
        '  						nextKey.value,',
        '  						iRate,',
        '  						mid',
        '  					);',
        '  					var timeSpent = previousKey.time - time;',
        '  					var damp = Math.exp(timeSpent * inDamping);',
        '  					inVal = (inVal-value)/damp + value;',
        '					}',
        '				} else if (iType == 6) // Log',
        '				{',
        '					inVal = value;',
        '				} else if (iType == 7 && nextKey) // Exp ',
        '				{',
        '					var previousKey = nextKey;',
        '					if (previousKey.index < numKeys)',
        '					{',
        '					  var nextKey = key(previousKey.index + 1);',
        '  					inVal = expInterpolation(',
        '  						time,',
        '  						previousKey.time,',
        '  						nextKey.time,',
        '  						previousKey.value,',
        '  						nextKey.value,',
        '  						iRate',
        '  					);',
        '  					var timeSpent = previousKey.time - time;',
        '  					var damp = Math.exp(timeSpent * inDamping);',
        '  					inVal = (inVal-value)/damp + value;',
        '					}',
        '				}',
        '			}',
        '	  }',
        '	  // Out Extrapolation',
        '	  if (outInStill || !nKey)',
        '	  {',
        '	    var outTime = lastActiveTime(isOut, time);',
        '	    var prevKey = getPrevKey(time, thisProperty);',
        '	    ',
        '			if (outType == 3) outVal = cycleOut(outTime, outNumKeyframes, true, iAtTime, outDamping);',
        '			else if (outType == 4) outVal = cycleOut(outTime, outNumKeyframes, false, iAtTime, outDamping);',
        '			else if (outType == 5) outVal = pingPongOut(outTime, outNumKeyframes, iAtTime, outDamping);',
        '			else if (outType == 2 && isOut.value) {',
        '				if (iType == 1) outVal = continueOut(outTime, outDamping); // None',
        '				else if (iType == 2 && prevKey) // Linear ',
        '				{',
        '					var lastVelocity = (prevKey.value - iAtTime(prevKey.time - 0.01)) * 100;',
        '					var timeSpent = time - prevKey.time;',
        '					var damp = Math.exp(timeSpent * outDamping);',
        '					outVal = prevKey.value + (timeSpent * lastVelocity)/damp;',
        '				} else if (iType == 3 && prevKey) // Bezier',
        '				{',
        '					var bUseAdvanced = fx(' + i['Bezier options']['Use advanced options'].index + ').valueAtTime(pKey.time);',
        '					if (!bUseAdvanced) outVal = value;',
        '					else ',
        '					{',
        '					  var bOutV = fx(' + i['Bezier options']['Advanced']['Out Velocity'].index + ').valueAtTime(pKey.time) / 100;',
        '  					if (bOutV == 0) outVal = value;',
        '  					else',
        '  					{',
        '  					  var lastVelocity = ( prevKey.value - iAtTime(prevKey.time - 0.01)) * 100;',
        '    					var timeSpent = time - prevKey.time;',
        '    					var damp = Math.exp(timeSpent * outDamping);',
        '    					outVal = prevKey.value + (timeSpent * lastVelocity)/damp;',
        '  					}',
        '					}',
        '				} else if (iType == 4) // Gaussian',
        '				{',
        '					outVal = value;',
        '				} else if (iType == 5 && prevKey) // Logistic',
        '				{',
        '				  var nextKey = prevKey;',
        '				  if (nextKey.index > 0)',
        '				  {',
        '				    prevKey = key(nextKey.index - 1);',
        '  					var midRatio = fx(' + i['Logistic options']['Mid point'].index + ') / 100;',
        '  					var mid = prevKey.time + (nextKey.time - prevKey.time) * midRatio;',
        '  					outVal = logisticInterpolation(',
        '  						time,',
        '  						prevKey.time,',
        '  						nextKey.time,',
        '  						prevKey.value,',
        '  						nextKey.value,',
        '  						iRate,',
        '  						mid',
        '  					);',
        '  					var timeSpent = time - nextKey.time;',
        '  					var damp = Math.exp(timeSpent * outDamping);',
        '  					outVal = (outVal-value)/damp + value;',
        '				  }',
        '					',
        '				} else if (iType == 6 && prevKey) // Log',
        '				{',
        '					var nextKey = prevKey;',
        '				  if (nextKey.index > 0)',
        '				  {',
        '				    prevKey = key(nextKey.index - 1);',
        '				    outVal = logInterpolation(',
        '  						time,',
        '  						prevKey.time,',
        '  						nextKey.time,',
        '  						prevKey.value,',
        '  						nextKey.value,',
        '  						iRate',
        '  					);',
        '  					var timeSpent = time - nextKey.time;',
        '  					var damp = Math.exp(timeSpent * outDamping);',
        '  					outVal = (outVal-value)/damp + value;',
        '				  }',
        '				} else if (iType == 7 && prevKey) // Exp ',
        '				{',
        '					var nextKey = prevKey;',
        '				  if (nextKey.index > 0)',
        '				  {',
        '				    prevKey = key(nextKey.index - 1);',
        '				    outVal = expInterpolation(',
        '  						time,',
        '  						prevKey.time,',
        '  						nextKey.time,',
        '  						prevKey.value,',
        '  						nextKey.value,',
        '  						iRate',
        '  					);',
        '  					var timeSpent = time - nextKey.time;',
        '  					var damp = Math.exp(timeSpent * outDamping);',
        '  					outVal = (outVal-value)/damp + value;',
        '				  }',
        '				}',
        '			}',
        '			else if (outType == 6 && isOut.value) outVal = overShoot(time, elasticity, outDamping, iAtTime );',
        '			else if (outType == 7 && isOut.value) outVal = bounce(time, elasticity, outDamping, iAtTime );',
        '	  }',
        '	  ',
        '	  if (!pKey) return inVal;',
        '	  if (!nKey) return outVal;',
        '	  ',
        '	  // Blend',
        '	  if (inInStill && outInStill)',
        '	  {',
        '	    // Blend',
        '	    return ease( time, pKey.time, nKey.time, outVal, inVal);',
        '	  }',
        '	  if (inInStill) return inVal;',
        '	  if (outInStill) return outVal;',
        '	  return value;',
        '	}',
        '',
        '	return iAtTime(time);',
        '}',
        '',
        'if (fx.enabled) result = i();',
        'result;'//*/
        ].join('\n');

    // Add expressions
    props.do(function (prop)
    {
        prop = new DuAEProperty(prop);
        // Only for riggable props (no recursion)
        if (prop.riggable())
            prop.setExpression( exp, false );
    });

    DuAE.endUndoGroup(DuScriptUI.String.INTERPOLATOR);

    return effect;
};

Duik.CmdLib['Animation']["Add roving key"] = "Duik.Animation.addRovingKey()";
/**
 * Adds a roving key to the properties at current time
 * @param {Bool} [animatedProps=true] Set to false to add a key to all selected properties, instead of all animated properties.
 * @param {Bool} [selectedLayers=true] Set to false to add a key to all layers instead of just the selection.
 */
Duik.Animation.addRovingKey = function(animatedProps, selectedLayers)
{
    animatedProps = def(animatedProps, true);
    selectedLayers = def(selectedLayers, true);

    DuAE.beginUndoGroup(DuScriptUI.String.ROVING, false);

    var props;
    if (animatedProps) props = DuAEComp.getAnimatedProps(undefined, undefined, undefined, selectedLayers);
    else props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.addKey('roving');
    });

    DuAE.endUndoGroup(DuScriptUI.String.ROVING);
};

Duik.CmdLib['Animation']["Set roving"] = "Duik.Animation.setRoving()";
/**
 * Sets the selected keyframes to roving
 */
Duik.Animation.setRoving = function() {
    var props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    DuAE.beginUndoGroup(DuScriptUI.String.ROVING, false);

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.setInterpolation('roving', undefined, undefined, undefined, true);
    });

    DuAE.endUndoGroup(DuScriptUI.String.ROVING);
};

Duik.CmdLib['Animation']["Add linear key"] = "Duik.Animation.addLinearKey()";
/**
 * Adds a linear key to the properties at current time
 * @param {Bool} [animatedProps=true] Set to false to add a key to all selected properties, instead of all animated properties.
 * @param {Bool} [selectedLayers=true] Set to false to add a key to all layers instead of just the selection.
 */
Duik.Animation.addLinearKey = function(animatedProps, selectedLayers)
{
    animatedProps = def(animatedProps, true);
    selectedLayers = def(selectedLayers, true);

    DuAE.beginUndoGroup(DuScriptUI.String.LINEAR, false);

    var props;
    if (animatedProps) props = DuAEComp.getAnimatedProps(undefined, undefined, undefined, selectedLayers);
    else props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.addKey(KeyframeInterpolationType.LINEAR);
    });

    DuAE.endUndoGroup(DuScriptUI.String.LINEAR);
};

Duik.CmdLib['Animation']["Set linear"] = "Duik.Animation.setLinear()";
/**
 * Sets the selected keyframes to linear
 */
Duik.Animation.setLinear = function() {
    var props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    DuAE.beginUndoGroup(DuScriptUI.String.LINEAR, false);

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.setInterpolation(KeyframeInterpolationType.LINEAR, undefined, undefined, undefined, true);
    });

    DuAE.endUndoGroup(DuScriptUI.String.LINEAR);
};

Duik.CmdLib['Animation']["Add Ease In key"] = "Duik.Animation.addEaseInKey()";
/**
 * Adds an Ease In key to the properties at current time
 * @param {Bool} [animatedProps=true] Set to false to add a key to all selected properties, instead of all animated properties.
 * @param {Bool} [selectedLayers=true] Set to false to add a key to all layers instead of just the selection.
 */
Duik.Animation.addEaseInKey = function(animatedProps, selectedLayers)
{
    animatedProps = def(animatedProps, true);
    selectedLayers = def(selectedLayers, true);

    DuAE.beginUndoGroup(DuScriptUI.String.EASE_IN, false);

    var props;
    if (animatedProps) props = DuAEComp.getAnimatedProps(undefined, undefined, undefined, selectedLayers);
    else props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.addKey(KeyframeInterpolationType.BEZIER, KeyframeInterpolationType.LINEAR );
    });

    DuAE.endUndoGroup(DuScriptUI.String.EASE_IN);
};

Duik.CmdLib['Animation']["Set ease in"] = "Duik.Animation.setEaseIn()";
/**
 * Sets the selected keyframes to ease in
 */
Duik.Animation.setEaseIn = function() {
    var props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    DuAE.beginUndoGroup(DuScriptUI.String.EASE_IN, false);

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.setInterpolation(KeyframeInterpolationType.BEZIER, KeyframeInterpolationType.LINEAR, undefined, undefined, true);
    });

    DuAE.endUndoGroup(DuScriptUI.String.EASE_IN);
};

Duik.CmdLib['Animation']["Add Ease Out key"] = "Duik.Animation.addEaseOutKey()";
/**
 * Adds an Ease Out key to the properties at current time
 * @param {Bool} [animatedProps=true] Set to false to add a key to all selected properties, instead of all animated properties.
 * @param {Bool} [selectedLayers=true] Set to false to add a key to all layers instead of just the selection.
 */
Duik.Animation.addEaseOutKey = function(animatedProps, selectedLayers)
{
    animatedProps = def(animatedProps, true);
    selectedLayers = def(selectedLayers, true);

    DuAE.beginUndoGroup(DuScriptUI.String.EASE_OUT, false);

    var props;
    if (animatedProps) props = DuAEComp.getAnimatedProps(undefined, undefined, undefined, selectedLayers);
    else props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.addKey(KeyframeInterpolationType.LINEAR, KeyframeInterpolationType.BEZIER );
    });

    DuAE.endUndoGroup(DuScriptUI.String.EASE_OUT);
};

Duik.CmdLib['Animation']["Set ease out"] = "Duik.Animation.setEaseOut()";
/**
 * Sets the selected keyframes to ease out
 */
Duik.Animation.setEaseOut = function() {
    var props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    DuAE.beginUndoGroup(DuScriptUI.String.EASE_OUT, false);

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.setInterpolation(KeyframeInterpolationType.LINEAR, KeyframeInterpolationType.BEZIER, undefined, undefined, true);
    });

    DuAE.endUndoGroup(DuScriptUI.String.EASE_OUT);
};

Duik.CmdLib['Animation']["Add Easy Ease key"] = "Duik.Animation.addEasyEaseKey()";
/**
 * Adds an Easy Ease key to the properties at current time
 * @param {Bool} [animatedProps=true] Set to false to add a key to all selected properties, instead of all animated properties.
 * @param {Bool} [selectedLayers=true] Set to false to add a key to all layers instead of just the selection.
 */
Duik.Animation.addEasyEaseKey = function(animatedProps, selectedLayers)
{
    animatedProps = def(animatedProps, true);
    selectedLayers = def(selectedLayers, true);

    DuAE.beginUndoGroup(DuScriptUI.String.EASY_EASE, false);

    var props;
    if (animatedProps) props = DuAEComp.getAnimatedProps(undefined, undefined, undefined, selectedLayers);
    else props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.addKey(KeyframeInterpolationType.BEZIER, KeyframeInterpolationType.BEZIER );
    });

    DuAE.endUndoGroup(DuScriptUI.String.EASY_EASE);
};

Duik.CmdLib['Animation']["Set easy ease"] = "Duik.Animation.setEasyEase()";
/**
 * Sets the selected keyframes to easy ease
 */
Duik.Animation.setEasyEase = function() {
    var props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    DuAE.beginUndoGroup(DuScriptUI.String.EASY_EASE, false);

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.setInterpolation(KeyframeInterpolationType.BEZIER, KeyframeInterpolationType.BEZIER, undefined, undefined, true);
    });

    DuAE.endUndoGroup(DuScriptUI.String.EASY_EASE);
};

Duik.CmdLib['Animation']["Add Continuous key"] = "Duik.Animation.addContinuousKey()";
/**
 * Adds a Continuous key to the properties at current time
 * @param {Bool} [animatedProps=true] Set to false to add a key to all selected properties, instead of all animated properties.
 * @param {Bool} [selectedLayers=true] Set to false to add a key to all layers instead of just the selection.
 */
Duik.Animation.addContinuousKey = function(animatedProps, selectedLayers)
{
    animatedProps = def(animatedProps, true);
    selectedLayers = def(selectedLayers, true);

    DuAE.beginUndoGroup(DuScriptUI.String.CONTINUOUS, false);

    var props;
    if (animatedProps) props = DuAEComp.getAnimatedProps(undefined, undefined, undefined, selectedLayers);
    else props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.addKey('continuous');
    });

    DuAE.endUndoGroup(DuScriptUI.String.CONTINUOUS);
};

Duik.CmdLib['Animation']["Set continuous"] = "Duik.Animation.setContinuous()";
/**
 * Sets the selected keyframes to continuous
 */
Duik.Animation.setContinuous = function() {
    var props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    DuAE.beginUndoGroup(DuScriptUI.String.CONTINUOUS, false);

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.setInterpolation('continuous', undefined, undefined, undefined, true);
    });

    DuAE.endUndoGroup(DuScriptUI.String.CONTINUOUS);
};

Duik.CmdLib['Animation']["Add Hold key"] = "Duik.Animation.addHoldKey()";
/**
 * Adds a Hold key to the properties at current time
 * @param {Bool} [animatedProps=true] Set to false to add a key to all selected properties, instead of all animated properties.
 * @param {Bool} [selectedLayers=true] Set to false to add a key to all layers instead of just the selection.
 */
Duik.Animation.addHoldKey = function(animatedProps, selectedLayers)
{
    animatedProps = def(animatedProps, true);
    selectedLayers = def(selectedLayers, true);

    DuAE.beginUndoGroup(DuScriptUI.String.HOLD, false);

    var props;
    if (animatedProps) props = DuAEComp.getAnimatedProps(undefined, undefined, undefined, selectedLayers);
    else props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.addKey(KeyframeInterpolationType.HOLD);
    });

    DuAE.endUndoGroup(DuScriptUI.String.HOLD);
};

Duik.CmdLib['Animation']["Set hold"] = "Duik.Animation.setHold()";
/**
 * Sets the selected keyframes to hold
 */
Duik.Animation.setHold = function() {
    var props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    DuAE.beginUndoGroup(DuScriptUI.String.HOLD, false);

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.setInterpolation(KeyframeInterpolationType.HOLD, undefined, undefined, undefined, true);
    });

    DuAE.endUndoGroup(DuScriptUI.String.HOLD);
};

/**
 * Sets the ease values on the selected keyframes
 * @param {float} easeIn The in ease
 * @param {float} easeOut The out ease
 */
Duik.Animation.setEase = function( easeIn, easeOut ) {
    var props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    DuAE.beginUndoGroup(DuScriptUI.String.SET_EASE, false);

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.setEase(easeIn, easeOut);
    });

    DuAE.endUndoGroup(DuScriptUI.String.SET_EASE);
}

/**
 * Sets the velocity values on the selected keyframes
 * @param {float} vIn The in velocity
 * @param {float} vOut The out velocity
 */
Duik.Animation.setVelocity = function( vIn, vOut ) {
    var props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    DuAE.beginUndoGroup(DuScriptUI.String.SET_VELOCITY, false);

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.setEase(undefined, undefined, vIn, vOut, true);
    });

    DuAE.endUndoGroup(DuScriptUI.String.SET_VELOCITY);
}

/**
 * Sets the selected keyframes spatial interpolation
 */
Duik.Animation.setSpatialInterpolation = function( inType, outType) {
    var props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    outType = def(outType, inType);

    DuAE.beginUndoGroup(DuScriptUI.String.SPATIAL_INTERPOLATION, false);

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.setSpatialInterpolation( inType, outType, true );
    });

    DuAE.endUndoGroup(DuScriptUI.String.SPATIAL_INTERPOLATION);
};

Duik.CmdLib['Animation']["Set spatial linear"] = "Duik.Animation.setSpatialLinear()";
/**
 * Sets the selected keyframes spatial interpolation to linear
 */
Duik.Animation.setSpatialLinear = function() {
    Duik.Animation.setSpatialInterpolation(KeyframeInterpolationType.LINEAR);
};

Duik.CmdLib['Animation']["Set spatial bezier in"] = "Duik.Animation.setSpatialBezierIn()";
/**
 * Sets the selected keyframes spatial interpolation to linear
 */
Duik.Animation.setSpatialBezierIn = function() {
    Duik.Animation.setSpatialInterpolation(KeyframeInterpolationType.BEZIER, KeyframeInterpolationType.LINEAR);
};

Duik.CmdLib['Animation']["Set spatial bezier out"] = "Duik.Animation.setSpatialBezierOut()";
/**
 * Sets the selected keyframes spatial interpolation to linear
 */
Duik.Animation.setSpatialBezierOut = function() {
    Duik.Animation.setSpatialInterpolation(KeyframeInterpolationType.LINEAR, KeyframeInterpolationType.BEZIER);
};

Duik.CmdLib['Animation']["Set spatial bezier"] = "Duik.Animation.setSpatialBezier()";
/**
 * Sets the selected keyframes spatial interpolation to linear
 */
Duik.Animation.setSpatialBezier = function() {
    Duik.Animation.setSpatialInterpolation(KeyframeInterpolationType.BEZIER, KeyframeInterpolationType.BEZIER);
};

Duik.CmdLib['Animation']["Fix spatial interpolation"] = "Duik.Animation.fixSpatialInterpolation()";
/**
 * Sets the selected keyframes spatial interpolation to linear
 */
Duik.Animation.fixSpatialInterpolation = function() {
    var props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    DuAE.beginUndoGroup(DuScriptUI.String.SPATIAL_INTERPOLATION, false);

    props.do(function(prop) {
        if (prop.isGroup()) return;
        prop.fixSpatialInterpolation( undefined, true );
    });

    DuAE.endUndoGroup(DuScriptUI.String.SPATIAL_INTERPOLATION);
};

/**
 * Adds a key to the properties at current time, tweening according to the previous and next keyframe
 * @param {float} [tweenRatio=0.5] The value ratio for tweening: 0.0 is the value of the previous key, 1.0 is the value of the next key. Note that this value can be < 0 and > 1.0 if you wish.
 * @param {Bool} [animatedProps=true] Set to false to add a key to all selected properties, instead of all animated properties.
 * @param {Bool} [selectedLayers=true] Set to false to add a key to all layers instead of just the selection.
 */
Duik.Animation.tween = function(tweenRatio, animatedProps, selectedLayers) {
    tweenRatio = def(tweenRatio, 0.5);
    animatedProps = def(animatedProps, true);
    selectedLayers = def(selectedLayers, true);

    DuAE.beginUndoGroup(DuScriptUI.String.TWEEN, false);

    var props;
    if (animatedProps) props = DuAEComp.getAnimatedProps(undefined, undefined, undefined, selectedLayers);
    else props = DuAEComp.getSelectedProps();
    props = new DuList(props);
    if (props.length == 0) return;

    props.do(function(prop) {
        var numKeys = prop.numKeys(false);
        if (numKeys == 0) return;
        // Current time
        var time = prop.comp.time;
        // Values
        var nKey = prop.nearestKeyAtTime(time);
        var pKey;
        // There's a keyframe at the current time, remove it and try again
        if (nKey._time == time && nKey._index != 0 && nKey._index != numKeys) {
            prop.removeKey(nKey);
            nKey = prop.nearestKeyAtTime(time);
        }
        // Get the previous key
        if (nKey._time < time) {
            // It's the last one; ignore
            if (nKey._index == numKeys) return;
            pKey = nKey;
            nKey = prop.keyAtIndex(nKey._index + 1);
        }
        else {
            // It's the first one; just set a new key at current time
            if (nKey._index == 0) return;
            pKey = prop.keyAtIndex(nKey._index - 1);
        }
    
        // Interpolate the value and set the new key
        var newValue = DuMath.linear(tweenRatio, 0.0, 1.0, pKey.value, nKey.value);
        prop.setValueAtTime( newValue, time);
    });

    DuAE.endUndoGroup(DuScriptUI.String.TWEEN, false);
};