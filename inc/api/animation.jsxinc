/**
 * The animator's toolkit.
 * @namespace
 */
Duik.Animation = {};

// low-level undocumented list
// The animations which have been copied by Duik.Animation.copy()
Duik.Animation.copied = [];

/**
 * The list of animation functions
 */
Duik.CmdLib['Animation'] = [];

Duik.CmdLib['Animation']["Select Keyframes"] = "Duik.Animation.selectKeyframes()";
/**
 * Selects the keyframes in the comp
 * @param {CompItem} [comp=DuAEProject.getActiveComp] The composition
 * @param {Boolean} [selectedLayers=false] Set to true to get the keyframes only on the selected layers instead of all the layers.
 * @param {Boolean} [controllersOnly=true] Set to false to get the keyframes from all types of layers instead of just the controllers.
 * @param {float[]} [range] The time range to select the keyframes, [in, out]. If omitted, will use the work area of the composition.
 * @param {string[]} [propertyMatchNames=[]] The list of matchnames to select only keyframes of a specific type. If empty, will select all types of keyframes.
 */
Duik.Animation.selectKeyframes = function( comp, selectedLayers, controllersOnly, range, propertyMatchNames )
{
    comp = def(comp, DuAEProject.getActiveComp() );
    if(!comp) return;
    selectedLayers = def( selectedLayers, false );
    controllersOnly = def( controllersOnly, true );
    range = def( range, [comp.workAreaStart, comp.workAreaStart + comp.workAreaDuration ] );
    propertyMatchNames = def( propertyMatchNames, [
        'ADBE Position',
        'ADBE Vector Position',
        'ADBE Position_0',
        'ADBE Position_1',
        'ADBE Position_2',
        'ADBE Rotate Z',
        'ADBE Rotate Y',
        'ADBE Rotate X',
        'ADBE Orientation',
        'ADBE Vector Rotation',
        'ADBE Scale',
        'ADBE Vector Scale',
        'ADBE Opacity',
        'ADBE Vector Group Opacity',
        'ADBE Mask Parade',
        'ADBE Effect Parade'
    ]);
    propertyMatchNames = new DuList(propertyMatchNames);

    DuAE.beginUndoGroup(DuScriptUI.String.SELECT_KEYFRAMES, false);
    DuAEProject.setProgressMode(true);

    //get layers
    var layers = [];
    if ( !selectedLayers )
    {
        if ( !controllersOnly ) layers = comp.layers;
        else layers = Duik.Controller.get( false, comp );
    }
    else
    {
        if ( !controllersOnly ) layers = comp.selectedLayers;
        else layers = Duik.Controller.get( true, comp );
    }

    if (layers.length == 0)
    {
        DuAEProject.setProgressMode(false);
        DuAE.endUndoGroup(DuScriptUI.String.SELECT_KEYFRAMES);
        return;
    }

    //unselect all previously selected keyframes
	DuAEComp.unselectProperties();

    // A filter to get properties
    function filterProps( prop )
    {
        if ( propertyMatchNames.length() == 0) return true;
        return propertyMatchNames.indexOf( prop.matchName ) >= 0;
    }

    //get all properties
    layers = new DuList(layers);
    layers.do(function (layer)
    {
        var props = DuAEProperty.getProps(layer,filterProps);
        props = new DuList(props);
        props.do(function(prop)
        {
            prop.selectKeys( range[0], range[1]);
        });
    });

    DuAEProject.setProgressMode(false);
    DuAE.endUndoGroup(DuScriptUI.String.SELECT_KEYFRAMES);
}

Duik.CmdLib['Animation']["Copy"] = "Duik.Animation.copy()";
/**
 * Copies the currently selected keyframes, which can then be pasted with {@link Duik.Animation.paste}.
 * @param {CompItem} [comp=DuAEProject.getActiveComp] The composition
 * @returns {DuAELayerAnimation[]} The list of animations which have been copied.
 */
Duik.Animation.copy = function( comp )
{
    comp = def(comp, DuAEProject.getActiveComp() );
    if(!comp) return;

    var layers = comp.selectedLayers;
    if (layers.length == 0) return;

    copiedAnim = [];

    for (var i = 0 ; i < layers.length ; i++)
    {
        copiedAnim.push(DuAELayer.getAnim( layers[i],true ));
    }
    //get the first keyframe time to offset when pasting
    copiedAnim.firstKeyFrameTime = DuAELayer.firstKeyFrameTime(layers, true);

    Duik.Animation.copied = copiedAnim;

    return copiedAnim;
}

Duik.CmdLib['Animation']["Paste"] = "Duik.Animation.paste()";
Duik.CmdLib['Animation']["Paste Reversed"] = "Duik.Animation.paste( undefined, false, false, true )";
Duik.CmdLib['Animation']["Paste Offset"] = "Duik.Animation.paste( undefined, false, true )";
Duik.CmdLib['Animation']["Paste Replace"] = "Duik.Animation.paste( undefined, true )";
/**
 * Pastes the animation previously copied by {@link Duik.Animation.copy} to the selected properties.
 * @param {CompItem} [comp] The composition.
 * @param {Boolean} [replace=false] - Whether to completely erase and replace the current animation
 * @param {Boolean} [offset=false] - Whether to offset the animation from the current value
 * @param {Boolean} [reverse=false] - Whether to reverse the animation
 * @param {string[]} [matchNames=[]] A filter to apply only on specific property types
 */
Duik.Animation.paste = function( comp, replace, offset, reverse )
{
    DuIO.Animation.paste( comp, Duik.Animation.copied, replace, offset, reverse );
}

Duik.CmdLib['Animation']["Interpolator"] = "Duik.Animation.interpolator()";
/**
 * Control the selected keyframes with advanced but easy-to-use keyframe interpolation driven by an effect.
 * @param {PropertyBase[]|DuList.<PropertyBase>|PropertyBase} [props] The properties to interpolate. The selected properties in the active comp if omitted.
 * @param {PropertyGroup} [effect] The pseudo effect to use if it already exists.
 * @returns {PropertyGroup} The pseudo-effect
 */
Duik.Animation.interpolator = function( props, effect )
{
    props = def(props, DuAEComp.getSelectedProps() );
    props = new DuList(props);
    if (props.length() == 0) return null;

    var p = props.at(0);
    p = new DuAEProperty(p);
    var ctrlLayer = p.layer;

    DuAE.beginUndoGroup(DuScriptUI.String.INTERPOLATOR, false);

    // Add the effect
    if (!effect)
    {
        effect = Duik.PseudoEffect.INTERPOLATOR.apply( ctrlLayer, DuScriptUI.String.INTERPOLATOR + ' | ' + p.name );
    }

    // Indices
    var i = Duik.PseudoEffect.INTERPOLATOR.props;

    // The Expression
    var exp = [ DuAEExpression.Id.INTERPOLATOR,
        'var fx = thisComp.layer("' + ctrlLayer.name + '").effect("' + effect.name + '");',
        'var iType = fx(' + i['Type'].index + ').value;',
        'var iRate = fx(' + i['Rate'].index + ').value;',
        '',
        'var isIn = fx(' + i['Extrapolation and loop']['In']['In'].index + ');',
        'var inType = fx(' + i['Extrapolation and loop']['In']['Type'].index + ').value;',
        'var inNumKeyframes = fx(' + i['Extrapolation and loop']['In']['Number of keyframes'].index + ').value;',
        'var isOut = fx(' + i['Extrapolation and loop']['Out']['Out'].index + ');',
        'var outType = fx(' + i['Extrapolation and loop']['Out']['Type'].index + ').value;',
        'var outNumKeyframes = fx(' + i['Extrapolation and loop']['Out']['Number of keyframes'].index + ').value;',
        '',
        DuAEExpression.Library.get([
            'lastActiveTime',
            'nextActiveTime',
            'continueOut',
            'continueIn',
            'cycleOut',
            'cycleIn',
            'pingPongOut',
            'pingPongIn',
            'bezierInterpolation',
            'gaussianInterpolation',
            'linearExtrapolation',
            'logisticInterpolation',
            'logInterpolation',
            'expInterpolation'
        ]),
        '',
        'var result = value;',
        '',
        'function iAtTime( t )',
        '{',
        '  // Needed keyframes',
        '	var pKey = getPrevKey(t, thisProperty);',
        '	var nKey = getNextKey(t, thisProperty);',
        '	',
        '	if (!pKey || !nKey) return value;',
        '	',
        '	if (iType == 1) // None',
        '	{',
        '	  return valueAtTime(t);',
        '	}',
        '	else if (iType == 2) // Linear ',
        '	{',
        '	  return linear(',
        '			t,',
        '			pKey.time,',
        '			nKey.time,',
        '			pKey.value,',
        '			nKey.value',
        '		);',
        '	}',
        '	else if (iType == 3) // Bezier',
        '	{',
        '	  var bUseAdvanced = fx(' + i['Bezier options']['Use advanced options'].index + ').value;',
        '	    ',
        '    if (bUseAdvanced)',
        '    {',
        '      var bInI = fx(' + i['Bezier options']['Advanced']['In Influence'].index + ').value/100;',
        '      var bInV = fx(' + i['Bezier options']['Advanced']['In Velocity'].index + ').value/100;',
        '      var bOutI = fx(' + i['Bezier options']['Advanced']['Out Influence'].index + ').value/100;',
        '      var bOutV = fx(' + i['Bezier options']['Advanced']['Out Velocity'].index + ').value/100;',
        '      ',
        '      return bezierInterpolation(',
        '        t,',
        '        pKey.time,',
        '        nKey.time,',
        '        pKey.value,',
        '        nKey.value,',
        '        [bInI, bInV, 1 - bOutI, 1 - bOutV]',
        '      );',
        '    }',
        '    else',
        '    {',
        '      var bRatio = fx(' + i['Bezier options']['In/Out Ratio'].index + ').value / 100;',
        '      var bIn = linear(iRate, 0, 10, 0.0, 1.0) * bRatio;',
        '      var bOut = linear(iRate, 0, 10, 0.0, 1.0) * (1-bRatio);',
        '      bOut = 1 - bOut;',
        '      ',
        '      return bezierInterpolation(',
        '        t,',
        '        pKey.time,',
        '        nKey.time,',
        '        pKey.value,',
        '        nKey.value,',
        '        [bIn, 0, bOut, 1]',
        '      );',
        '    }',
        '	}',
        '	else if (iType == 4) // Gaussian ',
        '	{',
        '	  iRate = linear(iRate, 1, 10, -1, 1);',
        '	  return gaussianInterpolation(',
        '	    t,',
        '	    pKey.time,',
        '      nKey.time,',
        '      pKey.value,',
        '      nKey.value,',
        '      iRate',
        '	  );',
        '	}',
        '	else if (iType == 5) // Logistic',
        '	{',
        '	  var midRatio = fx(' + i['Logistic options']['Mid point'].index + ') / 100;',
        '	  var mid = pKey.time + ( nKey.time - pKey.time ) * midRatio;',
        '	  return logisticInterpolation(',
        '	    t,',
        '	    pKey.time,',
        '	    nKey.time,',
        '	    pKey.value,',
        '	    nKey.value,',
        '	    iRate,',
        '	    mid',
        '	  );',
        '	}',
        '	else if (iType == 6) // Logarithmic',
        '	{',
        '	  return logInterpolation(',
        '	    t,',
        '	    pKey.time,',
        '	    nKey.time,',
        '	    pKey.value,',
        '	    nKey.value,',
        '	    iRate',
        '	  );',
        '	}',
        '	else if (iType == 7) // Inverse log ',
        '	{',
        '	  return expInterpolation(',
        '	    t,',
        '	    pKey.time,',
        '	    nKey.time,',
        '	    pKey.value,',
        '	    nKey.value,',
        '	    iRate',
        '	  );',
        '	}',
        '	',
        '	return -1;',
        '}',
        '',
        'function i() {',
        '	if (numKeys < 2) return value;',
        '',
        '	// Needed keyframes',
        '	var pKey = getPrevKey(time, thisProperty);',
        '	var nKey = getNextKey(time, thisProperty);',
        '	',
        '	if (!pKey || !nKey)',
        '	{',
        '		var outTime = lastActiveTime(isOut, time);',
        '		var inTime = nextActiveTime(isIn, time);',
        '',
        '		if (time < key(1).time) {',
        '			if (inType == 1) return value;',
        '			else if (inType == 3) return cycleIn(inTime, inNumKeyframes, true, iAtTime);',
        '			else if (inType == 4) return cycleIn(inTime, inNumKeyframes, false, iAtTime);',
        '			else if (inType == 5) return pingPongIn(inTime, inNumKeyframes, iAtTime);',
        '			else if (inType == 2)',
        '			{',
        '			  if (iType == 1) return continueIn(inTime); // None',
        '			  else if (iType == 2) // Linear ',
        '			  {',
        '			    var firstVelocity = (nKey.value - iAtTime( nKey.time + 0.01 )) * 100;',
        '        	    var timeSpent = nKey.time - time;',
        '        	    return nKey.value + timeSpent * firstVelocity;',
        '			  }',
        '			  else if (iType == 3) // Bezier',
        '			  {',
        '			    var bUseAdvanced = fx(' + i['Bezier options']['Use advanced options'].index + ').valueAtTime(nKey.time);',
        '			    if (!bUseAdvanced) return value;',
        '			    var bInV = fx(' + i['Bezier options']['Advanced']['In Velocity'].index + ').valueAtTime(nKey.time) / 100;',
        '			    if (bInV == 0) return value;',
        '			    var firstVelocity = (iAtTime( nKey.time + 0.01 ) - nKey.value) * 100;',
        '			    var timeSpent = nKey.time - time;',
        '	            return  nKey.value - timeSpent * firstVelocity;',
        '			  }',
        '			  else if (iType == 4) // Gaussian',
        '			  {',
        '			    return value;',
        '			  }',
        '			  else if (iType == 5) // Logistic',
        '			  {',
        '			    var pKey = key(1);',
        '			    var nKey = key(2);',
        '			    var midRatio = fx(' + i['Logistic options']['Mid point'].index + ') / 100;',
        '      	        var mid = pKey.time + ( nKey.time - pKey.time ) * midRatio;',
        '      	        return logisticInterpolation(',
        '      	            time,',
        '      	            pKey.time,',
        '      	            nKey.time,',
        '      	            pKey.value,',
        '      	            nKey.value,',
        '      	            iRate,',
        '      	            mid',
        '      	        );',
        '			  }',
        '			  else if (iType == 6) // Log',
        '			  {',
        '			    return value;',
        '			  }',
        '			  else if (iType == 7) // Exp ',
        '			  {',
        '			    var pKey = key(1);',
        '			    var nKey = key(2);',
        '			    return expInterpolation(',
        '      	            time,',
        '      	            pKey.time,',
        '      	            nKey.time,',
        '      	            pKey.value,',
        '      	            nKey.value,',
        '      	            iRate',
        '      	        );',
        '			  }',
        '			}',
        '		} else if (outTime > key(numKeys).time) {',
        '			if (outType == 1) return value;',
        '			else if (outType == 3) return cycleOut(outTime, outNumKeyframes, true, iAtTime);',
        '			else if (outType == 4) return cycleOut(outTime, outNumKeyframes, false, iAtTime);',
        '			else if (outType == 5) return pingPongOut(outTime, outNumKeyframes, iAtTime);',
        '			else if (outType == 2) ',
        '			{',
        '			  if (iType == 1) return continueOut(outTime); // None',
        '			  else if (iType == 2) // Linear ',
        '			  {',
        '			    var lastVelocity = (pKey.value - iAtTime( pKey.time - 0.01 )) * 100;',
        '			    var timeSpent = time - pKey.time;',
        '			    return pKey.value + timeSpent * lastVelocity;',
        '			  }',
        '			  else if (iType == 3) // Bezier',
        '			  {',
        '			    var bUseAdvanced = fx(' + i['Bezier options']['Use advanced options'].index + ').valueAtTime(pKey.time);',
        '			    if (!bUseAdvanced) return value;',
        '			    var bOutV = fx(' + i['Bezier options']['Advanced']['Out Velocity'].index + ').valueAtTime(pKey.time) / 100;',
        '			    if (bOutV == 0) return value;',
        '			    var lastVelocity = (pKey.value - iAtTime( pKey.time - 0.01 )) * 100;',
        '			    var timeSpent = time - pKey.time;',
        '	            return pKey.value + timeSpent * lastVelocity;',
        '			  }',
        '			  else if (iType == 4) // Gaussian',
        '			  {',
        '			    return value;',
        '			  }',
        '			  else if (iType == 5) // Logistic',
        '			  {',
        '			    var pKey = key(numKeys - 1);',
        '			    var nKey = key(numKeys);',
        '			    var midRatio = fx(' + i['Logistic options']['Mid point'].index + ') / 100;',
        '      	        var mid = pKey.time + ( nKey.time - pKey.time ) * midRatio;',
        '      	        return logisticInterpolation(',
        '      	            time,',
        '      	            pKey.time,',
        '      	            nKey.time,',
        '      	            pKey.value,',
        '      	            nKey.value,',
        '      	            iRate,',
        '      	            mid',
        '      	        );',
        '			  }',
        '			  else if (iType == 6) // Log',
        '			  {',
        '			    var pKey = key(numKeys - 1);',
        '			    var nKey = key(numKeys);',
        '			    return logInterpolation(',
        '      	            time,',
        '      	            pKey.time,',
        '      	            nKey.time,',
        '      	            pKey.value,',
        '      	            nKey.value,',
        '      	            iRate',
        '      	        );',
        '			  }',
        '			  else if (iType == 7) // Exp ',
        '			  {',
        '			    var pKey = key(numKeys - 1);',
        '			    var nKey = key(numKeys);',
        '			    return expInterpolation(',
        '      	            time,',
        '      	            pKey.time,',
        '      	            nKey.time,',
        '      	            pKey.value,',
        '      	            nKey.value,',
        '      	            iRate',
        '      	        );',
        '			  }',
        '			}',
        '		}',
        '	}',
        '	',
        '	return iAtTime( time );',
        '}',
        '',
        'result = i();',
        'result;'//*/
        ].join('\n');

    // Add expressions
    props.do(function (prop)
    {
        prop = new DuAEProperty(prop);
        prop.setExpression( exp, false );
    });

    DuAE.endUndoGroup(DuScriptUI.String.INTERPOLATOR);

    return effect;
}