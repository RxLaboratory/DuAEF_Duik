/**
 * The lazy animator's toolkit.
 * @namespace
 */
Duik.Automation = {};

/**
 * The types of the comps in an NLA
 * @enum {int}
 * @readonly
 */
Duik.Automation.NLACompType = {
    NONE: 0,
    ORIGINAL: 1,
    RENDER: 2,
    CLIP: 3,
    EDIT: 4
}

/**
 * The prefixes for the NLA comp & folder names.<br />
 * These may be localized, don't use the actual strings!
 * @enum {string}
 * @readonly
 */
Duik.Automation.NLAPrefixes = {
    FOLDER: DuScriptUI.String.NLA_SHORT + '::',
    ORIGINAL: DuScriptUI.String.NLA_SHORT + '.' + DuScriptUI.String.ORIGINAL + '::',
    RENDER: DuScriptUI.String.NLA_SHORT + '.' + DuScriptUI.String.RENDER + '::',
    CLIP: DuScriptUI.String.NLA_SHORT + '.' + DuScriptUI.String.CLIP + '::',
    EDIT: DuScriptUI.String.NLA_SHORT + '.' + DuScriptUI.String.EDIT + '::'
}

/**
 * Checks if the given comp is part of an NLA
 * @return {Duik.Automation.NLACompType} The type of the comp; Duik.Automation.NLACompType.NONE if it's not part of an NLA.
 */
Duik.Automation.NLAType = function(comp) {
    // It must be in an NLA folder
    var nlaFolder = comp.parentFolder;
    if (nlaFolder.name.indexOf(Duik.Automation.NLAPrefixes.FOLDER) != 0) return Duik.Automation.NLACompType.NONE;

    var name = comp.name;
    if (name.indexOf(Duik.Automation.NLAPrefixes.ORIGINAL) == 0) return Duik.Automation.NLACompType.ORIGINAL;
    if (name.indexOf(Duik.Automation.NLAPrefixes.RENDER) == 0) return Duik.Automation.NLACompType.RENDER;
    if (name.indexOf(Duik.Automation.NLAPrefixes.CLIP) == 0) return Duik.Automation.NLACompType.CLIP;
    if (name.indexOf(Duik.Automation.NLAPrefixes.EDIT) == 0) return Duik.Automation.NLACompType.EDIT;
    return Duik.Automation.NLACompType.NONE;
}

/**
 * Gets the folder containing the NLA Compositions like the given comp.
 * @param {CompItem} comp The comp
 * @return {FolderItem|null} The folder or null if the comp is not part of an NLA
 */
Duik.Automation.getNLAFolder = function(comp) {
    var nlaFolder = comp.parentFolder;
    if (nlaFolder.name.indexOf(Duik.Automation.NLAPrefixes.FOLDER) != 0) return null;
    return nlaFolder;
}

/**
 * Gets the render, original and edit comps for this NLA
 * @param {FolderItem} nlaFolder The NLA Folder
 * @return {CompItem[]} The compositions in this order: [Original, Edit, Render]. Note that if one is not found, null is returned.
 */
Duik.Automation.getNLAComps = function(nlaFolder) {
    var originalComp = null;
    var editComp = null;
    var renderComp = null;
    for (var i = 1, n = nlaFolder.numItems; i <= n; i++) {
        var c = nlaFolder.item(i);
        if (!c instanceof CompItem) continue;
        if (c.name.indexOf(Duik.Automation.NLAPrefixes.ORIGINAL) == 0) {
            originalComp = c;
        }
        if (c.name.indexOf(Duik.Automation.NLAPrefixes.EDIT) == 0) {
            editComp = c;
        }
        if (c.name.indexOf(Duik.Automation.NLAPrefixes.RENDER) == 0) {
            renderComp = c;
        }
        // Got'em all
        if (originalComp && editComp && renderComp) break;
    }
    return [originalComp, editComp, renderComp];
}

/**
 * The list of automation functions
 */
Duik.CmdLib['Automation'] = [];

Duik.CmdLib['Automation']["NLA"] = "Duik.Automation.setupNLA()";
/**
 * Sets up a non-linear animation comp.
 * @param {CompItem} [comp] The composition to set up. The active composition if omitted.
 * @param {Boolean} [selectedProps=true] Use only currently selected properties if true, all properties (according to the other options) if false.
 * @param {Boolean} [transformProps=true] If true, filters only properties in the transform group of the layers. Ignored if selectedProps is true.
 * @param {Boolean} [effectProps=false] If true, filters only properties in effects. Ignored if selectedProps is true.
 * @param {Boolean} [layerTypes=[Duik.Layer.Type.BONE, Duik.Layer.Type.CONTROLLER]] The types of layer to setup; if empty, will setup all layers.
 * @param {PropertyBase[]|DuList.<PropertyBase>} [props] A list of properties to set up. In case this parameter is provided, all other parameters are ignored.
 */
Duik.Automation.setupNLA = function(comp, selectedProps, transformProps, effectProps, layerTypes, props) {
    comp = def(comp, DuAEProject.getActiveComp());

    if (typeof props === 'undefined') {
        selectedProps = def(selectedProps, true);
        transformProps = def(transformProps, true);
        effectProps = def(effectProps, false);
        layerTypes = def(layerTypes, [Duik.Layer.Type.BONE, Duik.Layer.Type.CONTROLLER]);

        // List properties according to the filters

        if (selectedProps) {
            props = DuAEComp.getSelectedProps();
            if (props.length == 0) selectedProps = false;
        }

        if (!selectedProps) {
            // Get the layers
            var layers = [];
            props = [];
            if (layerTypes.length > 0) {
                for (var i = 1, n = comp.numLayers; i <= n; i++) {
                    var l = comp.layer(i);
                    for (var j = 0, nt = layerTypes.length; j < nt; j++) {
                        if (Duik.Layer.isType(l, layerTypes[j])) {
                            layers.push(l);
                            break;
                        }
                    }
                }
            } else layers = comp.layers;
            layers = new DuList(layers);
            layers.do(function(layer) {
                if (transformProps) props.push(new DuAEProperty(layer.transform));
                if (effectProps) props.push(new DuAEProperty(layer.property('ADBE Effects Parade')));
            });
        }
    }

    props = new DuList(props);
    if (props.length() == 0) return;

    DuAE.beginUndoGroup(DuScriptUI.String.NLA, false);

    var compName = comp.name;

    var editComp;

    // Check if it's already an NLA; in this case don't create, just add the properties.
    var create = true;
    if (Duik.Automation.NLAType(comp) != Duik.Automation.NLACompType.NONE) {
        var nlaFolder = Duik.Automation.getNLAFolder(comp);
        if (nlaFolder)
        {
            create = false;
            var nlaComps = Duik.Automation.getNLAComps(nlaFolder);
            var renderComp = nlaComps[2];
            editComp = nlaComps[1];
            // Find the same properties in the render comp
            if(renderComp) {
                var renderProps = [];
                props.do(function(prop) {
                    renderProp = prop.findInComp(renderComp);
                    if (renderProp) renderProps.push(renderProp);
                });
                // Replace props with the ones from the render comp
                props = new DuList(renderProps);
            }
        }
    }

    if (create) {
        // Create folderitem NLA::compName
        var parentFolder = comp.parentFolder;
        var nlaFolder = app.project.items.addFolder(Duik.Automation.NLAPrefixes.FOLDER + compName);
        nlaFolder.parentFolder = parentFolder;
        comp.parentFolder = nlaFolder;
        var renderComp = comp;

        // Duplicate comp twice
        // One will be NLA.Render::compName
        var oComp = renderComp.duplicate();
        oComp.name = Duik.Automation.NLAPrefixes.ORIGINAL + compName;
        // Other NLA.Clip::compName
        var clipComp = renderComp.duplicate();
        clipComp.name = Duik.Automation.NLAPrefixes.CLIP + compName;
        // and keep NLA.Original::compName
        renderComp.name = Duik.Automation.NLAPrefixes.RENDER + compName;
        // Create NLA.Edit::compName
        var editComp = nlaFolder.items.addComp(
            Duik.Automation.NLAPrefixes.EDIT + compName,
            renderComp.width, renderComp.height, renderComp.pixelAspect, renderComp.duration, renderComp.frameRate
        );

        // Add NLA.Clip + time remap + looper, and a keyframe on the opacity
        var clipPrecomp = editComp.layers.add(clipComp);
        clipPrecomp.enabled = false;
        clipPrecomp.guideLayer = false;

        // Add NLA.Render
        editComp.layers.add(comp);
    }

    // Setup properties in NLA.Render

    var exp = [DuAEExpression.Id.NLA,
        'var editComp = comp("' + editComp.name + '");',
        '',
        'var result = value;',
        'var weights = 0;',
        '',
        DuAEExpression.Library.get(['getSameProp', 'isZero']),
        '',
        'for (var i = 1, n = editComp.numLayers; i <= n; i++)',
        '{',
        '	var l = editComp.layer(i);',
        '	if (l.name == thisComp.name) continue;',
        '   if (l.name.indexOf(\'NLA.Clip::\') != 0) continue;',
        '	if (time >= l.inPoint && time < l.outPoint)',
        '	{',
        '	    var precomp = l.source;',
        '	    try { var c = precomp.layer(thisLayer.name); }',
        '        catch(e) { continue; }',
        '        var weight = l.opacity.value/100;',
        '        var t = time;',
        '        try { t = l.timeRemap.value; }',
        '        catch(e) { t = time - l.startTime; }',
        '        var dif = getSameProp(c).valueAtTime(t) - value;',
        '        if (isZero(dif)) continue;',
        '        weights += weight;',
        '        result += dif * weight;',
        '	}',
        '}',
        'result;'
    ].join('\n');

    props.do(function(prop) {
        prop.setExpression(exp);
    });

    // Open edit comp
    editComp.openInViewer();

    DuAE.endUndoGroup(DuScriptUI.String.NLA);

}

Duik.CmdLib['Automation']["NLA Clip"] = "Duik.Automation.addNLAClip()";
/**
 * Creates a clip and adds it to the NLA
 * @param {CompItem} [nlaComp] A comp belonging to an NLA, the active comp if omitted.
 * @returns {int} Success code: 1 if the clip could be created, 0 if the original comp is not found, -1 if the NLA is invalid/not found
 */
Duik.Automation.addNLAClip = function(nlaComp) {
    nlaComp = def(nlaComp, DuAEProject.getActiveComp());
    if (!nlaComp) return -1;

    var nlaFolder = Duik.Automation.getNLAFolder(nlaComp);
    if (!nlaFolder) return -1;

    var nlaName = nlaFolder.name.replace('NLA::', '');

    // Get the original comp
    var nlaComps = Duik.Automation.getNLAComps(nlaFolder);
    var originalComp = nlaComps[0];
    var editComp = nlaComps[1];

    if (!originalComp) return 0;

    // Duplicate
    var newClip = originalComp.duplicate();

    // Rename
    newClip.name = originalComp.name.replace('NLA.Original', 'NLA.Clip') + '-newClip';

    // Add to edit
    if (editComp) {
        var clipLayer = editComp.layers.add(newClip);
        clipLayer.enabled = false;
        if (editComp.numLayers >= 2) clipLayer.moveAfter(editComp.layer(2));
    }

    // Open clip
    newClip.openInViewer();

    return 1;
}

Duik.CmdLib['Automation']["Looper"] = "Duik.Automation.looper()";
/**
 * Adds a loop expression and pseudo effect with more options than the loopOut and loopIn expressions.
 * @param {PropertyBase[]|DuList.<PropertyBase>|PropertyBase} [props] The properties to loop. The selected properties in the active comp if omitted.
 * @param {PropertyGroup} [effect] The pseudo effect to use if it already exists.
 * @returns {PropertyGroup} The pseudo-effect
 */
Duik.Automation.looper = function(props, effect) {
    effect = Duik.Animation.interpolator(props, effect);

    var i = Duik.PseudoEffect.INTERPOLATOR.props;

    // Set interpolation to none
    effect(i['Type'].index).setValue(1);
    // Set cycles
    effect(i['In Extrapolation and loop']['Type'].index).setValue(4);
    effect(i['Out Extrapolation and loop']['Type'].index).setValue(4);
    // Activate
    effect(i['In Extrapolation and loop']['Before keys'].index).setValue(1);
    effect(i['Out Extrapolation and loop']['After keys'].index).setValue(1);

    return effect;
}

Duik.Automation.copiedExpression = '';
Duik.CmdLib['Automation']["Copy Expression"] = "Duik.Automation.copyExpression()"
/**
 * Copies the expression from the property, which can be pasted in multiple properties with {@link Duik.Automation.pasteExpression}.
 * @param {Property|DuAEProperty} [prop] The property, the selected/active property if omitted.
 * @returns {string} The expression.
 */
Duik.Automation.copyExpression = function(prop) {
    if (typeof prop === 'undefined') {
        var props = DuAEComp.getSelectedProps();
        if (props.length == 0) return Duik.Automation.copiedExpression;
        prop = props.pop();
    }

    prop = new DuAEProperty(prop);
    if (prop.riggable()) {
        prop = prop.getProperty();
        Duik.Automation.copiedExpression = prop.expression;
    }

    return Duik.Automation.copiedExpression;
}

Duik.CmdLib['Automation']["Paste Expression"] = "Duik.Automation.pasteExpression()"
/**
 * Pastes the expression previously copied with {@link Duik.Automation.copyExpression}.
 * @param {Property[]|DuAEProperty[]} [props] The properties where to paste the expression, the selecte properties if omitted.
 * @param {string} [expression] A specific expression to paste.
 */
Duik.Automation.pasteExpression = function(props, expression) {
    props = def(props, DuAEComp.getSelectedProps());
    if (props.length == 0) return;
    expression = def(expression, Duik.Automation.copiedExpression);

    DuAE.beginUndoGroup(DuScriptUI.String.PASTE_EXPRESSION, false);

    var i = new DuList(props);
    i.do(function(prop) {
        if (prop.riggable()) {
            prop.setExpression(expression, false);
        }
    });

    DuAE.endUndoGroup(DuScriptUI.String.PASTE_EXPRESSION);
}

Duik.CmdLib['Automation']["Remove Expressions"] = "Duik.Automation.removeExpressions()"
/**
 * Removes the expressions from the properties.
 * @param {Boolean} [keepPostExpressionValue=true]  Set to false to just remove the expressions and get back the pre expression value.
 * @param {Property[]|DuAEProperty[]} [props] The properties, the selected properties if omitted (or the selected layers).
 */
Duik.Automation.removeExpressions = function(keepPostExpressionValue, props) {
    keepPostExpressionValue = def(keepPostExpressionValue, true);
    props = def(props, DuAEComp.getSelectedProps());
    if (props.length == 0) props = DuAEComp.getSelectedLayers();

    DuAE.beginUndoGroup(DuScriptUI.String.REMOVE_EXPRESSIONS, false);

    for (var i = 0, num = props.length; i < num; i++) {
        var p = new DuAEProperty(props[i]);
        p.removeExpressions(undefined, keepPostExpressionValue);
    }

    DuAE.endUndoGroup(DuScriptUI.String.REMOVE_EXPRESSIONS);

}

Duik.CmdLib['Automation']["Bake Expressions"] = "Duik.Automation.bakeExpressions()"
/**
 * Bakes the expressions to keyframes
 * @param {DuAEExpression.BakeAlgorithm} [mode=DuAEExpression.BakeAlgorithm.SMART] The algorithm to use for baking the expressions.
 * @param {float} [frameStep=1.0] By default, checks one value per keyframe. A lower value increases the precision and allows for sub-frame sampling. A higher value is faster but less precise.
 * @param {Duik.SelectionMode} [selectionMode=DuAE.SelectionMode.SELECTED_PROPERTIES] The expressions to bake
 */
Duik.Automation.bakeExpressions = function(mode, frameStep, selectionMode) {
    // Defaults
    mode = def(mode, DuAEExpression.BakeAlgorithm.SMART);
    frameStep = def(frameStep, 1);
    selectionMode = def(selectionMode, DuAE.SelectionMode.SELECTED_PROPERTIES);

    DuAE.beginUndoGroup(DuScriptUI.String.BAKE_EXPRESSIONS, false);
    DuAEProject.setProgressMode(true, false); // For some reason the progress bar keeps poping up...

    //DuScriptUI.progressBar.stg("Baking expressions to keyframes");

    if (selectionMode == DuAE.SelectionMode.ALL_COMPOSITIONS) DuAEProject.bakeExpressions(mode, frameStep);
    else if (selectionMode == DuAE.SelectionMode.SELECTED_COMPOSITIONS) {
        var comps = DuAEProject.getSelectedComps();
        for (var i = 0, n = comps.length; i < n; i++) {
            DuAEComp.bakeExpressions(mode, frameStep, comp);
        }
    } else if (selectionMode == DuAE.SelectionMode.ACTIVE_COMPOSITION) DuAEComp.bakeExpressions(mode, frameStep);
    else if (selectionMode == DuAE.SelectionMode.SELECTED_LAYERS) {
        var layers = DuAEComp.getSelectedLayers();
        for (var i = 0, n = layers.length; i < n; i++) {
            var p = new DuAEProperty(layers[i]);
            p.bakeExpressions(mode, frameStep);
        }
    } else {
        var props = DuAEComp.getSelectedProps();
        for (var i = 0, n = props.length; i < n; i++) {
            var p = new DuAEProperty(props[i]);
            p.bakeExpressions(mode, frameStep);
        }
    }

    DuAEProject.setProgressMode(false);
    DuAE.endUndoGroup(DuScriptUI.String.BAKE_EXPRESSIONS);
}