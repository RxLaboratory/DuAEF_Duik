/**
 * Constraint tools.
 * @namespace
 */
Duik.Constraint = {};

/**
 * The types of IK for three-layer chains.
 * @enum {int}
 */
Duik.Constraint.IKType = {
    THREE: 0,
    ONE_TWO: 1,
    TWO_ONE: 2
};

/**
 * The list of constraint functions
 */
Duik.CmdLib['Constraint'] = [];

Duik.CmdLib['Constraint']["List"] = "Duik.Constraint.list()";
/**
 * List
 */
Duik.Constraint.list = function ( )
{
    var props = DuAEComp.getSelectedProps();
	if (props.length == 0) return;

	DuAE.beginUndoGroup( DuScriptUI.String.LIST );

	var layers = DuAEComp.unselectLayers();
	for (var i = 0, n = props.length; i < n ; i++)
	{
		Duik.Constraint.createList(props[i]);
	}
	DuAEComp.selectLayers(layers);

	DuAE.endUndoGroup();
}

/**
	* Adds a list on a property
	* @param {Property|DuAEProperty} prop - The Property
    * @returns {DuAEProperty} The list effect
*/
Duik.Constraint.createList = function (prop)
{
	prop = new DuAEProperty(prop);
    if (!prop.riggable()) return;

    DuAE.beginUndoGroup(DuScriptUI.String.CONSTRAINT_LIST, false);

	var dim = prop.dimensions();

	var layer = prop.layer;

	var effect = null;
	var name = prop.getProperty().name + ' List';
	if (dim == 1) effect = Duik.PseudoEffect.ONED_LIST.apply(layer, name);
	else if (dim == 2) effect = Duik.PseudoEffect.TWOD_LIST.apply(layer, name);
	else if (dim == 3) effect = Duik.PseudoEffect.THREED_LIST.apply(layer, name);
	else return;

	//set animation with expression
	var anim = prop.animation(false);
	if (anim)
    {
        var newProp = new DuAEProperty(effect(2));
        newProp.setAnim(anim,0,true,true,false);
    }
	prop.removeAnimation();

	prop.getProperty().expression =  [DuAEExpression.Id.LIST,
        "var fx = effect(\"" + effect.name + "\");",
        "var v1 = fx(2);",
        "var w1 = fx(3);",
        "var v2 = fx(6);",
        "var w2 = fx(7);",
        "var v3 = fx(10);",
        "var w3 = fx(11);",
        "var v4 = fx(14);",
        "var w4 = fx(15);",
        "var v5 = fx(18);",
        "var w5 = fx(19);",
        "v1*w1/100+v2*w2/100+v3*w3/100+v4*w4/100+v5*w5/100;"
        ].join('\n');

    DuAE.endUndoGroup(DuScriptUI.String.CONSTRAINT_LIST);

    return prop;
}

Duik.CmdLib['Constraint']["Separate Dimensions"] = "Duik.Constraint.separateDimensions()";
/**
 * Separate Dimensions
 */
Duik.Constraint.separateDimensions = function ()
{
    var props = DuAEComp.getSelectedProps();
    if ( props.length == 0 ) return;

    DuAE.beginUndoGroup( DuScriptUI.String.SEPARATE_DIMENSIONS );

    for ( var i = 0, num = props.length; i < num; i++ )
    {
        Duik.Constraint.separatePropDimensions( props[ i ] );
    }

    DuAE.endUndoGroup();
}

/**
 * Separates the dimensions of the properties into an effect.<br />
 * Works with 2D, 3D, and colors
 * @param {Property|DuAEProperty} prop - The property
 * @return {DuAEProperty[]} The seperated properties (or the original one if it could not be separated)
 */
Duik.Constraint.separatePropDimensions = function ( prop )
{
    var propInfo = new DuAEProperty( prop );
    prop = propInfo.getProperty();

    var layer = propInfo.layer;
    var dim = propInfo.dimensions();

    if ( dim < 2 || dim > 4 ) return [propInfo];

    if (prop.isSeparationLeader)
    {
        prop.dimensionsSeparated = true;
        var newProps = [];
        for (var i = 1; i <= dim; i++)
        {
            var newProp = prop.parentProperty(prop.propertyIndex + i);
            newProp = new DuAEProperty(newProp);
            newProps.push( newProp );
        }
        return newProps;
    }

    if ( dim == 2 )
    {
        var pseudo;
        if ( propInfo.isScale ) pseudo = Duik.PseudoEffect.TWO_DIMENSIONS_SCALE;
        else if ( propInfo.isAngle ) pseudo = Duik.PseudoEffect.TWO_DIMENSIONS_ANGLE;
        else pseudo = Duik.PseudoEffect.TWO_DIMENSIONS;

        var effect = pseudo.apply( layer, propInfo.name + " XY" );

        prop = propInfo.getProperty();

        var xIndex = pseudo.props['X'].index;
        var yIndex = pseudo.props['Y'].index;

        //copy values
        if ( prop.numKeys == 0 )
        {
            effect( xIndex ).setValue( prop.value[ 0 ] );
            effect( yIndex ).setValue( prop.value[ 1 ] );
        }
        else
        {
            for ( var k = prop.numKeys; k > 0; k-- )
            {
                var time = prop.keyTime( k );
                var value = prop.keyValue( k );
                effect( xIndex ).setValueAtTime( time, value[ 0 ] );
                effect( yIndex ).setValueAtTime( time, value[ 1 ] );
                prop.removeKey(k);
            }
        }

        //add expression
        prop.expression = [DuAEExpression.Id.SEPARATE_DIMENSIONS,
            'var fx = thisLayer.effect("' + effect.name + '");',
            '[fx(' + xIndex + ').value,fx(' + yIndex + ').value];'
            ].join('\n');

        //return the new props
        var xProp = new DuAEProperty(effect( xIndex ));
        var yProp = new DuAEProperty(effect( yIndex ));
        return [xProp,yProp];
    }
    
    if ( dim == 3 )
    {
        var pseudo;
        if ( propInfo.isScale ) pseudo = Duik.PseudoEffect.THREE_DIMENSIONS_SCALE;
        else if ( propInfo.isAngle ) pseudo = Duik.PseudoEffect.THREE_DIMENSIONS_ANGLE;
        else pseudo = Duik.PseudoEffect.THREE_DIMENSIONS;

        var effect = pseudo.apply( layer, propInfo.name + " XYZ" );

        prop = propInfo.getProperty();

        var xIndex = pseudo.props['X'].index;
        var yIndex = pseudo.props['Y'].index;
        var zIndex = pseudo.props['Z'].index;

        //copy values
        if ( prop.numKeys == 0 )
        {
            effect( xIndex ).setValue( prop.value[ 0 ] );
            effect( yIndex ).setValue( prop.value[ 1 ] );
            effect( zIndex ).setValue( prop.value[ 2 ] );
        }
        else
        {
            for ( var k = prop.numKeys; k > 0; k-- )
            {
                var time = prop.keyTime( k );
                var value = prop.keyValue( k );
                effect( xIndex ).setValueAtTime( time, value[ 0 ] );
                effect( yIndex ).setValueAtTime( time, value[ 1 ] );
                effect( zIndex ).setValueAtTime( time, value[ 2 ] );
                prop.removeKey(k);
            }
        }

        //add expression
        prop.expression = [DuAEExpression.Id.SEPARATE_DIMENSIONS,
            'var fx = thisLayer.effect("' + effect.name + '");',
            '[fx(' + xIndex + ').value,fx(' + yIndex + ').value, fx(' + zIndex + ').value];'
            ].join('\n');

        //return the new props
        var xProp = new DuAEProperty(effect( xIndex ));
        var yProp = new DuAEProperty(effect( yIndex ));
        var zProp = new DuAEProperty(effect( zIndex ));
        return [xProp,yProp,zProp];
    }
    
    if ( dim == 4 )
    {
        var pseudo = Duik.PseudoEffect.COLOR;
        var effect = pseudo.apply( layer, propInfo.name + " RGB/HSL" );

        var modeIndex = pseudo.props['Channels'].index;
        var rIndex = pseudo.props['R / H'].index;
        var gIndex = pseudo.props['G / S'].index;
        var bIndex = pseudo.props['B / L'].index;

        effect( modeIndex ).setValue( 2 );
        prop = propInfo.getProperty();

        //copy values
        if ( prop.numKeys == 0 )
        {
            var color = prop.value;
            color = new DuColor(color).floatHSL();
            effect( rIndex ).setValue( color[ 0 ] );
            effect( gIndex ).setValue( color[ 1 ] );
            effect( bIndex ).setValue( color[ 2 ] );
        }
        else
        {
            for ( var k = prop.numKeys; k > 0; k-- )
            {
                var time = prop.keyTime( k );
                var value = prop.keyValue( k );
                value = new DuColor(value).floatHSL();
                effect( rIndex ).setValueAtTime( time, value[ 0 ] );
                effect( gIndex ).setValueAtTime( time, value[ 1 ] );
                effect( bIndex ).setValueAtTime( time, value[ 2 ] );
                prop.removeKey(k);
            }
        }

        //add expression
        prop.expression = [DuAEExpression.Id.SEPARATE_DIMENSIONS,
            'var fx = thisLayer.effect("' + effect.name + '");',
            'var color = [fx(' + rIndex + ').value,fx(' + gIndex + ').value, fx(' + bIndex + ').value, 1];',
            'if (fx(' + modeIndex + ').value == 2) hslToRgb(color);',
            'else color;'
            ].join('\n');

        //return the new props
        var xProp = new DuAEProperty(effect( rIndex ));
        var yProp = new DuAEProperty(effect( gIndex ));
        var zProp = new DuAEProperty(effect( bIndex ));
        return [xProp,yProp,zProp];
    }
}

Duik.CmdLib['Constraint']["Lock"] = "Duik.Constraint.lock()";
/**
 * Lock propery values
 */
Duik.Constraint.lock = function ()
{
    var props = DuAEComp.getSelectedProps();
    if ( props.length == 0 ) return;

    DuAE.beginUndoGroup( DuScriptUI.String.LOCK_PROPERTIES );

    DuAEProperty.lock( props );

    DuAE.endUndoGroup();
}

Duik.CmdLib['Constraint']["Zero"] = "Duik.Constraint.zero()";
/**
 * Zero-out selected layers
 * @param {Layer[]|LayerCollection|DuList.<Layer>|Layer} [layers=DuAEComp.getSelectedLayers()] The layer. If omitted, will use all selected layers in the comp
 * @returns {ShapeLayer[]} The zeroes
 */
Duik.Constraint.zero = function( layers )
{
    layers = def(layers, DuAEComp.getSelectedLayers());
    layers = new DuList(layers);

    DuAE.beginUndoGroup( DuScriptUI.String.ADD_ZERO, false );
    DuAEProject.setProgressMode(true);

    var zeroes = [];

    layers.do( function(layer)
    {
        //create null object
        var zero = DuAEComp.addNull( layer.containingComp );
        var layerparent = layer.parent;
        layer.parent = null;
        zero.position.setValue( layer.position.value );
        zero.rotation.setValue( layer.rotation.value );
        
        Duik.Layer.copyAttributes( zero, layer, Duik.Layer.Type.ZERO );

        layer.parent = zero;
        zero.scale.setValue( layer.scale.value );
        layer.scale.setValue( [ 100, 100, 100 ] );

        //parent
        zero.parent = layerparent;

        //lock and hide
        zero.moveToEnd();
        zero.shy = true;
        zero.enabled = false;
        zero.selected = false;
        zero.locked = true;
        zeroes.push(zero);
    } );

    DuAEProject.setProgressMode(false);
    DuAE.endUndoGroup( DuScriptUI.String.ADD_ZERO );

    return zeroes;
}

Duik.CmdLib['Constraint']["Move Anchor Point Top"] = "Duik.Constraint.moveAnchorPoint(DuMath.Location.TOP)";
Duik.CmdLib['Constraint']["Move Anchor Point Top Right"] = "Duik.Constraint.moveAnchorPoint(DuMath.Location.TOP_RIGHT)";
Duik.CmdLib['Constraint']["Move Anchor Point Right"] = "Duik.Constraint.moveAnchorPoint(DuMath.Location.RIGHT)";
Duik.CmdLib['Constraint']["Move Anchor Point Bottom Right"] = "Duik.Constraint.moveAnchorPoint(DuMath.Location.BOTTOM_RIGHT)";
Duik.CmdLib['Constraint']["Move Anchor Point Bottom"] = "Duik.Constraint.moveAnchorPoint(DuMath.Location.BOTTOM)";
Duik.CmdLib['Constraint']["Move Anchor Point Bottom Left"] = "Duik.Constraint.moveAnchorPoint(DuMath.Location.BOTTOM_LEFT)";
Duik.CmdLib['Constraint']["Move Anchor Point Left"] = "Duik.Constraint.moveAnchorPoint(DuMath.Location.LEFT)";
Duik.CmdLib['Constraint']["Move Anchor Point Top Left"] = "Duik.Constraint.moveAnchorPoint(DuMath.Location.TOP_LEFT)";
Duik.CmdLib['Constraint']["Move Anchor Point Center"] = "Duik.Constraint.moveAnchorPoint(DuMath.Location.CENTER)";
/**
 * Repositions the anchor points of the layers
 * @param {DuMath.Location} location The new location of the anchor points relative to the layer bounds.
 * @param {float} [margin=0.0] A margin, in pixels.
 * @param {Boolean} [includeMasks=false] Use masks to compute the bounds.
 * @param {Layer[]|LayerCollection|DuList.<Layer>|Layer} [layers=DuAEComp.getSelectedLayers()] The layer. If omitted, will use all selected layers in the comp
 */
Duik.Constraint.moveAnchorPoint = function( location, m, includeMasks, layers )
{
    layers = def(layers, DuAEComp.getSelectedLayers());
    layers = new DuList(layers);

    m = def(m, 0);
    includeMasks = def( includeMasks, false);

    DuAE.beginUndoGroup( DuScriptUI.String.MOVE_ANCHOR_POINTS, false );
    DuAEProject.setProgressMode(true);

    layers.do(function(layer) {
        // Get the current values
        var apProp = layer.transform.anchorPoint;
        var layerBounds = DuAELayer.sourceRect(layer, undefined, true, includeMasks);

        var t = layerBounds[0];
        var l = layerBounds[1];
        var w = layerBounds[2];
        var h = layerBounds[3];

        var ap = apProp.value;
        var x = ap[0];
        var y = ap[1];

        // Update
        if (location == DuMath.Location.TOP)
        {
            DuAELayer.repositionAnchorPoint( layer, [l+w/2,t-m] );
        }
        else if (location == DuMath.Location.TOP_RIGHT)
        {
            DuAELayer.repositionAnchorPoint( layer, [l+w+m,t-m] );
        }
        else if (location == DuMath.Location.RIGHT)
        {
            DuAELayer.repositionAnchorPoint( layer, [l+w+m,t+h/2] );
        }
        else if (location == DuMath.Location.BOTTOM_RIGHT)
        {
            DuAELayer.repositionAnchorPoint( layer, [l+w+m,t+h+m] );
        }
        else if (location == DuMath.Location.BOTTOM)
        {
            DuAELayer.repositionAnchorPoint( layer, [l+w/2,t+h+m] );
        }
        else if (location == DuMath.Location.BOTTOM_LEFT)
        {
            DuAELayer.repositionAnchorPoint( layer, [l-m,t+h+m] );
        }
        else if (location == DuMath.Location.LEFT)
        {
            DuAELayer.repositionAnchorPoint( layer, [l-m,t+h/2] );
        }
        else if (location == DuMath.Location.TOP_LEFT)
        {
            DuAELayer.repositionAnchorPoint( layer, [l-m,t-m] );
        }
        else if (location == DuMath.Location.CENTER)
        {
            DuAELayer.repositionAnchorPoint( layer, [l+w/2,t+h/2] );
        }
    });

    DuAEProject.setProgressMode(false);
    DuAE.endUndoGroup( DuScriptUI.String.MOVE_ANCHOR_POINTS );
}

Duik.CmdLib['Constraint']["Reset Transformation"] = "Duik.Constraint.resetPRS()";
Duik.CmdLib['Constraint']["Reset Transformation and opacity"] = "Duik.Constraint.resetPRS(undefined, true)";
/**
 * Resets the transformation of the selected layers to 0.
 * @param {Layer[]|LayerCollection|DuList.<Layer>|Layer} [layers=DuAEComp.getSelectedLayers()] The layer. If omitted, will use all selected layers in the comp
 * @param {Boolean} [opacity=false] When true, also resets the opacity to 100%
 */
Duik.Constraint.resetPRS = function( layers, opacity )
{
    opacity = def(opacity, false);
    layers = def(layers, DuAEComp.getSelectedLayers());
    layers = new DuList(layers);

    DuAE.beginUndoGroup( DuScriptUI.String.RESET_TRANSFORMATION, false );
    DuAEProject.setProgressMode(true);

    layers.do( function(layer)
    {
        var comp = layer.containingComp;
        //is it 3D?
        var threeD = layer.threeDLayer;
        //has parent ?
        var parent = layer.parent !== null;
        if (threeD)
        {
            var positionValue = parent ? [0,0,0] : [comp.width / 2, comp.height / 2, 0];
            if (layer.transform.position.dimensionsSeparated)
            {
                layer.transform.xPosition.setValue(positionValue[0]);
                layer.transform.yPosition.setValue(positionValue[1]);
                layer.transform.zPosition.setValue(positionValue[2]);
            }
            else 
            {
                layer.transform.position.setValue(positionValue);
            }
            layer.transform.scale.setValue([100,100,100]);
            layer.transform.zRotation.setValue(0);
            layer.transform.xRotation.setValue(0);
            layer.transform.yRotation.setValue(0);
            layer.transform.orientation.setValue([0,0,0]);
        }
        else
        {
            var positionValue = parent ? [0,0] : [comp.width / 2, comp.height / 2];
            if (layer.transform.position.dimensionsSeparated)
            {
                layer.transform.xPosition.setValue(positionValue[0]);
                layer.transform.yPosition.setValue(positionValue[1]);
            }
            else 
            {
                layer.transform.position.setValue(positionValue);
            }
            layer.transform.scale.setValue([100,100]);
            layer.transform.rotation.setValue(0);
        }

        if (opacity) layer.transform.opacity.setValue(100);
    });

    DuAEProject.setProgressMode(false);
    DuAE.endUndoGroup( DuScriptUI.String.RESET_TRANSFORMATION );
}

Duik.CmdLib['Constraint']["Align layers"] = "Duik.Constraint.alignLayers()";
/**
 * Align selected Layers to the last selected one
 * @param {Boolean} [position=true] - whether to align the position.
 * @param {Boolean} [rotation=true] - whether to align the rotation.
 * @param {Boolean} [scale=true] - whether to align the scale.
 * @param {Boolean} [opacity=true] - whether to align the opacity.
 */
Duik.Constraint.alignLayers = function( position, rotation, scale, opacity )
{
    position = def (position, true);
    rotation = def (rotation, true);
    scale = def (scale, true);
    opacity = def (opacity, false);


    var layers = DuAEComp.getSelectedLayers();
    if (layers.length <= 1) return;

    var target = layers.pop();

    DuAE.beginUndoGroup( DuScriptUI.String.ALIGN_LAYERS, false );
    DuAELayer.align(
        layers,
        target,
        position,
        rotation,
        scale,
        opacity
    );
    DuAE.endUndoGroup( DuScriptUI.String.ALIGN_LAYERS );
}

Duik.CmdLib['Constraint']["Expose Transform"] = "Duik.Constraint.exposeTransform()";
/**
 * Expose Transform
 */
Duik.Constraint.exposeTransform = function ( comp, layers )
{
    if (typeof comp === 'undefined')
	{
		if (typeof layer !== 'undefined')
		{
			comp = layer.containingComp;
		}
		else
		{
			comp = DuAEProject.getActiveComp();
		}
	}
	if (!comp) return;

    layers = def(layers, DuAEComp.unselectLayers());
    layers = new DuList(layers);

    DuAE.beginUndoGroup( DuScriptUI.String.DUIK_EXPOSE_TRANSFORM, false);
    DuAEProject.setProgressMode( true );

    var ctrls = [];

    function createETM( layer )
    {
        var ctrl = Duik.Controller.create( comp, Duik.Controller.Type.EXPOSE_TRANSFORM, layer);

        //add pseudo effect
        var pE = Duik.PseudoEffect.EXPOSE_TRANSFORM;
        var effect = pE.apply(ctrl);

        // indices
        var guideIndex = pE.props['Display']['Guides'].index;
        var refColorIndex = pE.props['Display']['Reference'].index;
        var targetColorIndex = pE.props['Display']['Target'].index;
        var angleColorIndex = pE.props['Display']['Angle'].index;
        var distanceColorIndex = pE.props['Display']['Distance'].index;
        var pos2DAbsIndex = pE.props['2D Position (Comp projection)']['Absolute'].index;
        var dist2DIndex = pE.props['2D Position (Comp projection)']['2D Distance'].index;
        var pos3DAbsIndex = pE.props['3D Position (World)']['Absolute'].index;
        var pos2DRelIndex = pE.props['2D Position (Comp projection)']['Relative to reference'].index;
        var pos3DRelIndex = pE.props['3D Position (World)']['Relative to reference'].index;
        var dist3DIndex = pE.props['3D Position (World)']['3D Distance'].index;
        var rotRelIndex = pE.props['2D Orientation']['Relative to reference'].index;
        var rotAbsIndex = pE.props['2D Orientation']['Absolute'].index;
        var angleIndex = pE.props['Angle (Layer-This-Reference)'].index;
        var targetIndex = pE.props['Target Layer'].index;
        var refParentIndex = pE.props['Reference'].index;
        var refIndex = pE.props['Reference Layer'].index;

        //add guides
        var guidesGroup = ctrl("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
        guidesGroup.name = 'Guides';

        var refGroup = guidesGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
        refGroup.name = 'Reference';

        var refOrientationGroup = refGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
        refOrientationGroup.name = 'Orientation';
        refOrientation = refOrientationGroup("ADBE Vectors Group");

        var path = refOrientation.addProperty("ADBE Vector Shape - Group");
        path("ADBE Vector Shape").expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = effect("' + effect.name + '");',
            'if (fx(' + guideIndex + ').value)',
            '{',
            '	var A = [0,0];',
            '	var B = [ 0 , -thisComp.height/20 ];',
            '	createPath([A,B],[],[],false);',
            '}',
            'else',
            '{',
            '	value;',
            '}'
            ].join('\n');

        path = refOrientation.addProperty("ADBE Vector Shape - Ellipse");
        path("ADBE Vector Ellipse Size").expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = effect("' + effect.name + '");',
            'var s = thisComp.height/40;',
            'if (fx(' + guideIndex + ').value) [s,s];',
            'else [0,0];'
            ].join('\n');

        var stroke = refOrientation.addProperty("ADBE Vector Graphic - Stroke");
        stroke("ADBE Vector Stroke Color").expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\neffect("Expose Transform")(' + refColorIndex + ').value;';
        stroke("ADBE Vector Stroke Width").expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/500;';
        stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
        stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Dash 1').expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/100;';
        stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Gap 1" );
        stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Gap 1').expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/500;';

        refOrientationTransform = refOrientationGroup('ADBE Vector Transform Group');
        refOrientationTransform('ADBE Vector Position').expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = effect("' + effect.name + '");',
            'var P = fx(' + pos2DAbsIndex + ');',
            'var R = fx(' + pos2DAbsIndex + ') - fx(' + pos2DRelIndex + ');',
            'fromComp(R);'
        ].join('\n');
        refOrientationTransform('ADBE Vector Rotation').expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\ncontent("Guides").content("Target").transform.rotation + content("Guides").content("Target").content("Reference Orientation").transform.rotation;'

        var targetGroup = guidesGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
        targetGroup.name = 'Target';

        var targetOrientationGroup = targetGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
        targetOrientationGroup.name = 'Orientation';
        targetOrientation = targetOrientationGroup("ADBE Vectors Group");

        path = targetOrientation.addProperty("ADBE Vector Shape - Group");
        path("ADBE Vector Shape").expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = effect("' + effect.name + '");',
            'if (fx(' + guideIndex + ').value)',
            '{',
            '	var A = [0,0];',
            '	var B = [ 0 , -thisComp.height/10 ];',
            '	createPath([A,B],[],[],false);',
            '}',
            'else',
            '{',
            '	value;',
            '}'
        ].join('\n');

        path = targetOrientation.addProperty("ADBE Vector Shape - Ellipse");
        path("ADBE Vector Ellipse Size").expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = effect("' + effect.name + '");',
            'var s = thisComp.height/20;',
            'if (fx(' + guideIndex + ').value) [s,s];',
            'else [0,0];'
        ].join('\n');

        stroke = targetOrientation.addProperty("ADBE Vector Graphic - Stroke");
        stroke("ADBE Vector Stroke Color").expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\neffect("Expose Transform")(' + targetColorIndex + ');';
        stroke("ADBE Vector Stroke Width").expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/500;';
        stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
        stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Dash 1').expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/100;';
        stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Gap 1" );
        stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Gap 1').expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/500;';

        var refOrientationGroup = targetGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
        refOrientationGroup.name = 'Reference Orientation';
        refOrientation = refOrientationGroup("ADBE Vectors Group");

        path = refOrientation.addProperty("ADBE Vector Shape - Group");
        path("ADBE Vector Shape").expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = effect("' + effect.name + '");',
            'if (fx(' + guideIndex + ').value)',
            '{',
            '	var A = [0,0];',
            '	var B = [ 0 , -thisComp.height/20 ];',
            '	createPath([A,B],[],[],false);',
            '}',
            'else',
            '{',
            '	value;',
            '}'
        ].join('\n');

        stroke = refOrientation.addProperty("ADBE Vector Graphic - Stroke");
        stroke("ADBE Vector Stroke Color").expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\neffect("Expose Transform")(' + refColorIndex + ');';
        stroke("ADBE Vector Stroke Width").expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/500;';
        stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
        stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Dash 1').expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/100;';
        stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Gap 1" );
        stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Gap 1').expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/500;';
        
        refOrientationTransform = refOrientationGroup('ADBE Vector Transform Group');

        refOrientationTransform('ADBE Vector Rotation').expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = effect("' + effect.name + '");',
            '-fx(' + rotRelIndex + ');'
        ].join('\n');

        targetTransform = targetGroup('ADBE Vector Transform Group');
        targetTransform('ADBE Vector Position').expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = effect("' + effect.name + '");',
            'if (fx(' + guideIndex + ').value)',
            '{',
            '	fromComp(fx(' + pos2DAbsIndex + '));',
            '}',
            'else',
            '{',
            '	value;',
            '}'
        ].join('\n');
        targetTransform('ADBE Vector Rotation').expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = effect("' + effect.name + '");',
            'var result = fx(' + rotAbsIndex + ');',
            'var l = thisLayer;',
            'result -= l.rotation.value;',
            'while(l.hasParent)',
            '{',
            '	l = l.parent;',
            '	result -= l.rotation.value;',
            '}',
            'result;'
        ].join('\n');

        var angleGroup = guidesGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
        angleGroup.name = 'Angle';

        var angleGroup1 = angleGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
        angle1 = angleGroup1("ADBE Vectors Group");

        path = angle1.addProperty("ADBE Vector Shape - Group");
        path("ADBE Vector Shape").expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = effect("Expose Transform");',
            'if (fx(' + guideIndex + ').value)',
            '{',
            '	var A = fromComp(fx(' + pos2DAbsIndex + '));',
            '	var B = fromComp( fx(' + pos2DAbsIndex + ') - fx(' + pos2DRelIndex + ') );',
            '	createPath([A,[0,0],B],[],[],false);',
            '}',
            'else',
            '{',
            '	value;',
            '}'
        ].join('\n');

        stroke = angle1.addProperty("ADBE Vector Graphic - Stroke");
        stroke("ADBE Vector Stroke Color").expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\neffect("Expose Transform")(' + angleColorIndex + ');';
        stroke("ADBE Vector Stroke Width").expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/500;';
        stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
        stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Dash 1').expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/100;';
        stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Gap 1" );
        stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Gap 1').expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/500;';

        var angleGroup2 = angleGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
        angle2 = angleGroup2("ADBE Vectors Group");

        path = angle2.addProperty("ADBE Vector Shape - Group");
        path("ADBE Vector Shape").expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = effect("' + effect.name + '");',
            'if (fx(' + guideIndex + ').value)',
            '{',
            '	var A = fromComp(fx(' + pos2DAbsIndex + '));',
            '	var B = fromComp( fx(' + pos2DAbsIndex + ') - fx(' + pos2DRelIndex + ') );',
            '	var M = (A+B)/2;',
            '	var tA = [0,0];',
            '	var tB = [0,0];',
            '	var lB = length(B);',
            '	var lA = length(A);',
            '	if (lA > lB)',
            '	{',
            '		var q = 1;',
            '		if (lA != 0) q = lB/lA;',
            '		A = A/3*q;',
            '		B = B/3;',
            '		tA = M/6*q;',
            '		tB = M/6;',
            '	}',
            '	else',
            '	{',
            '		var q = 1;',
            '		if (lB != 0) q = lA/lB;',
            '		A = A/3;',
            '		B = B/3*q;',
            '		tA = M/6;',
            '		tB = M/6*q;',
            '	}',
            '	createPath([A,B],[ [0,0], tB ],[ tA, [0,0] ],false);',
            '}',
            'else',
            '{',
            '	value;',
            '}'
        ].join('\n');

        stroke = angle2.addProperty("ADBE Vector Graphic - Stroke");
        stroke("ADBE Vector Stroke Color").expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\neffect("Expose Transform")(' + angleColorIndex + ');';
        stroke("ADBE Vector Stroke Width").expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/500;';
        stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
        stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Dash 1').expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/100;';
        stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Gap 1" );
        stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Gap 1').expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/500;';
        
        var distanceGroup = guidesGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
        distanceGroup.name = 'Distance';
        distance = distanceGroup("ADBE Vectors Group");

        path = distance.addProperty("ADBE Vector Shape - Group");
        path("ADBE Vector Shape").expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = effect("' + effect.name + '");',
            'if (fx(' + guideIndex + ').value)',
            '{',
            '	var A = fromComp(fx(' + pos2DAbsIndex + '));',
            '	var B = fromComp( fx(' + pos2DAbsIndex + ') - fx(' + pos2DRelIndex + ') );',
            '	createPath([A,B],[],[],false);',
            '}',
            'else',
            '{',
            '	value;',
            '}'
        ].join('\n');

        stroke = distance.addProperty("ADBE Vector Graphic - Stroke");
        stroke("ADBE Vector Stroke Color").expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\neffect("Expose Transform")(' + distanceColorIndex + ');';
        stroke("ADBE Vector Stroke Width").expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/500;';
        stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
        stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Dash 1').expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/100;';
        stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Gap 1" );
        stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Gap 1').expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/500;';

        //Effect expressions

        effect(pos2DAbsIndex).expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = thisProperty.propertyGroup();',
            'var l = null;',
            'try { l = fx(' + targetIndex + '); } catch (e){ }',
            'if (!l) l = thisLayer;',
            'var result = l.toComp(l.anchorPoint);',
            'result;'
        ].join('\n');

        effect(pos2DRelIndex).expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = thisProperty.propertyGroup();',
            'var useParent = fx(' + refParentIndex + ').value;',
            'var layerPosition = fx(' + pos2DAbsIndex + ');',
            'var referencePosition = [0,0];',
            'var rL = null;',
            'if (useParent)',
            '{',
            '   var l = null;',
            '	try { l = fx(' + targetIndex + '); } catch (e){ }',
            '   if (!l) l = thisLayer;',
            '	if (l.hasParent) rL = l.parent;',
            '	else rL = l;',
            '}',
            'else',
            '{',
            '	try { rL = fx(' + refIndex + '); } catch (e){ }',
            '   if (!rL) rL = thisLayer;',
            '}',
            'referencePosition = rL.toComp(rL.anchorPoint);',
            'var result = layerPosition - referencePosition;',
            'result;'
        ].join('\n');

        effect(dist2DIndex).expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = thisProperty.propertyGroup();',
            'var relativePosition = fx(' + pos2DRelIndex + ');',
            'var result = length( relativePosition );',
            'result;'
        ].join('\n');

        effect(pos3DAbsIndex).expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = thisProperty.propertyGroup();',
            'var l = null;',
            'try { l = fx(' + targetIndex + '); } catch (e){ }',
            'if (!l) l = thisLayer;',
            'var result = l.toWorld(l.anchorPoint);',
            'result;'
        ].join('\n');

        effect(pos3DRelIndex).expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = thisProperty.propertyGroup();',
            'var layerPosition = fx(' + pos3DAbsIndex + ');',
            'var useParent = fx(' + refParentIndex + ').value;',
            'var rL = null;',
            'if (useParent)',
            '{',
            '   var l = null;',
            '	try { l = fx(' + targetIndex + '); } catch (e){ }',
            '   if (!l) l = thisLayer;',
            '	if (l.hasParent) rL = l.parent;',
            '	else rL = l;',
            '}',
            'else',
            '{',
            '	try { rL = fx(' + refIndex + '); } catch (e){ }',
            '   if (!rL) rL = thisLayer;',
            '}',
            'var referencePosition = rL.toWorld(rL.anchorPoint);',
            'var result = layerPosition - referencePosition;',
            'result;'
        ].join('\n');

        effect(dist3DIndex).expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = thisProperty.propertyGroup();',
            'var relativePosition = fx(' + pos3DRelIndex + ');',
            'var result = length( relativePosition );',
            'result;'
        ].join('\n');

        effect(rotAbsIndex).expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = thisProperty.propertyGroup();',
            'var l = null;',
            'try { l = fx(' + targetIndex + ') } catch (e){ }',
            'if (!l) l = thisLayer;',
            'var result = l.rotation;',
            'if (l.position.value.length == 3) result += l.orientation[2];',
            'while(l.hasParent)',
            '{',
            '	l = l.parent;',
            '	result += l.rotation;',
            '	if (l.position.value.length == 3) result += l.orientation[2];',
            '}',
            'result;'
        ].join('\n');

        effect(rotRelIndex).expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = thisProperty.propertyGroup();',
            'var useParent = fx(' + refParentIndex + ').value;',
            'var rot = fx(' + rotAbsIndex + ');',
            'var result = value;',
            'var rL = null;',
            'if (useParent)',
            '{',
            '   var l = null;',
            '	try { l = fx(' + targetIndex + '); } catch (e){ }',
            '   if (!l) l = thisLayer;',
            '	if (l.hasParent) rL = l.parent;',
            '	else rL = l;',
            '}',
            'else',
            '{',
            '	try { rL = fx(' + refIndex + '); } catch (e){ }',
            '   if (!rL) rL = thisLayer;',
            '}',
            'var refRot = rL.rotation.value;',
            'if (rL.position.value.length == 3) refRot += rL.orientation.value[2];',
            'while(rL.hasParent)',
            '{',
            '	rL = rL.parent;',
            '	refRot += rL.rotation.value;',
            '	if (rL.position.value.length == 3) refRot += rL.orientation.value[2];',
            '}',
            'result = rot - refRot;',
            'result;'
        ].join('\n');

        effect(angleIndex).expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = thisProperty.propertyGroup();',
            'var useParent = fx(' + refParentIndex + ').value;',
            'var O = thisLayer.toComp(thisLayer.anchorPoint);',
            'var l = null;',
            'var rL = null;',
            'try { l = fx(' + targetIndex + '); } catch (e){ }',
            'if (!l) l = thisLayer;',
            'if (useParent)',
            '{',
            '	if (l.hasParent) rL = l.parent;',
            '	else rL = l;',
            '}',
            'else',
            '{',
            '	try { rL = fx(' + refIndex + '); } catch (e){ }',
            '   if (!rL) rL = thisLayer;',
            '}',
            'var A = l.toComp(l.anchorPoint);',
            'var B = rL.toComp(rL.anchorPoint);',
            'var OA = O-A;',
            'var OB = O-B;',
            'var angleA = Math.atan2(OA[1], OA[0]);',
            'var angleB = Math.atan2(OB[1], OB[0]);',
            'var result = angleA + angleB;',
            'result = radiansToDegrees(angleB-angleA);',
            'if (result < -180) result += 360;',
            'result;'
        ].join('\n');

        //set the layer as target
        if (typeof layer !== 'undefined')
        {
            effect( targetIndex ).setValue(layer.index);
        }

        //fold
        ctrl.selected = true;
        DuAE.executeCommand( DuAE.MenuCommandID.REVEAL_EXPRESSION_ERRORS );

        return ctrl;
    }

    if (layers.length() == 0) ctrls.push( createETM() );
    else
    {
        for (var  i = 0, num = layers.length() ; i < num ; i++)
        {
            var ctrl = createETM( layers.at(i) );
            ctrls.push(ctrl);
        }
    }

    DuAEComp.selectLayers(ctrls);
    DuAEProject.setProgressMode( false );
    DuAE.endUndoGroup( DuScriptUI.String.DUIK_EXPOSE_TRANSFORM );
}

Duik.CmdLib['Constraint']["Morph Keys"] = "Duik.Constraint.morphKeys()";
/**
 * Morph Keys
 */
Duik.Constraint.morphKeys = function ( props )
{
    props = def(props, DuAEComp.getSelectedProps());
    if (props.length == 0) return;

    // Get layer
    var layer = new DuAEProperty(props[0]).layer;

    DuAE.beginUndoGroup( DuScriptUI.String.DUIK_KEY_MORPH, false);

    // Add key morph effect
    var peKM = Duik.PseudoEffect.KEY_MORPH;
    var peKMK = Duik.PseudoEffect.KEY_MORPH_K;
    var kmEffect = peKM.apply(layer);
    var kmEffectName = kmEffect.name;
    var kmp = peKM.props;
    var kmkp = peKMK.props;

    // number of keys expression
    kmEffect(kmp['Number of keys'].index).expression = [DuAEExpression.Id.KEY_MORPH,
        'var numK = 0;',
        '',
        'function checkDuikEffect(fx, duikMatchName) {',
        '    if (fx.numProperties  < 3) return false;',
        '    if (!!$.engineName) {',
        '        if ( fx(2).name != duikMatchName ) return false;',
        '    }',
        '    else {',
        '        try { if (fx(2).name != duikMatchName) return false; }',
        '        catch (e) { return false; }',
        '    }',
        '    return true;',
        '}',
        '',
        'for (var i = 1, n = thisLayer(\'Effects\').numProperties; i <= n; i++) {',
        '	if (!checkDuikEffect( thisLayer.effect(i), "key morph k")) continue;',
        '	numK++;',
        '}',
        '',
        'numK;'
        ].join('\n');

    // Count keyframes & add expression
    var numKeys = 1;
    for (var i = 0, n = props.length; i < n; i++)
    {
        var p = props[i];

        var pInfo = new DuAEProperty(p);
        p = pInfo.getProperty();

        if (!pInfo.riggable()) continue;
        var np = p.numKeys;
        if (np < 2) continue;

        // count keyframes
        if (numKeys < 2 )  numKeys = np;
        else if (np < numKeys) numKeys = np;

        // add expression
        p.expression = [DuAEExpression.Id.KEY_MORPH,
            'var ctrlLayer = thisComp.layer("' + layer.name + '");',
            'var cumulative = !ctrlLayer.effect("' + kmEffectName + '")(' + kmp['Weights'].index + ').value;',
            '',
            'var result = zero();',
            'var weights = [];',
            'var sumWeights = 0;',
            'var nKeys = 0;',
            'var thisIsPath = isPath(thisProperty);',
            '',
            '// If path, oVal must be a path',
            'var oVal;',
            'if (thisIsPath) oVal = getPath(0);',
            'else oVal = valueAtTime(0);',
            '',
            DuAEExpression.Library.get([
                'zero',
                'isPath',
                'getPath',
                'addPath',
                'subPath',
                'multPath',
                'multPoints',
                'addPoints',
                'subPoints',
                'checkDuikEffect',
                'normalizeWeights',
            ]),
            '',
            '// Get weights',
            'var k = 0;',
            'for (var i = 1, n = ctrlLayer("Effects").numProperties; i <= n; i++) {',
            '	var fx = ctrlLayer.effect(i);',
            '	if (!checkDuikEffect( fx, "key morph k")) continue;',
            '	k++;',
            '	if (k > numKeys) break;',
            '	var weight = fx(' + kmkp['Weight'].index + ').value / 100;',
            '	weights.push(weight);',
            '	sumWeights += weight;',
            '	if (weight > 0 && !(cumulative && k == 1)) nKeys++;',
            '}',
            '',
            '// Normalize',
            'if (!cumulative)',
            '{',
            '  weights = normalizeWeights(weights, sumWeights);',
            '  sumWeights = 1;',
            '}',
            '',
            '// Sum',
            'for (var i = 0, n = weights.length; i < n; i++)',
            '{',
            '  if (i > numKeys) break;',
            '  if (cumulative && i == 0) continue;',
            '  var w = weights[i];',
            '  if (w == 0) continue;',
            '  if( thisIsPath ) {',
            '    var p = getPath( key(i+1).time );',
            '    result = addPath(result, p, w);',
            '    if (cumulative) result = addPath(result, oVal, (1-w));',
            '  }',
            '  else {',
            '    result += key(i+1).value * w;',
            '    if (cumulative) result += oVal * (1-w);',
            '  }',
            '  ',
            '}',
            '',
            '// Weights',
            'if (nKeys > 0) {',
            '  if (!cumulative)',
            '  {',
            '    if (thisIsPath) result = multPath( result, 1 / sumWeights);',
            '    else result /= sumWeights;',
            '  }',
            '  else if (nKeys > 1)',
            '  {',
            '    if (thisIsPath) result = subPath( result, oVal, 1);',
            '    else result -= oVal;',
            '  }',
            '}',
            ' else {',
            '	if (thisIsPath) result = getPath(0);',
            '	else result = valueAtTime(0);',
            '}',
            '',
            'if (thisIsPath) createPath(result.points, result.inTangents, result.outTangents, isClosed());',
            'else result;'
            ].join('\n');
        
    }

    // Add Key effects
    for (var i = 0; i < numKeys; i++)
    {
        var kmkFX = peKMK.apply(layer);

        // Weight expression
        kmkFX(kmkp['Weight'].index).expression = [DuAEExpression.Id.KEY_MORPH,
            'var selection = effect("' + kmEffectName + '")(' + kmp["Key Selection"].index + ');',
            'var thisIndex = thisProperty.propertyGroup(1)(' + kmkp["Key Index"].index + ').value;',
            '',
            DuAEExpression.Library.get([
                'getNextKey',
                'getPrevKey'
            ]),
            '',
            'function interpolate()',
            '{',
            '  var pK = getPrevKey(time, selection);',
            '  var nK = getNextKey(time, selection);',
            '',
            '  if (!pK && !nK && Math.round(selection.value) == thisIndex) return 100;',
            '	var nValue = 0;',
            '	var pValue = 0;',
            '	if(nK) nValue = Math.round(nK.value);',
            '	if(pK) pValue = Math.round(pK.value);',
            '  if (!pK && !nK) return 0;',
            '  if (!pK && nValue == thisIndex) return 100;',
            '  if (!pK) return 0;',
            '  if (!nK && pValue == thisIndex) return 100;',
            '  if (!nK) return 0;',
            '  if (pValue != thisIndex && nValue != thisIndex) return 0;',
            '  if (pValue == nValue) return 100;',
            '  if (pValue == thisIndex && pValue < nValue)',
            '      return linear( selection.value, nValue, pValue, 100, 0 );',
            '  if (pValue == thisIndex && pValue >= nValue)',
            '       return linear( selection.value, pValue, nValue, 0, 100 );',
            '  if (pValue < nValue)',
            '      return linear( selection.value, pValue, nValue, 0, 100 );',
            '  return linear( selection.value, pValue, nValue, 100, 0 );',
            '}',
            '',
            'var result = value + interpolate();',
            '',
            'result;'
            ].join('\n');

        kmkFX(kmkp['Key Index'].index).expression = [DuAEExpression.Id.KEY_MORPH,
            'var numK = 1;',
            '',
            DuAEExpression.Library.get([
                'checkDuikEffect'
            ]),
            '',
            'for (var i = 1, n = thisProperty.propertyGroup(1).propertyIndex; i < n; i++) {',
            '	if (!checkDuikEffect( thisLayer.effect(i), "key morph k")) continue;',
            '	numK++;',
            '}',
            '',
            'numK;'
            ].join('\n');
    }

    DuAE.endUndoGroup( DuScriptUI.String.DUIK_KEY_MORPH );
}

Duik.CmdLib['Constraint']["IK"] = "Duik.Constraint.ik()";
Duik.CmdLib['Constraint']["IK (3-layer)"] = "Duik.Constraint.ik(Duik.Constraint.IKType.THREE)";
Duik.CmdLib['Constraint']["IK (2+1-layer)"] = "Duik.Constraint.ik(Duik.Constraint.IKType.TWO_ONE)";
Duik.CmdLib['Constraint']["IK (1+2-layer)"] = "Duik.Constraint.ik(Duik.Constraint.IKType.ONE_TWO)";
Duik.CmdLib['Constraint']["Bézier IK"] = "Duik.Constraint.ik(undefined, true)";
/**
 * Creates an IK on the layers
 * @param {Duik.IKType} [type=Duik.Constraint.IKType.ONE_TWO] The type of IK to use with three layers.
 * @param {boolean} [forceBezier=false] - force the use of a bezier IK even with two or three layers
 * @param {Layer[]|LayerCollection|DuList.<Layer>|Layer} [layers=DuAEComp.getSelectedLayers()] The layer. If omitted, will use all selected layers in the comp
 * @param {Layer} [controller] - An already existing controller.
 * @return {Layer[]} The controller(s) of the IK.
 */
Duik.Constraint.ik = function ( type, forceBezier, layers, controller )
{
    layers = def(layers, DuAEComp.unselectLayers());
    layers = new DuList(layers);
    if (layers.length() < 1) return [];

    DuAE.beginUndoGroup( DuScriptUI.String.IK, false);

    type = def(type, Duik.Constraint.IKType.ONE_TWO)
    forceBezier = def(forceBezier, false);
    controller = def(controller, null);

    //check if there is a controller in the selection
    if ( controller == null )
    {
        if ( layers.length < 2 ) return [];
        for ( var i = 0, n = layers.length(); i < n; i++ )
        {
            var l = layers.at( i );
            if ( Duik.Layer.isType( l, Duik.Layer.Type.CONTROLLER ) )
            {
                controller = l;
                layers.remove( i );
                break;
            }
        }
    }
    //sort layers and parent them
    layers = DuAELayer.sortByParent( layers );
    //reset rotation and scale if structures
    layers = new DuList( layers );
    layers.do( Duik.Bone.resetTransform );
    //parent
    DuAELayer.parentChain( layers );

    //check if the last one is a goal
    var withGoal = true;
    if ( controller != null )
    {
        var l = layers.last();
        //check position
        var distance = DuAELayer.getDistance( controller, l );
        if ( distance > 10 ) withGoal = false;
    }
    var goal = null;
    if ( withGoal ) goal = layers.pop();

    if ( layers.length() == 1 && !forceBezier ) controller = [ Duik.Constraint.oneLayerIK( layers.at(0), goal, controller ) ];
    else if ( layers.length() == 2 && !forceBezier ) controller = [ Duik.Constraint.twoLayerIK( layers.at(0), layers.at(1), goal, controller ) ];
    else if ( layers.length() == 3 && !forceBezier && type ==  Duik.Constraint.IKType.ONE_TWO ) controller = [ Duik.Constraint.oneTwoLayerIK( layers.at(0), layers.at(1), layers.at(2), goal, controller ) ];
    else if ( layers.length() == 3 && !forceBezier && type ==  Duik.Constraint.IKType.TWO_ONE ) controller = [ Duik.Constraint.twoOneLayerIK( layers.at(0), layers.at(1), layers.at(2), goal, controller ) ];
    else if ( layers.length() == 3 && !forceBezier && type ==  Duik.Constraint.IKType.THREE ) controller = [ Duik.Constraint.threeLayerIK( layers.at(0), layers.at(1), layers.at(2), goal, controller ) ];
    else controller = Duik.Constraint.bezierIK( layers, goal, controller );

    DuAE.endUndoGroup( DuScriptUI.String.IK );

    return controller;
}

/**
 * Creates a one-layer-ik on the layer
 * @param {Layer} layer - The layer
 * @param {Layer|null} [goal] - The goal layer, at the end of the IK
 * @param {Layer|Controller|null} [controller] - The layer to use as a controller, can be automatically created.<br />
 * Must be provided if goal is undefined
 * @param {Boolean} [showGuides=true] - Set to false to hide guides on the controllers (and improve performance)
 * @return {Layer} The controller created
 */
Duik.Constraint.oneLayerIK = function (layer, goal, controller, showGuides )
{
    goal = def(goal, null);
    controller = def(controller, null);
    if ( controller == null && goal == null ) throw "You must provide either a goal layer or a controller";
    var comp = layer.containingComp;

    showGuides = def( showGuides, 1 );
    if (!showGuides) showGuides = 0;

    //Create controller
    if ( controller == null )
    {
        controller = Duik.Controller.create( comp,  Duik.Controller.Type.POSITION, goal );
    }

    //is right ?
    var ctrlPos = DuAELayer.getWorldPos( controller );
    var layerPos = DuAELayer.getWorldPos( layer );

    var right = ( ctrlPos[ 0 ] - layerPos[ 0 ] ) < 0;

    //Add Effect
    var name = Duik.Layer.limbName(layer);
    if ( goal != null ) name = Duik.Layer.limbName(goal);
    var pe = Duik.PseudoEffect.ONE_LAYER_IK
    var effect = pe.apply( controller, DuScriptUI.String.IK + ' | ' + name );

    //indices
    var reverseIndex = pe.props["Advanced"]["Full rotation limit"].index;
    var layerIndex = pe.props["Data"]["Layer"].index;
    var ikIndex = pe.props["IK"].index;
    var guidesIndex = pe.props["Display"]["Draw guides"].index;
    var weightIndex = pe.props["Weight"].index;
    var fkIndex = pe.props["FK"].index;
    var parentIndex = pe.props["Advanced"]["Parent rotation"].index;
    var ulIndex = pe.props["Limits"]["Upper limit"].index;
    var llIndex = pe.props["Limits"]["Lower limit"].index;
    var lsIndex = pe.props["Limits"]["Softness"].index;
    
    //default values
    if ( right ) effect( reverseIndex ).setValue( 1 );
    effect( layerIndex ).setValue( layer.index );
    effect( ulIndex ).setValue( 180 );
    effect( llIndex ).setValue( -180 );
    effect( guidesIndex ).setValue( showGuides );

    //guides
    if ( DuAE.version.version >= 15 && controller instanceof ShapeLayer )
    {
        var lineGroup = controller( "ADBE Root Vectors Group" ).property( 'IK Line' );
        if ( !lineGroup )
        {
            lineGroup = controller( "ADBE Root Vectors Group" ).addProperty( "ADBE Vector Group" );
            lineGroup.name = 'IK Line';
        }
        var lineContent = lineGroup.property( "ADBE Vectors Group" );
        var shape = lineContent.addProperty( "ADBE Vector Shape - Group" );
        shape( 'ADBE Vector Shape' ).expression = [DuAEExpression.Id.ONE_IK,
            'var fx = effect("' + effect.name + '");',
            'var layer1 = null;',
            'var result = [[0,0]];',
            'if (fx(' + ikIndex + ').value && fx(' + guidesIndex + ').value)',
            '{',
            '   try{ layer1 = fx(' + layerIndex + '); }catch(e){}',
            '   if (layer1!=null)',
            '   {',
            '       var l = layer1.toWorld(layer1.anchorPoint);',
            '       l = fromWorld(l);',
            '       result = [l,[0,0]];',
            '   }',
            '}',
            'createPath(result,[],[],false);'
            ].join('\n');
        var stroke = lineContent.property( "ADBE Vector Graphic - Stroke" );
        var ctrlEffect = controller.effect( Duik.PseudoEffect.CONTROLLER.matchName );
        if ( !stroke ) stroke = lineContent.addProperty( "ADBE Vector Graphic - Stroke" );
        if ( ctrlEffect ) stroke( "ADBE Vector Stroke Color" ).expression = DuAEExpression.Id.CONTROLLER + '\neffect("' + ctrlEffect.name + '")(' + Duik.PseudoEffect.CONTROLLER.props['Icon']['Color'].index + ')-[0.2,0.2,0.2,0]';
        stroke( "ADBE Vector Stroke Width" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Line Cap" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
        stroke( "ADBE Vector Stroke Dashes" )( "ADBE Vector Stroke Dash 1" ).setValue( 5 );

        var limitsGroup = controller( "ADBE Root Vectors Group" ).property( 'IK Limits' );
        if ( !limitsGroup )
        {
            limitsGroup = controller( "ADBE Root Vectors Group" ).addProperty( "ADBE Vector Group" );
            limitsGroup.name = 'IK Limits';
        }
        limitsGroup.transform.position.expression = [DuAEExpression.Id.ONE_IK,
            'var fx = effect("' + effect.name + '");',
            'var l = null;',
            'try{ l = fx(' + layerIndex + '); }catch(e){}',
            'var result = value;',
            'if (l != null)',
            '{',
            '	var p = l.toWorld(l.anchorPoint);',
            '	result = fromWorld(p);',
            '}',
            'result;'
            ].join('\n');
        limitsGroup.transform.rotation.expression = DuAEExpression.Id.ONE_IK + '\n-rotation;';

        var limitLinesGroup = limitsGroup.property( "ADBE Vectors Group" ).addProperty( "ADBE Vector Group" );
        limitLinesGroup.name = 'Limit Lines';
        limitLinesGroup.transform.rotation.expression = [DuAEExpression.Id.ONE_IK,
            DuAEExpression.Library.get(['getOrientation']),
            '',
            'var fx = effect("' + effect.name + '");',
            'var layer1 = null;',
            'var result = value;',
            'if (fx(' + ikIndex + ').value && fx(' + guidesIndex + ').value)',
            '{',
            '   try{ layer1 = fx(' + layerIndex + '); }catch(e){}',
            '   if (layer1 != null)',
            '   {',
            '       if (layer1.hasParent) result = getOrientation(layer1.parent);',
            '   }',
            '}',
            'result;'
            ].join('\n');

        var limitLinesContent = limitLinesGroup.property( "ADBE Vectors Group" );
        var lLimitGroup = limitLinesContent.addProperty( "ADBE Vector Group" );
        lLimitGroup.name = 'Lower Limit';
        lLimitGroup.transform.rotation.expression = [DuAEExpression.Id.ONE_IK,
            'var fx = effect("' + effect.name + '");',
            'fx(' + llIndex + ').value-180;'
            ].join('\n');

        var lLimitContent = lLimitGroup.property( "ADBE Vectors Group" );
        lLimitShape = lLimitContent.addProperty( "ADBE Vector Shape - Group" );
        lLimitShape( 'ADBE Vector Shape' ).expression = [DuAEExpression.Id.ONE_IK,
            'var fx = effect("' + effect.name + '");',
            'var layer1 = null;',
            'var result = [[0,0]];',
            'if (fx(' + ikIndex + ').value && fx(' + guidesIndex + ').value)',
            '{',
            '   try{ layer1 = fx(' + layerIndex + '); }catch(e){}',
            '   if (layer1!=null)',
            '   {',
            '       var l = layer1.toWorld(layer1.anchorPoint);',
            '       l = fromWorld(l);',
            '       l = length(l) * .5;',
            '       if (!fx(' + reverseIndex + ').value) l = -l;',
            '       result = [[l,0],[0,0]];',
            '   }',
            '}',
            'createPath(result,[],[],false);'
            ].join('\n');
        
        stroke = lLimitContent.addProperty( "ADBE Vector Graphic - Stroke" );
        if ( ctrlEffect ) stroke( "ADBE Vector Stroke Color" ).expression = DuAEExpression.Id.CONTROLLER + '\neffect("' + ctrlEffect.name + '")(' + Duik.PseudoEffect.CONTROLLER.props['Icon']['Color'].index + ')-[0.2,0.2,0.2,0]';
        stroke( "ADBE Vector Stroke Width" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Line Cap" ).setValue( 2 );

        var uLimitGroup = limitLinesContent.addProperty( "ADBE Vector Group" );
        uLimitGroup.name = 'Upper Limit';
        uLimitGroup.transform.rotation.expression = [DuAEExpression.Id.ONE_IK,
            'var fx = effect("' + effect.name + '");',
            'fx(' + ulIndex + ').value-180;'
            ].join('\n');

        var uLimitContent = uLimitGroup.property( "ADBE Vectors Group" );
        uLimitShape = uLimitContent.addProperty( "ADBE Vector Shape - Group" );
        uLimitShape( 'ADBE Vector Shape' ).expression = [DuAEExpression.Id.ONE_IK,
            'var fx = effect("' + effect.name + '");',
            'var layer1 = null;',
            'var result = [[0,0]];',
            'if (fx(' + ikIndex + ').value && fx(' + guidesIndex + ').value)',
            '{',
            '   try{ layer1 = fx(' + layerIndex + '); }catch(e){}',
            '   if (layer1!=null)',
            '   {',
            '       var l = layer1.toWorld(layer1.anchorPoint);',
            '       l = fromWorld(l);',
            '       l = length(l) * .5;',
            '       if (!fx(' + reverseIndex + ').value) l = -l;',
            '       result = [[l,0],[0,0]];',
            '   }',
            '}',
            'createPath(result,[],[],false);'
            ].join('\n');
        
        stroke = uLimitContent.addProperty( "ADBE Vector Graphic - Stroke" );
        if ( ctrlEffect ) stroke( "ADBE Vector Stroke Color" ).expression = DuAEExpression.Id.CONTROLLER + '\neffect("' + ctrlEffect.name + '")(' + Duik.PseudoEffect.CONTROLLER.props['Icon']['Color'].index + ')-[0.2,0.2,0.2,0]';
        stroke( "ADBE Vector Stroke Width" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Line Cap" ).setValue( 2 );

        var lSftnssGroup = limitLinesContent.addProperty( "ADBE Vector Group" );
        lSftnssGroup.name = 'Lower Softness';
        lSftnssGroup.transform.rotation.expression = [DuAEExpression.Id.ONE_IK,
            'var fx = effect("' + effect.name + '");',
            'fx(' + llIndex + ').value-180+fx(' + lsIndex + ').value;'
            ].join('\n');

        var lSftnssContent = lSftnssGroup.property( "ADBE Vectors Group" );
        lSftnssShape = lSftnssContent.addProperty( "ADBE Vector Shape - Group" );
        lSftnssShape( 'ADBE Vector Shape' ).expression = [DuAEExpression.Id.ONE_IK,
            'var fx = effect("' + effect.name + '");',
            'var layer1 = null;',
            'var result = [[0,0]];',
            'if (fx(' + ikIndex + ').value && fx(' + guidesIndex + ').value)',
            '{',
            '   try{ layer1 = fx(' + layerIndex + '); }catch(e){}',
            '   if (layer1!=null)',
            '   {',
            '       var l = layer1.toWorld(layer1.anchorPoint);',
            '       l = fromWorld(l);',
            '       l = length(l) * .4;',
            '       if (!fx(' + reverseIndex + ').value) l = -l;',
            '       result = [[l,0],[0,0]];',
            '   }',
            '}',
            'createPath(result,[],[],false);'
            ].join('\n');
        
        stroke = lSftnssContent.addProperty( "ADBE Vector Graphic - Stroke" );
        if ( ctrlEffect ) stroke( "ADBE Vector Stroke Color" ).expression = DuAEExpression.Id.CONTROLLER + '\neffect("' + ctrlEffect.name + '")(' + Duik.PseudoEffect.CONTROLLER.props['Icon']['Color'].index + ')-[0.2,0.2,0.2,0]';
        stroke( "ADBE Vector Stroke Width" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Line Cap" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
        stroke( "ADBE Vector Stroke Dashes" )( "ADBE Vector Stroke Dash 1" ).setValue( 5 );

        var uSftnssGroup = limitLinesContent.addProperty( "ADBE Vector Group" );
        uSftnssGroup.name = 'Upper Softness';
        uSftnssGroup.transform.rotation.expression = [DuAEExpression.Id.ONE_IK,
            'var fx = effect("' + effect.name + '");',
            'fx(' + ulIndex + ').value-180-fx(' + lsIndex + ').value;'
            ].join('\n');

        var uSftnssContent = uSftnssGroup.property( "ADBE Vectors Group" );
        uSftnssShape = uSftnssContent.addProperty( "ADBE Vector Shape - Group" );
        uSftnssShape( 'ADBE Vector Shape' ).expression = [DuAEExpression.Id.ONE_IK,
            'var fx = effect("' + effect.name + '");',
            'var layer1 = null;',
            'var result = [[0,0]];',
            'if (fx(' + ikIndex + ').value && fx(' + guidesIndex + ').value)',
            '{',
            '   try{ layer1 = fx(' + layerIndex + '); }catch(e){}',
            '   if (layer1!=null)',
            '   {',
            '       var l = layer1.toWorld(layer1.anchorPoint);',
            '       l = fromWorld(l);',
            '       l = length(l) * .4;',
            '       if (!fx(' + reverseIndex + ').value) l = -l;',
            '       result = [[l,0],[0,0]];',
            '   }',
            '}',
            'createPath(result,[],[],false);'
            ].join('\n');
        
        stroke = uSftnssContent.addProperty( "ADBE Vector Graphic - Stroke" );
        if ( ctrlEffect ) stroke( "ADBE Vector Stroke Color" ).expression = DuAEExpression.Id.CONTROLLER + '\neffect("' + ctrlEffect.name + '")(' + Duik.PseudoEffect.CONTROLLER.props['Icon']['Color'].index + ')-[0.2,0.2,0.2,0]';
        stroke( "ADBE Vector Stroke Width" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Line Cap" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
        stroke( "ADBE Vector Stroke Dashes" )( "ADBE Vector Stroke Dash 1" ).setValue( 5 );

        var flGroup = limitsGroup.property( "ADBE Vectors Group" ).addProperty( "ADBE Vector Group" );
        flGroup.name = 'Flip Line';
        var flContent = flGroup.property( "ADBE Vectors Group" );
        flShape = flContent.addProperty( "ADBE Vector Shape - Group" );
        flShape( 'ADBE Vector Shape' ).expression = [DuAEExpression.Id.ONE_IK,
            'var fx = effect("' + effect.name + '");',
            'var layer1 = null;',
            'var result = [[0,0]];',
            'if (fx(' + ikIndex + ').value && fx(' + guidesIndex + ').value)',
            '{',
            '   try{ layer1 = fx(' + layerIndex + '); }catch(e){}',
            '   if (layer1!=null)',
            '   {',
            '       var l = layer1.toWorld(layer1.anchorPoint);',
            '       l = fromWorld(l);',
            '       l = length(l) * .3;',
            '       if (!fx(' + reverseIndex + ').value) l = -l;',
            '       result = [[l,0],[0,0]];',
            '   }',
            '}',
            'createPath(result,[],[],false);'
            ].join('\n');
        
        stroke = flContent.addProperty( "ADBE Vector Graphic - Stroke" );
        if ( ctrlEffect ) stroke( "ADBE Vector Stroke Color" ).expression = DuAEExpression.Id.CONTROLLER + '\n' + DuColor.Color.RAINBOX_RED.floatRGBA().toSource();
        stroke( "ADBE Vector Stroke Width" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Line Cap" ).setValue( 2 );

        //close controller details
        controller.selected = true;
        DuAE.executeCommand( DuAE.MenuCommandID.REVEAL_EXPRESSION_ERRORS, true );
    }

    //Add Data
    var layerData = layer('ADBE Effect Parade').addProperty('ADBE Layer Control');
    layerData.name = DuScriptUI.String.IK;
    layerData( 1 ).setValue( controller.index );
    //Expression
    var expr = [DuAEExpression.Id.ONE_IK,
        'var ctrl = null;',
        'var result = 0;',
        'try {',
        '	ctrl = effect("' + layerData.name + '")(1);',
        '} catch (e) {',
        '	result = value;',
        '}',
        'if (ctrl != null) {',
        '	var C = ctrl.toWorld(ctrl.anchorPoint);',
        '	var O = thisLayer.toWorld(thisLayer.anchorPoint);',
        '	var fx = ctrl.effect("' + effect.name + '");',
        '	var weight = fx(' + weightIndex + ').value / 100;',
        '	var fk = fx(' + fkIndex + ').value;',
        '	var rev = fx(' + reverseIndex + ').value;',
        '	var useIK = fx(' + ikIndex + ').value;',
        '	var parentRot = fx(' + parentIndex + ').value;',
        '	var uLimit = fx(' + ulIndex + ').value;',
        '	var lLimit = fx(' + llIndex + ').value;',
        '	var lmtSftnss = fx(' + lsIndex + ').value;',
        '	result = fk;',
        '	if (useIK) {',
        '		var vec = rev == 1 ? O - C : C - O;',
        '		var layer = thisLayer;',
        '		if (layer.hasParent && parentRot) result += layer.parent.rotation.value;',
        '		while (layer.hasParent) {',
        '			layer = layer.parent;',
        '			result = result - layer.rotation;',
        '		}',
        '		var angle = Math.atan2(vec[1], vec[0]);',
        '		angle = radiansToDegrees(angle);',
        '		angle = angle * weight;',
        '		result += angle;',
        '	}',
        '',
        '   if (result > 180) result -= 360;',
        '   else if (result < -180) result += 360;',
        '	uLimit = uLimit - lmtSftnss;',
        '	lLimit = lLimit + lmtSftnss;',
        '	if (result > uLimit)',
        '	{',
        '	  if (lmtSftnss == 0) result = uLimit;',
        '	  else result = uLimit + lmtSftnss - lmtSftnss/(1 + (result - uLimit)/lmtSftnss);',
        '	}',
        '	else if (result < lLimit)',
        '	{',
        '	  if (lmtSftnss == 0) result = lLimit;',
        '	  else result = lLimit - lmtSftnss + lmtSftnss/(1 + (lLimit-result)/lmtSftnss);',
        '	}',
        '	',
        '	result += value;',
        '}',
        'result;'
        ].join('\n');

    var rotProp = new DuAEProperty( layer.transform.rotation );
    rotProp.setExpression( expr );

    if ( goal != null )
    {
        var goalData = goal('ADBE Effect Parade').addProperty('ADBE Layer Control');
        goalData.name = DuScriptUI.String.IK;
        goalData( 1 ).setValue( controller.index );
        expr = [DuAEExpression.Id.ONE_IK,
            'var ctrl = null;',
            'var result = value;',
            'try { ctrl = effect("' + goalData.name + '")(1); } catch (e){ value };',
            'if (ctrl != null)',
            '{',
            'var goal = ctrl.effect("' + effect.name + '")(' + ikIndex +').value;',
            'result += ctrl.rotation.value;',
            'if (goal)',
            '{',
            'var layer = thisLayer;',
            'while (layer.hasParent)',
            '{',
            'layer = layer.parent;',
            'result = result - layer.rotation;',
            '}',
            '}',
            '}',
            'result;'
            ].join('\n');

        rotProp = new DuAEProperty( goal.transform.rotation );
        rotProp.setExpression( expr );
    }

    return controller;
}

/**
 * Creates a two-layer-ik on the layer
 * @param {Layer} layer1 - The root layer
 * @param {Layer} layer2 - The end layer
 * @param {Layer|null} [goal] - The goal layer, at the end of the IK
 * @param {Layer|null} [controller] - The layer to use as a controller, can be automatically created.<br />
 * Must be provided if goal is undefined
 * @param {Boolean} [showGuides=true] - Set to false to hide guides on the controllers (and improve performance)
 * @return {Layer} The controller created
 */
Duik.Constraint.twoLayerIK = function( layer1, layer2, goal, controller, showGuides )
{
    goal = def(goal, null);
    controller = def(controller, null);
    if ( controller == null && goal == null ) throw "You must provide either a goal layer or a controller";
    var comp = layer1.containingComp;

    showGuides = def( showGuides, 1 );
    if (!showGuides) showGuides = 0;

    //Create controller
    if ( controller == null )
    {
        controller = Duik.Controller.create( comp,  Duik.Controller.Type.TRANSFORM, goal );
        goal.parent = null;
        controller.transform.rotation.setValue( goal.transform.rotation.value );
        goal.parent = layer2;
    }

    //Check if clockwise and lengths

    //unparent
    var rootParent = layer1.parent;
    layer1.parent = null;
    var middleParent = layer2.parent;
    layer2.parent = null;
    var endParent = controller.parent;
    controller.parent = null;

    var clockwise = false;

    var upperLength = DuMath.length( layer1.transform.position.value, layer2.transform.position.value );
    var lowerLength = DuMath.length( layer2.transform.position.value, controller.transform.position.value );
    var endPos = controller.transform.position.value - layer1.transform.position.value;
    var middlePos = layer2.transform.position.value - layer1.transform.position.value;
    if ( endPos[ 0 ] == 0 && endPos[ 1 ] > 0 && middlePos[ 0 ] > 0 ) clockwise = true;
    else if ( endPos[ 0 ] == 0 && endPos[ 1 ] < 0 && middlePos[ 0 ] < 0 ) clockwise = true;
    else
    {
        var coef = endPos[ 1 ] / endPos[ 0 ];
        if ( middlePos[ 1 ] < middlePos[ 0 ] * coef && endPos[ 0 ] > 0 ) clockwise = true;
        if ( middlePos[ 1 ] > middlePos[ 0 ] * coef && endPos[ 0 ] < 0 ) clockwise = true;
    }

    //reparent
    layer1.parent = rootParent;
    layer2.parent = middleParent;
    controller.parent = endParent;

    //add effect
    var name = Duik.Layer.limbName(layer2);
    if ( goal != null ) name = Duik.Layer.limbName(goal);
    var pe = Duik.PseudoEffect.TWO_LAYER_IK;
    var effect = pe.apply( controller, DuScriptUI.String.IK + ' | ' + name );

    // indices
    var ikIndex = pe.props["IK / FK"].index;
    var weightIndex = pe.props["Weight"].index;
    var sideIndex = pe.props["Side"].index;

    var swingIndex = pe.props["Swing"]["Swing"].index;
    var swingSftnssIndex = pe.props["Swing"]["Softness"].index;
    var swingLimitIndex = pe.props["Swing"]["Limit angle"].index;
    var swingRevIndex = pe.props["Swing"]["Reverse"].index;

    var pRotationIndex = pe.props["FK"]["Parent rotation"].index;
    var uFKIndex = pe.props["FK"]["Upper"].index;
    var lFKIndex = pe.props["FK"]["Lower"].index;
    var endFKIndex = pe.props["FK"]["End"].index;

    var overlapAnimIndex = pe.props["FK Overlap"]["Animation"].index;
    var resistanceIndex = pe.props["FK Overlap"]["Resistance"].index;
    var flexibilityIndex = pe.props["FK Overlap"]["Flexibility"].index;
    var overlapIndex = pe.props["FK Overlap"]["Overlap"].index;
    
    var stretchIndex = pe.props["Stretch"]["Stretch"].index;
    var upperStretchIndex = pe.props["Stretch"]["Upper Stretch"].index;
    var lowerStretchIndex = pe.props["Stretch"]["Lower Stretch"].index;
    var autoStretchIndex = pe.props["Stretch"]["Auto-Stretch"].index;

    var uStretchIndex = pe.props["Data"]["Stretch data"]["Upper stretch"].index;
    var uScaleIndex = pe.props["Data"]["Stretch data"]["Upper scale"].index;
    var lStretchIndex = pe.props["Data"]["Stretch data"]["Lower stretch"].index;
    var lScaleIndex = pe.props["Data"]["Stretch data"]["Lower scale"].index;
    var goalPosIndex = pe.props["Data"]["Stretch data"]["Goal position"].index;
    var goalWPosIndex = pe.props["Data"]["Stretch data"]["Goal world position"].index;

    var uLengthIndex = pe.props["Data"]["Lengths"]["Upper length"].index;
    var lLengthIndex = pe.props["Data"]["Lengths"]["Lower length"].index;
    var ikLengthIndex = pe.props["Data"]["Lengths"]["IK length"].index;

    var straightIndex = pe.props["Data"]["Straight"].index;

    var uLayerIndex = pe.props["Data"]["Layers"]["Upper"].index;
    var lLayerIndex = pe.props["Data"]["Layers"]["Lower"].index;
    var gLayerIndex = pe.props["Data"]["Layers"]["Goal"].index;

    var guidesIndex = pe.props["Display"]["Draw guides"].index;

    // Default values
    effect( guidesIndex ).setValue( showGuides );
    effect( swingSftnssIndex ).setValue( 10 );

    if ( clockwise ) effect( sideIndex ).setValue( -100 );
    else effect( sideIndex ).setValue( 100 );

    //set layers
    effect( uLayerIndex ).setValue( layer1.index );
    effect( lLayerIndex ).setValue( layer2.index );
    if ( goal != null ) effect( gLayerIndex ).setValue( goal.index );

    //set lengths
    effect( uLengthIndex ).setValue( upperLength );
    effect( lLengthIndex ).setValue( lowerLength );

    //inherit parent rotation
    effect( pRotationIndex ).setValue( 1 );

    //get some useful coordinates
    var goalPos = [ 0, 0 ];
    if ( goal != null )
    {
        goalPos = goal.transform.position.value;
    }
    else
    {
        effect( goalPosIndex ).expression = "thisComp.layer(" + layer2.index + ").fromWorld( thisComp.layer(" + controller.index + ").position)";
        goalPos = effect( goalPosIndex ).value;
        effect( goalPosIndex ).expression = "";
    }
    var goalPosProp = new DuAEProperty( effect( goalPosIndex ) );
    goalPosProp.setValue( goalPos );

    var rootAp = layer1.transform.anchorPoint.value.toSource();
    var middleAp = layer2.transform.anchorPoint.value.toSource();
    var middlePos = layer2.transform.position.value.toSource();

    //add expressions
    effect( uStretchIndex ).expression = [DuAEExpression.Id.TWO_IK,
        'var fx = effect("' + effect.name + '");',
        'var layer1 = null;',
        'var layer2 = null;',
        'var result = 0;',
        'try { layer1 = fx(' + uLayerIndex + '); layer2 = fx(' + lLayerIndex + '); } catch (e) {}',
        'if ( layer1 != null )',
        '{',
        '   var newLength = length( layer1.toWorld(layer1.anchorPoint), layer2.toWorld(layer2.anchorPoint) );',
        '   result = newLength - fx(' + uLengthIndex + ').value;',
        '}',
        'result;'
        ].join('\n');

    effect( uScaleIndex ).expression = [DuAEExpression.Id.TWO_IK,
        'var fx = effect("' + effect.name + '");',
        'var upperLength =  fx(' + uLengthIndex + ').value',
        'var upperStretch =  fx(' + uStretchIndex + ').value',
        'var result = 100',
        'if ( upperLength > 0 ) result = ( upperStretch + upperLength ) / upperLength * 100;',
        'result;'
        ].join('\n');

    effect( lStretchIndex ).expression = [DuAEExpression.Id.TWO_IK,
        'var fx = effect("' + effect.name + '");',
        'var layer2 = null;',
        'var result = 0;',
        'try{ layer2 = fx(' + lLayerIndex + '); }catch (e) {}',
        'if ( layer2 != null)',
        '{',
        '   var goalPos = fx(' + goalPosIndex + ').value',
        '   var lowerLength = fx(' + lLengthIndex + ').value;',
        '   var newLength = length( layer2.toWorld( goalPos ), layer2.toWorld( layer2.anchorPoint ) );',
        '   result = newLength - lowerLength;',
        '}',
        'result;'
        ].join('\n');

    effect( lScaleIndex ).expression = [DuAEExpression.Id.TWO_IK,
        'var fx = effect("' + effect.name + '");',
        'var lowerLength =  fx(' + lLengthIndex + ').value',
        'var lowerStretch =  fx(' + lStretchIndex + ').value',
        'var result = 100',
        'if ( lowerLength > 0 ) result = ( lowerStretch + lowerLength ) / lowerLength * 100;',
        'result;'
        ].join('\n');

    effect( goalPosIndex ).expression = [DuAEExpression.Id.TWO_IK,
        'var result = value;',
        'var fx = effect("' + effect.name + '");',
        'var layer1 = null;',
        'try {',
        '	layer1 = fx(' + uLayerIndex + ')',
        '} catch (e) {}',
        'if (layer1 != null) {',
        '	var stretch = fx(' + stretchIndex + ') + fx(' + lowerStretchIndex + ');',
        '	var auto = fx(' + autoStretchIndex + ').value;',
        '	var IK = fx(' + ikIndex + ').value;',
        '   IK *= fx(' + weightIndex + ').value/100;',
        '	var shrinkVal = fx(' + sideIndex + ').value;',
        '   shrinkVal /= 100;',
        '	shrinkVal = 1 - Math.abs(shrinkVal);',
        '',
        '	function getWorldPos(L) {',
        '		return L.toWorld(L.anchorPoint);',
        '	}',
        '	var dist1 = fx(' + uLengthIndex + ').value;',
        '	var dist2 = fx(' + lLengthIndex + ').value;',
        '	var IKLength = dist1 + dist2;',
        '	var IKStretched = IKLength + stretch;',
        '	var boneStretch = 0;',
        '	var proportion = dist2 / (IKLength);',
        '	var posC = toWorld(anchorPoint);',
        '	var posR = getWorldPos(layer1);',
        '	var distC = length(posC, posR);',
        '	var shrinkMax = IKLength * shrinkVal;',
        '	var shrink = 0;',
        '	if (distC < IKStretched) shrink = (1 - distC / IKStretched)*IK;',
        '	boneStretch -= linear(shrink, 0, shrinkMax) * proportion;',
        '	if (distC > IKStretched && auto) boneStretch += ((distC - IKLength) * proportion)*IK;',
        '	else boneStretch += stretch * proportion;',
        '	var coef = 1;',
        '	dist2 != 0 ? coef = (dist2 + boneStretch) / dist2 : coef = 1;',
        '	result = (' + goalPos.toSource() + ' - ' + middleAp + ') * coef + ' + middleAp + ';',
        '}',
        'result;'
        ].join('\n');

    effect( goalWPosIndex ).expression = [DuAEExpression.Id.TWO_IK,
        'var fx = effect("' + effect.name + '");',
        'var layer2 = null;',
        'var result = [0,0];',
        'try { layer2 = fx(' + lLayerIndex + ') } catch (e) {}',
        'if ( layer2 != null)',
        '{',
        '   result = layer2.toWorld( fx(' + goalPosIndex + ').value );',
        '}',
        'result;'
        ].join('\n');

    effect( ikLengthIndex ).expression = [DuAEExpression.Id.TWO_IK,
        'var fx = effect("' + effect.name + '");',
        'var upperLength = fx(' + uLengthIndex + ').value;',
        'var lowerLength = fx(' + lLengthIndex + ').value;',
        'var result = upperLength + lowerLength;',
        'var goalWorldPos = fx(' + goalWPosIndex + ').value;',
        'var layer1 = null;',
        'try{ layer1 = fx(' + uLayerIndex + '); } catch (e) {}',
        'if (layer1 != null)',
        '{',
        '   result = length( layer1.toWorld(layer1.anchorPoint), goalWorldPos);',
        '}',
        'result;'
        ].join('\n');

    effect( straightIndex ).expression = [DuAEExpression.Id.TWO_IK,
        'fx = effect("' + effect.name + '");',
        'var layer1 = null;',
        'var layer2 = null;',
        'var result = false;',
        'try { layer1 = fx(' + uLayerIndex + '); layer2  = fx(' + lLayerIndex + ');} catch (e) {}',
        'if (layer1 != null)',
        '{',
        '   var goalPos = fx(' + goalPosIndex + ').value',
        '   var a = layer1.toWorld( layer1.anchorPoint );',
        '   var b = layer2.toWorld( layer2.anchorPoint );',
        '   var c = layer2.toWorld( goalPos );',
        '   result = Math.abs(a[0] * (b[1] - c[1]) + b[0] * (c[1] - a[1]) + c[0] * (a[1] - b[1])) < 1000;',
        '}',
        'result;'
    ].join('\n');

    effect( sideIndex ).expression = [DuAEExpression.Id.TWO_IK,
        'var result = value;',
        'var fx = effect("' + effect.name + '");',
        'var auto = fx(' + swingIndex + ').value;',
        'if (auto)',
        '{',
        '	var layer1 = null;',
        '	try {',
        '		layer1 = fx(' + uLayerIndex + ')',
        '	} catch (e) {}',
        '	if (layer1 != null) {',
        '		var rev = fx(' + swingRevIndex + ').value;',
        '       var sftnss = fx(' + swingSftnssIndex + ').value;',
        '       var angle = fx(' + swingLimitIndex + ').value;',
        '		var lowerLimit = angle - sftnss;',
        '		var upperLimit = angle + sftnss;',
        '		var C = toWorld(anchorPoint);',
        '		var O = layer1.toWorld(layer1.anchorPoint);',
        '		var vec = C - O;',
        '		var angle = Math.atan2(vec[1], vec[0]);',
        '		angle = radiansToDegrees(angle);',
        '		angle = linear(angle, lowerLimit, upperLimit, -100, 100);',
        '		if(rev) angle = -angle;',
        '		result = angle;',
        '	}',
        '}',
        '',
        'result;'
	].join('\n');

    
    //add controller visual feedback
    if ( controller instanceof ShapeLayer )
    {
        // Will be null if baked / removed
        var peCtrl = Duik.PseudoEffect.CONTROLLER;
        var ctrlEffect = controller.effect( peCtrl.matchName );
        var iconColorIndex = peCtrl.props["Icon"]["Color"].index;
        var iconSizeIndex = peCtrl.props["Icon"]["Size"].index;
        var iconPosIndex = peCtrl.props["Icon"]["Position"].index;
        var iconOpacityIndex = peCtrl.props["Icon"]["Opacity"].index;

        // reusable expressions
        var colorExp = '';
        if (ctrlEffect) colorExp = DuAEExpression.Id.TWO_IK + '\neffect("' + ctrlEffect.name + '")(' + iconColorIndex + ')-[0.2,0.2,0.2,0]';

        var ikGroup = controller( "ADBE Root Vectors Group" ).addProperty( "ADBE Vector Group" );
        ikGroup.name = 'IK';
        var ikContent = ikGroup.property( "ADBE Vectors Group" );
        var shape = ikContent.addProperty( "ADBE Vector Shape - Group" );
        var ikShape = new Shape();
        ikShape.vertices = [
            [ -8, 16 ],
            [ 8, 16 ]
        ];
        ikShape.inTangents = [
            [ 0, 0 ],
            [ 0, 0 ]
        ];
        ikShape.outTangents = [
            [ 0, 0 ],
            [ 0, 0 ]
        ];
        ikShape.closed = false;
        shape( 'ADBE Vector Shape' ).setValue( ikShape );
        var stroke = ikContent.addProperty( "ADBE Vector Graphic - Stroke" );

        if (ctrlEffect) stroke( "ADBE Vector Stroke Color" ).expression = colorExp;
        else stroke( "ADBE Vector Stroke Color" ).setValue( DuColor.Color.APP_HIGHLIGHT_COLOR.darker(150).floatRGBA() );
        stroke( "ADBE Vector Stroke Width" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Line Cap" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Opacity" ).expression = [DuAEExpression.Id.TWO_IK,
            'var fx = effect("' + effect.name + '");\n' +
            'if (fx(' + guidesIndex + ').value) fx(' + straightIndex + ').value;',
            'else 0;'
            ].join('\n');

        if (ctrlEffect) ikGroup.transform.scale.expression = DuAEExpression.Id.TWO_IK + '\n[ effect("' + ctrlEffect.name + '")(' + iconSizeIndex + ') * 2 ,effect("' + ctrlEffect.name + '")(' + iconSizeIndex + ') * 2 ]';
        if (ctrlEffect) ikGroup.transform.position.expression = DuAEExpression.Id.TWO_IK + '\neffect("' + ctrlEffect.name + '")(' + iconPosIndex + ')';
        if (ctrlEffect) ikGroup.transform.opacity.expression = DuAEExpression.Id.TWO_IK + '\neffect("' + ctrlEffect.name + '")(' + iconOpacityIndex + ') * effect("' + effect.name + '")(' + weightIndex + ').value/100;';

        if ( DuAE.version.version >= 15 )
        {
            var lineGroup = controller( "ADBE Root Vectors Group" ).property( 'IK Line' );
            if ( !lineGroup )
            {
                lineGroup = controller( "ADBE Root Vectors Group" ).addProperty( "ADBE Vector Group" );
                lineGroup.name = 'IK Line';
            }
            lineGroup.transform.opacity.expression = DuAEExpression.Id.TWO_IK + '\neffect("' + effect.name + '")(' + weightIndex + ').value;';
            var lineContent = lineGroup.property( "ADBE Vectors Group" );
            var shape = lineContent.addProperty( "ADBE Vector Shape - Group" );
            shape( 'ADBE Vector Shape' ).expression = [DuAEExpression.Id.TWO_IK,
                'var fx = effect("' + effect.name + '");',
                'var layer1 = null;',
                'var result = [[0,0]];',
                'if (fx(' + ikIndex + ').value && fx(' + guidesIndex + ').value)',
                '{',
                '   try{ layer1 = fx(' + uLayerIndex + '); }catch (e) {}',
                '   if (layer1!=null)',
                '   {',
                '       var l = layer1.toWorld(layer1.anchorPoint);',
                '       l = fromWorld(l);',
                '       result = [l,[0,0]];',
                '   }',
                '}',
                'createPath(result,[],[],false);'
            ].join('\n');

            var stroke = lineContent.property( "ADBE Vector Graphic - Stroke" );
            if ( !stroke ) stroke = lineContent.addProperty( "ADBE Vector Graphic - Stroke" );
            if (ctrlEffect) stroke( "ADBE Vector Stroke Color" ).expression = colorExp;
            else stroke( "ADBE Vector Stroke Color" ).setValue( DuColor.Color.APP_HIGHLIGHT_COLOR.darker(150).floatRGBA() );
            stroke( "ADBE Vector Stroke Width" ).setValue( 2 );
            stroke( "ADBE Vector Stroke Line Cap" ).setValue( 2 );
            stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
            stroke( "ADBE Vector Stroke Dashes" )( "ADBE Vector Stroke Dash 1" ).setValue( 5 );

            var ikSideGroup = controller( "ADBE Root Vectors Group" ).addProperty( "ADBE Vector Group" );
            ikSideGroup.name = "IK Swing";
            ikSideContent = ikSideGroup.property( "ADBE Vectors Group" );

            var upperLimitGroup = ikSideContent.addProperty( "ADBE Vector Group" );
            upperLimitGroup.name = "Upper Limit";
            var upperLimitContent = upperLimitGroup.property( "ADBE Vectors Group" );

            shape = upperLimitContent.addProperty( "ADBE Vector Shape - Group" );
            shape( 'ADBE Vector Shape' ).expression = [DuAEExpression.Id.TWO_IK,
                'var fx = effect("' + effect.name + '");',
                'var layer1 = null;',
                'var result = [[0,0]];',
                'if (fx(' + ikIndex + ').value && fx(' + guidesIndex + ').value && fx(' + swingIndex + ').value)',
                '{',
                '	try{ layer1 = fx(' + uLayerIndex + '); }catch (e) {}',
                '	if ( layer1 != null)',
                '	{',
                '		var l = layer1.toWorld( layer1.anchorPoint );',
                '		l = fromWorld(l);',
                '		l = length(l) * .5;',
                '		result = [[l,0],[0,0]];',
                '	}',
                '}',
                'createPath(result,[],[],false);'
                ].join('\n');

            stroke = upperLimitContent.addProperty( "ADBE Vector Graphic - Stroke" );
            if (ctrlEffect) stroke( "ADBE Vector Stroke Color" ).expression = colorExp;
            else stroke( "ADBE Vector Stroke Color" ).setValue( DuColor.Color.APP_HIGHLIGHT_COLOR.darker(150).floatRGBA() );
            stroke( "ADBE Vector Stroke Width" ).setValue( 2 );
            stroke( "ADBE Vector Stroke Line Cap" ).setValue( 2 );
            stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
            stroke( "ADBE Vector Stroke Dashes" )( "ADBE Vector Stroke Dash 1" ).setValue( 5 );

            upperLimitGroup.transform.rotation.expression = DuAEExpression.Id.TWO_IK + '\n-effect("' + effect.name + '")(' + swingSftnssIndex + ').value;';
            upperLimitGroup.transform.opacity.expression = [DuAEExpression.Id.TWO_IK,
                'var fx = effect("' + effect.name + '");',
                'if (fx(' + ikIndex + ').value && fx(' + guidesIndex + ').value && fx(' + swingIndex + ').value) 100;',
                'else 0;'
                ].join('\n');

            var lowerLimitGroup = ikSideContent.addProperty( "ADBE Vector Group" );
            lowerLimitGroup.name = "Lower Limit";
            var lowerLimitContent = lowerLimitGroup.property( "ADBE Vectors Group" );

            shape = lowerLimitContent.addProperty( "ADBE Vector Shape - Group" );
            shape( 'ADBE Vector Shape' ).expression = [DuAEExpression.Id.TWO_IK,
                'var fx = effect("' + effect.name + '");',
                'var layer1 = null;',
                'var result = [[0,0]];',
                'if (fx(' + ikIndex + ').value && fx(' + guidesIndex + ').value && fx(' + swingIndex + ').value)',
                '{',
                '	try{ layer1 = fx(' + uLayerIndex + '); }catch (e) {}',
                '	if ( layer1 != null)',
                '	{',
                '		var l = layer1.toWorld( layer1.anchorPoint );',
                '		l = fromWorld(l);',
                '		l = length(l) * .5;',
                '		result = [[l,0],[0,0]];',
                '	}',
                '}',
                'createPath(result,[],[],false);'
                ].join('\n');

            stroke = lowerLimitContent.addProperty( "ADBE Vector Graphic - Stroke" );
            if (ctrlEffect) stroke( "ADBE Vector Stroke Color" ).expression = colorExp;
            else stroke( "ADBE Vector Stroke Color" ).setValue( DuColor.Color.APP_HIGHLIGHT_COLOR.darker(150).floatRGBA() );
            stroke( "ADBE Vector Stroke Width" ).setValue( 2 );
            stroke( "ADBE Vector Stroke Line Cap" ).setValue( 2 );
            stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
            stroke( "ADBE Vector Stroke Dashes" )( "ADBE Vector Stroke Dash 1" ).setValue( 5 );

            lowerLimitGroup.transform.rotation.expression = DuAEExpression.Id.TWO_IK + '\neffect("' + effect.name + '")(' + swingSftnssIndex + ').value;';
            lowerLimitGroup.transform.opacity.expression = [DuAEExpression.Id.TWO_IK,
                'var fx = effect("' + effect.name + '");',
                'if (fx(' + ikIndex + ').value && fx(' + guidesIndex + ').value && fx(' + swingIndex + ').value) 100;',
                'else 0;'
                ].join('\n');

            var angleGroup = ikSideContent.addProperty( "ADBE Vector Group" );
            angleGroup.name = "Lower Limit";
            var angleContent = angleGroup.property( "ADBE Vectors Group" );

            shape = angleContent.addProperty( "ADBE Vector Shape - Group" );
            shape( 'ADBE Vector Shape' ).expression = [DuAEExpression.Id.TWO_IK,
                'var fx = effect("' + effect.name + '");',
                'var layer1 = null;',
                'var result = [[0,0]];',
                'if (fx(' + ikIndex + ').value && fx(' + guidesIndex + ').value && fx(' + swingIndex + ').value)',
                '{',
                '	try{ layer1 = fx(' + uLayerIndex + '); }catch (e) {}',
                '	if ( layer1 != null)',
                '	{',
                '		var l = layer1.toWorld( layer1.anchorPoint );',
                '		l = fromWorld(l);',
                '		l = length(l) * .8;',
                '		result = [[l,0],[0,0]];',
                '	}',
                '}',
                'createPath(result,[],[],false);'
                ].join('\n');

            stroke = angleContent.addProperty( "ADBE Vector Graphic - Stroke" );
            if (ctrlEffect) stroke( "ADBE Vector Stroke Color" ).expression = colorExp;
            else stroke( "ADBE Vector Stroke Color" ).setValue( DuColor.Color.APP_HIGHLIGHT_COLOR.darker(150).floatRGBA() );
            stroke( "ADBE Vector Stroke Width" ).setValue( 2 );
            stroke( "ADBE Vector Stroke Line Cap" ).setValue( 2 );

            angleGroup.transform.opacity.expression = [DuAEExpression.Id.TWO_IK,
                'var fx = effect("' + effect.name + '");',
                'if (fx(' + ikIndex + ').value && fx(' + guidesIndex + ').value && fx(' + swingIndex + ').value) 100;',
                'else 0;'
                ].join('\n');

            ikSideGroup.transform.position.expression = [DuAEExpression.Id.TWO_IK,
                'var fx = effect("' + effect.name + '");',
                'var layer1 = null;',
                'var result = value;',
                'if (fx(' + ikIndex + ').value && fx(' + guidesIndex + ').value && fx(' + swingIndex + ').value)',
                '{',
                '	try{ layer1 = fx(' + uLayerIndex + '); }catch (e) {}',
                '	if ( layer1 != null)',
                '	{',
                '		var l = layer1.toWorld( layer1.anchorPoint );',
                '		result = fromWorld( l );',
                '	}',
                '}',
                'result;'
            ].join('\n');

            ikSideGroup.transform.rotation.expression = [DuAEExpression.Id.TWO_IK,
                'var fx = effect("' + effect.name + '");',
                'var layer1 = null;',
                'var result = value;',
                '',
                DuAEExpression.Library.get(['getOrientation']),
                '',
                'if (fx(' + ikIndex + ').value && fx(' + guidesIndex + ').value && fx(' + swingIndex + ').value)',
                '{',
                '	try{ layer1 = fx(' + uLayerIndex + '); }catch (e) {}',
                '	if (layer1 != null)',
                '	{',
                '       if ( layer1.hasParent ) result = getOrientation( layer1.parent );',
                '		result += fx(' + swingLimitIndex + ').value;',
                '   }',
                '}',
                'result;'
                ].join('\n');
        }

        //close controller details
        controller.selected = true;
        DuAE.executeCommand( DuAE.MenuCommandID.REVEAL_EXPRESSION_ERRORS, true );
    }


    //setup layers
    var layer1Data = layer1('ADBE Effect Parade').addProperty('ADBE Layer Control');
    layer1Data.name = DuScriptUI.String.IK;
    layer1Data( 1 ).setValue( controller.index );

    layer1.transform.rotation.expression = [DuAEExpression.Id.TWO_IK,
        'var controller = null;',
        'var result = value;',
        'try {',
        '	controller = effect("' + layer1Data.name + '")(1)',
        '} catch (e) {}',
        'if (controller != null) {',
        '	var fx = controller.effect("' + effect.name + '");',
        '	var IKFK = fx(' + ikIndex + ').value;',
        '   IKFK *= fx(' + weightIndex + ').value/100;',
        '',
        '	function ik() {',
        '		var layer1 = thisLayer;',
        '		var layer2 = null;',
        '		try {',
        '			layer2 = fx(' + lLayerIndex + ');',
        '		} catch (e) {',
        '			return value;',
        '		}',
        '		if (layer2 != null) {',
        '			var endPos = fx(' + goalPosIndex + ').value;',
        '			var side = fx(' + sideIndex + ').value;',
        '			var cw = side < 0;',
        '',
        '			function getWorldPos(L) {',
        '				return L.toWorld(L.anchorPoint);',
        '			}',
        '			var A = getWorldPos(layer1);',
        '			var C = layer2.toWorld(endPos);',
        '			var B = getWorldPos(layer2);',
        '			var E = getWorldPos(controller);',
        '			var a = length(B, C);',
        '			var b = length(E, A);',
        '			var c = length(A, B);',
        '			var x = (b * b + c * c - a * a) / (2 * b);',
        '			var alpha = Math.acos(clamp(x / c, -1, 1));',
        '			var D = E - A;',
        '			var delta = Math.atan2(D[1], D[0]);',
        '			var r = radiansToDegrees(delta - (cw ? 1 : -1) * alpha);',
        '			var V = B - A;',
        '			var adj1 = radiansToDegrees(Math.atan2(V[1], V[0]));',
        '			var IK = r - adj1 + value;',
        '           IK = IK % 360;',
		'           if (IK > 180) return IK - 360;',
		'           if (IK < -180) return IK + 360;',
		'           return IK;',
        '		}',
        '	}',
        '',
        '	function fk() {',
        '		var follow = fx(' + pRotationIndex + ').value;',
        '		var FK = fx(' + uFKIndex + ').value + fx(' + overlapAnimIndex + ').value;',
        '		var p = thisLayer;',
        '		if (!follow) {',
        '			while (p.hasParent) {',
        '				p = p.parent;',
        '				FK -= p.rotation.value;',
        '			}',
        '		}',
        '		return FK;',
        '	}',
        '	result = ik()*IKFK + fk()*(1-IKFK);',
        '}',
        'result;'
    ].join('\n');

    var layer2Data = layer2('ADBE Effect Parade').addProperty('ADBE Layer Control');
    layer2Data.name = DuScriptUI.String.IK;
    layer2Data( 1 ).setValue( controller.index );

    layer2.transform.rotation.expression =[DuAEExpression.Id.TWO_IK,
        'var controller = null;',
        'var result = value;',
        'try {',
        '	controller = effect("' + layer1Data.name + '")(1);',
        '} catch (e) {}',
        'if (controller != null) {',
        '	var fx = controller.effect("' + effect.name + '");',
        '	var IKFK = fx(' + ikIndex + ').value;',
        '   IKFK *= fx(' + weightIndex + ').value/100;',
        '	var layer1 = null;',
        '	var layer2 = thisLayer;',
        '	try {',
        '		layer1 = fx(' + uLayerIndex + ');',
        '	} catch (e) {}',
        '	if (layer1 != null) {',
        '		function ik() {',
        '			var endPos = fx(' + goalPosIndex + ').value;',
        '			var side = fx(' + sideIndex + ').value;',
        '			var cw = side < 0;',
        '',
        '			function getWorldPos(L) {',
        '				return L.toWorld(L.anchorPoint);',
        '			}',
        '			var A = getWorldPos(layer1);',
        '			var B = getWorldPos(layer2);',
        '			var C = layer2.toWorld(endPos);',
        '			var E = getWorldPos(controller);',
        '			var a = length(B, C);',
        '			var b = length(E, A);',
        '			var c = length(A, B);',
        '			var x = (b * b + c * c - a * a) / (2 * b);',
        '			var alpha = Math.acos(clamp(x / c, -1, 1));',
        '			var y = b - x;',
        '			var gamma = Math.acos(clamp(y / a, -1, 1));',
        '			var r = (cw ? 1 : -1) * radiansToDegrees(gamma + alpha);',
        '			var V1 = B - A;',
        '			var adj1 = radiansToDegrees(Math.atan2(V1[1], V1[0]));',
        '			var V2 = C - B;',
        '			var adj2 = radiansToDegrees(Math.atan2(V2[1], V2[0]));',
        '			var IK = r + adj1 - adj2 + value;',
        '           IK = IK % 360;',
		'           if (IK > 180) return IK - 360;',
		'           if (IK < -180) return IK + 360;',
		'           return IK;',
        '		}',
        '',
        '		function fk() {',
        '			var ctrlRot = fx(' + overlapAnimIndex + ');',
        '			var delay = fx(' + resistanceIndex + ').value;',
        '			var amp = fx(' + flexibilityIndex + ').value;',
        '			var follow = fx(' + pRotationIndex + ').value;',
        '			var ftEnabled = fx(' + overlapIndex + ').value;',
        '			if (!ftEnabled) {',
        '				amp = 0;',
        '				delay = 0;',
        '			} else {',
        '				delay = delay / 100;',
        '				amp = amp / 100;',
        '			}',
        '			FK = ctrlRot.valueAtTime(time - delay);',
        '			if (follow && hasParent) {',
        '				var cP = layer1;',
        '				while (cP.hasParent) {',
        '					cP = cP.parent;',
        '					FK -= cP.rotation.value - cP.rotation.valueAtTime(time - delay);',
        '				}',
        '			}',
        '			FK = FK - ctrlRot.value;',
        '			FK = FK * amp;',
        '			FK = FK - ctrlRot.velocity * (delay / 5);',
        '			FK += fx(' + lFKIndex + ').value;',
        '			return FK;',
        '		}',
        '		result = ik()*IKFK + fk()*(1-IKFK);',
        '	}',
        '}',
        'result;'
    ].join('\n');

    layer2.transform.position.expression = [DuAEExpression.Id.TWO_IK,
        'var ctrl = null;',
        'var result = value;',
        'try { ctrl = effect("' + layer1Data.name + '")(1); } catch (e) {}',
        'if (ctrl != null) {',
        '	var fx = ctrl.effect("' + effect.name + '");',
        '	var layer1 = null;',
        '	var result = ' + middlePos.toSource() + ';',
        '	try { layer1 = fx(' + uLayerIndex + '); } catch (e) {}',
        '	if (layer1 != null) {',
        '		var stretch = fx(' + stretchIndex + ').value + fx(' + upperStretchIndex + ').value;',
        '		var auto = fx(' + autoStretchIndex + ').value;',
        '		var IK = fx(' + ikIndex + ').value;',
        '       IK *= fx(' + weightIndex + ').value/100;',
        '		var shrinkVal = fx(' + sideIndex + ').value;',
        '       shrinkVal /= 100;',
        '		shrinkVal = 1 - Math.abs(shrinkVal);',
        '',
        '		function getWorldPos(L) {',
        '			return L.toWorld(L.anchorPoint);',
        '		}',
        '		var dist1 = fx(' + uLengthIndex + ').value;',
        '		var dist2 = fx(' + lLengthIndex + ').value;',
        '		var IKLength = dist1 + dist2;',
        '		var IKStretched = IKLength + stretch;',
        '		var boneStretch = 0;',
        '		var proportion = dist1 / (IKLength);',
        '		var posC = getWorldPos(ctrl);',
        '		var posR = getWorldPos(layer1);',
        '		var distC = length(posC, posR);',
        '		var shrinkMax = IKLength * shrinkVal;',
        '		var shrink = 0;',
        '		if (distC < IKStretched) shrink = (1 - distC / IKStretched)*IK;',
        '		boneStretch -= linear(shrink, 0, shrinkMax) * proportion;',
        '		if (distC > IKStretched && auto) boneStretch += ((distC - IKLength) * proportion)*IK;',
        '		else boneStretch += stretch * proportion;',
        '		var coef = 1;',
        '		dist1 != 0 ? coef = (dist1 + boneStretch) / dist1 : coef = 1;',
        '		result = (' + middlePos + ' -' + rootAp + ') * coef+' + rootAp + ';',
        '	}',
        '}',
        'result;'
    ].join('\n');

    if ( goal != null )
    {
        var goalData = goal('ADBE Effect Parade').addProperty('ADBE Layer Control');
        layer2Data.name = DuScriptUI.String.IK;
        goalData( 1 ).setValue( controller.index );

        var rotExpr = [DuAEExpression.Id.TWO_IK,
            'var ctrl = null;',
            'try {',
            '    ctrl = effect( "' + goalData.name + '" )( 1 );',
            '} catch ( e ) {};',
            'var result = value;',
            'if ( ctrl != null ) {',
            '    var fx = ctrl.effect( "' + effect.name + '" );',
            '    var ikfk = fx( ' + ikIndex + ' ).value;',
            '    ikfk *= fx(2).value/100;',
            '',
            '    function ik() {',
            '        var IK = ctrl.rotation.value;',
            '        var layer = thisLayer;',
            '        while ( layer.hasParent ) {',
            '            layer = layer.parent;',
            '            IK = IK - layer.rotation;',
            '        }',
            '        return IK;',
            '    }',
            '',
            '    function fk() {',
            '        var FK = value;',
            '        var parentRot = parent.transform.rotation;',
            '        var delay = fx( ' + resistanceIndex + ' ).value;',
            '        var amp = fx( ' + flexibilityIndex + ' ).value;',
            '        var ftEnabled = fx( ' + overlapIndex + ' ).value;',
            '',
            '        delay = delay / 100;',
            '        amp = amp / 100;',
            '',
            '        if (ftEnabled)',
            '        {',
            '            FK = parentRot.valueAtTime( time - delay );',
            '            FK = FK * amp;',
            '        }',
            '        ',
            '        FK = FK + value + fx( ' + endFKIndex + ' );',
            '',
            '        if (ftEnabled)',
            '        {',
            '            FK = FK - parentRot.valueAtTime( 0 )',
            '        }',
            '        ',
            '        return FK;',
            '    }',
            '    result = ik()*ikfk + fk()*(1-ikfk);',
            '}',
            'result;'
            ].join('\n');

        var rotProp = new DuAEProperty( goal.transform.rotation );
        rotProp.setExpression( rotExpr );

        goal.transform.position.expression = [DuAEExpression.Id.TWO_IK,
            'var ctrl = null;',
            'var result = value;',
            'try { ctrl = effect("' + goalData.name + '")(1); } catch (e){ value };',
            'if (ctrl != null)',
            '{',
            'result = ctrl.effect("' + effect.name + '")(' + goalPosIndex + ').value;',
            '}',
            'result;'
        ].join('\n');
    }

    return controller;
}

/**
 * Creates a three-layer-ik on the layer
 * @param {Layer} layer1 - The root layer
 * @param {Layer} layer2 - The middle layer
 * @param {Layer} layer3 - The end layer
 * @param {Layer|null} [goal] - The goal layer, at the end of the IK
 * @param {Layer|null} [controller] - The layer to use as a controller, can be automatically created.<br />
 * Must be provided if goal is undefined
 * @param {Boolean} [showGuides=true] - Set to false to hide guides on the controllers (and improve performance)
 * @return {Layer} The controller created
 */
Duik.Constraint.threeLayerIK = function( layer1, layer2, layer3, goal, controller, showGuides )
{
    goal = def(goal, null);
    controller = def(controller, null);
    if ( controller == null && goal == null ) throw "You must provide either a goal layer or a controller";
    var comp = layer1.containingComp;

    showGuides = def( showGuides, 1 );
    if (!showGuides) showGuides = 0;

    //Create controller
    if ( controller == null )
    {
        controller = Duik.Controller.create( comp,  Duik.Controller.Type.TRANSFORM, goal );
        goal.parent = null;
        controller.transform.rotation.setValue( goal.transform.rotation.value );
        goal.parent = layer3;
    }

    //Check if clockwise and lengths

    //unparent
    var rootParent = layer1.parent;
    layer1.parent = null;
    var middleParent = layer2.parent;
    layer2.parent = null;
    var endParent = controller.parent;
    controller.parent = null;

    var upperLength = DuMath.length( layer1.transform.position.value, layer2.transform.position.value );
    var lowerLength = DuAELayer.getDistance( layer3, controller );
    var middleLength = DuAELayer.getDistance( layer3, layer2 );
    var endPos = controller.transform.position.value - layer1.transform.position.value;
    var middlePos = layer2.transform.position.value - layer1.transform.position.value;
    var coef = endPos[ 1 ] / endPos[ 0 ];

    var clockwise = false;
    if ( middlePos[ 1 ] < middlePos[ 0 ] * coef && endPos[ 0 ] > 0 ) clockwise = true;
    if ( middlePos[ 1 ] > middlePos[ 0 ] * coef && endPos[ 0 ] < 0 ) clockwise = true;

    //reparent
    layer1.parent = rootParent;
    layer2.parent = middleParent;
    controller.parent = endParent;

    //add effect
    var name = Duik.Layer.limbName(layer3);
    if ( goal != null ) name = Duik.Layer.limbName(goal);
    var pe = Duik.PseudoEffect.THREE_LAYER_IK;
    var effect = pe.apply( controller, DuScriptUI.String.IK + ' | ' + name );

    // indices
    var ikIndex = pe.props["IK / FK"].index;
    var weightIndex = pe.props["Weight"].index;
    var revIndex = pe.props["Reverse"].index;

    var pRotationIndex = pe.props["FK"]["Parent rotation"].index;
    var uFKIndex = pe.props["FK"]["Upper"].index;
    var mFKIndex = pe.props["FK"]["Middle"].index;
    var lFKIndex = pe.props["FK"]["Lower"].index;
    var endFKIndex = pe.props["FK"]["End"].index;

    var overlapAnimIndex = pe.props["FK Overlap"]["Animation"].index;
    var resistanceIndex = pe.props["FK Overlap"]["Resistance"].index;
    var flexibilityIndex = pe.props["FK Overlap"]["Flexibility"].index;
    var overlapIndex = pe.props["FK Overlap"]["Overlap"].index;

    var stretchIndex = pe.props["Stretch"]["Stretch"].index;
    var upperStretchIndex = pe.props["Stretch"]["Upper Stretch"].index;
    var middleStretchIndex = pe.props["Stretch"]["Middle Stretch"].index;
    var lowerStretchIndex = pe.props["Stretch"]["Lower Stretch"].index;
    var autoStretchIndex = pe.props["Stretch"]["Auto-Stretch"].index;

    var uStretchIndex = pe.props["Data"]["Stretch data"]["Upper stretch"].index;
    var mStretchIndex = pe.props["Data"]["Stretch data"]["Middle stretch"].index;
    var lStretchIndex = pe.props["Data"]["Stretch data"]["Lower stretch"].index;
    var scaleIndex = pe.props["Data"]["Stretch data"]["Stretch scale"].index;
    var goalPosIndex = pe.props["Data"]["Stretch data"]["Goal position"].index;
    var goalWPosIndex = pe.props["Data"]["Stretch data"]["Goal world position"].index;

    var uLengthIndex = pe.props["Data"]["Lengths"]["Upper length"].index;
    var mLengthIndex = pe.props["Data"]["Lengths"]["Middle length"].index;
    var lLengthIndex = pe.props["Data"]["Lengths"]["Lower length"].index;
    var ikLengthIndex = pe.props["Data"]["Lengths"]["IK length"].index;

    var straightIndex = pe.props["Data"]["Straight"].index;

    var uLayerIndex = pe.props["Data"]["Layers"]["Upper"].index;
    var mLayerIndex = pe.props["Data"]["Layers"]["Middle"].index;
    var lLayerIndex = pe.props["Data"]["Layers"]["Lower"].index;
    var gLayerIndex = pe.props["Data"]["Layers"]["Goal"].index;

    var guidesIndex = pe.props["Display"]["Draw guides"].index;

    // Default values
    effect( guidesIndex ).setValue( showGuides );

    if ( clockwise ) effect( revIndex ).setValue( 1 );

    //set layers
    effect( uLayerIndex ).setValue( layer1.index );
    effect( mLayerIndex ).setValue( layer2.index );
    effect( lLayerIndex ).setValue( layer3.index );
    if ( goal != undefined ) effect( gLayerIndex ).setValue( goal.index );

    //set lengths
    effect( uLengthIndex ).setValue( upperLength );
    effect( mLengthIndex ).setValue( middleLength );
    effect( lLengthIndex ).setValue( lowerLength );

    //get some useful coordinates
    var goalPos = [ 0, 0 ];
    if ( goal != null )
    {
        goalPos = goal.transform.position.value;
    }
    else
    {
        effect( goalPosIndex ).expression = "thisComp.layer(" + layer3.index + ").fromWorld( thisComp.layer(" + controller.index + ").position)";
        goalPos = effect( goalPosIndex ).value;
        effect( goalPosIndex ).expression = "";
    }
    var goalPosProp = new DuAEProperty( effect( goalPosIndex ) );
    goalPosProp.setValue( goalPos );
    var rootAp = layer1.transform.anchorPoint.value.toSource();
    var middleAp = layer2.transform.anchorPoint.value.toSource();
    var lowerAp = layer3.transform.anchorPoint.value.toSource();
    var middlePos = layer2.transform.position.value.toSource();
    var lowerPos = layer3.transform.position.value.toSource();

    //add expressions
    effect( uStretchIndex ).expression = [DuAEExpression.Id.THREE_IK,
        'var fx = effect("' + effect.name + '");',
        'var layer1 = null;',
        'var layer2 = null;',
        'var result = 0;',
        'try { layer1 = fx(' + uLayerIndex + ');layer2=fx(' + mLayerIndex + ');}catch(e){}',
        'if (layer1!=null)',
        '{',
        '   var newLength = length(layer1.toWorld(layer1.anchorPoint),layer2.toWorld(layer2.anchorPoint));',
        '   result = newLength - fx(' + uLengthIndex + ').value;',
        '}',
        'result;'
    ].join('\n');

    effect( mStretchIndex ).expression = [DuAEExpression.Id.THREE_IK,
        'var fx = effect("' + effect.name + '");',
        'var layer2 = null;',
        'var layer3 = null;',
        'var result = 0;',
        'try { layer3 = fx(' + lLayerIndex + '); layer2=fx(' + mLayerIndex + '); }catch (e) {}',
        'if (layer3!=null)',
        '{',
        '   var newLength = length( layer2.toWorld( layer2.anchorPoint ), layer3.toWorld( layer3.anchorPoint ) );',
        '   result = newLength - fx(' + mLengthIndex + ').value;',
        '}',
        'result;'
    ].join('\n');

    effect( lStretchIndex ).expression = [DuAEExpression.Id.THREE_IK,
        'var fx = effect("' + effect.name + '");',
        'var layer3 = null;',
        'var result = 0;',
        'try{ layer3=fx(' + lLayerIndex + '); }catch (e) {}',
        'if (layer3!=null)',
        '{',
        '   var newLength = length( fx(' + goalWPosIndex + ').value , layer3.toWorld(layer3.anchorPoint));',
        '   result = newLength - fx(' + lLengthIndex + ').value;',
        '}',
        'result;'
    ].join('\n');

    effect( scaleIndex ).expression = [DuAEExpression.Id.THREE_IK,
        'var fx = effect("' + effect.name + '");',
        'result = fx(' + uStretchIndex + ').value + fx(' + mStretchIndex + ').value + fx(' + lStretchIndex + ').value;',
        'var o = fx(' + uLengthIndex + ').value + fx(' + mLengthIndex + ').value + fx(' + lLengthIndex + ').value;',
        'result += o;',
        'result = result / o * 100;'
    ].join('\n');

    effect( goalPosIndex ).expression = [DuAEExpression.Id.THREE_IK,
        'var result = value;',
        'var fx = effect("' + effect.name + '");',
        'var layer1 = null;',
        'try { layer1 = fx(' + uLayerIndex + '); } catch (e) {}',
        'if ( layer1 != null )',
        '{',
        '   var stretch = fx(' + stretchIndex + ').value + fx(' + lowerStretchIndex + ');',
        '   var auto = fx(' + autoStretchIndex + ').value;',
        '   var IK = fx(' + ikIndex + ').value;',
        '   IK *= fx(' + weightIndex + ').value/100;',
        '   function getWorldPos(L){',
        '       return L.toWorld(L.anchorPoint);',
        '   }',
        '   var upperAP = ' + rootAp + ';',
        '   var middlePos = ' + middlePos + ';',
        '   var middleAP = ' + middleAp + ';',
        '   var lowerPos = ' + lowerPos + ';',
        '   var lowerAP = ' + lowerAp + ';',
        '   var zeroPos = ' + goalPos.toSource() + ';',
        '   var dist1 = fx(' + uLengthIndex + ');',
        '   var dist2 = fx(' + mLengthIndex + ');',
        '   var dist3 = fx(' + lLengthIndex + ');',
        '   var IKLength = dist1+dist2+dist3;',
        '   var IKStretched = IKLength+stretch;',
        '   var boneStretch = 0;',
        '   var proportion = dist3/(IKLength);',
        '   var posC = toWorld(anchorPoint);',
        '   var posR = getWorldPos(layer1);',
        '   var distC = length(posC,posR);',
        '   if (distC > IKStretched && auto) boneStretch += ((distC-IKLength)*proportion)*IK;',
        '   else boneStretch += stretch*proportion;',
        '   var coef = 1;',
        '   dist3 != 0 ? coef = (dist3+boneStretch)/dist3 : coef = 1;',
        '   result = (middlePos-upperAP)*coef+upperAP;',
        '}',
        'result;'
    ].join('\n');

    effect( goalWPosIndex ).expression = [DuAEExpression.Id.THREE_IK,
        'var fx = effect("' + effect.name + '");',
        'var layer3 = null;',
        'var result = [0,0];',
        'try { layer3 = fx(' + lLayerIndex + '); }catch (e) {}',
        'if ( layer3 != null )',
        '{',
        '   result = layer3.toWorld(fx(' + goalPosIndex + ').value);',
        '}',
        'result;'
    ].join('\n');

    effect( ikLengthIndex ).expression = [DuAEExpression.Id.THREE_IK,
        'var fx = effect("' + effect.name + '");',
        'var result = fx(' + uLengthIndex + ').value + fx(' + mLengthIndex + ').value + fx(' + lLengthIndex + ').value;',
        'var goalPos = fx(' + goalWPosIndex + ').value;',
        'var layer1 = null;',
        'try{ layer1 = fx(' + uLayerIndex + '); } catch(e){}',
        'if (layer1 != null)',
        '{',
        'result = length(layer1.toWorld(layer1.anchorPoint), goalPos);',
        '}',
        'result;'
    ].join('\n');

    effect( straightIndex ).expression = [DuAEExpression.Id.THREE_IK,
        'var fx = effect("' + effect.name + '");',
        'var layer1 = null;',
        'var layer2 = null;',
        'var layer3 = null;',
        'var result = false;',
        'try { layer1 = fx(' + uLayerIndex + '); layer2 = fx(' + mLayerIndex + '); layer3 = fx(' + lLayerIndex + '); } catch (e) {}',
        'if ( layer1 != null )',
        '{',
        '   var a = layer1.toWorld(layer1.anchorPoint);',
        '   var b = layer2.toWorld(layer2.anchorPoint);',
        '   var c = layer3.toWorld(layer3.anchorPoint);',
        '   result = Math.abs(a[0] * (b[1] - c[1]) + b[0] * (c[1] - a[1]) + c[0] * (a[1] - b[1])) < 10 ;',
        '}',
        'result;'
    ].join('\n');

    //add controller visual feedback
    if ( controller instanceof ShapeLayer )
    {
        // Will be null if baked / removed
        var peCtrl = Duik.PseudoEffect.CONTROLLER;
        var ctrlEffect = controller.effect( peCtrl.matchName );
        var iconColorIndex = peCtrl.props["Icon"]["Color"].index;
        var iconSizeIndex = peCtrl.props["Icon"]["Size"].index;
        var iconPosIndex = peCtrl.props["Icon"]["Position"].index;
        var iconOpacityIndex = peCtrl.props["Icon"]["Opacity"].index;

        var ikGroup = controller( "ADBE Root Vectors Group" ).addProperty( "ADBE Vector Group" );
        ikGroup.name = 'IK';
        var ikContent = ikGroup.property( "ADBE Vectors Group" );
        var shape = ikContent.addProperty( "ADBE Vector Shape - Group" );
        var ikShape = new Shape();
        ikShape.vertices = [
            [ -8, 16 ],
            [ 8, 16 ]
        ];
        ikShape.inTangents = [
            [ 0, 0 ],
            [ 0, 0 ]
        ];
        ikShape.outTangents = [
            [ 0, 0 ],
            [ 0, 0 ]
        ];
        ikShape.closed = false;
        shape( 'ADBE Vector Shape' ).setValue( ikShape );
        var stroke = ikContent.addProperty( "ADBE Vector Graphic - Stroke" );

        var ctrlEffect = controller.effect( peCtrl.matchName );

        if (ctrlEffect) stroke( "ADBE Vector Stroke Color" ).expression = DuAEExpression.Id.THREE_IK + '\neffect("' + ctrlEffect.name + '")(' + iconColorIndex + ')-[0.2,0.2,0.2,0]';
        stroke( "ADBE Vector Stroke Width" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Line Cap" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Opacity" ).expression = DuAEExpression.Id.THREE_IK + '\nvar fx = effect("' + effect.name + '");\n' +
            'if (fx(' + guidesIndex + ').value) fx(' + straightIndex + ').value*100; else 0;';

        if (ctrlEffect) ikGroup.transform.scale.expression = DuAEExpression.Id.THREE_IK + '\n[effect("' + ctrlEffect.name + '")(' + iconSizeIndex + ')*2,effect("' + ctrlEffect.name + '")(' + iconSizeIndex + ')*2]';
        if (ctrlEffect) ikGroup.transform.position.expression = DuAEExpression.Id.THREE_IK + '\neffect("' + ctrlEffect.name + '")(' + iconPosIndex + ')';
        if (ctrlEffect) ikGroup.transform.opacity.expression = DuAEExpression.Id.THREE_IK + '\neffect("' + ctrlEffect.name + '")(' + iconOpacityIndex + ') * effect("' + effect.name + '")(' + weightIndex + ').value/100;';

        if ( DuAE.version.version >= 15 )
        {
            var lineGroup = controller( "ADBE Root Vectors Group" ).property( 'IK Line' );
            if ( !lineGroup )
            {
                lineGroup = controller( "ADBE Root Vectors Group" ).addProperty( "ADBE Vector Group" );
                lineGroup.name = 'IK Line';
            }
            lineGroup.transform.opacity.expression = DuAEExpression.Id.THREE_IK + '\neffect("' + effect.name + '")(' + weightIndex + ').value;';
            var lineContent = lineGroup.property( "ADBE Vectors Group" );
            var shape = lineContent.addProperty( "ADBE Vector Shape - Group" );
            shape( 'ADBE Vector Shape' ).expression = DuAEExpression.Id.THREE_IK + '\nif (active){\n' +
                'var fx = effect("' + effect.name + '");\n' +
                'var layer1 = null;\n' +
                'var result = [[0,0]];\n' +
                'if (fx(' + ikIndex + ').value && fx(' + guidesIndex + ').value)\n' +
                '{\n' +
                'try{layer1 = fx(' + uLayerIndex + ');}catch(e){}\n' +
                'if (layer1!=null)\n' +
                '{\n' +
                'var l = layer1.toWorld(layer1.anchorPoint);\n' +
                'l = fromWorld(l);\n' +
                'result = [l,[0,0]];\n' +
                '}\n' +
                '}\n' +
                'createPath(result,[],[],false);\n' +
                '} else value;';
            var stroke = lineContent.property( "ADBE Vector Graphic - Stroke" );
            if ( !stroke ) stroke = lineContent.addProperty( "ADBE Vector Graphic - Stroke" );
            if (ctrlEffect) stroke( "ADBE Vector Stroke Color" ).expression = DuAEExpression.Id.THREE_IK + '\neffect("' + ctrlEffect.name + '")(' + iconColorIndex + ')-[0.2,0.2,0.2,0]';
            stroke( "ADBE Vector Stroke Width" ).setValue( 2 );
            stroke( "ADBE Vector Stroke Line Cap" ).setValue( 2 );
            stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
            stroke( "ADBE Vector Stroke Dashes" )( "ADBE Vector Stroke Dash 1" ).setValue( 5 );
        }
    }

    //setup layers
    var layer1Data = layer1('ADBE Effect Parade').addProperty('ADBE Layer Control');
    layer1Data.name = DuScriptUI.String.IK;
    layer1Data( 1 ).setValue( controller.index );

    layer1.transform.rotation.expression = [DuAEExpression.Id.THREE_IK,
        'var controller = null;',
        'var result = value;',
        'try { controller = effect("' + layer1Data.name + '")(1); }catch (e) {}',
        'if (controller !=null)',
        '{',
        '   var fx = controller.effect("' + effect.name + '");',
        '   var IKFK = fx(' + ikIndex + ').value;',
        '   IKFK *= fx(' + weightIndex + ').value/100;',
        '   var layer1 = thisLayer;\n' +
        '   var layer2 = null',
        '   var layer3 = null;',
        '   try{ layer2 = fx(' + mLayerIndex + '); layer3 = fx(' + lLayerIndex + '); }  catch (e) {}',
        '   if (layer1 != null)',
        '   {',
        '       function ik()',
        '       {',
        '           var endPos = fx(' + goalPosIndex + ').value;',
        '           var cw = fx(' + revIndex + ').value;',
        '           function getWorldPos(layer)',
        '           {',
        '               return layer.toWorld(layer.anchorPoint);',
        '           }',
        '           function sq(result)',
        '           {',
        '               return result*result;',
        '           }',
        '           function getAngle(p1,p2)',
        '           {',
        '               var dist = p2-p1;',
        '               var angle = Math.atan2(dist[1],dist[0]);',
        '               return radiansToDegrees(angle);',
        '           }',
        '           var uPos = getWorldPos(layer1);',
        '           var mPos = getWorldPos(layer2);',
        '           var cPos = getWorldPos(controller);',
        '           var uLength = fx(' + uLengthIndex + ').value',
        '           var mLength = fx(' + mLengthIndex + ').value;',
        '           var lLength = fx(' + lLengthIndex + ').value;',
        '           var ikLength = length(uPos,cPos);',
        '           if (ikLength == 0) ikLength = 1;',
        '           var d1 = sq(mLength) - sq(ikLength) - sq(uLength-lLength);',
        '           var d2 = sq(ikLength) * (uLength+lLength);',
        '           var d3 = -sq(ikLength) * uLength * lLength;',
        '           var d4 = (-d2 - Math.sqrt( sq(d2) - 4*d1*d3 )) / (2*d1);',
        '           var baseA = Math.acos(clamp(ikLength/(2*d4),-1,1));',
        '           var upperA = cw ? -baseA : baseA ;',
        '           upperA = radiansToDegrees(upperA);',
        '           var uToC =getAngle(uPos,cPos);',
        '           var uToM =getAngle(uPos,mPos);',
        '           var ikResult = upperA + uToC - uToM;',
        '           ikResult = ikResult % 360;',
		'           if (ikResult > 180) return ikResult - 360;',
		'           if (ikResult < -180) return ikResult + 360;',
		'           return ikResult;',
        '       }',
        '       function fk()',
        '       {',
        '       var FK = fx(' + uFKIndex + ').value;',
        '       FK += fx(' + overlapIndex + ').value;',
        '       var follow = fx(' + pRotationIndex + ').value;',
        '       var p = thisLayer;',
        '       if (!follow)',
        '       {',
        '           while(p.hasParent)',
        '           {',
        '               p = p.parent;',
        '               FK -= p.rotation.value;',
        '           }',
        '       }',
        '       return FK;',
        '   }',
        '   result += ik()*IKFK + fk()*(1-IKFK);',
        '   }',
        '}',
        'result;'
    ].join('\n');

    var layer2Data = layer2('ADBE Effect Parade').addProperty('ADBE Layer Control');
    layer2Data.name = DuScriptUI.String.IK;
    layer2Data( 1 ).setValue( controller.index );

    layer2.transform.rotation.expression = [DuAEExpression.Id.THREE_IK,
        'var controller = null;',
        'var result = value;',
        'try { controller = effect("' + layer2Data.name + '")(1); }catch (e) {}',
        'if (controller !=null)',
        '{',
        '   var fx = controller.effect("' + effect.name + '");',
        '   var IKFK = fx(' + ikIndex + ').value;',
        '   IKFK *= fx(' + weightIndex + ').value/100;',
        '   var layer1 = null;',
        '   var layer2 = thisLayer;',
        '   var layer3 = null;',
        '   try{ layer1 = fx(' + uLayerIndex + '); layer3 = fx(' + lLayerIndex + '); }  catch (e) {}',
        '   if (layer1 != null)',
        '   {',
        '       function ik()',
        '       {',
        '           var endPos = fx(' + goalPosIndex + ').value;',
        '           cw = fx(' + revIndex + ').value;',
        '           function getWorldPos(layer)',
        '           {',
        '               return layer.toWorld(layer.anchorPoint);',
        '           }',
        '           function sq(result)',
        '           {',
        '               return result*result;',
        '           }',
        '           function getAngle(p1,p2)',
        '           {',
        '               var dist = p2-p1;',
        '               var angle = Math.atan2(dist[1],dist[0]);',
        '               return radiansToDegrees(angle);',
        '           }',
        '           var uPos = getWorldPos(layer1);',
        '           var mPos = getWorldPos(layer2);',
        '           var lPos = getWorldPos(layer3);',
        '           var cPos = getWorldPos(controller);',
        '           var uLength = fx(' + uLengthIndex + ').value',
        '           var mLength = fx(' + mLengthIndex + ').value;',
        '           var lLength = fx(' + lLengthIndex + ').value;',
        '           var ikLength = length(uPos,cPos);',
        '           if (ikLength == 0) ikLength = 1;',
        '           var d1 = sq(mLength) - sq(ikLength) - sq(uLength-lLength);',
        '           var d2 = sq(ikLength) * (uLength+lLength);',
        '           var d3 = -sq(ikLength) * uLength * lLength;',
        '           var d4 = (-d2 - Math.sqrt( sq(d2) - 4*d1*d3 )) / (2*d1);',
        '           var baseA = Math.acos(clamp(ikLength/(2*d4),-1,1));',
        '           var d5 = Math.sqrt( sq(ikLength) + sq(lLength) - 2*ikLength*lLength*Math.cos(baseA));',
        '           var middleA = Math.acos(clamp((sq(d5)-sq(uLength)-sq(mLength)) / (-2*uLength*mLength),-1,1));',
        '           middleA = cw ? -middleA : middleA ;',
        '           middleA = radiansToDegrees(middleA);',
        '           var uToM =getAngle(uPos,mPos);',
        '           var mToL =getAngle(mPos,lPos);',
        '           var ikResult = middleA + uToM - mToL +180;',
        '           ikResult = ikResult % 360;',
		'           if (ikResult > 180) return ikResult - 360;',
		'           if (ikResult < -180) return ikResult + 360;',
		'           return ikResult;',
        '       }',
        '       function fk()',
        '       {',
        '           var ctrlRot = fx(' + overlapIndex + ');',
        '           var delay = fx(' + resistanceIndex + ').value;',
        '           var amp = fx(' + flexibilityIndex + ').value;',
        '           var manual = fx(' + mFKIndex + ').value;',
        '           var follow = fx(' + pRotationIndex + ').value;',
        '           var ftEnabled = fx(' + overlapIndex + ').value;',
        '           if (!ftEnabled)',
        '           {',
        '               amp = 0;',
        '               delay = 0;',
        '           }',
        '           else',
        '           {',
        '               delay = delay / 100;',
        '               amp = amp / 100 ;',
        '           }',
        '           var FK = ctrlRot.valueAtTime(time-delay);',
        '           if (follow && hasParent)',
        '           {',
        '               var cP = parent;',
        '               while(cP.hasParent)',
        '               {',
        '                   cP = cP.parent;',
        '                   if (cP.index = controller.index) follow = false;',
        '                   FK -= cP.rotation.value - cP.rotation.valueAtTime(time-delay);',
        '               }',
        '           }',
        '           FK = FK - ctrlRot.value ;',
        '           FK = FK * amp;',
        '           FK = FK - ctrlRot.velocity*(delay/5);',
        '           if (follow) FK -= parent.transform.rotation.valueAtTime(0);',
        '           FK += manual;',
        '           return FK;',
        '       }',
        '       result += ik()*IKFK + fk()*(1-IKFK);',
        '   }',
        '}',
        'result;'
    ].join('\n');

    layer2.transform.position.expression = [DuAEExpression.Id.THREE_IK,
        'var controller = null;',
        'var result = value;',
        'try { controller = effect("' + layer2Data.name + '")(1); } catch (e){ value };',
        'if (controller != null)',
        '{',
        '   var fx = controller.effect("' + effect.name + '");',
        '   var layer1 = null;',
        '   try{ layer1 = fx(' + uLayerIndex + '); }catch (e) {}',
        '   if (layer1 != null)',
        '   {',
        '       var stretch = fx(' + stretchIndex + ').value + fx(' + upperStretchIndex + ');',
        '       var auto = fx(' + autoStretchIndex + ').value;',
        '       var IK = fx(' + ikIndex + ').value;',
        '       IK *= fx(' + weightIndex + ').value/100;',
        '       function getWorldPos(L){',
        '           return L.toWorld(L.anchorPoint);',
        '       }',
        '       var upperAP = ' + rootAp + ';',
        '       var middlePos = ' + middlePos + ';',
        '       var middleAP = ' + middleAp + ';',
        '       var lowerPos = ' + lowerPos + ';',
        '       var lowerAP = ' + lowerAp + ';',
        '       var zeroPos = ' + goalPos.toSource() + ';',
        '       var dist1 = length(upperAP,middlePos);',
        '       var dist2 = length(middleAP,lowerPos);',
        '       var dist3 = length(lowerAP,zeroPos);',
        '       var IKLength = dist1+dist2+dist3;',
        '       var IKStretched = IKLength+stretch;',
        '       var boneStretch = 0;',
        '       var proportion = dist1/(IKLength);',
        '       var posC = getWorldPos(controller);',
        '       var posR = getWorldPos(layer1);',
        '       var distC = length(posC,posR);',
        '       if (distC > IKStretched && auto) boneStretch += ((distC-IKLength)*proportion)*IK;',
        '       else boneStretch += stretch*proportion;',
        '       coef = 1;',
        '       dist1 != 0 ? coef = (dist1+boneStretch)/dist1 : coef = 1;',
        '       result = (middlePos-upperAP)*coef+upperAP;',
        '   }',
        '}',
        'result;'
    ].join('\n');


    var layer3Data = layer3('ADBE Effect Parade').addProperty('ADBE Layer Control');
    layer3Data.name = DuScriptUI.String.IK;
    layer3Data( 1 ).setValue( controller.index );

    layer3.transform.rotation.expression = [DuAEExpression.Id.THREE_IK,
        'var controller = null;',
        'var result = value;',
        'try { controller = effect("' + layer3Data.name + '")(1); }catch (e) {}',
        'if ( controller != null)',
        '{',
        '   var fx = controller.effect("' + effect.name + '");',
        '   var IKFK = fx(' + ikIndex + ').value;',
        '   IKFK *= fx(' + weightIndex + ').value/100;',
        '   var layer1 = null;',
        '   var layer2 = null;',
        '   var layer3 = thisLayer;',
        '   try{ layer1 = fx(' + uLayerIndex + '); layer2 = fx(' + mLayerIndex + '); }  catch (e) {}',
        '   if (layer1 != null)',
        '   {',
        '       function ik()',
        '       {',
        '           var endPos = fx(' + goalPosIndex + ').value;',
        '           var cw = fx(' + revIndex + ').value;',
        '           function getWorldPos(layer)',
        '           {',
        '               return layer.toWorld(layer.anchorPoint);',
        '           }',
        '           function sq(result)',
        '           {',
        '               return result*result;',
        '           }',
        '           function getAngle(p1,p2)',
        '           {',
        '               var dist = p2-p1;',
        '               var angle = Math.atan2(dist[1],dist[0]);',
        '               return radiansToDegrees(angle);',
        '           }',
        '           var uPos = getWorldPos(layer1);',
        '           var mPos = getWorldPos(layer2);',
        '           var lPos = getWorldPos(layer3);',
        '           var zPos = fx(' + goalWPosIndex + ').value;',
        '           var cPos = getWorldPos(controller);',
        '           var uLength = fx(' + uLengthIndex + ').value',
        '           var mLength = fx(' + mLengthIndex + ').value;',
        '           var lLength = fx(' + lLengthIndex + ').value;',
        '           var ikLength = length(uPos,cPos);',
        '           if (ikLength == 0) ikLength = 1;',
        '           var d1 = sq(mLength) - sq(ikLength) - sq(uLength-lLength);',
        '           var d2 = sq(ikLength) * (uLength+lLength);',
        '           var d3 = -sq(ikLength) * uLength * lLength;',
        '           var d4 = (-d2 - Math.sqrt( sq(d2) - 4*d1*d3 )) / (2*d1);',
        '           var baseA = Math.acos(clamp(ikLength/(2*d4),-1,1));',
        '           var d6 = Math.sqrt( sq(ikLength) + sq(uLength) - 2*ikLength*uLength*Math.cos(baseA));',
        '           var lowerA = Math.acos(clamp((sq(d6) - sq(lLength) - sq(mLength)) / (-2*lLength*mLength),-1,1));',
        '           lowerA = cw ? -lowerA : lowerA;',
        '           lowerA = radiansToDegrees(lowerA);',
        '           var mToL =getAngle(mPos,lPos);',
        '           var lToZ =getAngle(lPos,zPos);',
        '           var ikResult = lowerA + mToL - lToZ +180;',
        '           ikResult = ikResult % 360;',
		'           if (ikResult > 180) return ikResult - 360;',
		'           if (ikResult < -180) return ikResult + 360;',
		'           return ikResult;',
        '       }',
        '       function fk()',
        '       {',
        '           var parentRot = parent.transform.rotation;',
        '           var ctrlRot = fx(' + overlapIndex + ');',
        '           var delay = fx(' + resistanceIndex + ').value;',
        '           var amp = fx(' + flexibilityIndex + ').value;',
        '           var manual = fx(' + lFKIndex + ').value;',
        '           var follow = fx(' + pRotationIndex + ').value;',
        '           var ftEnabled = fx(' + overlapIndex + ').value;',
        '           if (!ftEnabled)',
        '           {',
        '               amp = 0;',
        '               delay = 0;',
        '           }',
        '           else',
        '           {',
        '               delay = delay / 100;',
        '               amp = amp / 100 ;',
        '           }',
        '           var FK = parentRot.valueAtTime(time-delay);',
        '           FK = FK * amp;',
        '           FK = FK + manual - parentRot.valueAtTime(0);',
        '           return FK;',
        '       }',
        '       result += ik()*IKFK + fk()*(1-IKFK);',
        '   }',
        '}',
        'result;'
    ].join('\n');

    layer3.transform.position.expression = [DuAEExpression.Id.THREE_IK,
        'var controller = null;',
        'var result = value;',
        'try { controller = effect("' + layer3Data.name + '")(1); } catch (e) { };',
        'if (controller != null)',
        '{',
        '   var fx = controller.effect("' + effect.name + '");',
        '   var layer1 = null;',
        '   try{ layer1 = fx(' + uLayerIndex + ')}catch(e){}',
        '   if (layer1 != null)',
        '   {',
        '       var stretch = fx(' + stretchIndex + ').value + fx(' + middleStretchIndex + ');',
        '       var auto = fx(' + autoStretchIndex + ').value;',
        '       var IK = fx(' + ikIndex + ').value;',
        '       IK *= fx(' + weightIndex + ').value/100;',
        '       function getWorldPos(L) {',
        '           return L.toWorld(L.anchorPoint);',
        '       }',
        '       var upperAP = ' + rootAp + ';',
        '       var middlePos = ' + middlePos + ';',
        '       var middleAP = ' + middleAp + ';',
        '       var lowerPos = ' + lowerPos + ';',
        '       var lowerAP = ' + lowerAp + ';',
        '       var zeroPos = ' + goalPos.toSource() + ';',
        '       var dist1 = length(upperAP,middlePos);',
        '       var dist2 = length(middleAP,lowerPos);',
        '       var dist3 = length(lowerAP,zeroPos);',
        '       var IKLength = dist1+dist2+dist3;',
        '       var IKStretched = IKLength+stretch;',
        '       var boneStretch = 0;',
        '       var proportion = dist2/(IKLength);',
        '       var posC = getWorldPos(controller);',
        '       var posR = getWorldPos(layer1);',
        '       var distC = length(posC,posR);',
        '       if (distC > IKStretched && auto) boneStretch += ((distC-IKLength)*proportion)*IK;',
        '       else boneStretch += stretch*proportion;',
        '       var coef = 1;',
        '       dist2 != 0 ? coef = (dist2+boneStretch)/dist2 : coef = 1;',
        '       result = (middlePos-upperAP)*coef+upperAP;',
        '   }',
        '}',
        'result;'
    ].join('\n');

    if ( goal != null )
    {
        var goalData = goal('ADBE Effect Parade').addProperty('ADBE Layer Control');
        goalData.name = DuScriptUI.String.IK;
        goalData( 1 ).setValue( controller.index );

        var rotExpr = [DuAEExpression.Id.THREE_IK,
            'var ctrl = null;',
            'var result = value;',
            'try { ctrl = effect("' + goalData.name + '")(1); } catch (e){};',
            'if (ctrl != null)',
            '{',
            '   var fx = ctrl.effect("' + effect.name + '");',
            '   var IKFK = fx(' + ikIndex + ').value;',
            '   function ik()',
            '   {',
            '       var layer = thisLayer;',
            '       var IK = 0;',
            '       while (layer.hasParent)',
            '       {',
            '           layer = layer.parent;',
            '           IK = IK - layer.rotation;',
            '       }',
            '       return IK;',
            '   }',
            '   function fk()',
            '   {',
            '       var parentRot = parent.transform.rotation ;',
            '       var ctrlRot = fx(' + overlapIndex + ');',
            '       var delay = fx(' + resistanceIndex + ').value;',
            '       var amp = fx(' + flexibilityIndex + ').value;',
            '       var ftEnabled = fx(' + overlapIndex + ').value;',
            '       var manual = fx(' + endFKIndex + ').value;',
            '       var follow = fx(' + pRotationIndex + ').value;',
            '       if (!ftEnabled)',
            '       {',
            '           amp = 0;',
            '           delay = 0;',
            '       }',
            '       else',
            '       {',
            '           delay = delay / 100;',
            '           amp = amp / 100 ;',
            '       }',
            '       var FK = parentRot.valueAtTime(time-delay);',
            '       FK = FK * amp;',
            '       FK = FK + manual - parent.transform.rotation.valueAtTime(0);',
            '       return FK;',
            '   }',
            '   IKFK ? result += ik() : result += fk();',
            '}',
            'result;'
        ].join('\n');

        var rotProp = new DuAEProperty( goal.transform.rotation );
        rotProp.setExpression( rotExpr );

        goal.transform.position.expression = [DuAEExpression.Id.THREE_IK,
            'var ctrl = null;',
            'var result = value;',
            'try { ctrl = effect("' + goalData.name + '")(1); } catch (e){ value };',
            'if (ctrl != null)',
            '{',
            '   result = ctrl.effect("' + effect.name + '")(' + goalPosIndex + ').value;',
            '}',
            'result;'
        ].join('\n');
    }

    return controller;
}

/**
 * Creates a 1+2-layer-ik on the layer
 * @param {Layer} layer1 - The root layer
 * @param {Layer} layer2 - The middle layer
 * @param {Layer} layer3 - The end layer
 * @param {Layer|null} [goal] - The goal layer, at the end of the IK
 * @param {Layer|null} [controller] - The layer to use as a controller, can be automatically created.<br />
 * Must be provided if goal is undefined
 * @param {Boolean} [showGuides=true] - Set to false to hide guides on the controllers (and improve performance)
 * @return {Layer} The controller created
 */
Duik.Constraint.oneTwoLayerIK = function ( layer1, layer2, layer3, goal, controller, showGuides )
{
    controller = Duik.Constraint.twoLayerIK( layer2, layer3, goal, controller, showGuides );
    Duik.Constraint.oneLayerIK( layer1, goal, controller, showGuides );
    var pe = Duik.PseudoEffect.ONE_LAYER_IK;
    controller.effect( pe.matchName )( pe.props["Weight"].index ).setValue( 50 );
    controller.effect( pe.matchName )( pe.props["Limits"]["Softness"].index ).setValue( 160 );
    return controller;
}

/**
 * Creates a 1+2-layer-ik on the layer
 * @param {Layer} layer1 - The root layer
 * @param {Layer} layer2 - The middle layer
 * @param {Layer} layer3 - The end layer
 * @param {Layer|null} [goal] - The goal layer, at the end of the IK
 * @param {Layer|null} [controller] - The layer to use as a controller, can be automatically created.<br />
 * Must be provided if goal is undefined
 * @param {Boolean} [showGuides=true] - Set to false to hide guides on the controllers (and improve performance)
 * @return {Layer} The controller created
 */
Duik.Constraint.twoOneLayerIK = function ( layer1, layer2, layer3, goal, controller, showGuides )
{
    var comp = layer1.containingComp;
    goal = def(goal, null);
    controller = def(controller, null);
    if ( controller == null && goal == null ) throw "You must provide either a goal layer or a controller";
    // Null for the IK
    var n = DuAEComp.addNull(comp, 20);
    if (typeof goal !== 'undefined') Duik.Layer.copyAttributes( n, goal, Duik.Layer.Type.IK );
    else Duik.Layer.copyAttributes( n, layer3, Duik.Layer.Type.IK );
    // Move it to the third layer
    layer3.parent = null;
    n.transform.position.setValue( layer3.transform.position.value );
    n.moveBefore( layer3 );
    layer3.parent = layer2;
    // Create a 2-layer IK
    Duik.Constraint.twoLayerIK( layer1, layer2, undefined, n, showGuides );
    // Create a 1-layer IK
    // Create controller
    if ( controller == null )
    {
        controller = Duik.Controller.create( comp,  Duik.Controller.Type.TRANSFORM, goal );
    }
    Duik.Constraint.oneLayerIK( layer3, goal, controller, showGuides );
    // Move the 2-layer effect to the controller
    var pe = Duik.PseudoEffect.TWO_LAYER_IK;
    var newEffect = pe.apply(controller);
    var oldEffect = n.effect(pe.matchName);
    if (oldEffect) 
    {
        var oldEffectProp = new DuAEProperty(oldEffect);
        // Set side
        var sideIndex = pe.props["Side"].index;
        newEffect( sideIndex ).setValue ( oldEffect(sideIndex).value );
        oldEffectProp.linkProperties(newEffect, true);
    }
    // fix goal
    if (goal)
    {
        var goalAngleEffect = controller('ADBE Effect Parade').addProperty('ADBE Angle Control');
        goalAngleEffect.name = DuScriptUI.String.TIP_ANGLE;
        var ikEffect = controller.effect( Duik.PseudoEffect.ONE_LAYER_IK.matchName) ;
        var layerEffect = DuAELayer.lastEffect( goal, 'ADBE Layer Control' );

        var rotProp = new DuAEProperty( goal.transform.rotation );
        rotProp.setExpression( [DuAEExpression.Id.TWO_ONE_IK,
            'var ctrl = null;',
            'var result = value;',
            'try { ctrl = effect("' + layerEffect.name + '")(1); } catch (e){ value };',
            'if (ctrl != null)',
            '{',
            '   var goal = ctrl.effect("' + ikEffect.name + '")(1).value;',
            '   if (goal)',
            '   {',
            '       result -= ctrl.rotation.value;',
            '       result += ctrl.effect("' + goalAngleEffect.name + '")(1).value;',
            '   }',
            '}',
            'result;'
            ].join('\n')
        );
    }
    //parent
    n.parent = controller;
    //hide & lock
    n.enabled = false;
    n.locked = true;

    return controller;
}

/**
 * Creates a bezier ik on the layers
 * @param {Layer[]|DuList.<Layer>} layers - The layers, ordered from root to end
 * @param {Layer|null} [goal] - The goal layer, at the end of the IK
 * @param {Layer|null} [controller] - The layer to use as controller, can be automatically created.<br />
 * Must be provided if goal is undefined.
 * @param {Boolean} [showGuides=true] - Set to false to hide guides on the controllers (and improve performance)
 * @return {Layer[]} The controllers [curve,end,root]
 */
Duik.Constraint.bezierIK = function( layers, goal, controller, showGuides )
{
    goal = def(goal, null);
    controller = def(controller, null);
    if ( controller == null && goal == null ) throw "You must provide either a goal layer or a controller";

    showGuides = def( showGuides, 1 );
    if (!showGuides) showGuides = 0;

    DuAE.beginUndoGroup( DuScriptUI.String.BEZIER_IK, false);

    layers = new DuList(layers);
    var comp = layers.first().containingComp;

    //create controllers
    if ( controller == null )
    {
        controller = Duik.Controller.create( comp,  Duik.Controller.Type.TRANSFORM, goal );
        goal.parent = null;
        controller.transform.rotation.setValue( goal.transform.rotation.value );
    }

    if ( goal != null ) goal.parent = controller;

    //add effect
    var name = Duik.Layer.limbName( layers.first() );
    var pe = Duik.PseudoEffect.BEZIER_IK;
    var effect = pe.apply( controller, DuScriptUI.String.IK + ' | ' + name );

    var limbName = Duik.Layer.limbName( layers.first() );

    //create curve controller
    var curveController = Duik.Controller.create( comp,  Duik.Controller.Type.POSITION, goal );
    curveController.transform.scale.expression = '';
    curveController.name = curveController.name + "_Curve";
    Duik.Layer.setLimbName( limbName + '_Curve', curveController );
    Duik.Controller.setSize( 50, curveController);

    //create root controller
    var rootController = Duik.Controller.create( comp,  Duik.Controller.Type.POSITION, layers.first() );
    rootController.name = rootController.name + "_Root";
    Duik.Layer.setLimbName( limbName + '_Root', rootController );
    Duik.Controller.setSize( 50, rootController);

    //add effect
    var cPe = Duik.PseudoEffect.BEZIER_IK_CURVE;
    var curveEffect = cPe.apply( curveController );
    curveEffect( cPe.props["Controllers"]["Root"].index ).setValue( rootController.index );
    curveEffect( cPe.props["Controllers"]["Curve"].index ).setValue( curveController.index );
    curveEffect( cPe.props["Controllers"]["End"].index ).setValue( controller.index );
    curveEffect( cPe.props["Draw guides"].index ).setValue( showGuides );

    //useful positions
    var endPosition = DuAELayer.getWorldPos( controller );
    if ( goal != null ) endPosition = DuAELayer.getWorldPos( goal );
    var rootPosition = DuAELayer.getWorldPos( layers.first() );
    curveController.transform.position.setValue( ( endPosition + rootPosition ) / 2 );
    var cOutPosition = ( 2 * endPosition + rootPosition ) / 3;
    var cInPosition = ( endPosition + 2 * rootPosition ) / 3;

    //add handles
    var handleInGroup = curveController( "ADBE Root Vectors Group" ).addProperty( "ADBE Vector Group" );
    handleInGroup.name = 'Handle In';
    handleInContent = handleInGroup.property( "ADBE Vectors Group" );
    var circle = handleInContent.addProperty( "ADBE Vector Shape - Ellipse" );
    circle( "ADBE Vector Ellipse Size" ).setValue( [ 25, 25 ] );
    var fill = handleInContent.addProperty( "ADBE Vector Graphic - Fill" );

    var ctrlPe = Duik.PseudoEffect.CONTROLLER;

    var ctrlEffect = curveController.effect( ctrlPe.matchName );
    var iconColorIndex = ctrlPe.props["Icon"]["Color"].index;
    var iconSizeIndex = ctrlPe.props["Icon"]["Size"].index;

    if (ctrlEffect) fill( "ADBE Vector Fill Color" ).expression = DuAEExpression.Id.CONTROLLER + '\neffect("' + ctrlEffect.name + '")(' + iconColorIndex + ')-[0.2,0.2,0.2,0]\n';
    else fill( "ADBE Vector Fill Color" ).setValue( DuColor.Color.APP_HIGHLIGHT_COLOR.darker(150).floatRGBA() );
    if (ctrlEffect) handleInGroup.transform.scale.expression = DuAEExpression.Id.CONTROLLER + '\n[effect("' + ctrlEffect.name + '")(' + iconSizeIndex + '),effect("' + ctrlEffect.name + '")(' + iconSizeIndex + ')]';

    handleInGroup.transform.position.expression = [DuAEExpression.Id.BEZIER_IK,
        'var fx = effect("' + curveEffect.name + '");',
        'var root = null;',
        'var curve = thisLayer;',
        'var result = value;',
        'try { root = fx(' + cPe.props["Controllers"]["Root"].index + ') ;} catch(e){}',
        'if (root != null)',
        '{',
        '   var rootPos = root.toWorld(root.anchorPoint);',
        '   rootPos = fromWorld(rootPos);',
        '   result += rootPos/2;',
        '}',
        'result;'
    ].join('\n');
    //Auto handle position disabled as it messes up the order of the evaluation of the expressions
    //DuAEF.DuAE.Property.removeExpression(handleInGroup.transform.position);

    handleInGroup.transform.opacity.expression = DuAEExpression.Id.BEZIER_IK + '\nvar fx = effect("' + curveEffect.name + '");\n' +
        'fx(' + cPe.props["Show handles"].index + ').value * 100;';

    var handleOutGroup = curveController( "ADBE Root Vectors Group" ).addProperty( "ADBE Vector Group" );
    handleOutGroup.name = 'Handle Out';
    handleOutContent = handleOutGroup.property( "ADBE Vectors Group" );
    var circle = handleOutContent.addProperty( "ADBE Vector Shape - Ellipse" );
    circle( "ADBE Vector Ellipse Size" ).setValue( [ 25, 25 ] );
    var fill = handleOutContent.addProperty( "ADBE Vector Graphic - Fill" );
    if (ctrlEffect) fill( "ADBE Vector Fill Color" ).expression = DuAEExpression.Id.CONTROLLER + '\neffect("' + ctrlEffect.name + '")(' + iconColorIndex + ')-[0.2,0.2,0.2,0]\n';
    else fill( "ADBE Vector Fill Color" ).setValue( DuColor.Color.APP_HIGHLIGHT_COLOR.darker(150).floatRGBA() );
    if (ctrlEffect) handleOutGroup.transform.scale.expression = DuAEExpression.Id.CONTROLLER + '\n[effect("' + ctrlEffect.name + '")(' + iconSizeIndex + '),effect("' + ctrlEffect.name + '")(' + iconSizeIndex + ')]';

    handleOutGroup.transform.position.expression = [DuAEExpression.Id.BEZIER_IK,
        'var fx = effect("' + curveEffect.name + '");',
        'var end = null;',
        'var curve = thisLayer;',
        'var result = value;',
        'try { end = fx(' + cPe.props["Controllers"]["End"].index + '); } catch(e){}',
        'if (end != null)',
        '{',
        '   var endPos = end.toWorld(end.anchorPoint);',
        '   endPos = fromWorld(endPos);',
        '   result += endPos/2;',
        '}',
        'result;'
    ].join('\n');
    //Auto handle position disabled as it mess up the order of the evaluation of the expressions
    //DuAEF.DuAE.Property.removeExpression(handleOutGroup.transform.position);

    handleOutGroup.transform.opacity.expression = DuAEExpression.Id.BEZIER_IK + '\nvar fx = effect("' + curveEffect.name + '");\n' +
        'fx(' + cPe.props["Show handles"].index + ').value * 100;';

    //add line
    if ( DuAE.version.version >= 15 )
    {
        var lineGroup = curveController( "ADBE Root Vectors Group" ).addProperty( "ADBE Vector Group" );
        lineGroup.name = 'IK Line';
        var lineContent = lineGroup.property( "ADBE Vectors Group" );
        var shape = lineContent.addProperty( "ADBE Vector Shape - Group" );
        shape( 'ADBE Vector Shape' ).expression = [DuAEExpression.Id.BEZIER_IK,
            'var fx = effect("' + curveEffect.name + '");',
            'var root = null;',
            'var curve = thisLayer;',
            'var end = null;',
            'var result = [[0,0]];',
            'if (fx(' + cPe.props["Draw guides"].index + ').value)',
            '{',
            '   try { root = fx(' + cPe.props["Controllers"]["Root"].index + '); end = fx(' + cPe.props["Controllers"]["End"].index + ') } catch(e){}',
            '   if (root != null)',
            '   {',
            '       var r = root.toWorld(root.anchorPoint);',
            '       r = fromWorld(r);',
            '       var e = end.toWorld(end.anchorPoint);',
            '       e = fromWorld(e);',
            '       var t1 = content("Handle In").transform.position;',
            '       var t2 = content("Handle Out").transform.position;',
            '       result = [r,t1,t2,e];',
            '   }',
            '}',
            'createPath(result,[],[],false);'
        ].join('\n');

        var stroke = lineContent.addProperty( "ADBE Vector Graphic - Stroke" );
        if (ctrlEffect) stroke( "ADBE Vector Stroke Color" ).expression = DuAEExpression.Id.CONTROLLER + '\neffect("' + ctrlEffect.name + '")(' + iconColorIndex + ')-[0.2,0.2,0.2,0]\n';
        else stroke( "ADBE Vector Stroke Color" ).setValue( DuColor.Color.APP_HIGHLIGHT_COLOR.darker(150).floatRGBA() );
        stroke( "ADBE Vector Stroke Width" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Line Cap" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
        stroke( "ADBE Vector Stroke Dashes" )( "ADBE Vector Stroke Dash 1" ).setValue( 5 );
    }

    //close controller details
    curveController.selected = true;
    DuAE.executeCommand( DuAE.MenuCommandID.REVEAL_EXPRESSION_ERRORS, true );

    //setup layers
    var rootIndex = rootController.index;
    var endIndex = controller.index;
    var curveIndex = curveController.index;
    var totalLength = DuMath.length( rootPosition, cInPosition ) + DuMath.length( cOutPosition, cInPosition ) + DuMath.length( cOutPosition, endPosition );

    //un-parent
    for ( var i = 0, n = layers.length(); i < n; i++ )
    {
        layers.at(i).parent = null;
    }

    layers.first().parent = rootController;

    var lPe = Duik.PseudoEffect.BEZIER_IK_LAYER

    for ( var i = 0, n = layers.length(); i < n; i++ )
    {
        var layer = layers.at(i);
        //add effect
        var layerEffect = lPe.apply( layer );
        layerEffect( lPe.props["Layers"]["Root"].index ).setValue( rootIndex );
        layerEffect( lPe.props["Layers"]["Curve"].index ).setValue( curveIndex );
        layerEffect( lPe.props["Layers"]["End"].index ).setValue( endIndex );
        if ( i < layers.length() - 1 ) layerEffect( lPe.props["Layers"]["Next"].index ).setValue( layers.at( i + 1 ).index );
        else layerEffect( lPe.props["Layers"]["Next"].index ).setValue( controller.index );

        //expressions

        //position
        if ( i != 0 )
        {
            var index = DuMath.length( endPosition, layer.transform.position.value );
            index = index / totalLength;
            var expression = [DuAEExpression.Id.BEZIER_IK,
                'var end = null;',
                'var root = null;',
                'var curve = null;',
                'var result = value;',
                'var thisFx = effect("' + layerEffect.name + '");',
                'try { end = thisFx(' + lPe.props["Layers"]["End"].index + '); curve = thisFx(' + lPe.props["Layers"]["Curve"].index + '); root = thisFx(' + lPe.props["Layers"]["Root"].index + '); }catch (e) {};',
                'if ( root !=null )',
                '{',
                '   var ind = ' + index + ';',
                '   var fx = end.effect("' + effect.name + '");',
                '   var offset = thisFx(' + lPe.props["Offset"].index + ')/100;',
                '   var generalOffset = fx(' + pe.props["Offset"].index + ')/100;',
                '   var endPosition = end.toComp(end.anchorPoint);',
                '   var rootPosition = root.toComp(root.anchorPoint);',
                '   var curvePosition1 = curve.toComp(curve.content("Handle Out").transform.position);',
                '   var curvePosition2 = curve.toComp(curve.content("Handle In").transform.position);',
                '   var t = ind + generalOffset + offset;',
                '   var c = 3*(curvePosition1 - endPosition);',
                '   var b = 3*(curvePosition2 - curvePosition1) - c;',
                '   var a = rootPosition - endPosition - c - b;',
                '   result += ((a*t +b )*t + c)*t + endPosition ;',
                '   result -= ' + layer.transform.position.value.toSource() + ';',
                '}',
                'result;'
            ].join('\n');

            var posProp = new DuAEProperty( layer.transform.position );
           posProp.setExpression( expression );
        }

        //rotation
        var expr = [DuAEExpression.Id.BEZIER_IK,
            'var c = null;',
            'var result = value;',
            'var thisFx = effect("' + layerEffect.name + '");',
            'try{ c = thisFx(' + lPe.props["Layers"]["End"].index + ') }catch (e) {}',
            'if ( c!=null )',
            '{',
            '   var n = c;',
            '   try { n = thisFx(' + lPe.props["Layers"]["Next"].index + '); if (n.index == index) n = c; } catch (e) {}',
            '   var fx = c.effect("' + effect.name + '");',
            '   var autoOrient = fx(' + pe.props["Auto orient"].index + ').value;',
            '   var C = n.toWorld(n.anchorPoint);',
            '   var O =  thisLayer.toWorld(thisLayer.anchorPoint);',
            '   var vec = O-C;',
            '   var angle = Math.atan2(vec[1], vec[0]);',   
            '   var ik = radiansToDegrees(angle);',
            '   if (autoOrient==1) result += ik;'
        ].join('\n');

        if ( i == 0 )
        {
            expr += 'var layer = thisLayer;\n' +
                'while(layer.hasParent)\n' +
                '{\n' +
                'layer = layer.parent;\n' +
                'result -= layer.transform.rotation;\n' +
                '}\n';
        }
        expr += '}\n' +
            'result;';

        var rotProp = new DuAEProperty( layer.transform.rotation );
        rotProp.setExpression( expr );
    }

    curveController.selected = false;
    controller.moveBefore( curveController );

    DuAE.endUndoGroup( DuScriptUI.String.BEZIER_IK);

    return [ curveController, controller, rootController ];
}

Duik.CmdLib['Constraint']["FK"] = "Duik.Constraint.fk()";
/**
 * Creates a FK with auto-overlapping and its controller on the layers.
 * @param {Layer[]|DuList.<Layer>} [layers] - The layers, already parented or ordered from root (at index 0) to end
 * @param {Layer} [controller] - An already existing controller.
 * @return {Layer} The controller of the FK.
 */
Duik.Constraint.fk = function( layers, controller )
{
    controller = def(controller, null);
    layers = def(layers, DuAEComp.unselectLayers());
    layers = new DuList(layers);

    DuAE.beginUndoGroup( DuScriptUI.String.FK, false);

    var comp = layers.first().containingComp;

    //check if there is a controller in the selection
    if ( controller == null )
    {
        for ( var i = 0, num = layers.length(); i < num; i++ )
        {
            var l = layers.at(i);
            if ( Duik.Layer.isType( l, Duik.Layer.Type.CONTROLLER ) )
            {
                controller = l;
                layers.remove( i );
                break;
            }
        }
    }

    //sort layers and parent them
    var layers = DuAELayer.sortByParent( layers );
    layers = new DuList(layers);
    //reset rotation and scale if structures
    layers.do( Duik.Bone.resetTransform );
    DuAELayer.parentChain( layers );

    //Create controller
    if ( controller == null )
    {
        controller = Duik.Controller.create( comp,  Duik.Controller.Type.ROTATION, layers.first() );
    }

    var pe = Duik.PseudoEffect.FK;

    var name = Duik.Layer.limbName( layers.first() );
    var fkEffect = pe.apply( controller );
    fkEffect( pe.props["Limits"]["Lower"].index ).setValue( -180 );
    fkEffect( pe.props["Flexibility"].index ).setValue( 100 );
    fkEffect( pe.props["Resistance"].index ).setValue( 10 );
    var fkEffectName = fkEffect.name;

    //rig layers
    layers.do( function( layer )
    {
        //add Data
        var layerData = layer('ADBE Effect Parade').addProperty('ADBE Layer Control');
        layerData.name = DuScriptUI.String.FK;
        layerData( 1 ).setValue( controller.index );

        //add FK control
        var fkControl = controller( 'ADBE Effect Parade' ).addProperty( 'ADBE Angle Control' );
        fkControl.name = DuScriptUI.String.FK + ' | ' + Duik.Layer.limbName( layer );

        //add expression
        if ( layers.current == 0 )
        {
            layer.transform.rotation.expression = [DuAEExpression.Id.FK,
                'var controller = null;',
                'var result = value;',
                'try { controller = effect("' + layerData.name + '")(1); } catch (e) {}',
                'if ( controller !=null )',
                '{',
                '   var fx = controller.effect("' + fkEffectName + '");',
                '   result += controller.transform.rotation.value + fx(' + pe.props["Curve"].index + ').value;',
                '   var follow = fx(' + pe.props["Parent rotation"].index + ').value;',
                '   var p = thisLayer;',
                '   if (!follow)',
                '   {',
                '       while(p.hasParent)',
                '       {',
                '           p = p.parent;',
                '           result -= p.rotation.value;',
                '       }',
                '   }',
                '   var fk = controller.effect("' + fkControl.name + '")(1).value;',
                '   result += fk;',
                '}',
                'result;'
            ].join('\n');
        }
        else if ( layers.current == 1 )
        {
            layer.transform.rotation.expression = [DuAEExpression.Id.FK,
                'var controller = null;',
                'var result = value;',
                'try { controller=effect("' + layerData.name + '")(1); } catch (e) {}',
                'if (controller !=null && hasParent)',
                '{',
                '   var fx = controller.effect("' + fkEffectName + '");',
                '   var ctrlRot = controller.transform.rotation;',
                '   var delay = fx(' + pe.props["Resistance"].index + ').value;',
                '   var amp = fx(' + pe.props["Flexibility"].index + ').value;',
                '   var uLimit = fx(' + pe.props["Limits"]["Upper"].index + ').value;',
                '   var lLimit = fx(' + pe.props["Limits"]["Lower"].index + ').value;',
                '   var manual = fx(' + pe.props["Curve"].index + ').value;',
                '   var follow = fx(' + pe.props["Parent rotation"].index + ').value;',
                '   delay = delay / 100;',
                '   amp = amp / 100 ;',
                '   result = ctrlRot.valueAtTime(time-delay) + fx(3).valueAtTime(time-delay);',
                '   if (follow && hasParent)',
                '   {',
                '       var cP = parent;',
                '       while(cP.hasParent)',
                '       {',
                '           cP = cP.parent;',
                '           if (cP.index = controller.index) follow = false;',
                '           result -= cP.rotation.value - cP.rotation.valueAtTime(time-delay);',
                '       }',
                '   }',
                '   result = result - ctrlRot.value ;',
                '   result = result * amp;',
                '   result = result - ctrlRot.velocity*(delay/5);',
                '   if (result > uLimit) result = uLimit;',
                '   if (result < lLimit) result = lLimit;',
                '   result = result + value + manual;',
                '   if (follow) result -= parent.transform.rotation.valueAtTime(0);',
                '   var fk = controller.effect("' + fkControl.name + '")(1).value;',
                '   result += fk;',
                '}',
                'result;'
            ].join('\n');
        }
        else
        {
            layer.transform.rotation.expression = [DuAEExpression.Id.FK,
                'var controller = null;',
                'var result = value;',
                'try { controller=effect("' + layerData.name + '")(1); }catch (e) {}',
                'if (controller !=null && hasParent)',
                '{',
                '   var fx = controller.effect("' + fkEffectName + '");',
                '   var ctrlRot = controller.transform.rotation;',
                '   var parentRot = parent.transform.rotation ;',
                '   var delay = fx(' + pe.props["Resistance"].index + ').value;',
                '   var amp = fx(' + pe.props["Flexibility"].index + ').value;',
                '   var uLimit = fx(' + pe.props["Limits"]["Upper"].index + ').value;',
                '   var lLimit = fx(' + pe.props["Limits"]["Lower"].index + ').value;',
                '   var manual = fx(' + pe.props["Curve"].index + ').value;',
                '   delay = delay / 100;',
                '   amp = amp / 100 ;',
                '   result = parentRot.valueAtTime(time-delay);',
                '   result = result * amp;',
                '   if (result > uLimit) result = uLimit;',
                '   if (result < lLimit) result = lLimit;',
                '   result = result + value + manual - parent.transform.rotation.valueAtTime(0);',
                '   var fk = controller.effect("' + fkControl.name + '")(1).value;',
                '   result += fk;',
                '}',
                'result;'
            ].join('\n');
        }
    } );

    controller.selected = true;

    DuAE.endUndoGroup( DuScriptUI.String.FK);

    return controller;
}

Duik.CmdLib['Constraint']["Auto Parent"] = "Duik.Constraint.autoParent()";
Duik.CmdLib['Constraint']["Auto Parent Orphans"] = "Duik.Constraint.autoParent( true )";
/**
 * Auto-Parent. Parent selected layers to the last selected one.
 * @param {Boolean} [orphansOnly=false] - When true, parent only the orphans to the last selected layers
 * @param {Layer[]|DuList.<Layer>} [layers] - The layers
 */
Duik.Constraint.autoParent = function( orphansOnly, layers )
{
    orphansOnly = def(orphansOnly, false);

    layers = def(layers, DuAEComp.getSelectedLayers());
    layers = new DuList(layers);

    DuAE.beginUndoGroup( DuScriptUI.String.AUTO_PARENT, false);

    DuAELayer.parent( layers, undefined, orphansOnly );

    DuAE.endUndoGroup( DuScriptUI.String.AUTO_PARENT );
}

Duik.CmdLib['Constraint']["Parent"] = "Duik.Constraint.parent()";
/**
 * Parent Constraint
 * @param {Layer[]|DuList.<Layer>} [layers] - The layers
 */
Duik.Constraint.parent = function ( layers )
{
    layers = def(layers, DuAEComp.unselectLayers());
    layers = new DuList(layers);

    DuAE.beginUndoGroup( DuScriptUI.String.PARENT_CONSTRAINT, false);

    var pe = Duik.PseudoEffect.PARENT;
    var p = pe.props;

    layers.do(function(layer)
    {
        var effect = pe.apply(layer);

        var posExpr = [DuAEExpression.Id.PARENT_CONSTRAINT,
            DuAEExpression.Library.get(['translatePointWithLayer','checkDuikEffect']),
            'var result = thisLayer.position.valueAtTime( 0 );',
            'var mbPrecision = 1;',
            'var step = framesToTime(1);',
            'var cT = 0;',
            'while ( cT < time ) {',
            '    cT += step;',
            '    var roundedFrame = Math.round( timeToFrames(cT) );',
            '    var roundedTime = roundedFrame * thisComp.frameDuration;',
            '    if (cT - roundedTime < 0.0001) cT = roundedTime;',
            '',
            '	for ( var i = 1; i <= thisLayer( "Effects" ).numProperties; i++ ) {',
            '		var fx = effect( i );',
            '		if ( !checkDuikEffect(fx, "DUIK parentConstraint") ) continue;',
            '		if ( !fx(' + p['Inheritance']['Position'].index + ').value ) continue;',
            '		var parentLayer = null;',
            '		try {',
            '			parentLayer = fx(' + p['Layer'].index + ');',
            '		} catch ( e ) {',
            '			continue;',
            '		}',
            '',
            '		mbPrecision = fx(' + p['Motion Blur Precision'].index + ').value;',
            '		step = framesToTime(1)/mbPrecision;',
            '',
            '        if ( !parentLayer ) continue;',
            '        if ( parentLayer.index == index ) continue;',
            '        var weight = fx(' + p['Weight'].index + ').valueAtTime( cT ) / 100;',
            '        if ( weight == 0 ) continue;',
            '        result += translatePointWithLayer( parentLayer, result, cT - step, cT ) * weight;',
            '    }',
            '    result += valueAtTime( cT ) - valueAtTime( cT - step );',
            '}',
            'result;'
        ].join('\n');

        if (layer.position.dimensionsSeparated)
        {
            layer.transform.xPosition.expression = posExpr + '\nresult[0];';

            layer.transform.yPosition.expression = posExpr + '\nresult[1];';
            if (layer.threeDLayer) layer.transform.zPosition.expression = posExpr + '\nresult[2];';
        }
        else
        {
            layer.position.expression = posExpr;
        }

        var rotExpression = [DuAEExpression.Id.PARENT_CONSTRAINT,
            DuAEExpression.Library.get(['getOrientationAtTime','checkDuikEffect']),
            'var result = value;',
            'for ( var i = 1; i <= thisLayer( "Effects" ).numProperties; i++ ) {',
            '    var fx = effect( i );',
            '    if ( !checkDuikEffect(fx, "DUIK parentConstraint") ) continue;',
            '    if ( !fx(' + p['Inheritance']['Rotation'].index + ').value ) continue;',
            '    var l = null;',
            '    try {',
            '        l = fx(' + p['Layer'].index + ');',
            '    } catch ( e ) {',
            '        continue;',
            '    }',
            '    if ( !l ) continue;',
            '    if ( l.index == index ) continue;',
            '    if ( fx(' + p['Weight'].index + ').numKeys < 2 ) {',
            '        var w = fx(' + p['Weight'].index + ').value / 100;',
            '        if ( w == 0 ) continue;',
            '        var P = getOrientationAtTime( l, time );',
            '        var oP = getOrientationAtTime( l, 0 );',
            '        result += ( P - oP ) * w;',
            '    } else {',
            '        var cT = time ;',
            '        var step = framesToTime(1) / fx(' + p['Motion Blur Precision'].index + ').value;',
            '        while (cT > 0) {',
            '            var prevT = cT - step;',
            '            var w = fx(' + p['Weight'].index + ').valueAtTime( cT ) / 100;',
            '            var P = getOrientationAtTime( l, cT );',
            '            var oP = getOrientationAtTime( l, prevT );',
            '            result += ( P - oP ) * w;',
            '            cT = cT - step;',
            '        }',
            '    }',
            '}',
            'result;'
        ].join('\n');

        layer.rotation.expression = rotExpression

        if (layer.parent != null)
        {
            var comp = layer.containingComp;
            var time = comp.time;
            comp.time = 0;
            var parent = layer.parent;
            layer.parent = null;
            effect( p['Layer'].index ).setValue(parent.index);
            comp.time = time;
        }
    });

    DuAE.endUndoGroup( DuScriptUI.String.PARENT_CONSTRAINT );
}

Duik.CmdLib['Constraint']["Locator"] = "Duik.Constraint.locator()";
/**
 * Add Locator
 * @param {Layer[]|DuList.<Layer>} [layers] - The layers
 */
Duik.Constraint.locator = function( layers )
{
    layers = def(layers, DuAEComp.getSelectedLayers());
    layers = new DuList(layers);

    DuAE.beginUndoGroup( DuScriptUI.String.LOCATOR, false);

    if (layers.length() > 0) layers.do( Duik.Constraint.createLocator );
    else Duik.Constraint.createLocator();

    DuAE.endUndoGroup( DuScriptUI.String.LOCATOR);
}

/**
 * Creates a new locator linked to the layer
 * @param {Layer|CompItem} [layerOrComp] The layer or the containing comp
 * @returns {ShapeLayer} The locator
 */
Duik.Constraint.createLocator = function ( layerOrComp )
{
    var layer = null;
    var comp = null;
    if ( typeof layerOrComp === 'undefined' ) comp = DuAEProject.getActiveComp();
    else if ( layerOrComp instanceof CompItem ) comp = layerOrComp;
    else
    {
        layer = layerOrComp;
        comp = layer.containingComp;
    }
    if ( !comp ) return;

    //create null object
    var loc = DuAEComp.addNull(comp, 50);
    loc.moveToEnd();
    var name = 'LOC';
    if ( layer ) Duik.Layer.copyAttributes( loc, layer, Duik.Layer.Type.LOCATOR );
    else Duik.Layer.setAttributes( loc, Duik.Layer.Type.LOCATOR, DuScriptUI.String.LOCATOR );

    //add layer control
    var layerfx = loc.property( 'ADBE Effect Parade' ).addProperty( 'ADBE Layer Control' );
    layerfx.name = DuScriptUI.String.LOCATOR;
    if ( layer ) layerfx( 1 ).setValue( layer.index );

    //add expressions
    loc.transform.rotation.expression = [ DuAEExpression.Id.LOCATOR,
        DuAEExpression.Library.get(['sign','dishineritRotation','getOrientation']),
        'var result = 0;',
        'var l = null;',
        'try{ l = effect("' + layerfx.name + '")(1) } catch(e) { }',
        'if (l)',
        '{',
        '    var sign = getScaleMirror( thisLayer );',
        '    var flip = getScaleUTurn( thisLayer );',
        '    result = getOrientation( l ) * sign + flip;',
        '    result += dishineritRotation( thisLayer ) - value;',
        '}',
        'result;'
        ].join('\n');

    loc.transform.position.expression = [ DuAEExpression.Id.LOCATOR,
        'var result = [thisComp.width/2,thisComp.height/2];',
        'var l = null;',
        'try{ l = effect("' + layerfx.name + '")(1) } catch(e) { }',
        'if (l)',
        '{',
        '   result = l.toWorld(l.anchorPoint);',
        '}',
        'if (hasParent)',
        '{',
        '   result = parent.fromWorld(result);',
        '}',
        'result;'
        ].join('\n');

    loc.transform.anchorPoint.expression = [ DuAEExpression.Id.LOCATOR,
        'var result = value;',
        'var l = null;',
        'try{ l = effect("' + layerfx.name + '")(1) } catch(e) { }',
        'if (l)',
        '{',
        '   result =l.anchorPoint.value;',
        '}',
        'result;'
        ].join('\n');

    loc.transform.scale.expression = [ DuAEExpression.Id.LOCATOR,
        'var l = null;',
        'try{ l = effect("' + layerfx.name + '")(1) } catch(e) { }',
        DuAEExpression.Library.get(['getScale','dishineritScale']),
        '',
        'var threeD = value.length == 3;',
        'var result = dishineritScale( thisLayer ) - value;',
        'if (threeD) result += [100,100,100];',
        'else result += [100,100];',
        '',
        'if (l)',
        '{',
        '    var sl = getScale( l )/100;',
        '    if (result.length == 3 && sl.length == 3) {',
        '        result = [ result[0]*sl[0], result[1]*sl[1], result[2]*sl[2] ];',
        '    }',
        '    else if (result.length == 3) {',
        '        result = [result[0]*sl[0], result[1]*sl[1], result[2] ];',
        '    }',
        '    else {',
        '        result = [result[0]*sl[0], result[1]*sl[1] ];',
        '    }',
        '}',
        '',
        'result;'
    ].join('\n');

    return loc;
}

Duik.CmdLib['Constraint']["Extract Locators"] = "Duik.Constraint.extractLocators()";
/**
 * Extract Locators
 * @param {Boolean} [useEssentialProperties] - whether to use essential properties instead of expressions to extract the controllers. True by default if Ae >= 17.0
 * @param {Layer[]|DuList.<Layer>} [precompLayers] - The layers
 */
Duik.Constraint.extractLocators = function ( useEssentialProperties, precompLayers )
{
    precompLayers = def(precompLayers, DuAEComp.getSelectedLayers());
    precompLayers = new DuList(precompLayers);
    if ( precompLayers.length() == 0 ) return;

    DuAE.beginUndoGroup( DuScriptUI.String.EXTRACT_LOCATORS, false);

    precompLayers.do(function( precompLayer )
    {
        var preComp = precompLayer.source;
        if ( !preComp instanceof CompItem ) return;

        //get locators in precomp
        var preCompLocs = Duik.Layer.get( Duik.Layer.Type.LOCATOR, false, preComp );

        var it = new DuList( preCompLocs );
        it.do( function( preCompLoc )
        {
            Duik.Constraint.extractLocator( preCompLoc, precompLayer, useEssentialProperties );
        } );
    });

    DuAE.endUndoGroup( DuScriptUI.String.EXTRACT_LOCATORS);
}

/**
 * Extracts one locator from a precomposition
 * @param {ShapeLayer} locator - The locator to extract
 * @param {AVLayer} preCompLayer - The precomposition layer
 * @param {Boolean} [useEssentialProperties=true] - true to extract using master properties instead of expressions (ignored in Ae < 15.1, false by default if 15.1 <= Ae < 17 and true by default in Ae >= 17)
 * @return {ShapeLayer} The extracted locator
 */
Duik.Constraint.extractLocator = function( locator, preCompLayer, useEssentialProperties )
{
    if (DuAE.version.version < 15.1) useEssentialProperties = false;
	if (DuAE.version.version < 17.0) useEssentialProperties = def( useEssentialProperties, false );
	else useEssentialProperties = def( useEssentialProperties, true );

    var comp = preCompLayer.containingComp;
    //comp names
    DuAEComp.setUniqueCompName( comp );
    DuAEComp.setUniqueCompName( locator.containingComp );

    //apply locator values to workaround all kind of bugs
    locator.transform.anchorPoint.setValue( locator.transform.anchorPoint.valueAtTime(0, false));
    locator.transform.position.setValue( locator.transform.position.valueAtTime(0, false));
    locator.transform.scale.setValue( locator.transform.scale.valueAtTime(0, false));
    locator.transform.rotation.setValue( locator.transform.rotation.valueAtTime(0, false));
    locator.transform.opacity.setValue( locator.transform.opacity.valueAtTime(0, false));
    
    //create a null in the comp
    var loc = DuAEComp.addNull(comp);
    loc.moveToEnd();
    Duik.Layer.setAttributes( loc, Duik.Layer.Type.LOCATOR, DuScriptUI.String.LOCATOR );
    loc.parent = preCompLayer;

    var trProp = new DuAEProperty( locator.transform );

    if (useEssentialProperties) {
        trProp.addToEGP();
        // get essential properties
        var mps = DuAEProperty.getProps( preCompLayer('ADBE Layer Overrides'), PropertyType.PROPERTY );
        var it = new DuList(mps);
        //links
        it.do( function(mp) {
            var newProp = null;

            //get prop name
            var nameArray = mp.name.split(' / ');
            if ( nameArray.length != 2 ) return;
            var pLink = nameArray[1];
            var layerName = nameArray[0];
            if ( layerName != locator.name ) return;
        
            try { newProp = eval('loc' + pLink); }
            catch (e) { return; }

            //link
            if (newProp) {
                var p = new DuAEProperty( newProp );
                p.pickWhip( mp, true );
            }
        });
    } else {
        trProp.linkProperties( locator.transform );
    }
    return loc;
}

/**
 * Sets the current values of the locators. This fixes some bugs when unparenting layers parented to the locators.
 * @param {Layer|LayerCollection|Layer[]|DuList.<Layer>} [layers=DuAEComp.getSelectedLayers()] The layer(s). If omitted, will use all selected layers in the comp
 * @param {boolean} [disable=true] - whether to disable the expressions after having applied the values
 */
Duik.Constraint.applyLocatorValues = function ( layers, disable )
{
    layers = def(layer, DuAEComp.getSelectedLayers());
    layers = new DuList(layers);
    if (layers.length() == 0) return;

    disable = def(disable, true);

    for(var i = 0, n = layers.length(); i < n; i++)
    {
        var layer = layers.at(i);

        if ( !Duik.Layer.isType(layer, Duik.Layer.Type.LOCATOR) ) continue;

        var l = locator.locked;
        locator.locked = false;
        var p = new DuAEProperty( locator.transform.anchorPoint );
        p.setValue( locator.transform.anchorPoint.valueAtTime(0, false), 0 );
        var p = new DuAEProperty( locator.transform.position );
        p.setValue( locator.transform.position.valueAtTime(0, false), 0 );
        var p = new DuAEProperty( locator.transform.scale );
        p.setValue( locator.transform.scale.valueAtTime(0, false), 0 );
        var p = new DuAEProperty( locator.transform.rotation );
        p.setValue( locator.transform.rotation.valueAtTime(0, false), 0 );
        var p = new DuAEProperty( locator.transform.opacity );
        p.setValue( locator.transform.opacity.valueAtTime(0, false), 0 );
        if (disable) Duik.Constraint.disableLocator( locator );
        locator.locked = l;
    }
}

/**
 * Disables the locator. Disable the transform expressions
 * @param {Layer|LayerCollection|Layer[]|DuList.<Layer>} [layers=DuAEComp.getSelectedLayers()] The layer(s). If omitted, will use all selected layers in the comp
 * @param {boolean} [disable=true]
 */
Duik.Constraint.disableLocator = function( layers, disable )
{
    layers = def(layer, DuAEComp.getSelectedLayers());
    layers = new DuList(layers);
    if (layers.length() == 0) return;

    disable = def(disable, true);

        for(var i = 0, n = layers.length(); i < n; i++)
    {
        var layer = layers.at(i);

        if ( !Duik.Layer.isType(layer, Duik.Layer.Type.LOCATOR) ) continue;

        var l = locator.locked;
        locator.locked = false;
        locator.transform.anchorPoint.expressionEnabled = !disable;
        locator.transform.position.expressionEnabled = !disable;
        locator.transform.scale.expressionEnabled = !disable;
        locator.transform.rotation.expressionEnabled = !disable;
        locator.transform.opacity.expressionEnabled = !disable;
        locator.locked = l;
    }
}

/**
 * Parent the layers across compositions to the chosen layer
 * @param {Layer} parent The parent layer
 * @param {Boolean} [useEssentialProperties=true] - true to extract using master properties instead of expressions (ignored in Ae < 15.1, false by default if 15.1 <= Ae < 17 and true by default in Ae >= 17)
 * @param {Layer[]|DuList.<Layer>} [children] - The child layers
 */
Duik.Constraint.parentAcrossComp = function ( parent, useEssentialProperties, children )
{
    children = def(children, DuAEComp.getSelectedLayers());
    children = new DuList(children);

    DuAE.beginUndoGroup( DuScriptUI.String.PARENT_ACROSS_COMP, false);

    var parentComp = parent.containingComp;

    //create the parent locator
    var locator = Duik.Constraint.createLocator( parent );
    //the children locators
    var childLocators = [];

    new DuList( children ).do( function( child )
    {
        var childComp = child.containingComp;

        //check if there already is a child locator
        var childLocator = null;
        for ( var i = 0, num = childLocators.length; i < num; i++ )
        {
            if ( childLocators[ i ].containingComp.id == childComp.id )
            {
                childLocator = childLocators[ i ];
                break;
            }
        }

        //if precomp
        var precomps = DuAEComp.getPrecomps( childComp );
        var precompList = new DuList(precomps);

        if ( precompList.indexOf( parentComp ) >= 0 )
        {
            //select the first precomp layer
            var precompLayer;
            for ( var i = 1, num = childComp.numLayers; i <= num; i++ )
            {
                var l = childComp.layer( i );
                if ( l.source )
                {
                    if ( l.source.id == parentComp.id )
                    {
                        precompLayer = l;
                        break;
                    }
                }
            }

            //create the child Locator
            if ( !childLocator )
            {
                //create a locator and extract it
                var childLocator = Duik.Constraint.extractLocator( locator, precompLayer, useEssentialProperties );
                childLocator.selected = false;
                childLocator.enabled = false;
                childLocator.shy = true;
                childLocator.locked = true;
                childLocators.push( childLocator );
            }
            var locked = child.locked;
            child.locked = false;
            child.parent = childLocator;
            child.locked = locked;
            child.selected = true;

            return;
        }

        //if parent comp
        var parentComps = DuAEComp.getParentComps( childComp );
        var parentCompList = new DuList(parentComps);
        if ( parentCompList.indexOf( parentComp ) >= 0 )
        {
            //select the first precomp layer
            var precompLayer;
            for ( var i = 1, num = parentComp.numLayers; i <= num; i++ )
            {
                var l = parentComp.layer( i );
                if ( l.source == childComp )
                {
                    precompLayer = l;
                    break;
                }
            }

            locator.parent = precompLayer;

            //create the child Locator
            if ( !childLocator )
            {
                //create a null in the comp
                var childLocator = DuAEComp.addNull(childComp);
                childLocator.moveToEnd();
                Duik.Layer.copyAttributes( childLocator, locator, Duik.Layer.Type.LOCATOR );
                var ctr = new DuAEProperty( childLocator.transform );
                ctr.linkProperties( locator.transform, undefined, precompLayer );
                //lock and hide
                childLocator.selected = false;
                childLocator.enabled = false;
                childLocator.shy = true;
                childLocator.locked = true;
                childLocators.push( childLocator );
            }

            child.parent = childLocator;
            child.selected = true;

            return;
        }

    });

    //lock and hide
    locator.selected = false;
    locator.enabled = false;
    locator.locked = true;
    locator.shy = true;
    parent.selected = true;

    DuAE.endUndoGroup( DuScriptUI.String.PARENT_ACROSS_COMP);
}

Duik.CmdLib['Constraint']["Position"] = "Duik.Constraint.position()";
/**
 * Adds a position constraint to the layers
 * @param {Layer[]|DuList.<Layer>} [layers] - The layers
 */
Duik.Constraint.position = function ( layers )
{
    layers = def(layers, DuAEComp.unselectLayers());
    layers = new DuList(layers);

    DuAE.beginUndoGroup( DuScriptUI.String.POSITION_CONSTRAINT, false);

    var pe = Duik.PseudoEffect.POSITION;

    layers.do(function( layer )
    {
        var effect = pe.apply(layer);
        var p = pe.props;
        effect( p['Weight'].index ).setValue( 0 );

        layer.position.expression = [DuAEExpression.Id.POSITION_CONSTRAINT,
            DuAEExpression.Library.get(['checkDuikEffect']),
            'var result = value;',
            'for ( var i = 1; i <= thisLayer( "Effects" ).numProperties; i++ ) {',
            '    var fx = effect( i );',
            '    if ( !checkDuikEffect(fx, "DUIK positionConstraint") ) continue;',
            '    var l = null;',
            '    try {',
            '        l = fx( ' + p['Constraint to'].index + ' );',
            '    } catch ( e ) {}',
            '    if ( l ) {',
            '        var cp = l.toWorld( l.anchorPoint );',
            '        if ( thisLayer.hasParent ) cp = thisLayer.parent.fromWorld( cp );',
            '        cp0 = l.toWorld( l.anchorPoint, 0 );',
            '        if ( thisLayer.hasParent ) cp0 = thisLayer.parent.fromWorld( cp0 );',
            '        cp -= cp0;',
            '        result += cp * ( fx( ' + p['Weight'].index + ' ).value / 100 );',
            '    }',
            '}',
            'result;',
            ''
            ].join('\n');

    });

    DuAE.endUndoGroup( DuScriptUI.String.POSITION_CONSTRAINT);
}

Duik.CmdLib['Constraint']["Orientation"] = "Duik.Constraint.orientation()";
/**
 * Adds an orientation constraint to the layers
 * @param {Layer[]|DuList.<Layer>} [layers] - The layers
 */
Duik.Constraint.orientation = function ( layers )
{
    layers = def(layers, DuAEComp.unselectLayers());
    layers = new DuList(layers);

    DuAE.beginUndoGroup( DuScriptUI.String.ORIENTATION_CONSTRAINT, false);

    var pe = Duik.PseudoEffect.ORIENTATION;

    layers.do(function( layer )
    {
        var effect = pe.apply(layer);
        var p = pe.props;

        layer.rotation.expression = [DuAEExpression.Id.ORIENTATION_CONSTRAINT,
        DuAEExpression.Library.get(['sign','getOrientation','dishineritRotation','checkDuikEffect']),
        'var result = dishineritRotation( thisLayer );',
        'for ( var i = 1; i <= thisLayer( "Effects" ).numProperties; i++ ) {',
        '    var fx = effect( i );',
        '    if ( !checkDuikEffect(fx, "DUIK orientationConstraint") ) continue;',
        '    var l = null;',
        '    try {',
        '        l = fx(' + p['Constraint to'].index + ');',
        '    } catch ( e ) {}',
        '    if ( l ) result += getOrientation( l ) * ( fx(' + p['Weight'].index + ').value / 100 );',
        '}',
        'result;',
        ''
        ].join('\n');

    });

    DuAE.endUndoGroup( DuScriptUI.String.ORIENTATION_CONSTRAINT);
}

Duik.CmdLib['Constraint']["Constraint"] = "Duik.Constraint.constraint()";
/**
 * Description
 * @param {PropertyBase|DuAEProperty} [path] - The path, taken from the layer selection if omitted
 * @param {Layer[]|DuList.<Layer>} [layers] - The layers
 * @returns {Boolean} true if a constraint could be created
 */
Duik.Constraint.path = function ( path, layers )
{
    layers = def(layers, DuAEComp.getSelectedLayers());
    layers = new DuList(layers);

    if ( typeof path === 'undefined' && layers.length() < 2) return false; 

    if ( typeof path === 'undefined' ) 
    {
        var pathLayer = layers.pop();
        var pathProps = DuAELayer.getSelectedProps( pathLayer, PropertyValueType.SHAPE )
        if (pathProps.length == 0) return false;
        path = pathProps.pop();
    }

    DuAE.beginUndoGroup( DuScriptUI.String.PATH_CONSTRAINT, false);

    var pe = Duik.PseudoEffect.PATH;

    layers.do(function( layer )
    {
        path = new DuAEProperty( path );
        path = path.pathProperty();
        if (!path) return;

        var effect = pe.apply( layer );
        var p = pe.props;

        var l = path.layer;
        var pathExpr = path.expressionLink( true );

        var expr = [ DuAEExpression.Id.PATH_CONSTRAINT,
            'var fx = effect("' + effect.name + '");',
            'var l = thisComp.layer("' + l.name + '");',
            'var p = ' + pathExpr + ';',
            'var percent = fx(' + p['Percent along path'].index + ').value % 100 / 100;',
            'if (percent == 0) percent = 0.0001;',
            'var pathOffset = fx(' + p['Path Offset'].index  + ').value;',
            '// path value',
            'var result = l.toWorld( p.pointOnPath(percent, time ) +  p.normalOnPath(percent, time) * pathOffset );',
            'if (hasParent) result = parent.fromWorld(result);',
            '//layer position',
            'result += value;'
        ].join('\n');

        var posProp = new DuAEProperty( layer.position );
        posProp.setExpression( expr );

        expr = [ DuAEExpression.Id.PATH_CONSTRAINT,
            'var fx = effect("' + effect.name + '");\n' +
            'var autoOrient = fx(' + p['Orientation'].index + ').value;\n' +
            'var result = value;\n' +
            'if (autoOrient)\n' +
            '{',
            'var l = thisComp.layer("' + l.name + '");',
            'var p = ' + pathExpr + ';\n' +
            'var percent = fx(' + p['Percent along path'].index + ').value % 100 / 100;\n' +
            'var C = p.tangentOnPath(percent, time);',
            'var angle = Math.atan2(C[1], C[0]);',
            'angle = radiansToDegrees(angle);',
            'angle += l.rotation.value;',
            'result += angle;',
            '}',
            'result;'
        ].join('\n');
        
        var rotProp = new DuAEProperty( layer.rotation );
        rotProp.setExpression( expr );
    });

    DuAE.endUndoGroup( DuScriptUI.String.PATH_CONSTRAINT );
    return true;
}

Duik.CmdLib['Constraint']["Pin"] = "Duik.Constraint.pin()";
Duik.CmdLib['Constraint']["Pin without tangent"] = "Duik.Constraint.pin( false )";
/**
 * Add pins on the properties
 * @param {Boolean} [tangents=true] Set to false to ignore Bézier path tangents
 * @param {PropertyBase[]} [props] The properties to pin
 * @returns {ShapeLayer[]} The pins
 */
Duik.Constraint.pin = function ( tangents, props )
{
    tangents = def( tangents, true );

    var props = DuAEComp.getSelectedProps();

    DuAE.beginUndoGroup( DuScriptUI.String.DUIK_PINS, false);

    //just create a single bone without any prop
    if (props.length == 0)
    {
        var pin = Duik.Pin.create();
        if (!pin) return;
        pin.selected = true;

        DuAE.endUndoGroup( DuScriptUI.String.DUIK_PINS );
        return [pin];
    }

    DuAEProject.setProgressMode( true );

    var pins = [];
    props = new DuList(props);
    props.do( function( prop )
    {
        pins = pins.concat( Duik.Pin.add( prop, tangents ) );
    } );

    //if nothing was created
    if ( pins.length == 0 )
    {
        var layers = DuAEComp.getSelectedLayers();
        layers = new DuList( layers );

        //Try to find puppet pins
        layers.do( function( layer )
        {
            var ps = DuAELayer.getPuppetPins( layer );
            ps = new DuList( ps );
            ps.do( function( pin )
            {
                pins.push( Duik.Pin.add( pin, tangents ) );
            } );

        } );
    }

    //Try any spatial property
    if ( pins.length == 0 )
    {
        props.do( function( prop )
        {
            pins = pins.concat( Duik.Pin.addPins( prop, tangents ) );
        } );
    }

    DuAEComp.selectLayers( pins );

    DuAEProject.setProgressMode( false );
    DuAE.endUndoGroup( DuScriptUI.String.DUIK_PINS );

    return pins;
}

/**
 * A very simple FK control
 * @param {Layer[]|DuList.<Layer>} [layers] - The layers, already parented or ordered from root (at index 0) to end
 * @param {Layer} [controller] - An already existing controller.
 * @return {Layer} The controller of the FK.
 */
Duik.Constraint.simpleFK = function( layers, controller )
{
    controller = def(controller, null);
    layers = def(layers, DuAEComp.unselectLayers());
    layers = new DuList(layers);
    layers = DuAELayer.sortByParent( layers );
    var numLayers = layers.length;

    // create controller
    if ( controller == null )
    {
        var l = layers[0];
        controller = Duik.Controller.create(l.containingComp, Duik.Controller.Type.ROTATION, l );
    }

    //add checkbox and data
    var effect = controller.effect.addProperty( "ADBE Checkbox Control" );
    effect.name = layers[ 0 ].name + " Follow";
    var effectName = effect.name;

    for ( var i = 0; i < numLayers; i++ )
    {
        var goalData = layers[ i ].effect.addProperty( "ADBE Layer Control" );
        goalData.name = "FK Controller";
        var dataName = goalData.name;
        goalData( 1 ).setValue( controller.index );

        var exp = DuAEExpression.Id.SIMPLE_FK + "\n" +
            "var ctrl = null;\n" +
            "var result = value;\n" +
            "try { ctrl = effect(\"" + dataName + "\")(1); } catch (e){};\n" +
            "if (ctrl != null)\n" +
            "{\n" +
            "var goal = ctrl.effect(\"" + effectName + "\")(1).value;\n" +
            "result += ctrl.rotation.value/" + ( numLayers / ( i + 1 ) ) + ";\n" +
            "if (!goal)\n" +
            "{\n" +
            "var layer = thisLayer;\n" +
            "while (layer.hasParent)\n" +
            "{\n" +
            "layer = layer.parent;\n" +
            "result = result - layer.rotation/" + ( numLayers / ( i + 1 ) ) + ";\n" +
            "}\n" +
            "}\n" +
            "}\n" +
            "result;";

        var rotProp = new DuAEProperty( layers[i].transform.rotation );
        rotProp.setExpression( exp );
    }
}

Duik.CmdLib['Constraint']["Remove thisComp"] = "Duik.Constraint.removeThisCompInExpressions()";
/**
 * Replace all <code>thisComp</code> occurences by <code>comp("name")</code>.
 * @param {Duik.SelectionMode} [selectionMode=DuAE.SelectionMode.ACTIVE_COMPOSITION] The items where to modify the expressions.
 */
Duik.Constraint.removeThisCompInExpressions = function( selectionMode )
{
    selectionMode = def(selectionMode, DuAE.SelectionMode.ACTIVE_COMPOSITION );
    DuAE.beginUndoGroup( DuScriptUI.String.REMOVE_THISCOMP );

    DuAEComp.removeThisCompInExpressions( selectionMode );

    DuAE.endUndoGroup();
}

Duik.CmdLib['Constraint']["Use thisComp"] = "Duik.Constraint.removeCompInExpressions()";
/**
 * Replace all <code>comp("name")</code> occurences by <code>thisComp</code>.
 * @param {Duik.SelectionMode} [selectionMode=DuAE.SelectionMode.ACTIVE_COMPOSITION] The items where to modify the expressions.
 */
Duik.Constraint.removeCompInExpressions = function( selectionMode )
{
    selectionMode = def(selectionMode, DuAE.SelectionMode.ACTIVE_COMPOSITION );
    DuAE.beginUndoGroup( DuScriptUI.String.USE_THISCOMP );

    DuAEComp.removeCompInExpressions( selectionMode );

    DuAE.endUndoGroup();
}

Duik.CmdLib['Constraint']["Remove thisLayer"] = "Duik.Constraint.removeThisLayerInExpressions()";
/**
 * Replace all <code>thisLayer</code> occurences by <code>layer("name")</code>.
 * @param {Duik.SelectionMode} [selectionMode=DuAE.SelectionMode.ACTIVE_COMPOSITION] The items where to modify the expressions.
 */
Duik.Constraint.removeThisLayerInExpressions = function( selectionMode )
{
    selectionMode = def(selectionMode, DuAE.SelectionMode.ACTIVE_COMPOSITION );
    DuAE.beginUndoGroup( DuScriptUI.String.REMOVE_THISCOMP );

    DuAEComp.removeThisLayerInExpressions( selectionMode );

    DuAE.endUndoGroup();
}

Duik.CmdLib['Constraint']["Use thisComp"] = "Duik.Constraint.removeLayerInExpressions()";
/**
 * Replace all <code>layer("name")</code> occurences by <code>thisLayer</code>.
 * @param {Duik.SelectionMode} [selectionMode=DuAE.SelectionMode.ACTIVE_COMPOSITION] The items where to modify the expressions.
 */
Duik.Constraint.removeLayerInExpressions = function( selectionMode )
{
    selectionMode = def(selectionMode, DuAE.SelectionMode.ACTIVE_COMPOSITION );
    DuAE.beginUndoGroup( DuScriptUI.String.USE_THISCOMP );

    DuAEComp.removeLayerInExpressions( selectionMode );

    DuAE.endUndoGroup();
}