/**
 * Constraint tools.
 * @namespace
 */
Duik.Constraint = {};

/**
 * The types of IK for three-layer chains.
 * @enum {int}
 */
Duik.Constraint.IKType = {
    THREE: 0,
    ONE_TWO: 1,
    TWO_ONE: 2
};

/**
 * The list of constraint functions
 */
Duik.CmdLib['Constraint'] = [];

Duik.CmdLib['Constraint']["List"] = "Duik.Constraint.list()";
/**
 * List
 */
Duik.Constraint.list = function ( )
{
    var props = DuAEComp.getSelectedProps();
	if (props.length == 0) return;

	DuAE.beginUndoGroup( DuScriptUI.String.LIST );

	var layers = DuAEComp.unselectLayers();
	for (var i = 0, n = props.length; i < n ; i++)
	{
		Duik.Constraint.createList(props[i]);
	}
	DuAEComp.selectLayers(layers);

	DuAE.endUndoGroup();
}

/**
	* Adds a list on a property
	* @param {Property|DuAEProperty} prop - The Property
    * @returns {DuAEProperty} The list effect
*/
Duik.Constraint.createList = function (prop)
{
	prop = new DuAEProperty(prop);
    if (!prop.riggable()) return;

	var dim = prop.dimensions();

	var layer = prop.layer;

	var effect = null;
	var name = prop.getProperty().name + ' List';
	if (dim == 1) effect = Duik.PseudoEffect.ONED_LIST.apply(layer, name);
	else if (dim == 2) effect = Duik.PseudoEffect.TWOD_LIST.apply(layer, name);
	else if (dim == 3) effect = Duik.PseudoEffect.THREED_LIST.apply(layer, name);
	else return;

	//set animation with expression
	var anim = prop.animation(false);
	if (anim)
    {
        var newProp = new DuAEProperty(effect(2));
        newProp.setAnim(anim,0,true,true,false);
    }
	prop.removeAnimation();

	prop.getProperty().expression =  [DuAEExpression.Id.LIST,
        "var fx = effect(\"" + effect.name + "\");",
        "var v1 = fx(2);",
        "var w1 = fx(3);",
        "var v2 = fx(6);",
        "var w2 = fx(7);",
        "var v3 = fx(10);",
        "var w3 = fx(11);",
        "var v4 = fx(14);",
        "var w4 = fx(15);",
        "var v5 = fx(18);",
        "var w5 = fx(19);",
        "v1*w1/100+v2*w2/100+v3*w3/100+v4*w4/100+v5*w5/100;"
        ].join('\n');

    return prop;
}

Duik.CmdLib['Constraint']["Separate Dimensions"] = "Duik.Constraint.separateDimensions()";
/**
 * Separate Dimensions
 */
Duik.Constraint.separateDimensions = function ()
{
    var props = DuAEComp.getSelectedProps();
    if ( props.length == 0 ) return;

    DuAE.beginUndoGroup( DuScriptUI.String.SEPARATE_DIMENSIONS );

    for ( var i = 0, num = props.length; i < num; i++ )
    {
        Duik.Constraint.separatePropDimensions( props[ i ] );
    }

    DuAE.endUndoGroup();
}

/**
 * Separates the dimensions of the properties into an effect.<br />
 * Works with 2D, 3D, and colors
 * @param {Property|DuAEProperty} prop - The property
 * @return {DuAEProperty[]} The seperated properties (or the original one if it could not be separated)
 */
Duik.Constraint.separatePropDimensions = function ( prop )
{
    var propInfo = new DuAEProperty( prop );
    prop = propInfo.getProperty();

    var layer = propInfo.layer;
    var dim = propInfo.dimensions();

    if ( dim < 2 || dim > 4 ) return [propInfo];

    if (prop.isSeparationLeader)
    {
        prop.dimensionsSeparated = true;
        var newProps = [];
        for (var i = 1; i <= dim; i++)
        {
            var newProp = prop.parentProperty(prop.propertyIndex + i);
            newProp = new DuAEProperty(newProp);
            newProps.push( newProp );
        }
        return newProps;
    }

    if ( dim == 2 )
    {
        var pseudo;
        if ( propInfo.isScale ) pseudo = Duik.PseudoEffect.TWO_DIMENSIONS_SCALE;
        else if ( propInfo.isAngle ) pseudo = Duik.PseudoEffect.TWO_DIMENSIONS_ANGLE;
        else pseudo = Duik.PseudoEffect.TWO_DIMENSIONS;

        var effect = pseudo.apply( layer, propInfo.name + " XY" );

        prop = propInfo.getProperty();

        var xIndex = pseudo.props['X'].index;
        var yIndex = pseudo.props['Y'].index;

        //copy values
        if ( prop.numKeys == 0 )
        {
            effect( xIndex ).setValue( prop.value[ 0 ] );
            effect( yIndex ).setValue( prop.value[ 1 ] );
        }
        else
        {
            for ( var k = prop.numKeys; k > 0; k-- )
            {
                var time = prop.keyTime( k );
                var value = prop.keyValue( k );
                effect( xIndex ).setValueAtTime( time, value[ 0 ] );
                effect( yIndex ).setValueAtTime( time, value[ 1 ] );
                prop.removeKey(k);
            }
        }

        //add expression
        prop.expression = [DuAEExpression.Id.SEPARATE_DIMENSIONS,
            'var fx = thisLayer.effect("' + effect.name + '");',
            '[fx(' + xIndex + ').value,fx(' + yIndex + ').value];'
            ].join('\n');

        //return the new props
        var xProp = new DuAEProperty(effect( xIndex ));
        var yProp = new DuAEProperty(effect( yIndex ));
        return [xProp,yProp];
    }
    
    if ( dim == 3 )
    {
        var pseudo;
        if ( propInfo.isScale ) pseudo = Duik.PseudoEffect.THREE_DIMENSIONS_SCALE;
        else if ( propInfo.isAngle ) pseudo = Duik.PseudoEffect.THREE_DIMENSIONS_ANGLE;
        else pseudo = Duik.PseudoEffect.THREE_DIMENSIONS;

        var effect = pseudo.apply( layer, propInfo.name + " XYZ" );

        prop = propInfo.getProperty();

        var xIndex = pseudo.props['X'].index;
        var yIndex = pseudo.props['Y'].index;
        var zIndex = pseudo.props['Z'].index;

        //copy values
        if ( prop.numKeys == 0 )
        {
            effect( xIndex ).setValue( prop.value[ 0 ] );
            effect( yIndex ).setValue( prop.value[ 1 ] );
            effect( zIndex ).setValue( prop.value[ 2 ] );
        }
        else
        {
            for ( var k = prop.numKeys; k > 0; k-- )
            {
                var time = prop.keyTime( k );
                var value = prop.keyValue( k );
                effect( xIndex ).setValueAtTime( time, value[ 0 ] );
                effect( yIndex ).setValueAtTime( time, value[ 1 ] );
                effect( zIndex ).setValueAtTime( time, value[ 2 ] );
                prop.removeKey(k);
            }
        }

        //add expression
        prop.expression = [DuAEExpression.Id.SEPARATE_DIMENSIONS,
            'var fx = thisLayer.effect("' + effect.name + '");',
            '[fx(' + xIndex + ').value,fx(' + yIndex + ').value, fx(' + zIndex + ').value];'
            ].join('\n');

        //return the new props
        var xProp = new DuAEProperty(effect( xIndex ));
        var yProp = new DuAEProperty(effect( yIndex ));
        var zProp = new DuAEProperty(effect( zIndex ));
        return [xProp,yProp,zProp];
    }
    
    if ( dim == 4 )
    {
        var pseudo = Duik.PseudoEffect.COLOR;
        var effect = pseudo.apply( layer, propInfo.name + " RGB/HSL" );

        var modeIndex = pseudo.props['Channels'].index;
        var rIndex = pseudo.props['R / H'].index;
        var gIndex = pseudo.props['G / S'].index;
        var bIndex = pseudo.props['B / L'].index;

        effect( modeIndex ).setValue( 2 );
        prop = propInfo.getProperty();

        //copy values
        if ( prop.numKeys == 0 )
        {
            var color = prop.value;
            color = new DuColor(color).floatHSL();
            effect( rIndex ).setValue( color[ 0 ] );
            effect( gIndex ).setValue( color[ 1 ] );
            effect( bIndex ).setValue( color[ 2 ] );
        }
        else
        {
            for ( var k = prop.numKeys; k > 0; k-- )
            {
                var time = prop.keyTime( k );
                var value = prop.keyValue( k );
                value = new DuColor(value).floatHSL();
                effect( rIndex ).setValueAtTime( time, value[ 0 ] );
                effect( gIndex ).setValueAtTime( time, value[ 1 ] );
                effect( bIndex ).setValueAtTime( time, value[ 2 ] );
                prop.removeKey(k);
            }
        }

        //add expression
        prop.expression = [DuAEExpression.Id.SEPARATE_DIMENSIONS,
            'var fx = thisLayer.effect("' + effect.name + '");',
            'var color = [fx(' + rIndex + ').value,fx(' + gIndex + ').value, fx(' + bIndex + ').value, 1];',
            'if (fx(' + modeIndex + ').value == 2) hslToRgb(color);',
            'else color;'
            ].join('\n');

        //return the new props
        var xProp = new DuAEProperty(effect( rIndex ));
        var yProp = new DuAEProperty(effect( gIndex ));
        var zProp = new DuAEProperty(effect( bIndex ));
        return [xProp,yProp,zProp];
    }
}

Duik.CmdLib['Constraint']["Lock"] = "Duik.Constraint.lock()";
/**
 * Lock propery values
 */
Duik.Constraint.lock = function ()
{
    var props = DuAEComp.getSelectedProps();
    if ( props.length == 0 ) return;

    DuAE.beginUndoGroup( DuScriptUI.String.LOCK_PROPERTIES );

    DuAEProperty.lock( props );

    DuAE.endUndoGroup();
}

Duik.CmdLib['Constraint']["Zero"] = "Duik.Constraint.zero()";
/**
 * Zero-out selected layers
 * @param {Layer[]|LayerCollection|DuList.<Layer>|Layer} [layers=DuAEComp.getSelectedLayers()] The layer. If omitted, will use all selected layers in the comp
 * @returns {ShapeLayer[]} The zeroes
 */
Duik.Constraint.zero = function( layers )
{
    layers = def(layers, DuAEComp.getSelectedLayers());
    layers = new DuList(layers);

    DuAE.beginUndoGroup( DuScriptUI.String.ADD_ZERO, false );
    DuAEProject.setProgressMode(true);

    var zeroes = [];

    layers.do( function(layer)
    {
        //create null object
        var zero = DuAEComp.addNull( layer.containingComp );
        var layerparent = layer.parent;
        layer.parent = null;
        zero.position.setValue( layer.position.value );
        zero.rotation.setValue( layer.rotation.value );
        
        Duik.Layer.copyAttributes( zero, layer, Duik.Layer.Type.ZERO );

        layer.parent = zero;
        zero.scale.setValue( layer.scale.value );
        layer.scale.setValue( [ 100, 100, 100 ] );

        //parent
        zero.parent = layerparent;

        //lock and hide
        zero.moveToEnd();
        zero.shy = true;
        zero.enabled = false;
        zero.selected = false;
        zero.locked = true;
        zeroes.push(zero);
    } );

    DuAEProject.setProgressMode(false);
    DuAE.endUndoGroup( DuScriptUI.String.ADD_ZERO );

    return zeroes;
}

Duik.CmdLib['Constraint']["Reset Transformation"] = "Duik.Constraint.resetPRS()";
Duik.CmdLib['Constraint']["Reset Transformation and opacity"] = "Duik.Constraint.resetPRS(undefined, true)";
/**
 * Resets the transformation of the selected layers to 0.
 * @param {Layer[]|LayerCollection|DuList.<Layer>|Layer} [layers=DuAEComp.getSelectedLayers()] The layer. If omitted, will use all selected layers in the comp
 * @param {Boolean} [opacity=false] When true, also resets the opacity to 100%
 */
Duik.Constraint.resetPRS = function( layers, opacity )
{
    opacity = def(opacity, false);
    layers = def(layers, DuAEComp.getSelectedLayers());
    layers = new DuList(layers);

    DuAE.beginUndoGroup( DuScriptUI.String.RESET_TRANSFORMATION, false );
    DuAEProject.setProgressMode(true);

    layers.do( function(layer)
    {
        var comp = layer.containingComp;
        //is it 3D?
        var threeD = layer.threeDLayer;
        //has parent ?
        var parent = layer.parent !== null;
        if (threeD)
        {
            var positionValue = parent ? [0,0,0] : [comp.width / 2, comp.height / 2, 0];
            if (layer.transform.position.dimensionsSeparated)
            {
                layer.transform.xPosition.setValue(positionValue[0]);
                layer.transform.yPosition.setValue(positionValue[1]);
                layer.transform.zPosition.setValue(positionValue[2]);
            }
            else 
            {
                layer.transform.position.setValue(positionValue);
            }
            layer.transform.scale.setValue([100,100,100]);
            layer.transform.zRotation.setValue(0);
            layer.transform.xRotation.setValue(0);
            layer.transform.yRotation.setValue(0);
            layer.transform.orientation.setValue([0,0,0]);
        }
        else
        {
            var positionValue = parent ? [0,0] : [comp.width / 2, comp.height / 2];
            if (layer.transform.position.dimensionsSeparated)
            {
                layer.transform.xPosition.setValue(positionValue[0]);
                layer.transform.yPosition.setValue(positionValue[1]);
            }
            else 
            {
                layer.transform.position.setValue(positionValue);
            }
            layer.transform.scale.setValue([100,100]);
            layer.transform.rotation.setValue(0);
        }

        if (opacity) layer.transform.opacity.setValue(100);
    });

    DuAEProject.setProgressMode(false);
    DuAE.endUndoGroup( DuScriptUI.String.RESET_TRANSFORMATION );
}

Duik.CmdLib['Constraint']["Align layers"] = "Duik.Constraint.alignLayers()";
/**
 * Align selected Layers to the last selected one
 * @param {Boolean} [position=true] - Wether to align the position.
 * @param {Boolean} [rotation=true] - Wether to align the rotation.
 * @param {Boolean} [scale=true] - Wether to align the scale.
 * @param {Boolean} [opacity=true] - Wether to align the opacity.
 */
Duik.Constraint.alignLayers = function( position, rotation, scale, opacity )
{
    position = def (position, true);
    rotation = def (rotation, true);
    scale = def (scale, true);
    opacity = def (opacity, false);


    var layers = DuAEComp.getSelectedLayers();
    if (layers.length <= 1) return;

    var target = layers.pop();

    DuAE.beginUndoGroup( DuScriptUI.String.ALIGN_LAYERS, false );
    DuAELayer.align(
        layers,
        target,
        position,
        rotation,
        scale,
        opacity
    );
    DuAE.endUndoGroup( DuScriptUI.String.ALIGN_LAYERS );
}

Duik.CmdLib['Constraint']["Expose Transform"] = "Duik.Constraint.exposeTransform()";
/**
 * Expose Transform
 */
Duik.Constraint.exposeTransform = function ( comp, layers )
{
    if (typeof comp === 'undefined')
	{
		if (typeof layer !== 'undefined')
		{
			comp = layer.containingComp;
		}
		else
		{
			comp = DuAEProject.getActiveComp();
		}
	}
	if (!comp) return;

    layers = def(layers, DuAEComp.unselectLayers());
    layers = new DuList(layers);

    DuAE.beginUndoGroup( DuScriptUI.String.DUIK_EXPOSE_TRANSFORM, false);
    DuAEProject.setProgressMode( true );

    var ctrls = [];

    function createETM( layer )
    {
        var ctrl = Duik.Controller.create( comp, Duik.Controller.Type.EXPOSE_TRANSFORM, layer);

        //add pseudo effect
        var pE = Duik.PseudoEffect.EXPOSE_TRANSFORM;
        var effect = pE.apply(ctrl);

        // indices
        var guideIndex = pE.props['Display']['Guides'].index;
        var refColorIndex = pE.props['Display']['Reference'].index;
        var targetColorIndex = pE.props['Display']['Target'].index;
        var angleColorIndex = pE.props['Display']['Angle'].index;
        var distanceColorIndex = pE.props['Display']['Distance'].index;
        var pos2DAbsIndex = pE.props['2D Position (Comp projection)']['Absolute'].index;
        var dist2DIndex = pE.props['2D Position (Comp projection)']['2D Distance'].index;
        var pos3DAbsIndex = pE.props['3D Position (World)']['Absolute'].index;
        var pos2DRelIndex = pE.props['2D Position (Comp projection)']['Relative to reference'].index;
        var pos3DRelIndex = pE.props['3D Position (World)']['Relative to reference'].index;
        var dist3DIndex = pE.props['3D Position (World)']['3D Distance'].index;
        var rotRelIndex = pE.props['2D Orientation']['Relative to reference'].index;
        var rotAbsIndex = pE.props['2D Orientation']['Absolute'].index;
        var angleIndex = pE.props['Angle (Layer-This-Reference)'].index;
        var targetIndex = pE.props['Target Layer'].index;
        var refParentIndex = pE.props['Reference'].index;
        var refIndex = pE.props['Reference Layer'].index;

        //add guides
        var guidesGroup = ctrl("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
        guidesGroup.name = 'Guides';

        var refGroup = guidesGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
        refGroup.name = 'Reference';

        var refOrientationGroup = refGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
        refOrientationGroup.name = 'Orientation';
        refOrientation = refOrientationGroup("ADBE Vectors Group");

        var path = refOrientation.addProperty("ADBE Vector Shape - Group");
        path("ADBE Vector Shape").expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = effect("' + effect.name + '");',
            'if (fx(' + guideIndex + ').value)',
            '{',
            '	var A = [0,0];',
            '	var B = [ 0 , -thisComp.height/20 ];',
            '	createPath([A,B],[],[],false);',
            '}',
            'else',
            '{',
            '	value;',
            '}'
            ].join('\n');

        path = refOrientation.addProperty("ADBE Vector Shape - Ellipse");
        path("ADBE Vector Ellipse Size").expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = effect("' + effect.name + '");',
            'var s = thisComp.height/40;',
            'if (fx(' + guideIndex + ').value) [s,s];',
            'else [0,0];'
            ].join('\n');

        var stroke = refOrientation.addProperty("ADBE Vector Graphic - Stroke");
        stroke("ADBE Vector Stroke Color").expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\neffect("Expose Transform")(' + refColorIndex + ').value;';
        stroke("ADBE Vector Stroke Width").expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/500;';
        stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
        stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Dash 1').expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/100;';
        stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Gap 1" );
        stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Gap 1').expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/500;';

        refOrientationTransform = refOrientationGroup('ADBE Vector Transform Group');
        refOrientationTransform('ADBE Vector Position').expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = effect("' + effect.name + '");',
            'var P = fx(' + pos2DAbsIndex + ');',
            'var R = fx(' + pos2DAbsIndex + ') - fx(' + pos2DRelIndex + ');',
            'fromComp(R);'
        ].join('\n');
        refOrientationTransform('ADBE Vector Rotation').expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\ncontent("Guides").content("Target").transform.rotation + content("Guides").content("Target").content("Reference Orientation").transform.rotation;'

        var targetGroup = guidesGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
        targetGroup.name = 'Target';

        var targetOrientationGroup = targetGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
        targetOrientationGroup.name = 'Orientation';
        targetOrientation = targetOrientationGroup("ADBE Vectors Group");

        path = targetOrientation.addProperty("ADBE Vector Shape - Group");
        path("ADBE Vector Shape").expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = effect("' + effect.name + '");',
            'if (fx(' + guideIndex + ').value)',
            '{',
            '	var A = [0,0];',
            '	var B = [ 0 , -thisComp.height/10 ];',
            '	createPath([A,B],[],[],false);',
            '}',
            'else',
            '{',
            '	value;',
            '}'
        ].join('\n');

        path = targetOrientation.addProperty("ADBE Vector Shape - Ellipse");
        path("ADBE Vector Ellipse Size").expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = effect("' + effect.name + '");',
            'var s = thisComp.height/20;',
            'if (fx(' + guideIndex + ').value) [s,s];',
            'else [0,0];'
        ].join('\n');

        stroke = targetOrientation.addProperty("ADBE Vector Graphic - Stroke");
        stroke("ADBE Vector Stroke Color").expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\neffect("Expose Transform")(' + targetColorIndex + ');';
        stroke("ADBE Vector Stroke Width").expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/500;';
        stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
        stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Dash 1').expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/100;';
        stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Gap 1" );
        stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Gap 1').expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/500;';

        var refOrientationGroup = targetGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
        refOrientationGroup.name = 'Reference Orientation';
        refOrientation = refOrientationGroup("ADBE Vectors Group");

        path = refOrientation.addProperty("ADBE Vector Shape - Group");
        path("ADBE Vector Shape").expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = effect("' + effect.name + '");',
            'if (fx(' + guideIndex + ').value)',
            '{',
            '	var A = [0,0];',
            '	var B = [ 0 , -thisComp.height/20 ];',
            '	createPath([A,B],[],[],false);',
            '}',
            'else',
            '{',
            '	value;',
            '}'
        ].join('\n');

        stroke = refOrientation.addProperty("ADBE Vector Graphic - Stroke");
        stroke("ADBE Vector Stroke Color").expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\neffect("Expose Transform")(' + refColorIndex + ');';
        stroke("ADBE Vector Stroke Width").expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/500;';
        stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
        stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Dash 1').expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/100;';
        stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Gap 1" );
        stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Gap 1').expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/500;';
        
        refOrientationTransform = refOrientationGroup('ADBE Vector Transform Group');

        refOrientationTransform('ADBE Vector Rotation').expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = effect("' + effect.name + '");',
            '-fx(' + rotRelIndex + ');'
        ].join('\n');

        targetTransform = targetGroup('ADBE Vector Transform Group');
        targetTransform('ADBE Vector Position').expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = effect("' + effect.name + '");',
            'if (fx(' + guideIndex + ').value)',
            '{',
            '	fromComp(fx(' + pos2DAbsIndex + '));',
            '}',
            'else',
            '{',
            '	value;',
            '}'
        ].join('\n');
        targetTransform('ADBE Vector Rotation').expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = effect("' + effect.name + '");',
            'var result = fx(' + rotAbsIndex + ');',
            'var l = thisLayer;',
            'result -= l.rotation.value;',
            'while(l.hasParent)',
            '{',
            '	l = l.parent;',
            '	result -= l.rotation.value;',
            '}',
            'result;'
        ].join('\n');

        var angleGroup = guidesGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
        angleGroup.name = 'Angle';

        var angleGroup1 = angleGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
        angle1 = angleGroup1("ADBE Vectors Group");

        path = angle1.addProperty("ADBE Vector Shape - Group");
        path("ADBE Vector Shape").expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = effect("Expose Transform");',
            'if (fx(' + guideIndex + ').value)',
            '{',
            '	var A = fromComp(fx(' + pos2DAbsIndex + '));',
            '	var B = fromComp( fx(' + pos2DAbsIndex + ') - fx(' + pos2DRelIndex + ') );',
            '	createPath([A,[0,0],B],[],[],false);',
            '}',
            'else',
            '{',
            '	value;',
            '}'
        ].join('\n');

        stroke = angle1.addProperty("ADBE Vector Graphic - Stroke");
        stroke("ADBE Vector Stroke Color").expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\neffect("Expose Transform")(' + angleColorIndex + ');';
        stroke("ADBE Vector Stroke Width").expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/500;';
        stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
        stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Dash 1').expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/100;';
        stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Gap 1" );
        stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Gap 1').expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/500;';

        var angleGroup2 = angleGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
        angle2 = angleGroup2("ADBE Vectors Group");

        path = angle2.addProperty("ADBE Vector Shape - Group");
        path("ADBE Vector Shape").expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = effect("' + effect.name + '");',
            'if (fx(' + guideIndex + ').value)',
            '{',
            '	var A = fromComp(fx(' + pos2DAbsIndex + '));',
            '	var B = fromComp( fx(' + pos2DAbsIndex + ') - fx(' + pos2DRelIndex + ') );',
            '	var M = (A+B)/2;',
            '	var tA = [0,0];',
            '	var tB = [0,0];',
            '	var lB = length(B);',
            '	var lA = length(A);',
            '	if (lA > lB)',
            '	{',
            '		var q = 1;',
            '		if (lA != 0) q = lB/lA;',
            '		A = A/3*q;',
            '		B = B/3;',
            '		tA = M/6*q;',
            '		tB = M/6;',
            '	}',
            '	else',
            '	{',
            '		var q = 1;',
            '		if (lB != 0) q = lA/lB;',
            '		A = A/3;',
            '		B = B/3*q;',
            '		tA = M/6;',
            '		tB = M/6*q;',
            '	}',
            '	createPath([A,B],[ [0,0], tB ],[ tA, [0,0] ],false);',
            '}',
            'else',
            '{',
            '	value;',
            '}'
        ].join('\n');

        stroke = angle2.addProperty("ADBE Vector Graphic - Stroke");
        stroke("ADBE Vector Stroke Color").expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\neffect("Expose Transform")(' + angleColorIndex + ');';
        stroke("ADBE Vector Stroke Width").expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/500;';
        stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
        stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Dash 1').expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/100;';
        stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Gap 1" );
        stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Gap 1').expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/500;';
        
        var distanceGroup = guidesGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
        distanceGroup.name = 'Distance';
        distance = distanceGroup("ADBE Vectors Group");

        path = distance.addProperty("ADBE Vector Shape - Group");
        path("ADBE Vector Shape").expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = effect("' + effect.name + '");',
            'if (fx(' + guideIndex + ').value)',
            '{',
            '	var A = fromComp(fx(' + pos2DAbsIndex + '));',
            '	var B = fromComp( fx(' + pos2DAbsIndex + ') - fx(' + pos2DRelIndex + ') );',
            '	createPath([A,B],[],[],false);',
            '}',
            'else',
            '{',
            '	value;',
            '}'
        ].join('\n');

        stroke = distance.addProperty("ADBE Vector Graphic - Stroke");
        stroke("ADBE Vector Stroke Color").expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\neffect("Expose Transform")(' + distanceColorIndex + ');';
        stroke("ADBE Vector Stroke Width").expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/500;';
        stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
        stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Dash 1').expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/100;';
        stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Gap 1" );
        stroke("ADBE Vector Stroke Dashes").property('ADBE Vector Stroke Gap 1').expression = DuAEExpression.Id.EXPOSE_TRANSFORM + '\nthisComp.height/500;';

        //Effect expressions

        effect(pos2DAbsIndex).expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = thisProperty.propertyGroup();',
            'var l = null;',
            'try { l = fx(' + targetIndex + '); } catch (e){ }',
            'if (!l) l = thisLayer;',
            'var result = l.toComp(l.anchorPoint);',
            'result;'
        ].join('\n');

        effect(pos2DRelIndex).expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = thisProperty.propertyGroup();',
            'var useParent = fx(' + refParentIndex + ').value;',
            'var layerPosition = fx(' + pos2DAbsIndex + ');',
            'var referencePosition = [0,0];',
            'var rL = null;',
            'if (useParent)',
            '{',
            '   var l = null;',
            '	try { l = fx(' + targetIndex + '); } catch (e){ }',
            '   if (!l) l = thisLayer;',
            '	if (l.hasParent) rL = l.parent;',
            '	else rL = l;',
            '}',
            'else',
            '{',
            '	try { rL = fx(' + refIndex + '); } catch (e){ }',
            '   if (!rL) rL = thisLayer;',
            '}',
            'referencePosition = rL.toComp(rL.anchorPoint);',
            'var result = layerPosition - referencePosition;',
            'result;'
        ].join('\n');

        effect(dist2DIndex).expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = thisProperty.propertyGroup();',
            'var relativePosition = fx(' + pos2DRelIndex + ');',
            'var result = length( relativePosition );',
            'result;'
        ].join('\n');

        effect(pos3DAbsIndex).expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = thisProperty.propertyGroup();',
            'var l = null;',
            'try { l = fx(' + targetIndex + '); } catch (e){ }',
            'if (!l) l = thisLayer;',
            'var result = l.toWorld(l.anchorPoint);',
            'result;'
        ].join('\n');

        effect(pos3DRelIndex).expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = thisProperty.propertyGroup();',
            'var layerPosition = fx(' + pos3DAbsIndex + ');',
            'var useParent = fx(' + refParentIndex + ').value;',
            'var rL = null;',
            'if (useParent)',
            '{',
            '   var l = null;',
            '	try { l = fx(' + targetIndex + '); } catch (e){ }',
            '   if (!l) l = thisLayer;',
            '	if (l.hasParent) rL = l.parent;',
            '	else rL = l;',
            '}',
            'else',
            '{',
            '	try { rL = fx(' + refIndex + '); } catch (e){ }',
            '   if (!rL) rL = thisLayer;',
            '}',
            'var referencePosition = rL.toWorld(rL.anchorPoint);',
            'var result = layerPosition - referencePosition;',
            'result;'
        ].join('\n');

        effect(dist3DIndex).expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = thisProperty.propertyGroup();',
            'var relativePosition = fx(' + pos3DRelIndex + ');',
            'var result = length( relativePosition );',
            'result;'
        ].join('\n');

        effect(rotAbsIndex).expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = thisProperty.propertyGroup();',
            'var l = null;',
            'try { l = fx(' + targetIndex + ') } catch (e){ }',
            'if (!l) l = thisLayer;',
            'var result = l.rotation;',
            'if (l.position.value.length == 3) result += l.orientation[2];',
            'while(l.hasParent)',
            '{',
            '	l = l.parent;',
            '	result += l.rotation;',
            '	if (l.position.value.length == 3) result += l.orientation[2];',
            '}',
            'result;'
        ].join('\n');

        effect(rotRelIndex).expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = thisProperty.propertyGroup();',
            'var useParent = fx(' + refParentIndex + ').value;',
            'var rot = fx(' + rotAbsIndex + ');',
            'var result = value;',
            'var rL = null;',
            'if (useParent)',
            '{',
            '   var l = null;',
            '	try { l = fx(' + targetIndex + '); } catch (e){ }',
            '   if (!l) l = thisLayer;',
            '	if (l.hasParent) rL = l.parent;',
            '	else rL = l;',
            '}',
            'else',
            '{',
            '	try { rL = fx(' + refIndex + '); } catch (e){ }',
            '   if (!rL) rL = thisLayer;',
            '}',
            'var refRot = rL.rotation.value;',
            'if (rL.position.value.length == 3) refRot += rL.orientation.value[2];',
            'while(rL.hasParent)',
            '{',
            '	rL = rL.parent;',
            '	refRot += rL.rotation.value;',
            '	if (rL.position.value.length == 3) refRot += rL.orientation.value[2];',
            '}',
            'result = rot - refRot;',
            'result;'
        ].join('\n');

        effect(angleIndex).expression = [DuAEExpression.Id.EXPOSE_TRANSFORM,
            'var fx = thisProperty.propertyGroup();',
            'var useParent = fx(' + refParentIndex + ').value;',
            'var O = thisLayer.toComp(thisLayer.anchorPoint);',
            'var l = null;',
            'var rL = null;',
            'try { l = fx(' + targetIndex + '); } catch (e){ }',
            'if (!l) l = thisLayer;',
            'if (useParent)',
            '{',
            '	if (l.hasParent) rL = l.parent;',
            '	else rL = l;',
            '}',
            'else',
            '{',
            '	try { rL = fx(' + refIndex + '); } catch (e){ }',
            '   if (!rL) rL = thisLayer;',
            '}',
            'var A = l.toComp(l.anchorPoint);',
            'var B = rL.toComp(rL.anchorPoint);',
            'var OA = O-A;',
            'var OB = O-B;',
            'var angleA = Math.atan2(OA[1], OA[0]);',
            'var angleB = Math.atan2(OB[1], OB[0]);',
            'var result = angleA + angleB;',
            'result = radiansToDegrees(angleB-angleA);',
            'if (result < -180) result += 360;',
            'result;'
        ].join('\n');

        //set the layer as target
        if (typeof layer !== 'undefined')
        {
            effect( targetIndex ).setValue(layer.index);
        }

        //fold
        ctrl.selected = true;
        DuAE.executeCommand( DuAE.MenuCommandID.REVEAL_EXPRESSION_ERRORS );

        return ctrl;
    }

    if (layers.length() == 0) ctrls.push( createETM() );
    else
    {
        for (var  i = 0, num = layers.length() ; i < num ; i++)
        {
            var ctrl = createETM( layers.at(i) );
            ctrls.push(ctrl);
        }
    }

    DuAEComp.selectLayers(ctrls);
    DuAEProject.setProgressMode( false );
    DuAE.endUndoGroup( DuScriptUI.String.DUIK_EXPOSE_TRANSFORM );
}

Duik.CmdLib['Constraint']["Morph Keys"] = "Duik.Constraint.morphKeys()";
/**
 * Morph Keys
 */
Duik.Constraint.morphKeys = function ( props )
{
    props = def(props, DuAEComp.getSelectedProps());
    if (props.length == 0) return;

    // Get layer
    var layer = new DuAEProperty(props[0]).layer;

    DuAE.beginUndoGroup( DuScriptUI.String.DUIK_KEY_MORPH, false);

    // Add key morph effect
    var peKM = Duik.PseudoEffect.KEY_MORPH;
    var peKMK = Duik.PseudoEffect.KEY_MORPH_K;
    var kmEffect = peKM.apply(layer);
    var kmEffectName = kmEffect.name;
    var kmp = peKM.props;
    var kmkp = peKMK.props;

    // number of keys expression
    kmEffect(kmp['Number of keys'].index).expression = [DuAEExpression.Id.KEY_MORPH,
        'var numK = 0;',
        '',
        'function checkDuikEffect(fx, duikMatchName) {',
        '    if (fx.numProperties  < 3) return false;',
        '    if (!!$.engineName) {',
        '        if ( fx(2).name != duikMatchName ) return false;',
        '    }',
        '    else {',
        '        try { if (fx(2).name != duikMatchName) return false; }',
        '        catch (e) { return false; }',
        '    }',
        '    return true;',
        '}',
        '',
        'for (var i = 1, n = thisLayer(\'Effects\').numProperties; i <= n; i++) {',
        '	if (!checkDuikEffect( thisLayer.effect(i), "key morph k")) continue;',
        '	numK++;',
        '}',
        '',
        'numK;'
        ].join('\n');

    // Count keyframes & add expression
    var numKeys = 1;
    for (var i = 0, n = props.length; i < n; i++)
    {
        var p = props[i];

        var pInfo = new DuAEProperty(p);
        p = pInfo.getProperty();

        if (!pInfo.riggable()) continue;
        var np = p.numKeys;
        if (np < 2) continue;

        // count keyframes
        if (numKeys < 2 )  numKeys = np;
        else if (np < numKeys) numKeys = np;

        // add expression
        p.expression = [DuAEExpression.Id.KEY_MORPH,
            'var cumulative = !effect("' + kmEffectName + '")(' + kmp['Weights'].index + ').value;',
            '',
            'var result = zero();',
            'var weights = [];',
            'var sumWeights = 0;',
            'var nKeys = 0;',
            'var thisIsPath = isPath(thisProperty);',
            '',
            '// If path, oVal must be a path',
            'var oVal;',
            'if (thisIsPath) oVal = getPath(0);',
            'else oVal = valueAtTime(0);',
            '',
            DuAEExpression.Library.get([
                'zero',
                'isPath',
                'getPath',
                'addPath',
                'subPath',
                'multPath',
                'multPoints',
                'addPoints',
                'subPoints',
                'checkDuikEffect',
                'normalizeWeights',
            ]),
            '',
            '// Get weights',
            'var k = 0;',
            'for (var i = 1, n = thisLayer("Effects").numProperties; i <= n; i++) {',
            '	var fx = effect(i);',
            '	if (!checkDuikEffect( thisLayer.effect(i), "key morph k")) continue;',
            '	k++;',
            '	if (k > numKeys) break;',
            '	var weight = fx(' + kmkp['Weight'].index + ').value / 100;',
            '	weights.push(weight);',
            '	sumWeights += weight;',
            '	if (weight > 0 && !(cumulative && k == 1)) nKeys++;',
            '}',
            '',
            '// Normalize',
            'if (!cumulative)',
            '{',
            '  weights = normalizeWeights(weights, sumWeights);',
            '  sumWeights = 1;',
            '}',
            '',
            '// Sum',
            'for (var i = 0, n = weights.length; i < n; i++)',
            '{',
            '  if (i > numKeys) break;',
            '  if (cumulative && i == 0) continue;',
            '  var w = weights[i];',
            '  if (w == 0) continue;',
            '  if( thisIsPath ) {',
            '    var p = getPath( key(i+1).time );',
            '    result = addPath(result, p, w);',
            '    if (cumulative) result = addPath(result, oVal, (1-w));',
            '  }',
            '  else {',
            '    result += key(i+1).value * w;',
            '    if (cumulative) result += oVal * (1-w);',
            '  }',
            '  ',
            '}',
            '',
            '// Weights',
            'if (nKeys > 0) {',
            '  if (!cumulative)',
            '  {',
            '    if (thisIsPath) result = multPath( result, 1 / sumWeights);',
            '    else result /= sumWeights;',
            '  }',
            '  else if (nKeys > 1)',
            '  {',
            '    if (thisIsPath) result = subPath( result, oVal, 1);',
            '    else result -= oVal;',
            '  }',
            '}',
            ' else {',
            '	if (thisIsPath) result = getPath(0);',
            '	else result = valueAtTime(0);',
            '}',
            '',
            'if (thisIsPath) createPath(result.points, result.inTangents, result.outTangents, isClosed());',
            'else result;'
            ].join('\n');
        
    }

    // Add Key effects
    for (var i = 0; i < numKeys; i++)
    {
        var kmkFX = peKMK.apply(layer);

        // Weight expression
        kmkFX(kmkp['Weight'].index).expression = [DuAEExpression.Id.KEY_MORPH,
            'var selection = effect("' + kmEffectName + '")(' + kmp["Key Selection"].index + ');',
            'var thisIndex = thisProperty.propertyGroup(1)(' + kmkp["Key Index"].index + ').value;',
            '',
            DuAEExpression.Library.get([
                'getNextKey',
                'getPrevKey'
            ]),
            '',
            'function interpolate()',
            '{',
            '  var pK = getPrevKey(time, selection);',
            '  var nK = getNextKey(time, selection);',
            '',
            '  if (!pK && !nK && Math.round(selection.value) == thisIndex) return 100;',
            '	var nValue = 0;',
            '	var pValue = 0;',
            '	if(nK) nValue = Math.round(nK.value);',
            '	if(pK) pValue = Math.round(pK.value);',
            '  if (!pK && !nK) return 0;',
            '  if (!pK && nValue == thisIndex) return 100;',
            '  if (!pK) return 0;',
            '  if (!nK && pValue == thisIndex) return 100;',
            '  if (!nK) return 0;',
            '  if (pValue != thisIndex && nValue != thisIndex) return 0;',
            '  if (pValue == nValue) return 100;',
            '  if (pValue == thisIndex && pValue < nValue)',
            '      return linear( selection.value, nValue, pValue, 100, 0 );',
            '  if (pValue == thisIndex && pValue >= nValue)',
            '       return linear( selection.value, pValue, nValue, 0, 100 );',
            '  if (pValue < nValue)',
            '      return linear( selection.value, pValue, nValue, 0, 100 );',
            '  return linear( selection.value, pValue, nValue, 100, 0 );',
            '}',
            '',
            'var result = value + interpolate();',
            '',
            'result;'
            ].join('\n');

        kmkFX(kmkp['Key Index'].index).expression = [DuAEExpression.Id.KEY_MORPH,
            'var numK = 1;',
            '',
            DuAEExpression.Library.get([
                'checkDuikEffect'
            ]),
            '',
            'for (var i = 1, n = thisProperty.propertyGroup(1).propertyIndex; i < n; i++) {',
            '	if (!checkDuikEffect( thisLayer.effect(i), "key morph k")) continue;',
            '	numK++;',
            '}',
            '',
            'numK;'
            ].join('\n');
    }

    DuAE.endUndoGroup( DuScriptUI.String.DUIK_KEY_MORPH );
}

Duik.CmdLib['Constraint']["IK"] = "Duik.Constraint.ik()";
Duik.CmdLib['Constraint']["IK (3-layer)"] = "Duik.Constraint.ik(Duik.Constraint.IKType.THREE)";
Duik.CmdLib['Constraint']["IK (2+1-layer)"] = "Duik.Constraint.ik(Duik.Constraint.IKType.TWO_ONE)";
Duik.CmdLib['Constraint']["IK (1+2-layer)"] = "Duik.Constraint.ik(Duik.Constraint.IKType.ONE_TWO)";
Duik.CmdLib['Constraint']["Bézier IK"] = "Duik.Constraint.ik(undefined, true)";
/**
 * Creates an IK on the layers
 * @param {Duik.IKType} [type=Duik.Constraint.IKType.ONE_TWO] The type of IK to use with three layers.
 * @param {boolean} [forceBezier=false] - force the use of a bezier IK even with two or three layers
 * @param {Layer[]|LayerCollection|DuList.<Layer>|Layer} [layers=DuAEComp.getSelectedLayers()] The layer. If omitted, will use all selected layers in the comp
 * @param {Layer} [controller] - An already existing controller.
 * @return {Layer[]} The controller(s) of the IK.
 */
Duik.Constraint.ik = function ( type, forceBezier, layers, controller )
{
    layers = def(layers, DuAEComp.unselectLayers());
    layers = new DuList(layers);
    if (layers.length < 1) return [];

    DuAE.beginUndoGroup( DuScriptUI.String.IK, false);

    type = def(type, Duik.Constraint.IKType.ONE_TWO)
    forceBezier = def(forceBezier, false);
    controller = def(controller, null);

    //check if there is a controller in the selection
    if ( controller == null )
    {
        if ( layers.length < 2 ) return [];
        for ( var i = 0, n = layers.length(); i < n; i++ )
        {
            var l = layers.at( i );
            if ( Duik.Layer.isType( l, Duik.Layer.Type.CONTROLLER ) )
            {
                controller = l;
                layers.remove( i );
                break;
            }
        }
    }
    //sort layers and parent them
    layers = DuAELayer.sortByParent( layers );
    //reset rotation and scale if structures
    layers = new DuList( layers );
    layers.do( Duik.Bone.resetTransform );
    //parent
    DuAELayer.parentChain( layers );

    //check if the last one is a goal
    var withGoal = true;
    if ( controller != null )
    {
        var l = layers.last();
        //check position
        var distance = DuAELayer.getDistance( controller, l );
        if ( distance > 10 ) withGoal = false;
    }
    var goal = null;
    if ( withGoal ) goal = layers.pop();

    if ( layers.length() == 1 && !forceBezier ) controller = [ Duik.Constraint.oneLayerIK( layers.at(0), goal, controller ) ];
    else if ( layers.length() == 2 && !forceBezier ) controller = [ Duik.Constraint.twoLayerIK( layers.at(0), layers.at(1), goal, controller ) ];
    else if ( layers.length() == 3 && !forceBezier && type ==  Duik.Constraint.IKType.ONE_TWO ) controller = [ Duik.Constraint.oneTwoLayerIK( layers.at(0), layers.at(1), layers.at(2), goal, controller ) ];
    else if ( layers.length() == 3 && !forceBezier && type ==  Duik.Constraint.IKType.TWO_ONE ) controller = [ Duik.Constraint.twoOneLayerIK( layers.at(0), layers.at(1), layers.at(2), goal, controller ) ];
    else if ( layers.length() == 3 && !forceBezier && type ==  Duik.Constraint.IKType.THREE ) controller = [ Duik.Constraint.threeLayerIK( layers.at(0), layers.at(1), layers.at(2), goal, controller ) ];
    else controller = Duik.Constraint.bezierIK( layers, goal, controller );

    DuAE.endUndoGroup( DuScriptUI.String.IK );

    return controller;
}

/**
 * Creates a one-layer-ik on the layer
 * @param {Layer} layer - The layer
 * @param {Layer|null} [goal] - The goal layer, at the end of the IK
 * @param {Layer|Controller|null} [controller] - The layer to use as a controller, can be automatically created.<br />
 * Must be provided if goal is undefined
 * @return {Layer} The controller created
 */
Duik.Constraint.oneLayerIK = function (layer, goal, controller )
{
    goal = def(goal, null);
    controller = def(controller, null);
    if ( controller == null && goal == null ) throw "You must provide either a goal layer or a controller";
    var comp = layer.containingComp;

    var drawGuides = true;

    //Create controller
    if ( controller == null )
    {
        controller = Duik.Controller.create( comp,  Duik.Controller.Type.TRANSFORM, goal );
    }
    if ( !( controller instanceof ShapeLayer ) ) drawGuides = false;

    //is right ?
    var ctrlPos = DuAELayer.getWorldPos( controller );
    var layerPos = DuAELayer.getWorldPos( layer );

    var right = ( ctrlPos[ 0 ] - layerPos[ 0 ] ) < 0;

    //Add Effect
    var name = layer.name;
    if ( goal != null ) name = goal.name;
    var pe = Duik.PseudoEffect.ONE_LAYER_IK
    var effect = pe.apply( controller, DuScriptUI.String.IK + ' | ' + name );

    //indices
    var reverseIndex = pe.props["Advanced"]["Full rotation limit"].index;
    var layerIndex = pe.props["Data"]["Layer"].index;
    var ikIndex = pe.props["IK"].index;
    var guidesIndex = pe.props["Display"]["Draw guides"].index;
    var weightIndex = pe.props["Weight"].index;
    var fkIndex = pe.props["FK"].index;
    var parentIndex = pe.props["Advanced"]["Parent rotation"].index;
    var ulIndex = pe.props["Limits"]["Upper limit"].index;
    var llIndex = pe.props["Limits"]["Lower limit"].index;
    var lsIndex = pe.props["Limits"]["Softness"].index;
    
    //default values
    if ( right ) effect( reverseIndex ).setValue( 1 );
    effect( layerIndex ).setValue( layer.index );
    effect( ulIndex ).setValue( 180 );
    effect( llIndex ).setValue( -180 );

    //guides
    if ( DuAE.version.version >= 15 && drawGuides )
    {
        var lineGroup = controller( "ADBE Root Vectors Group" ).property( 'IK Line' );
        if ( !lineGroup )
        {
            lineGroup = controller( "ADBE Root Vectors Group" ).addProperty( "ADBE Vector Group" );
            lineGroup.name = 'IK Line';
        }
        var lineContent = lineGroup.property( "ADBE Vectors Group" );
        var shape = lineContent.addProperty( "ADBE Vector Shape - Group" );
        shape( 'ADBE Vector Shape' ).expression = [DuAEExpression.Id.ONE_IK,
            'var fx = effect("' + effect.name + '");',
            'var layer1 = null;',
            'var result = [[0,0]];',
            'if (fx(' + ikIndex + ').value && fx(' + guidesIndex + ').value)',
            '{',
            '   try{ layer1 = fx(' + layerIndex + '); }catch(e){}',
            '   if (layer1!=null)',
            '   {',
            '       var l = layer1.toWorld(layer1.anchorPoint);',
            '       l = fromWorld(l);',
            '       result = [l,[0,0]];',
            '   }',
            '}',
            'createPath(result,[],[],false);'
            ].join('\n');
        var stroke = lineContent.property( "ADBE Vector Graphic - Stroke" );
        var ctrlEffect = controller.effect( Duik.PseudoEffect.CONTROLLER.matchName );
        if ( !stroke ) stroke = lineContent.addProperty( "ADBE Vector Graphic - Stroke" );
        if ( ctrlEffect ) stroke( "ADBE Vector Stroke Color" ).expression = DuAEExpression.Id.CONTROLLER + '\neffect("' + ctrlEffect.name + '")(' + Duik.PseudoEffect.CONTROLLER.props['Icon']['Color'].index + ')-[0.2,0.2,0.2,0]';
        stroke( "ADBE Vector Stroke Width" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Line Cap" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
        stroke( "ADBE Vector Stroke Dashes" )( "ADBE Vector Stroke Dash 1" ).setValue( 5 );

        var limitsGroup = controller( "ADBE Root Vectors Group" ).property( 'IK Limits' );
        if ( !limitsGroup )
        {
            limitsGroup = controller( "ADBE Root Vectors Group" ).addProperty( "ADBE Vector Group" );
            limitsGroup.name = 'IK Limits';
        }
        limitsGroup.transform.position.expression = [DuAEExpression.Id.ONE_IK,
            'var fx = effect("' + effect.name + '");',
            'var l = null;',
            'try{ l = fx(' + layerIndex + '); }catch(e){}',
            'var result = value;',
            'if (l != null)',
            '{',
            '	var p = l.toWorld(l.anchorPoint);',
            '	result = fromWorld(p);',
            '}',
            'result;'
            ].join('\n');

        var limitLinesGroup = limitsGroup.property( "ADBE Vectors Group" ).addProperty( "ADBE Vector Group" );
        limitsGroup.name = 'Limit Lines';
        limitLinesGroup.transform.rotation.expression = [DuAEExpression.Id.ONE_IK,
            DuAEExpression.Library.get(['getOrientation']),
            '',
            'var fx = effect("' + effect.name + '");',
            'var layer1 = null;',
            'var result = value;',
            'if (fx(' + ikIndex + ').value && fx(' + guidesIndex + ').value)',
            '{',
            '   try{ layer1 = fx(' + layerIndex + '); }catch(e){}',
            '   if (layer1 != null)',
            '   {',
            '       if (layer1.hasParent) result = getOrientation(layer1.parent);',
            '   }',
            '}',
            'result;'
            ].join('\n');

        var limitLinesContent = limitLinesGroup.property( "ADBE Vectors Group" );
        var lLimitGroup = limitLinesContent.addProperty( "ADBE Vector Group" );
        lLimitGroup.name = 'Lower Limit';
        lLimitGroup.transform.rotation.expression = [DuAEExpression.Id.ONE_IK,
            'var fx = effect("' + effect.name + '");',
            'fx(' + llIndex + ').value-180;'
            ].join('\n');

        var lLimitContent = lLimitGroup.property( "ADBE Vectors Group" );
        lLimitShape = lLimitContent.addProperty( "ADBE Vector Shape - Group" );
        lLimitShape( 'ADBE Vector Shape' ).expression = [DuAEExpression.Id.ONE_IK,
            'var fx = effect("' + effect.name + '");',
            'var layer1 = null;',
            'var result = [[0,0]];',
            'if (fx(' + ikIndex + ').value && fx(' + guidesIndex + ').value)',
            '{',
            '   try{ layer1 = fx(' + layerIndex + '); }catch(e){}',
            '   if (layer1!=null)',
            '   {',
            '       var l = layer1.toWorld(layer1.anchorPoint);',
            '       l = fromWorld(l);',
            '       l = length(l) * .8;',
            '       if (!fx(' + reverseIndex + ').value) l = -l;',
            '       result = [[l,0],[0,0]];',
            '   }',
            '}',
            'createPath(result,[],[],false);'
            ].join('\n');
        
        stroke = lLimitContent.addProperty( "ADBE Vector Graphic - Stroke" );
        if ( ctrlEffect ) stroke( "ADBE Vector Stroke Color" ).expression = DuAEExpression.Id.CONTROLLER + '\neffect("' + ctrlEffect.name + '")(' + Duik.PseudoEffect.CONTROLLER.props['Icon']['Color'].index + ')-[0.2,0.2,0.2,0]';
        stroke( "ADBE Vector Stroke Width" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Line Cap" ).setValue( 2 );

        var uLimitGroup = limitLinesContent.addProperty( "ADBE Vector Group" );
        uLimitGroup.name = 'Upper Limit';
        uLimitGroup.transform.rotation.expression = [DuAEExpression.Id.ONE_IK,
            'var fx = effect("' + effect.name + '");',
            'fx(' + ulIndex + ').value-180;'
            ].join('\n');

        var uLimitContent = uLimitGroup.property( "ADBE Vectors Group" );
        uLimitShape = uLimitContent.addProperty( "ADBE Vector Shape - Group" );
        uLimitShape( 'ADBE Vector Shape' ).expression = [DuAEExpression.Id.ONE_IK,
            'var fx = effect("' + effect.name + '");',
            'var layer1 = null;',
            'var result = [[0,0]];',
            'if (fx(' + ikIndex + ').value && fx(' + guidesIndex + ').value)',
            '{',
            '   try{ layer1 = fx(' + layerIndex + '); }catch(e){}',
            '   if (layer1!=null)',
            '   {',
            '       var l = layer1.toWorld(layer1.anchorPoint);',
            '       l = fromWorld(l);',
            '       l = length(l) * .8;',
            '       if (!fx(' + reverseIndex + ').value) l = -l;',
            '       result = [[l,0],[0,0]];',
            '   }',
            '}',
            'createPath(result,[],[],false);'
            ].join('\n');
        
        stroke = uLimitContent.addProperty( "ADBE Vector Graphic - Stroke" );
        if ( ctrlEffect ) stroke( "ADBE Vector Stroke Color" ).expression = DuAEExpression.Id.CONTROLLER + '\neffect("' + ctrlEffect.name + '")(' + Duik.PseudoEffect.CONTROLLER.props['Icon']['Color'].index + ')-[0.2,0.2,0.2,0]';
        stroke( "ADBE Vector Stroke Width" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Line Cap" ).setValue( 2 );

        var lSftnssGroup = limitLinesContent.addProperty( "ADBE Vector Group" );
        lSftnssGroup.name = 'Lower Softness';
        lSftnssGroup.transform.rotation.expression = [DuAEExpression.Id.ONE_IK,
            'var fx = effect("' + effect.name + '");',
            'fx(' + llIndex + ').value-180+fx(' + lsIndex + ').value;'
            ].join('\n');

        var lSftnssContent = lSftnssGroup.property( "ADBE Vectors Group" );
        lSftnssShape = lSftnssContent.addProperty( "ADBE Vector Shape - Group" );
        lSftnssShape( 'ADBE Vector Shape' ).expression = [DuAEExpression.Id.ONE_IK,
            'var fx = effect("' + effect.name + '");',
            'var layer1 = null;',
            'var result = [[0,0]];',
            'if (fx(' + ikIndex + ').value && fx(' + guidesIndex + ').value)',
            '{',
            '   try{ layer1 = fx(' + layerIndex + '); }catch(e){}',
            '   if (layer1!=null)',
            '   {',
            '       var l = layer1.toWorld(layer1.anchorPoint);',
            '       l = fromWorld(l);',
            '       l = length(l) * .5;',
            '       if (!fx(' + reverseIndex + ').value) l = -l;',
            '       result = [[l,0],[0,0]];',
            '   }',
            '}',
            'createPath(result,[],[],false);'
            ].join('\n');
        
        stroke = lSftnssContent.addProperty( "ADBE Vector Graphic - Stroke" );
        if ( ctrlEffect ) stroke( "ADBE Vector Stroke Color" ).expression = DuAEExpression.Id.CONTROLLER + '\neffect("' + ctrlEffect.name + '")(' + Duik.PseudoEffect.CONTROLLER.props['Icon']['Color'].index + ')-[0.2,0.2,0.2,0]';
        stroke( "ADBE Vector Stroke Width" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Line Cap" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
        stroke( "ADBE Vector Stroke Dashes" )( "ADBE Vector Stroke Dash 1" ).setValue( 5 );

        var uSftnssGroup = limitLinesContent.addProperty( "ADBE Vector Group" );
        uSftnssGroup.name = 'Upper Softness';
        uSftnssGroup.transform.rotation.expression = [DuAEExpression.Id.ONE_IK,
            'var fx = effect("' + effect.name + '");',
            'fx(' + ulIndex + ').value-180-fx(' + lsIndex + ').value;'
            ].join('\n');

        var uSftnssContent = uSftnssGroup.property( "ADBE Vectors Group" );
        uSftnssShape = uSftnssContent.addProperty( "ADBE Vector Shape - Group" );
        uSftnssShape( 'ADBE Vector Shape' ).expression = [DuAEExpression.Id.ONE_IK,
            'var fx = effect("' + effect.name + '");',
            'var layer1 = null;',
            'var result = [[0,0]];',
            'if (fx(' + ikIndex + ').value && fx(' + guidesIndex + ').value)',
            '{',
            '   try{ layer1 = fx(' + layerIndex + '); }catch(e){}',
            '   if (layer1!=null)',
            '   {',
            '       var l = layer1.toWorld(layer1.anchorPoint);',
            '       l = fromWorld(l);',
            '       l = length(l) * .5;',
            '       if (!fx(' + reverseIndex + ').value) l = -l;',
            '       result = [[l,0],[0,0]];',
            '   }',
            '}',
            'createPath(result,[],[],false);'
            ].join('\n');
        
        stroke = uSftnssContent.addProperty( "ADBE Vector Graphic - Stroke" );
        if ( ctrlEffect ) stroke( "ADBE Vector Stroke Color" ).expression = DuAEExpression.Id.CONTROLLER + '\neffect("' + ctrlEffect.name + '")(' + Duik.PseudoEffect.CONTROLLER.props['Icon']['Color'].index + ')-[0.2,0.2,0.2,0]';
        stroke( "ADBE Vector Stroke Width" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Line Cap" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Dashes" ).addProperty( "ADBE Vector Stroke Dash 1" );
        stroke( "ADBE Vector Stroke Dashes" )( "ADBE Vector Stroke Dash 1" ).setValue( 5 );

        var flGroup = limitsGroup.property( "ADBE Vectors Group" ).addProperty( "ADBE Vector Group" );
        flGroup.name = 'Flip Line';
        var flContent = flGroup.property( "ADBE Vectors Group" );
        flShape = flContent.addProperty( "ADBE Vector Shape - Group" );
        flShape( 'ADBE Vector Shape' ).expression = [DuAEExpression.Id.ONE_IK,
            'var fx = effect("' + effect.name + '");',
            'var layer1 = null;',
            'var result = [[0,0]];',
            'if (fx(' + ikIndex + ').value && fx(' + guidesIndex + ').value)',
            '{',
            '   try{ layer1 = fx(' + layerIndex + '); }catch(e){}',
            '   if (layer1!=null)',
            '   {',
            '       var l = layer1.toWorld(layer1.anchorPoint);',
            '       l = fromWorld(l);',
            '       l = length(l) * .3;',
            '       if (!fx(' + reverseIndex + ').value) l = -l;',
            '       result = [[l,0],[0,0]];',
            '   }',
            '}',
            'createPath(result,[],[],false);'
            ].join('\n');
        
        stroke = flContent.addProperty( "ADBE Vector Graphic - Stroke" );
        if ( ctrlEffect ) stroke( "ADBE Vector Stroke Color" ).expression = DuAEExpression.Id.CONTROLLER + '\n' + DuColor.Color.RAINBOX_RED.floatRGBA().toSource();
        stroke( "ADBE Vector Stroke Width" ).setValue( 2 );
        stroke( "ADBE Vector Stroke Line Cap" ).setValue( 2 );

        //close controller details
        controller.selected = true;
        DuAE.executeCommand( DuAE.MenuCommandID.REVEAL_EXPRESSION_ERRORS, true );
    }

    //Add Data
    var layerData = layer('ADBE Effect Parade').addProperty('ADBE Layer Control');
    layerData.name = DuScriptUI.String.IK;
    layerData( 1 ).setValue( controller.index );
    //Expression
    var expr = [DuAEExpression.Id.ONE_IK,
        'var ctrl = null;',
        'var result = 0;',
        'try {',
        '	ctrl = effect("' + layerData.name + '")(1);',
        '} catch (e) {',
        '	result = value;',
        '}',
        'if (ctrl != null) {',
        '	var C = ctrl.toWorld(ctrl.anchorPoint);',
        '	var O = thisLayer.toWorld(thisLayer.anchorPoint);',
        '	var fx = ctrl.effect("' + effect.name + '");',
        '	var weight = fx(' + weightIndex + ').value / 100;',
        '	var fk = fx(' + fkIndex + ').value;',
        '	var rev = fx(' + reverseIndex + ').value;',
        '	var useIK = fx(' + ikIndex + ').value;',
        '	var parentRot = fx(' + parentIndex + ').value;',
        '	var uLimit = fx(' + ulIndex + ').value;',
        '	var lLimit = fx(' + llIndex + ').value;',
        '	var lmtSftnss = fx(' + lsIndex + ').value;',
        '	result = fk;',
        '	if (useIK) {',
        '		var vec = rev == 1 ? O - C : C - O;',
        '		var layer = thisLayer;',
        '		if (layer.hasParent && parentRot) result += layer.parent.rotation.value;',
        '		while (layer.hasParent) {',
        '			layer = layer.parent;',
        '			result = result - layer.rotation;',
        '		}',
        '		var angle = Math.atan2(vec[1], vec[0]);',
        '		angle = radiansToDegrees(angle);',
        '		angle = angle * weight;',
        '		result += angle;',
        '	}',
        '	',
        '	uLimit = uLimit - lmtSftnss;',
        '	lLimit = lLimit + lmtSftnss;',
        '	if (result > uLimit)',
        '	{',
        '	  if (lmtSftnss == 0) result = uLimit;',
        '	  else result = uLimit + lmtSftnss - lmtSftnss/(1 + (result - uLimit)/lmtSftnss);',
        '	}',
        '	else if (result < lLimit)',
        '	{',
        '	  if (lmtSftnss == 0) result = lLimit;',
        '	  else result = lLimit - lmtSftnss + lmtSftnss/(1 + (lLimit-result)/lmtSftnss);',
        '	}',
        '	',
        '	result += value;',
        '}',
        'result;'
        ].join('\n');

    var rotProp = new DuAEProperty( layer.transform.rotation );
    rotProp.setExpression( expr );

    if ( goal != null )
    {
        var goalData = layer('ADBE Effect Parade').addProperty('ADBE Layer Control');
        goalData.name = DuScriptUI.String.IK;
        goalData( 1 ).setValue( controller.index );
        expr = [DuAEExpression.Id.ONE_IK,
            'var ctrl = null;',
            'var result = value;',
            'try { ctrl = effect("' + goalData.name + '")(1); } catch (e){ value };',
            'if (ctrl != null)',
            '{',
            'var goal = ctrl.effect("' + effect.name + '")(' + ikIndex +').value;',
            'result += ctrl.rotation.value;',
            'if (goal)',
            '{',
            'var layer = thisLayer;',
            'while (layer.hasParent)',
            '{',
            'layer = layer.parent;',
            'result = result - layer.rotation;',
            '}',
            '}',
            '}',
            'result;'
            ].join('\n');

        rotProp = new DuAEProperty( goal.transform.rotation );
        rotProp.setExpression( expr );
    }

    return controller;
}