/**
 * Constraint tools.
 * @namespace
 */
Duik.Constraint = {};

/**
 * The list of constraint functions
 */
Duik.CmdLib['Constraint'] = [];

Duik.CmdLib['Constraint']["List"] = "Duik.Constraint.list()";
/**
 * List
 */
Duik.Constraint.list = function ( )
{
    var props = DuAEComp.getSelectedProps();
	if (props.length == 0) return;

	DuAE.beginUndoGroup( DuScriptUI.String.LIST );

	var layers = DuAEComp.unselectLayers();
	for (var i = 0, n = props.length; i < n ; i++)
	{
		Duik.Constraint.createList(props[i]);
	}
	DuAEComp.selectLayers(layers);

	DuAE.endUndoGroup();
}

/**
	* Adds a list on a property
	* @param {Property|DuAEProperty} prop - The Property
    * @returns {DuAEProperty} The list effect
*/
Duik.Constraint.createList = function (prop)
{
	prop = new DuAEProperty(prop);
    if (!prop.riggable()) return;

	var dim = prop.dimensions();

	var layer = prop.layer;

	var effect = null;
	var name = prop.getProperty().name + ' List';
	if (dim == 1) effect = Duik.PseudoEffect.ONED_LIST.apply(layer, name);
	else if (dim == 2) effect = Duik.PseudoEffect.TWOD_LIST.apply(layer, name);
	else if (dim == 3) effect = Duik.PseudoEffect.THREED_LIST.apply(layer, name);
	else return;

	//set animation with expression
	var anim = prop.animation(false);
	if (anim)
    {
        var newProp = new DuAEProperty(effect(2));
        newProp.setAnim(anim,0,true,true,false);
    }
	prop.removeAnimation();

	prop.getProperty().expression =  [DuAEExpression.Id.LIST,
        "var fx = effect(\"" + effect.name + "\");",
        "var v1 = fx(2);",
        "var w1 = fx(3);",
        "var v2 = fx(6);",
        "var w2 = fx(7);",
        "var v3 = fx(10);",
        "var w3 = fx(11);",
        "var v4 = fx(14);",
        "var w4 = fx(15);",
        "var v5 = fx(18);",
        "var w5 = fx(19);",
        "v1*w1/100+v2*w2/100+v3*w3/100+v4*w4/100+v5*w5/100;"
        ].join('\n');

    return prop;
}

Duik.CmdLib['Constraint']["Separate Dimensions"] = "Duik.Constraint.separateDimensions()";
/**
 * Separate Dimensions
 */
Duik.Constraint.separateDimensions = function ()
{
    var props = DuAEComp.getSelectedProps();
    if ( props.length == 0 ) return;

    DuAE.beginUndoGroup( DuScriptUI.String.SEPARATE_DIMENSIONS );

    for ( var i = 0, num = props.length; i < num; i++ )
    {
        Duik.Constraint.separatePropDimensions( props[ i ] );
    }

    DuAE.endUndoGroup();
}

/**
 * Separates the dimensions of the properties into an effect.<br />
 * Works with 2D, 3D, and colors
 * @param {Property|DuAEProperty} prop - The property
 * @return {DuAEProperty[]} The seperated properties (or the original one if it could not be separated)
 */
Duik.Constraint.separatePropDimensions = function ( prop )
{
    var propInfo = new DuAEProperty( prop );
    prop = propInfo.getProperty();

    var layer = propInfo.layer;
    var dim = propInfo.dimensions();

    if ( dim < 2 || dim > 4 ) return [propInfo];

    if (prop.isSeparationLeader)
    {
        prop.dimensionsSeparated = true;
        var newProps = [];
        for (var i = 1; i <= dim; i++)
        {
            var newProp = prop.parentProperty(prop.propertyIndex + i);
            newProp = new DuAEProperty(newProp);
            newProps.push( newProp );
        }
        return newProps;
    }

    if ( dim == 2 )
    {
        var pseudo;
        if ( propInfo.isScale ) pseudo = Duik.PseudoEffect.TWO_DIMENSIONS_SCALE;
        else if ( propInfo.isAngle ) pseudo = Duik.PseudoEffect.TWO_DIMENSIONS_ANGLE;
        else pseudo = Duik.PseudoEffect.TWO_DIMENSIONS;

        var effect = pseudo.apply( layer, propInfo.name + " XY" );

        prop = propInfo.getProperty();

        var xIndex = pseudo.props['X'].index;
        var yIndex = pseudo.props['Y'].index;

        //copy values
        if ( prop.numKeys == 0 )
        {
            effect( xIndex ).setValue( prop.value[ 0 ] );
            effect( yIndex ).setValue( prop.value[ 1 ] );
        }
        else
        {
            for ( var k = prop.numKeys; k > 0; k-- )
            {
                var time = prop.keyTime( k );
                var value = prop.keyValue( k );
                effect( xIndex ).setValueAtTime( time, value[ 0 ] );
                effect( yIndex ).setValueAtTime( time, value[ 1 ] );
                prop.removeKey(k);
            }
        }

        //add expression
        prop.expression = [DuAEExpression.Id.SEPARATE_DIMENSIONS,
            'var fx = thisLayer.effect("' + effect.name + '");',
            '[fx(' + xIndex + ').value,fx(' + yIndex + ').value];'
            ].join('\n');

        //return the new props
        var xProp = new DuAEProperty(effect( xIndex ));
        var yProp = new DuAEProperty(effect( yIndex ));
        return [xProp,yProp];
    }
    
    if ( dim == 3 )
    {
        var pseudo;
        if ( propInfo.isScale ) pseudo = Duik.PseudoEffect.THREE_DIMENSIONS_SCALE;
        else if ( propInfo.isAngle ) pseudo = Duik.PseudoEffect.THREE_DIMENSIONS_ANGLE;
        else pseudo = Duik.PseudoEffect.THREE_DIMENSIONS;

        var effect = pseudo.apply( layer, propInfo.name + " XYZ" );

        prop = propInfo.getProperty();

        var xIndex = pseudo.props['X'].index;
        var yIndex = pseudo.props['Y'].index;
        var zIndex = pseudo.props['Z'].index;

        //copy values
        if ( prop.numKeys == 0 )
        {
            effect( xIndex ).setValue( prop.value[ 0 ] );
            effect( yIndex ).setValue( prop.value[ 1 ] );
            effect( zIndex ).setValue( prop.value[ 2 ] );
        }
        else
        {
            for ( var k = prop.numKeys; k > 0; k-- )
            {
                var time = prop.keyTime( k );
                var value = prop.keyValue( k );
                effect( xIndex ).setValueAtTime( time, value[ 0 ] );
                effect( yIndex ).setValueAtTime( time, value[ 1 ] );
                effect( zIndex ).setValueAtTime( time, value[ 2 ] );
                prop.removeKey(k);
            }
        }

        //add expression
        prop.expression = [DuAEExpression.Id.SEPARATE_DIMENSIONS,
            'var fx = thisLayer.effect("' + effect.name + '");',
            '[fx(' + xIndex + ').value,fx(' + yIndex + ').value, fx(' + zIndex + ').value];'
            ].join('\n');

        //return the new props
        var xProp = new DuAEProperty(effect( xIndex ));
        var yProp = new DuAEProperty(effect( yIndex ));
        var zProp = new DuAEProperty(effect( zIndex ));
        return [xProp,yProp,zProp];
    }
    
    if ( dim == 4 )
    {
        var pseudo = Duik.PseudoEffect.COLOR;
        var effect = pseudo.apply( layer, propInfo.name + " RGB/HSL" );

        var modeIndex = pseudo.props['Channels'].index;
        var rIndex = pseudo.props['R / H'].index;
        var gIndex = pseudo.props['G / S'].index;
        var bIndex = pseudo.props['B / L'].index;

        effect( modeIndex ).setValue( 2 );
        prop = propInfo.getProperty();

        //copy values
        if ( prop.numKeys == 0 )
        {
            var color = prop.value;
            color = new DuColor(color).floatHSL();
            effect( rIndex ).setValue( color[ 0 ] );
            effect( gIndex ).setValue( color[ 1 ] );
            effect( bIndex ).setValue( color[ 2 ] );
        }
        else
        {
            for ( var k = prop.numKeys; k > 0; k-- )
            {
                var time = prop.keyTime( k );
                var value = prop.keyValue( k );
                value = new DuColor(value).floatHSL();
                effect( rIndex ).setValueAtTime( time, value[ 0 ] );
                effect( gIndex ).setValueAtTime( time, value[ 1 ] );
                effect( bIndex ).setValueAtTime( time, value[ 2 ] );
                prop.removeKey(k);
            }
        }

        //add expression
        prop.expression = [DuAEExpression.Id.SEPARATE_DIMENSIONS,
            'var fx = thisLayer.effect("' + effect.name + '");',
            'var color = [fx(' + rIndex + ').value,fx(' + gIndex + ').value, fx(' + bIndex + ').value, 1];',
            'if (fx(' + modeIndex + ').value == 2) hslToRgb(color);',
            'else color;'
            ].join('\n');

        //return the new props
        var xProp = new DuAEProperty(effect( rIndex ));
        var yProp = new DuAEProperty(effect( gIndex ));
        var zProp = new DuAEProperty(effect( bIndex ));
        return [xProp,yProp,zProp];
    }
}

Duik.CmdLib['Constraint']["Lock"] = "Duik.Constraint.lock()";
/**
 * Lock propery values
 */
Duik.Constraint.lock = function ()
{
    var props = DuAEComp.getSelectedProps();
    if ( props.length == 0 ) return;

    DuAE.beginUndoGroup( DuScriptUI.String.LOCK_PROPERTIES );

    DuAEProperty.lock( props );

    DuAE.endUndoGroup();
}

Duik.CmdLib['Constraint']["Zero"] = "Duik.Constraint.zero()";
/**
 * Zero-out selected layers
 * @param {Layer[]|LayerCollection|DuList.<Layer>|Layer} [layers=DuAEComp.getSelectedLayers()] The layer. If omitted, will use all selected layers in the comp
 * @returns {ShapeLayer[]} The zeroes
 */
Duik.Constraint.zero = function( layers )
{
    layers = def(layers, DuAEComp.getSelectedLayers());
    layers = new DuList(layers);

    DuAE.beginUndoGroup( DuScriptUI.String.ADD_ZERO, false );
    DuAEProject.setProgressMode(true);

    var zeroes = [];

    layers.do( function(layer)
    {
        //create null object
        var zero = DuAEComp.addNull( layer.containingComp );
        var layerparent = layer.parent;
        layer.parent = null;
        zero.position.setValue( layer.position.value );
        zero.rotation.setValue( layer.rotation.value );
        
        Duik.Layer.copyAttributes( zero, layer, Duik.Layer.Type.ZERO );

        layer.parent = zero;
        zero.scale.setValue( layer.scale.value );
        layer.scale.setValue( [ 100, 100, 100 ] );

        //parent
        zero.parent = layerparent;

        //lock and hide
        zero.moveToEnd();
        zero.shy = true;
        zero.enabled = false;
        zero.selected = false;
        zero.locked = true;
        zeroes.push(zero);
    } );

    DuAEProject.setProgressMode(false);
    DuAE.endUndoGroup( DuScriptUI.String.ADD_ZERO );

    return zeroes;
}

Duik.CmdLib['Constraint']["Reset Transformation"] = "Duik.Constraint.resetPRS()";
Duik.CmdLib['Constraint']["Reset Transformation and opacity"] = "Duik.Constraint.resetPRS(undefined, true)";
/**
 * Resets the transformation of the selected layers to 0.
 * @param {Layer[]|LayerCollection|DuList.<Layer>|Layer} [layers=DuAEComp.getSelectedLayers()] The layer. If omitted, will use all selected layers in the comp
 * @param {Boolean} [opacity=false] When true, also resets the opacity to 100%
 */
Duik.Constraint.resetPRS = function( layers, opacity )
{
    opacity = def(opacity, false);
    layers = def(layers, DuAEComp.getSelectedLayers());
    layers = new DuList(layers);

    DuAE.beginUndoGroup( DuScriptUI.String.RESET_TRANSFORMATION, false );
    DuAEProject.setProgressMode(true);

    layers.do( function(layer)
    {
        var comp = layer.containingComp;
        //is it 3D?
        var threeD = layer.threeDLayer;
        //has parent ?
        var parent = layer.parent !== null;
        if (threeD)
        {
            var positionValue = parent ? [0,0,0] : [comp.width / 2, comp.height / 2, 0];
            if (layer.transform.position.dimensionsSeparated)
            {
                layer.transform.xPosition.setValue(positionValue[0]);
                layer.transform.yPosition.setValue(positionValue[1]);
                layer.transform.zPosition.setValue(positionValue[2]);
            }
            else 
            {
                layer.transform.position.setValue(positionValue);
            }
            layer.transform.scale.setValue([100,100,100]);
            layer.transform.zRotation.setValue(0);
            layer.transform.xRotation.setValue(0);
            layer.transform.yRotation.setValue(0);
            layer.transform.orientation.setValue([0,0,0]);
        }
        else
        {
            var positionValue = parent ? [0,0] : [comp.width / 2, comp.height / 2];
            if (layer.transform.position.dimensionsSeparated)
            {
                layer.transform.xPosition.setValue(positionValue[0]);
                layer.transform.yPosition.setValue(positionValue[1]);
            }
            else 
            {
                layer.transform.position.setValue(positionValue);
            }
            layer.transform.scale.setValue([100,100]);
            layer.transform.rotation.setValue(0);
        }

        if (opacity) layer.transform.opacity.setValue(100);
    });

    DuAEProject.setProgressMode(false);
    DuAE.endUndoGroup( DuScriptUI.String.RESET_TRANSFORMATION );
}