

/**
 * Bone and armatures related tools.
 * @namespace
 */
Duik.Bone = {};

/**
 * The list of bone functions
 */
Duik.CmdLib['Bone'] = [];

Duik.CmdLib['Bone']["Custom_Limb"] = "Duik.Bone.customLimb()";
/**
 * Creates a custom limb.
 * @param {int} [num=2] - The number of bones in case nothing is selected in the comp. Otherwize, a bone is created for each selected path vertex/puppet pin/layer.
 * @param {string} [name='Limb'] - The name of the limb
 * @param {DuOCO.Side} [side=DuOCO.Side.NONE] - The side of the limb
 * @param {DuOCO.Location} [location=DuOCO.Location.NONE] - The location of the limb
 * @param {boolean} [forceLink=false] - Wether link the selected layers/properties to the new armature
 */
Duik.Bone.customLimb = function ( num, name, characterName, side, location, forceLink )
{
    // get current comp
    var comp = DuAEProject.getActiveComp();
    if (!comp) return;

    num = def( num, 2);
    forceLink = def( forceLink, false);
    name = def( name, tr('Limb'));
    if (name == '') name = tr('Limb');
    characterName = def( characterName, '');
    side = def( side, DuOCO.Side.NONE);
    location = def( location, DuOCO.Location.NONE);

    DuAE.beginUndoGroup("Create custom armature");
    DuAEProject.setProgressMode(true);

    var layers = DuAEComp.getSelectedLayers();

    // If there's no selected layer, just create
    if( layers.length == 0 )
    {
        var doc = DuOCODoc.fromComp( characterName, comp );
        var limb = doc.newLimb( DuOCO.Limb.CUSTOM, side, location );
        limb.newArmature( name, num );
        doc.toComp( comp );
        DuAEProject.setProgressMode(false);
        DuAE.endUndoGroup();
        return;
    }

    // Links
    var linkPath = def(DuESF.scriptSettings.data.armatureLinkPaths, false);
    if (forceLink) linkPath = !linkPath;
    var linkPuppetPins = def(DuESF.scriptSettings.data.armatureLinkPuppetPins, false);
    if (forceLink) linkPuppetPins = !linkPuppetPins;
    var linkLayers = def(DuESF.scriptSettings.data.armatureLinkLayers, false);
    if (forceLink) linkLayers = !linkLayers;

    // if we have a shape layer selected and its path, and only a path, we're going to remove it after creation.  
    var layerToRemove = null;
    if (layers.length == 1 && !linkPath)
    {
        var l = layers[0];
        if (DuAEShapeLayer.isSingleShape(l)) layerToRemove = l;
    }

    // For each selected layer
    var it = new DuList( layers );
    it.do( function( layer )
    {
        //get paths
        var props = DuAELayer.getSelectedProps( layer, DuAEProperty.isPathProperty );

        if ( props.length > 0 )
        {
            // Create a limb for each path
            for (var i = 0, n = props.length; i < n; i++)
            {
                var path = props[i];
                // create the OCODoc
                var doc = DuOCODoc.fromComp( characterName, comp );
                var limb = doc.newLimb( DuOCO.Limb.CUSTOM, side, location );
                limb.armatureFromPath( doc, name, path );
                // create
                var boneLayers = doc.toComp( comp );
                // link
                if (linkPath) Duik.Pin.linkPathToLayers( path, boneLayers );
            }
            if (layerToRemove) layerToRemove.remove();
            return;
        }

        //puppet pins
        props = DuAELayer.getSelectedProps( layer, "ADBE FreePin3 PosPin Atom" );
        if ( props.length > 0 )
        {
            // Create a limb for all selected pins
            // create the OCODoc
            var doc = DuOCODoc.fromComp( characterName, comp );
            var limb = doc.newLimb( DuOCO.Limb.CUSTOM, side, location );
            limb.armatureFromPuppetPins( doc, name, props );
            // create
            var boneLayers = doc.toComp( comp );
            // link
            if (linkPuppetPins) Duik.Pin.linkPuppetPinsToLayers( props, boneLayers );
            return;
        }

        //puppet effect
        props = DuAELayer.getSelectedProps( layer, "ADBE FreePin3" );
        if ( props.length > 0 )
        {
            // Get pins from each effect
            for(var i = 0, n = props.length; i < n; i++)
            {
                var pins = [];

                var meshGroup = props[i].property( "ADBE FreePin3 ARAP Group" ).property( "ADBE FreePin3 Mesh Group" );
                for ( var j = 1, numProps = meshGroup.numProperties; j <= numProps; j++ )
                {
                    var mesh = meshGroup( j );
                    var pinsGroup = mesh.property( "ADBE FreePin3 PosPins" );
                    for ( var k = 1, numPins = pinsGroup.numProperties; k <= numPins; k++ )
                    {
                        var pin = pinsGroup.property( k );
                        var test = new DuAEProperty( pin.property( "ADBE FreePin3 PosPin Position" ) );
                        if ( test.riggable() ) pins.push( new DuAEProperty( pin ) );
                    }
                }

                if (pins.length == 0) continue;

                // Create a limb for all pins
                // create the OCODoc
                var doc = DuOCODoc.fromComp( characterName, comp );
                var limb = doc.newLimb( DuOCO.Limb.CUSTOM, side, location );
                limb.armatureFromPuppetPins( doc, name, pins );
                // create
                var boneLayers = doc.toComp( comp );
                // link
                if (linkPuppetPins) Duik.Pin.linkPuppetPinsToLayers( pins, boneLayers );
            }
            return;
        }
    });

}

/**
 * Checks the side of the layer
 * @param {Layer} [layer] The layer. If omitted, will check the first selected bone of the current comp
 * @returns {DuOCO.Side}
 */
Duik.Bone.side = function( layer )
{
    layer = def(layer, DuAEProject.getActiveLayer());
    if (!layer) return DuOCO.Side.NONE;

    if ( DuGR.inGroups( layer, [DuScriptUI.String.LEFT] ) ) return DuOCO.Side.LEFT;
    if ( DuGR.inGroups( layer, [DuScriptUI.String.RIGHT] ) ) return DuOCO.Side.RIGHT;
    return DuOCO.Side.NONE;
}

/**
 * Checks the location of the layer
 * @param {Layer} [layer=DuAEProject.getActiveLayer] The layer. If omitted, will check the first selected bone of the current comp
 * @returns {DuOCO.Location}
 */
Duik.Bone.location = function( layer )
{
    layer = def(layer, DuAEProject.getActiveLayer());
    if (!layer) return DuOCO.Location.NONE;

    if ( DuGR.inGroups( layer, [DuScriptUI.String.FRONT] ) ) return DuOCO.Location.FRONT;
    if ( DuGR.inGroups( layer, [DuScriptUI.String.BACK] ) ) return DuOCO.Location.BACK;
    if ( DuGR.inGroups( layer, [DuScriptUI.String.MIDDLE] ) ) return DuOCO.Location.MIDDLE;
    if ( DuGR.inGroups( layer, [DuScriptUI.String.UNDER] ) ) return DuOCO.Location.UNDER;
    if ( DuGR.inGroups( layer, [DuScriptUI.String.ABOVE] ) ) return DuOCO.Location.ABOVE;
    if ( DuGR.inGroups( layer, [DuScriptUI.String.TAIL] ) ) return DuOCO.Location.TAIL;
    return DuOCO.Side.NONE;
}

/**
 * Checks the color of the bone layer
 * @param {Layer} [layer=DuAEProject.getActiveLayer] The layer. If omitted, will check the first selected bone of the current comp
 * @returns {DuColor}
 */
Duik.Bone.color = function( layer )
{
    layer = def(layer, DuAEProject.getActiveLayer());
    if (!layer) return new DuColor();

    if ( !Duik.isLayerType(layer, Duik.LayerType.BONE) ) return new DuColor();

    var colorIndex = Duik.PseudoEffect.BONE.props['Display options']['Color'].index;

    var effect = layer.effect( Duik.PseudoEffect.BONE.matchName );
    if (!effect) return new DuColor();

    return new DuColor( effect( colorIndex ).value );
}

/**
 * Checks the size of the bone layer
 * @param {Layer} [layer=DuAEProject.getActiveLayer] The layer. If omitted, will check the first selected bone of the current comp
 * @returns {DuColor}
 */
Duik.Bone.size = function( layer )
{
    layer = def(layer, DuAEProject.getActiveLayer());
    if (!layer) return 100;

    if ( !Duik.isLayerType(layer, Duik.LayerType.BONE) ) return 100;

    var sizeIndex = Duik.PseudoEffect.BONE.props['Display options']['Size'].index;

    var effect = layer.effect( Duik.PseudoEffect.BONE.matchName );
    if (!effect) return 100;

    return effect( sizeIndex ).value;
}

/**
 * Checks the opacity of the bone layer
 * @param {Layer} [layer=DuAEProject.getActiveLayer] The layer. If omitted, will check the first selected bone of the current comp
 * @returns {DuColor}
 */
Duik.Bone.opacity = function( layer )
{
    layer = def(layer, DuAEProject.getActiveLayer());
    if (!layer) return 50;

    if ( !Duik.isLayerType(layer, Duik.LayerType.BONE) ) return 50;

    var opacityIndex = Duik.PseudoEffect.BONE.props['Display options']['Opacity'].index;

    var effect = layer.effect( Duik.PseudoEffect.BONE.matchName );
    if (!effect) return 50;

    return effect( opacityIndex ).value;
}

/**
 * Checks the character name this layer belongs to
 * @param {Layer} [layer=DuAEProject.getActiveLayer] The layer. If omitted, will check the first selected bone of the current comp
 * @returns {DuColor}
 */
Duik.Bone.characterName = function( layer )
{
    layer = def(layer, DuAEProject.getActiveLayer());
    if (!layer) return '';

    if ( !Duik.isLayerType(layer, Duik.LayerType.BONE) ) return '';

    // Split
    var name = layer.name.split(' | ');
    if (name.length <= 1) return '';

    // Must be in the corresponding group
    if (!DuGR.inGroups(layer, [name[1]]) ) return '';
    return name[1];
}

/**
 * Checks the limb name this layer belongs to
 * @param {Layer} [layer=DuAEProject.getActiveLayer] The layer. If omitted, will check the first selected bone of the current comp
 * @returns {DuColor}
 */
Duik.Bone.limbName = function( layer )
{
    layer = def(layer, DuAEProject.getActiveLayer());
    if (!layer) return '';

    if ( !Duik.isLayerType(layer, Duik.LayerType.BONE) ) return '';

    // Split
    var name = layer.name.split(' | ');
    if (name.length <= 2) return '';

    return name[2];
}