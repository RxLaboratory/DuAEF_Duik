/**
 * Bone and armatures related tools.
 * @namespace
 */
Duik.Bone = {};

/**
 * The list of bone functions
 */
Duik.CmdLib['Bone'] = [];

// Low-level undocumented function
// Creates a limb on the selection, optionally linking the items
Duik.Bone.createLimb = function ( comp, limbCreator, characterName, forceLink )
{
    var comp = DuAEProject.getActiveComp();
    if (!comp) return;
 
    // Links
    var linkPath = def(DuESF.scriptSettings.data.armatureLinkPaths, false);
    if (forceLink) linkPath = !linkPath;
    var linkPuppetPins = def(DuESF.scriptSettings.data.armatureLinkPuppetPins, false);
    if (forceLink) linkPuppetPins = !linkPuppetPins;
    var linkLayers = def(DuESF.scriptSettings.data.armatureLinkLayers, false);
    if (forceLink) linkLayers = !linkLayers;

    var layers = DuAEComp.getSelectedLayers();

    // if we have a shape layer selected and its path, and only a path, we're going to remove it after creation.  
    var layerToRemove = null;
    if (layers.length == 1 && !linkPath)
    {
        var l = layers[0];
        if (DuAEShapeLayer.isSingleShape(l)) layerToRemove = l;
    }

    // If there's no selected layer, just create
    if( layers.length == 0 )
    {
        var doc = DuOCODoc.fromComp( characterName, comp );
        var limb = limbCreator( doc );
        doc.toComp( comp );
        return;
    }

    // For each selected layer
    var it = new DuList( layers );
    var ok = false;
    it.do( function( layer )
    {
        //get paths
        var props = DuAELayer.getSelectedProps( layer, DuAEProperty.isPathProperty );

        if ( props.length > 0 )
        {
            // Create a limb for each path
            for (var i = 0, n = props.length; i < n; i++)
            {
                var path = props[i];
                // create the OCODoc
                var doc = DuOCODoc.fromComp( characterName, comp );
                var limb = limbCreator( doc );
                limb.moveArmatureToPath( doc, path );
                // create
                var boneLayers = doc.toComp( comp );
                // link
                if (linkPath) Duik.Pin.linkPathToLayers( path, boneLayers );
                ok = true;
            }
            if (layerToRemove) layerToRemove.remove();
            return;
        }

        //puppet pins
        props = DuAELayer.getSelectedProps( layer, "ADBE FreePin3 PosPin Atom" );
        if ( props.length > 0 )
        {
            // Create a limb for all selected pins
            // create the OCODoc
            var doc = DuOCODoc.fromComp( characterName, comp );
            var limb = limbCreator( doc );
            limb.moveArmatureToPuppetPins( doc, props );
            // create
            var boneLayers = doc.toComp( comp );
            // link
            if (linkPuppetPins) Duik.Pin.linkPuppetPinsToLayers( props, boneLayers );
            ok = true;
            return;
        }

        //puppet effect
        props = DuAELayer.getSelectedProps( layer, "ADBE FreePin3" );
        if ( props.length > 0 )
        {
            // Get pins from each effect
            for(var i = 0, n = props.length; i < n; i++)
            {
                var pins = [];

                var meshGroup = props[i].property( "ADBE FreePin3 ARAP Group" ).property( "ADBE FreePin3 Mesh Group" );
                for ( var j = 1, numProps = meshGroup.numProperties; j <= numProps; j++ )
                {
                    var mesh = meshGroup( j );
                    var pinsGroup = mesh.property( "ADBE FreePin3 PosPins" );
                    for ( var k = 1, numPins = pinsGroup.numProperties; k <= numPins; k++ )
                    {
                        var pin = pinsGroup.property( k );
                        var test = new DuAEProperty( pin.property( "ADBE FreePin3 PosPin Position" ) );
                        if ( test.riggable() ) pins.push( new DuAEProperty( pin ) );
                    }
                }

                if (pins.length == 0) continue;

                // Create a limb for all pins
                // create the OCODoc
                var doc = DuOCODoc.fromComp( characterName, comp );
                var limb = limbCreator( doc );
                limb.moveArmatureToPuppetPins( doc, pins );
                // create
                var boneLayers = doc.toComp( comp );
                // link
                if (linkPuppetPins) Duik.Pin.linkPuppetPinsToLayers( pins, boneLayers );
                ok = true;
            }
            return;
        }
    });

    //anchor points
    if(!ok)
    {
        // Create a limb for all selected pins
        // create the OCODoc
        var doc = DuOCODoc.fromComp( characterName, comp );
        var limb = limbCreator( doc );
        limb.moveArmatureToLayers( doc, layers );
        // create
        var boneLayers = doc.toComp( comp );
        // link
        if (linkLayers) Duik.Bone.linkLayers( layers, boneLayers );
    }
}

Duik.CmdLib['Bone']["Custom_Limb"] = "Duik.Bone.customLimb()";
/**
 * Creates a custom limb.
 * @param {int} [num=2] - The number of bones in case nothing is selected in the comp. Otherwize, a bone is created for each selected path vertex/puppet pin/layer.
 * @param {string} [name='Limb'] - The name of the limb
 * @param {string} [characterName] The name of the character
 * @param {DuOCO.Side} [side=DuOCO.Side.NONE] - The side of the limb
 * @param {DuOCO.Location} [location=DuOCO.Location.NONE] - The location of the limb
 * @param {boolean} [forceLink=false] - Wether to link the selected layers/properties to the new armature
 */
Duik.Bone.customLimb = function ( num, name, characterName, side, location, forceLink )
{
    // get current comp
    var comp = DuAEProject.getActiveComp();
    if (!comp) return;

    num = def( num, 2);
    forceLink = def( forceLink, false);
    name = def( name, tr('Limb'));
    if (name == '') name = tr('Limb');
    characterName = def( characterName, '');
    side = def( side, DuOCO.Side.NONE);
    location = def( location, DuOCO.Location.NONE);

    DuAE.beginUndoGroup("Create custom limb");
    DuAEProject.setProgressMode(true);

    var layers = comp.selectedLayers;

    // If there's no selected layer, just create
    if( layers.length == 0 )
    {
        var doc = DuOCODoc.fromComp( characterName, comp );
        var limb = doc.newLimb( DuOCO.Limb.CUSTOM, side, location );
        limb.newArmature( name, num );
        doc.toComp( comp );
        DuAEProject.setProgressMode(false);
        DuAE.endUndoGroup();
        return;
    }

    // Links
    var linkPath = def(DuESF.scriptSettings.data.armatureLinkPaths, false);
    if (forceLink) linkPath = !linkPath;
    var linkPuppetPins = def(DuESF.scriptSettings.data.armatureLinkPuppetPins, false);
    if (forceLink) linkPuppetPins = !linkPuppetPins;
    var linkLayers = def(DuESF.scriptSettings.data.armatureLinkLayers, false);
    if (forceLink) linkLayers = !linkLayers;

    // if we have a shape layer selected and its path, and only a path, we're going to remove it after creation.  
    var layerToRemove = null;
    if (layers.length == 1 && !linkPath)
    {
        var l = layers[0];
        if (DuAEShapeLayer.isSingleShape(l)) layerToRemove = l;
    }

    // For each selected layer
    var it = new DuList( layers );
    var ok = false;
    it.do( function( layer )
    {
        //get paths
        var props = DuAELayer.getSelectedProps( layer, DuAEProperty.isPathProperty );

        if ( props.length > 0 )
        {
            // Create a limb for each path
            for (var i = 0, n = props.length; i < n; i++)
            {
                var path = props[i];
                // create the OCODoc
                var doc = DuOCODoc.fromComp( characterName, comp );
                var limb = doc.newLimb( DuOCO.Limb.CUSTOM, side, location );
                limb.armatureFromPath( doc, name, path );
                // create
                var boneLayers = doc.toComp( comp );
                // link
                if (linkPath) Duik.Pin.linkPathToLayers( path, boneLayers );
                ok = true;
            }
            if (layerToRemove) layerToRemove.remove();       
            return;
        }

        //puppet pins
        props = DuAELayer.getSelectedProps( layer, "ADBE FreePin3 PosPin Atom" );
        if ( props.length > 0 )
        {
            // Create a limb for all selected pins
            // create the OCODoc
            var doc = DuOCODoc.fromComp( characterName, comp );
            var limb = doc.newLimb( DuOCO.Limb.CUSTOM, side, location );
            limb.armatureFromPuppetPins( doc, name, props );
            // create
            var boneLayers = doc.toComp( comp );
            // link
            if (linkPuppetPins) Duik.Pin.linkPuppetPinsToLayers( props, boneLayers );
            ok = true;
            return;
        }

        //puppet effect
        props = DuAELayer.getSelectedProps( layer, "ADBE FreePin3" );
        if ( props.length > 0 )
        {
            // Get pins from each effect
            for(var i = 0, n = props.length; i < n; i++)
            {
                var pins = [];

                var meshGroup = props[i].property( "ADBE FreePin3 ARAP Group" ).property( "ADBE FreePin3 Mesh Group" );
                for ( var j = 1, numProps = meshGroup.numProperties; j <= numProps; j++ )
                {
                    var mesh = meshGroup( j );
                    var pinsGroup = mesh.property( "ADBE FreePin3 PosPins" );
                    for ( var k = 1, numPins = pinsGroup.numProperties; k <= numPins; k++ )
                    {
                        var pin = pinsGroup.property( k );
                        var test = new DuAEProperty( pin.property( "ADBE FreePin3 PosPin Position" ) );
                        if ( test.riggable() ) pins.push( new DuAEProperty( pin ) );
                    }
                }

                if (pins.length == 0) continue;

                // Create a limb for all pins
                // create the OCODoc
                var doc = DuOCODoc.fromComp( characterName, comp );
                var limb = doc.newLimb( DuOCO.Limb.CUSTOM, side, location );
                limb.armatureFromPuppetPins( doc, name, pins );
                // create
                var boneLayers = doc.toComp( comp );
                // link
                if (linkPuppetPins) Duik.Pin.linkPuppetPinsToLayers( pins, boneLayers );
                ok = true;
            }
            return;
        }
    });

    // Nothing was created, use layer anchor points
    if (!ok)
    {
        var doc = DuOCODoc.fromComp( characterName, comp );
        var limb = doc.newLimb( DuOCO.Limb.CUSTOM, side, location );
        limb.armatureFromLayers( doc, name, layers );
        // create
        var boneLayers = doc.toComp( comp );
        // link
        if (linkLayers) Duik.Bone.linkLayers( layers, boneLayers );
    }

    DuAEProject.setProgressMode(false);
    DuAE.endUndoGroup();
}

Duik.CmdLib['Bone']["Arm"] = "Duik.Bone.arm()";
/**
 * Creates a new arm.
 * @param {string} [characterName] The name of the character
 * @param {DuOCO.LimbType} [type=DuOCO.LimbType.PLANTIGRADE] The type of limb
 * @param {DuOCO.Side} [side=DuOCO.Side.LEFT] The side
 * @param {Boolean} [shoulder=false] Whether to create a shoulder
 * @param {Boolean} [arm=true]  Whether to create an arm / humerus
 * @param {Boolean} [forearm=true]  Whether to create a forearm
 * @param {Boolean} [hand=true]  Whether to create a hand
 * @param {Boolean} [claws=false]  Whether to add claws
 * @param {Boolean} [location=DuOCO.Location.FRONT]  The location of the arm
 * @param {boolean} [forceLink=false] - Wether link the selected layers/properties to the new armature
 */
Duik.Bone.arm = function ( characterName, type, side, shoulder, arm, forearm, hand, claws, location, forceLink )
{
    // get current comp
    var comp = DuAEProject.getActiveComp();
    if (!comp) return;

    type = def(type, DuOCO.LimbType.PLANTIGRADE);
    side = def(side, DuOCO.Side.LEFT);
    location = def(location, DuOCO.Location.FRONT);
    forceLink = def( forceLink, false);
    characterName = def( characterName, '' );

    shoulder = def( shoulder, false );
    arm = def( arm, true );
    forearm = def( forearm, true );
    hand = def( hand, true );
    claws = def( claws, false );

    DuAE.beginUndoGroup("Create arm");
    DuAEProject.setProgressMode(true);

    function limbCreator( doc )
    {
        return doc.newArm( type, side, shoulder, arm, forearm, hand, claws, undefined, location );
    }

    Duik.Bone.createLimb( comp, limbCreator, characterName, forceLink );

    DuAEProject.setProgressMode(false);
    DuAE.endUndoGroup();
}

Duik.CmdLib['Bone']["Leg"] = "Duik.Bone.leg()";
/**
 * Creates a new arm.
 * @param {string} [characterName] The name of the character
 * @param {DuOCO.LimbType} [type=DuOCO.LimbType.PLANTIGRADE] The type of limb
 * @param {DuOCO.Side} [side=DuOCO.Side.LEFT] The side
 * @param {Boolean} [thigh=true]  Whether to create a thigh
 * @param {Boolean} [calf=true]  Whether to create a calf
 * @param {Boolean} [foot=true]  Whether to create a foot
 * @param {Boolean} [claws=false]  Whether to add claws
 * @param {Boolean} [location=DuOCO.Location.BACK]  The location of the leg
 * @param {boolean} [forceLink=false] - Wether link the selected layers/properties to the new armature
 */
Duik.Bone.leg = function ( characterName, type, side, thigh, calf, foot, claws, location, forceLink )
{
    // get current comp
    var comp = DuAEProject.getActiveComp();
    if (!comp) return;

    type = def(type, DuOCO.LimbType.PLANTIGRADE);
    side = def(side, DuOCO.Side.LEFT);
    location = def(location, DuOCO.Location.BACK);
    forceLink = def( forceLink, false);
    characterName = def( characterName, '' );

    thigh = def( thigh, true );
    calf = def( calf, true );
    foot = def( foot, true );
    claws = def( claws, false );

    DuAE.beginUndoGroup("Create leg");
    DuAEProject.setProgressMode(true);

    function limbCreator( doc )
    {
        return doc.newLeg( type, side, thigh, calf, foot, claws, undefined, location );
    }

    Duik.Bone.createLimb( comp, limbCreator, characterName, forceLink );

    DuAEProject.setProgressMode(false);
    DuAE.endUndoGroup();
}

Duik.CmdLib['Bone']["Spine"] = "Duik.Bone.spine()";
/**
 * Creates a new spine.
 * @param {string} [characterName] The name of the character
 * @param {Boolean} [head=true]  Whether to create a head
 * @param {int} [neck=1] Number of neck bones
 * @param {int} [spine=2] Number of spine bones
 * @param {Boolean} [hips=true]  Whether to create hips
 * @param {boolean} [forceLink=false] - Wether link the selected layers/properties to the new armature
 */
Duik.Bone.spine = function ( characterName, head, neck, spine, hips, forceLink )
{
    // get current comp
    var comp = DuAEProject.getActiveComp();
    if (!comp) return;

    forceLink = def( forceLink, false);
    characterName = def( characterName, '' );

    head = def( head, true );
    neck = def( neck, 1 );
    spine = def( spine, 2 );
    hips = def( hips, true );

    DuAE.beginUndoGroup("Create spine");
    DuAEProject.setProgressMode(true);

    function limbCreator( doc )
    {
        return doc.newSpine( head, neck, spine, hips );
    }

    Duik.Bone.createLimb( comp, limbCreator, characterName, forceLink );

    DuAEProject.setProgressMode(false);
    DuAE.endUndoGroup();
}

Duik.CmdLib['Bone']["Tail"] = "Duik.Bone.tail()";
/**
 * Creates a new tail.
 * @param {string} [characterName] The name of the character
 * @param {int} [num=3] Number of tail bones
 * @param {boolean} [forceLink=false] - Wether link the selected layers/properties to the new armature
 */
Duik.Bone.tail = function ( characterName, num, forceLink )
{
    // get current comp
    var comp = DuAEProject.getActiveComp();
    if (!comp) return;

    forceLink = def( forceLink, false);
    characterName = def( characterName, '' );

    num = def( num, 3 );

    DuAE.beginUndoGroup("Create tail");
    DuAEProject.setProgressMode(true);

    function limbCreator( doc )
    {
        return doc.newTail( num );
    }

    Duik.Bone.createLimb( comp, limbCreator, forceLink );

    DuAEProject.setProgressMode(false);
    DuAE.endUndoGroup();
}

Duik.CmdLib['Bone']["Hair"] = "Duik.Bone.hair()";
/**
 * Creates a new hair strand.
 * @param {string} [characterName] The name of the character
 * @param {int} [num=3] Number of hair bones
 * @param {boolean} [forceLink=false] - Wether link the selected layers/properties to the new armature
 */
Duik.Bone.hair = function ( characterName, num, forceLink )
{
    // get current comp
    var comp = DuAEProject.getActiveComp();
    if (!comp) return;

    forceLink = def( forceLink, false);
    characterName = def( characterName, '' );

    num = def( num, 3 );

    DuAE.beginUndoGroup("Create hair strand");
    DuAEProject.setProgressMode(true);

    function limbCreator( doc )
    {
        return doc.newHairStrand( num );
    }

    Duik.Bone.createLimb( comp, limbCreator, forceLink );

    DuAEProject.setProgressMode(false);
    DuAE.endUndoGroup();
}

Duik.CmdLib['Bone']["Wing"] = "Duik.Bone.wing()";
/**
 * Creates a new wing.
 * @param {string} [characterName] The name of the character
 * @param {DuOCO.Side} [side=DuOCO.Side.LEFT] The side
 * @param {Boolean} [arm=true]  Whether to create an arm / humerus
 * @param {Boolean} [forearm=true]  Whether to create a forearm
 * @param {Boolean} [hand=true]  Whether to create a hand
 * @param {int} [feathers=5]  Number of feathers
 * @param {boolean} [forceLink=false] - Wether link the selected layers/properties to the new armature
 */
Duik.Bone.wing = function ( characterName, side, arm, forearm, hand, feathers, forceLink )
{
    // get current comp
    var comp = DuAEProject.getActiveComp();
    if (!comp) return;

    forceLink = def( forceLink, false);
    characterName = def( characterName, '' );
    side = def(side, DuOCO.Side.LEFT);

    arm = def( arm, true );
    forearm = def( forearm, true );
    hand = def( hand, true );
    feathers = def( feathers, 5 );

    DuAE.beginUndoGroup("Create wing");
    DuAEProject.setProgressMode(true);

    function limbCreator( doc )
    {
        return doc.newWing( side, arm, forearm, hand, feathers );
    }

    Duik.Bone.createLimb( comp, limbCreator, forceLink );

    DuAEProject.setProgressMode(false);
    DuAE.endUndoGroup();
}

Duik.CmdLib['Bone']["Snake spine"] = "Duik.Bone.snakeSpine()";
/**
 * Creates a new snake / worm spine.
 * @param {string} [characterName] The name of the character
 * @param {Boolean} [head=true]  Whether to create a head
 * @param {int} [spine=5] Number of spine bones
 * @param {boolean} [forceLink=false] - Wether link the selected layers/properties to the new armature
 */
Duik.Bone.snakeSpine = function ( characterName, head, spine, forceLink )
{
    // get current comp
    var comp = DuAEProject.getActiveComp();
    if (!comp) return;

    forceLink = def( forceLink, false);
    characterName = def( characterName, '' );

    head = def( head, true );
    spine = def( spine, 5 );

    DuAE.beginUndoGroup("Create snake / worm spine");
    DuAEProject.setProgressMode(true);

    function limbCreator( doc )
    {
        return doc.newSnakeSpine( head, spine );
    }

    Duik.Bone.createLimb( comp, limbCreator, characterName, forceLink );

    DuAEProject.setProgressMode(false);
    DuAE.endUndoGroup();
}

Duik.CmdLib['Bone']["Fin"] = "Duik.Bone.fin()";
/**
 * Creates a new fin.
 * @param {string} [characterName] The name of the character
 * @param {DuOCO.Side} [side=DuOCO.Side.LEFT] The side
 * @param {int} [fishbones=true]  Number of fishbones to create
 * @param {boolean} [forceLink=false] - Wether link the selected layers/properties to the new armature
 */
Duik.Bone.fin = function ( characterName, side, fishbones, forceLink )
{
    // get current comp
    var comp = DuAEProject.getActiveComp();
    if (!comp) return;

    forceLink = def( forceLink, false);
    characterName = def( characterName, '' );
    side = def(side, DuOCO.Side.LEFT);

    fishbones = def( fishbones, 5 );

    DuAE.beginUndoGroup("Create fin");
    DuAEProject.setProgressMode(true);

    function limbCreator( doc )
    {
        return doc.newFin( side, fishbones );
    }

    Duik.Bone.createLimb( comp, limbCreator, characterName, forceLink );

    DuAEProject.setProgressMode(false);
    DuAE.endUndoGroup();
}

/**
 * Parents the given layers to the given bones.<br />
 * The two lists do not need to have the same number of layers, 
 * additionnal/missing layers will be ignored.
 * @param {Layer[]|LayerCollection|DuList} layers
 * @param {Layer[]|LayerCollection|DuList} boneLayers
 */
Duik.Bone.linkLayers = function(layers, boneLayers)
{
    layers = new DuList(layers);
    boneLayers = new DuList(boneLayers);

    for(var i = 0, n = layers.length(); i < n; i++)
    {
        // Finished, we don't have any more layer to link!
        if (boneLayers.length() == i) return;

        layers.at(i).parent = boneLayers.at(i);
    }
}

Duik.CmdLib['Bone']["Select"] = "Duik.Bone.select()";
/**
 * Selects all the bones in the comp (and deselects any other layer)
 * @param {CompItem} [comp=DuAEProject.getActiveComp()] The comp
 */
Duik.Bone.select = function( comp )
{
    Duik.Layer.select( Duik.Layer.Type.BONE, comp ); 
}

Duik.CmdLib['Bone']["Show / Hide"] = "Duik.Bone.toggleVisibility()";
/**
 * Show/hides all the bones
 * @param {CompItem} [comp=DuAEProject.getActiveComp()] The comp
 */
Duik.Bone.toggleVisibility = function( comp )
{
    Duik.Layer.toggleVisibility( Duik.Layer.Type.BONE, comp );
}

Duik.CmdLib['Bone']["Duplicate"] = "Duik.Bone.duplicate()";
/**
 * Duplicates the selected bones, updates the hierarchy and display
 * @param {CompItem} [comp=DuAEProject.getActiveComp()] The comp
 * @returns {Layer[]} The new bones
 */
Duik.Bone.duplicate = function( comp )
{
    comp = def( comp, DuAEProject.getActiveComp() );
    if (!comp) return;

    var layers = Duik.Bone.get( true, comp );
    if (layers.length == 0) return;

    // Sort bones by limb/armature
    var armatures = [];
    for(var i = 0, n = layers.length; i < n; i++)
    {
        var layer = layers[i];
        var id = DuAETag.getValue( layer, DuAETag.Key.DUIK_ARMATURE_ID, DuAETag.Type.INT );
        if (id == null) id = -1;
        // Search in armatures
        var found = false;
        for(var j = 0, na = armatures.length; j < na; j++)
        {
            var aid = armatures[j].id;
            if (aid == id)
            {
                armatures[j].push(layer);
                found = true;
                break;
            }
        }
        if (found) continue;
        // new armature
        var a = [layer];
        a.id = id;
        armatures.push(a);
    }

    var newArmatures = [];
    var autorigIds = [];

    DuAE.beginUndoGroup("Duplicate bones");
    DuAEProject.setProgressMode(true);

    for (var i = 0, n = armatures.length; i < n; i++)
    {
        //unselect all layers in the comp
        DuAEComp.unselectLayers( comp );
        //select the bones of the armature, then duplicate
        DuAEComp.selectLayers( armatures[i] );
        comp.openInViewer();
        DuAE.duplicate();
        //get topmost element
        var topIndex = comp.numLayers;
        var it = new DuList( armatures[i] );
        while ( boneLayer = it.next() )
        {
            if ( boneLayer.index < topIndex ) topIndex = boneLayer.index;
            if ( topIndex == 1 ) break;
        };

        var oldLayers = DuAELayer.sortByIndex( armatures[i] ).reverse();
        oldLayers = new DuList( oldLayers );
        var newLayers = DuAELayer.sortByIndex( comp.selectedLayers ).reverse();

        //adjustments
        function layerInArray ( layer, index )
        {
            return layer.index == index;
        }

        var id = new Date().getTime();

        // Set display link and Id
        new DuList( newLayers ).do( function( layer )
        {
            layer.moveBefore( comp.layer( topIndex ) );
            //set display link
            var pE = Duik.PseudoEffect.BONE;
            var targetIndex = pE.props['Display options']['Target'].index;
            var effect = layer.effect( pE.matchName );
            if (effect)
            {
                var oldLinkIndex = oldLayers.indexOf( effect( targetIndex ).value, layerInArray );
                if ( oldLinkIndex >= 0 )
                {
                    effect( targetIndex ).setValue( newLayers[ oldLinkIndex ].index );
                }
            }
            
            //set new id
            DuAETag.setValue( layer, DuAETag.Key.DUIK_ARMATURE_ID, id );
        } );

        if (newLayers.length == 0) continue;

        //adjust autorig id
        var autorigId = DuAETag.getValue( newLayers[0], DuAETag.Key.DUIK_AUTORIG_ID, DuAETag.Type.INT );
        if (autorigId == null) continue;
        var newAutorigId = -1;

        for (var j = 0, num = autorigIds.length; j < num; j++)
        {
            if (autorigIds[j][0] == autorigId) newAutorigId = autorigIds[j][1];
        }

        if (newAutorigId == -1)
        {
            newAutorigId = new Date().getTime();
            autorigIds.push([autorigId,newAutorigId]);
        }

        for (var j = 0, num = oldLayers.length; j < num; j++)
        {
            DuAETag.setValue( oldLayers[j], DuAETag.Key.DUIK_AUTORIG_ID, newAutorigId );
        }

        newArmatures.push(newLayers);
    }

    // Select new bones
    for (var i = 0, n = newArmatures.length; i < n; i++)
        for (var j = 0, nb = newArmatures[i].length; j < nb; j++)
            newArmatures[i][j].selected = true;

    DuAEProject.setProgressMode(false);
    DuAE.endUndoGroup();
}

Duik.CmdLib['Bone']["Edit mode"] = "Duik.Bone.unlink()";
/**
 * Toggles the edit mode on selected bones
 * @param {CompItem} [comp=DuAEProject.getActiveComp()] The comp
 */
Duik.Bone.unlink = function( comp )
{
    comp = def( comp, DuAEProject.getActiveComp() );
    if (!comp) return;

    var layers = Duik.Bone.get( true, comp );
    if (layers.length == 0) return;

    DuAE.beginUndoGroup("Toggle bone edit mode");
    DuAEProject.setProgressMode(true);

    for(var i = 0, n = layers.length; i < n; i++)
    {
        DuAELayer.toggleEditMode( layers[i] );
    }

    DuAEProject.setProgressMode(false);
    DuAE.endUndoGroup();
}

/**
 * Gets the bones in the comp
 * @param {Boolean} [selectedOnly=true] Whether to get only the selected layers or all of them
 * @param {CompItem} [comp=DuAEProject.getActiveComp()] The comp
 * @returns {ShapeLayer[]} The bones
 */
Duik.Bone.get = function ( selectedOnly, comp )
{
    return Duik.Layer.get( Duik.Layer.Type.BONE, selectedOnly, comp );
}

/**
 * Sets the side of the layer
 * @param {DuOCO.Side} side The side
 * @param {Layer[]} [layers=DuAEComp.getSelectedLayers()] The layer. If omitted, will use all selected layers in the comp
 */
Duik.Bone.setSide = function( side, layers )
{
    layers = def( layers, Duik.Bone.get() );
    Duik.Layer.setSide( side, layers );
}

/**
 * Sets the location of the layer
 * @param {DuOCO.Side} side The side
 * @param {Layer[]} [layers=DuAEComp.getSelectedLayers()] The layers. If omitted, will use all selected layers in the comp
 */
Duik.Bone.setLocation = function( location, layers )
{
    layers = def( layers, Duik.Bone.get() );
    Duik.Layer.setLocation( location, layers );
}

/**
 * Checks the color of the bone layer
 * @param {Layer} [layer=DuAEComp.getActiveLayer] The layer. If omitted, will check the first selected bone of the current comp
 * @returns {DuColor}
 */
Duik.Bone.color = function( layer )
{
    layer = def(layer, DuAEComp.getActiveLayer());
    if (!layer) return new DuColor();

    if ( !Duik.Layer.isType(layer, Duik.Layer.Type.BONE) ) return new DuColor();

    var colorIndex = Duik.PseudoEffect.BONE.props['Display options']['Color'].index;

    var effect = layer.effect( Duik.PseudoEffect.BONE.matchName );
    if (!effect) return new DuColor();

    return new DuColor( effect( colorIndex ).value );
}

/**
 * Sets the color of the bone layer
 * @param {DuColor} color The color
 * @param {Layer} [layer=DuAEComp.getSelectedLayers()] The layers. If omitted, will use all selected layers in the comp
 * @returns {DuColor}
 */
Duik.Bone.setColor = function( color, layer )
{
    layers = def(layer, DuAEComp.getSelectedLayers());
    if (layers.length == 0) return;

    for(var i = 0, n = layers.length; i < n; i++)
    {
        var layer = layers[i];

        if ( !Duik.Layer.isType(layer, Duik.Layer.Type.BONE) ) continue;

        var colorIndex = Duik.PseudoEffect.BONE.props['Display options']['Color'].index;
        var effect = layer.effect( Duik.PseudoEffect.BONE.matchName );
        if (!effect) continue;
        effect( colorIndex ).setValue( color.floatRGBA() );
    }
}

/**
 * Checks the size of the bone layer
 * @param {Layer} [layer=DuAEComp.getActiveLayer] The layer. If omitted, will check the first selected bone of the current comp
 * @returns {float}
 */
Duik.Bone.size = function( layer )
{
    layer = def(layer, DuAEComp.getActiveLayer());
    if (!layer) return 100;

    if ( !Duik.Layer.isType(layer, Duik.Layer.Type.BONE) ) return 100;

    var sizeIndex = Duik.PseudoEffect.BONE.props['Display options']['Size'].index;

    var effect = layer.effect( Duik.PseudoEffect.BONE.matchName );
    if (!effect) return 100;

    return effect( sizeIndex ).value;
}

/**
 * Sets the size of the bone layer
 * @param {float} size The size in %.
 * @param {Layer} [layer=DuAEComp.getSelectedLayers()] The layers. If omitted, will use all selected layers in the comp
 */
Duik.Bone.setSize = function( size, layer )
{
    layers = def(layer, DuAEComp.getSelectedLayers());
    if (layers.length == 0) return;

    for(var i = 0, n = layers.length; i < n; i++)
    {
        var layer = layers[i];

        if ( !Duik.Layer.isType(layer, Duik.Layer.Type.BONE) ) continue;

        var sizeIndex = Duik.PseudoEffect.BONE.props['Display options']['Size'].index;
        var effect = layer.effect( Duik.PseudoEffect.BONE.matchName );
        if (!effect) continue;
        effect( sizeIndex ).setValue( size );
    }
}

/**
 * Checks the opacity of the bone layer
 * @param {Layer} [layer=DuAEComp.getActiveLayer] The layer. If omitted, will check the first selected bone of the current comp
 * @returns {DuColor}
 */
Duik.Bone.opacity = function( layer )
{
    layer = def(layer, DuAEComp.getActiveLayer());
    if (!layer) return 50;

    if ( !Duik.Layer.isType(layer, Duik.Layer.Type.BONE) ) return 50;

    var opacityIndex = Duik.PseudoEffect.BONE.props['Display options']['Opacity'].index;

    var effect = layer.effect( Duik.PseudoEffect.BONE.matchName );
    if (!effect) return 50;

    return effect( opacityIndex ).value;
}

/**
 * Sets the opacity of the bone layer
 * @param {float} opacity The opacity in %.
 * @param {Layer} [layer=DuAEComp.getSelectedLayers()] The layers. If omitted, will use all selected layers in the comp
 */
Duik.Bone.setOpacity = function( opacity, layer )
{
    layers = def(layer, DuAEComp.getSelectedLayers());
    if (layers.length == 0) return;

    for(var i = 0, n = layers.length; i < n; i++)
    {
        var layer = layers[i];

        if ( !Duik.Layer.isType(layer, Duik.Layer.Type.BONE) ) continue;

        var opacityIndex = Duik.PseudoEffect.BONE.props['Display options']['Opacity'].index;
        var effect = layer.effect( Duik.PseudoEffect.BONE.matchName );
        if (!effect) continue;
        effect( opacityIndex ).setValue( opacity );
    }
}

/**
 * Sets the character name of the bone layer
 * @param {string} characterName The character name.
 * @param {Layer} [layer=DuAEComp.getSelectedLayers()] The layers. If omitted, will use all selected layers in the comp
 */
Duik.Bone.setCharacterName = function( characterName, layer )
{
    layers = def( layers, Duik.Bone.get() );
    Duik.Layer.setCharacterName( characterName, layers );
}

/**
 * Sets the limb name of the bone layer
 * @param {string} limbName The limb name.
 * @param {Layer} [layer=DuAEComp.getSelectedLayers()] The layers. If omitted, will use all selected layers in the comp
 */
Duik.Bone.setLimbName = function( limbName, layer )
{
    layers = def( layers, Duik.Bone.get() );
    Duik.Layer.setLimbName( limbName, layers );
}