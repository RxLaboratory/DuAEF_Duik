/**
 * Bone and armatures related tools.
 * @namespace
 */
Duik.Bone = {};

/**
 * The list of bone functions
 */
Duik.CmdLib['Bone'] = [];

Duik.CmdLib['Bone']["Custom_Limb"] = "Duik.Bone.customLimb()";
/**
 * Creates a custom limb.
 * @param {int} [num=2] - The number of bones in case nothing is selected in the comp. Otherwize, a bone is created for each selected path vertex/puppet pin/layer.
 * @param {string} [name='Limb'] - The name of the limb
 * @param {DuOCO.Side} [side=DuOCO.Side.NONE] - The side of the limb
 * @param {DuOCO.Location} [location=DuOCO.Location.NONE] - The location of the limb
 * @param {boolean} [forceLink=false] - Wether link the selected layers/properties to the new armature
 */
Duik.Bone.customLimb = function ( num, name, characterName, side, location, forceLink )
{
    // get current comp
    var comp = DuAEProject.getActiveComp();
    if (!comp) return;

    num = def( num, 2);
    forceLink = def( forceLink, false);
    name = def( name, tr('Limb'));
    if (name == '') name = tr('Limb');
    characterName = def( characterName, '');
    side = def( side, DuOCO.Side.NONE);
    location = def( location, DuOCO.Location.NONE);

    DuAE.beginUndoGroup("Create custom armature");
    DuAEProject.setProgressMode(true);

    var layers = DuAEComp.getSelectedLayers();

    // If there's no selected layer, just create
    if( layers.length == 0 )
    {
        var doc = DuOCODoc.fromComp( characterName, comp );
        var limb = doc.newLimb( DuOCO.Limb.CUSTOM, side, location );
        limb.newArmature( name, num );
        doc.toComp( comp );
        DuAEProject.setProgressMode(false);
        DuAE.endUndoGroup();
        return;
    }

    // Links
    var linkPath = def(DuESF.scriptSettings.data.armatureLinkPaths, false);
    if (forceLink) linkPath = !linkPath;
    var linkPuppetPins = def(DuESF.scriptSettings.data.armatureLinkPuppetPins, false);
    if (forceLink) linkPuppetPins = !linkPuppetPins;
    var linkLayers = def(DuESF.scriptSettings.data.armatureLinkLayers, false);
    if (forceLink) linkLayers = !linkLayers;

    // if we have a shape layer selected and its path, and only a path, we're going to remove it after creation.  
    var layerToRemove = null;
    if (layers.length == 1 && !linkPath)
    {
        var l = layers[0];
        if (DuAEShapeLayer.isSingleShape(l)) layerToRemove = l;
    }

    // For each selected layer
    var it = new DuList( layers );
    it.do( function( layer )
    {
        //get paths
        var props = DuAELayer.getSelectedProps( layer, DuAEProperty.isPathProperty );

        if ( props.length > 0 )
        {
            // Create a limb for each path
            for (var i = 0, n = props.length; i < n; i++)
            {
                var path = props[i];
                // create the OCODoc
                var doc = DuOCODoc.fromComp( characterName, comp );
                var limb = doc.newLimb( DuOCO.Limb.CUSTOM, side, location );
                limb.armatureFromPath( doc, name, path );
                // create
                var boneLayers = doc.toComp( comp );
                // link
                if (linkPath) Duik.Pin.linkPathToLayers( path, boneLayers );
            }
            if (layerToRemove) layerToRemove.remove();
            return;
        }

        //puppet pins
        props = DuAELayer.getSelectedProps( layer, "ADBE FreePin3 PosPin Atom" );
        if ( props.length > 0 )
        {
            // Create a limb for all selected pins
            // create the OCODoc
            var doc = DuOCODoc.fromComp( characterName, comp );
            var limb = doc.newLimb( DuOCO.Limb.CUSTOM, side, location );
            limb.armatureFromPuppetPins( doc, name, props );
            // create
            var boneLayers = doc.toComp( comp );
            // link
            if (linkPuppetPins) Duik.Pin.linkPuppetPinsToLayers( props, boneLayers );
            return;
        }

        //puppet effect
        props = DuAELayer.getSelectedProps( layer, "ADBE FreePin3" );
        if ( props.length > 0 )
        {
            // Get pins from each effect
            for(var i = 0, n = props.length; i < n; i++)
            {
                var pins = [];

                var meshGroup = props[i].property( "ADBE FreePin3 ARAP Group" ).property( "ADBE FreePin3 Mesh Group" );
                for ( var j = 1, numProps = meshGroup.numProperties; j <= numProps; j++ )
                {
                    var mesh = meshGroup( j );
                    var pinsGroup = mesh.property( "ADBE FreePin3 PosPins" );
                    for ( var k = 1, numPins = pinsGroup.numProperties; k <= numPins; k++ )
                    {
                        var pin = pinsGroup.property( k );
                        var test = new DuAEProperty( pin.property( "ADBE FreePin3 PosPin Position" ) );
                        if ( test.riggable() ) pins.push( new DuAEProperty( pin ) );
                    }
                }

                if (pins.length == 0) continue;

                // Create a limb for all pins
                // create the OCODoc
                var doc = DuOCODoc.fromComp( characterName, comp );
                var limb = doc.newLimb( DuOCO.Limb.CUSTOM, side, location );
                limb.armatureFromPuppetPins( doc, name, pins );
                // create
                var boneLayers = doc.toComp( comp );
                // link
                if (linkPuppetPins) Duik.Pin.linkPuppetPinsToLayers( pins, boneLayers );
            }
            return;
        }
    });

}

/**
 * Gets the selected bones in the comp
 * @param {CompItem} [comp=DuAEProject.getActiveComp()] The comp
 * @returns {ShapeLayer[]} The bones
 */
Duik.Bone.get = function ( selectedOnly, comp )
{
    return Duik.Layer.getType( Duik.Layer.Type.BONE, selectedOnly, comp );
}

/**
 * Sets the side of the layer
 * @param {DuOCO.Side} side The side
 * @param {Layer[]} [layers=DuAEComp.getSelectedLayers()] The layer. If omitted, will use all selected layers in the comp
 */
Duik.Bone.setSide = function( side, layers )
{
    layers = def( layers, Duik.Bone.get() );
    Duik.Layer.setSide( side, layers );
}

/**
 * Sets the location of the layer
 * @param {DuOCO.Side} side The side
 * @param {Layer[]} [layers=DuAEComp.getSelectedLayers()] The layers. If omitted, will use all selected layers in the comp
 */
Duik.Bone.setLocation = function( location, layers )
{
    layers = def( layers, Duik.Bone.get() );
    Duik.Layer.setLocation( location, layers );
}

/**
 * Checks the color of the bone layer
 * @param {Layer} [layer=DuAEComp.getActiveLayer] The layer. If omitted, will check the first selected bone of the current comp
 * @returns {DuColor}
 */
Duik.Bone.color = function( layer )
{
    layer = def(layer, DuAEComp.getActiveLayer());
    if (!layer) return new DuColor();

    if ( !Duik.Layer.isType(layer, Duik.Layer.Type.BONE) ) return new DuColor();

    var colorIndex = Duik.PseudoEffect.BONE.props['Display options']['Color'].index;

    var effect = layer.effect( Duik.PseudoEffect.BONE.matchName );
    if (!effect) return new DuColor();

    return new DuColor( effect( colorIndex ).value );
}

/**
 * Sets the color of the bone layer
 * @param {DuColor} color The color
 * @param {Layer} [layer=DuAEComp.getSelectedLayers()] The layers. If omitted, will use all selected layers in the comp
 * @returns {DuColor}
 */
Duik.Bone.setColor = function( color, layer )
{
    layers = def(layer, DuAEComp.getSelectedLayers());
    if (layers.length == 0) return;

    for(var i = 0, n = layers.length; i < n; i++)
    {
        var layer = layers[i];

        if ( !Duik.Layer.isType(layer, Duik.Layer.Type.BONE) ) continue;

        var colorIndex = Duik.PseudoEffect.BONE.props['Display options']['Color'].index;
        var effect = layer.effect( Duik.PseudoEffect.BONE.matchName );
        if (!effect) continue;
        effect( colorIndex ).setValue( color.floatRGBA() );
    }
}

/**
 * Checks the size of the bone layer
 * @param {Layer} [layer=DuAEComp.getActiveLayer] The layer. If omitted, will check the first selected bone of the current comp
 * @returns {float}
 */
Duik.Bone.size = function( layer )
{
    layer = def(layer, DuAEComp.getActiveLayer());
    if (!layer) return 100;

    if ( !Duik.Layer.isType(layer, Duik.Layer.Type.BONE) ) return 100;

    var sizeIndex = Duik.PseudoEffect.BONE.props['Display options']['Size'].index;

    var effect = layer.effect( Duik.PseudoEffect.BONE.matchName );
    if (!effect) return 100;

    return effect( sizeIndex ).value;
}

/**
 * Sets the size of the bone layer
 * @param {float} size The size in %.
 * @param {Layer} [layer=DuAEComp.getSelectedLayers()] The layers. If omitted, will use all selected layers in the comp
 */
Duik.Bone.setSize = function( size, layer )
{
    layers = def(layer, DuAEComp.getSelectedLayers());
    if (layers.length == 0) return;

    for(var i = 0, n = layers.length; i < n; i++)
    {
        var layer = layers[i];

        if ( !Duik.Layer.isType(layer, Duik.Layer.Type.BONE) ) continue;

        var sizeIndex = Duik.PseudoEffect.BONE.props['Display options']['Size'].index;
        var effect = layer.effect( Duik.PseudoEffect.BONE.matchName );
        if (!effect) continue;
        effect( sizeIndex ).setValue( size );
    }
}

/**
 * Checks the opacity of the bone layer
 * @param {Layer} [layer=DuAEComp.getActiveLayer] The layer. If omitted, will check the first selected bone of the current comp
 * @returns {DuColor}
 */
Duik.Bone.opacity = function( layer )
{
    layer = def(layer, DuAEComp.getActiveLayer());
    if (!layer) return 50;

    if ( !Duik.Layer.isType(layer, Duik.Layer.Type.BONE) ) return 50;

    var opacityIndex = Duik.PseudoEffect.BONE.props['Display options']['Opacity'].index;

    var effect = layer.effect( Duik.PseudoEffect.BONE.matchName );
    if (!effect) return 50;

    return effect( opacityIndex ).value;
}

/**
 * Sets the opacity of the bone layer
 * @param {float} opacity The opacity in %.
 * @param {Layer} [layer=DuAEComp.getSelectedLayers()] The layers. If omitted, will use all selected layers in the comp
 */
Duik.Bone.setOpacity = function( opacity, layer )
{
    layers = def(layer, DuAEComp.getSelectedLayers());
    if (layers.length == 0) return;

    for(var i = 0, n = layers.length; i < n; i++)
    {
        var layer = layers[i];

        if ( !Duik.Layer.isType(layer, Duik.Layer.Type.BONE) ) continue;

        var opacityIndex = Duik.PseudoEffect.BONE.props['Display options']['Opacity'].index;
        var effect = layer.effect( Duik.PseudoEffect.BONE.matchName );
        if (!effect) continue;
        effect( opacityIndex ).setValue( opacity );
    }
}

/**
 * Sets the character name of the bone layer
 * @param {string} characterName The character name.
 * @param {Layer} [layer=DuAEComp.getSelectedLayers()] The layers. If omitted, will use all selected layers in the comp
 */
Duik.Bone.setCharacterName = function( characterName, layer )
{
    layers = def( layers, Duik.Bone.get() );
    Duik.Layer.setCharacterName( characterName, layers );
}

/**
 * Sets the limb name of the bone layer
 * @param {string} limbName The limb name.
 * @param {Layer} [layer=DuAEComp.getSelectedLayers()] The layers. If omitted, will use all selected layers in the comp
 */
Duik.Bone.setLimbName = function( limbName, layer )
{
    layers = def( layers, Duik.Bone.get() );
    Duik.Layer.setLimbName( limbName, layers );
}