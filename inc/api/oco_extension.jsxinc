/**
 * Creates an OCO doc from the given composition.
 * @param {string} [name] The name of the character. If omitted, will use the comp name.
 * @param {CompItem} [comp=DuAEProject.getActiveComp()] The composition
 * @param {Boolean} [empty=false] Set to true to create an empty doc.
 * @param {Boolean} [selectedLayers=false] If empty is true, will use only the selected layers
 * @return {DoOCODoc} The new doc
 */
DuOCODoc.fromComp = function( name, comp , empty, selectedLayers )
{
    comp = def(comp, DuAEProject.getActiveComp());
    name = def( name, '');
    if (!comp) return new DuOCODoc( name );

    if (name == '')
    {
        var compStr = localize("$$$/AE/BEE/LStr/0005=composition");
        if (comp.name.toLowerCase().indexOf(compStr) == 0) name = DuScriptUI.String.CHARACTER;
        else if (comp.name.toLowerCase().indexOf('comp') == 0) name = DuScriptUI.String.CHARACTER;
        else name = comp.name;
    }

    empty = def(empty, false);
    selectedLayers = def( selectedLayers, false);
    
    var doc = new DuOCODoc( name );
    doc.resolution = [comp.width, comp.height];

    // Set the default params

    // world in the center, 20% above the bottom of the comp
    doc.world = [comp.width/2, comp.height*0.2];
    // 50% of the comp height, divided by 185cm
    doc.pixelsPerCm = comp.height*0.5/185;

    // TODO Get ground, character, etc

    return doc;
}

/**
 * Creates the limbs and armatures in the comp
 * @param {CompItem} [comp] The composition to use. If omitted, creates a new composition.
 * @param {float} [duration=60.0] The duration of the new comp, in seconds.
 * @param {frameRate} [float=24.0] The frame rate of the new comp.
 * @return {Layer[]} The new layers
 */
DuOCODoc.prototype.toComp = function( comp, duration, frameRate )
{
    duration = def(duration, 60);
    frameRate = def(frameRate, 24);

    if (typeof comp === 'undefined') comp = app.project.items.addComp( this.name, this.resolution[0], this.resolution[1], 1.0, duration, frameRate);

    var layers = [];
    // For each limb
    for(var i = 0, n = this.limbs.length; i < n; i++)
    {
        layers = layers.concat( this.limbs[i].toComp( this, comp ) );
    }
    return layers;
}

/**
 * Creates the limb and armatures in the comp
 * @param {DuOCODoc} doc The doc containing the limb.
 * @param {CompItem} [comp=DuAEProject.getActiveComp()] The composition to use.
 * @param {Layer} [parentLayer=null] The parent layer of the bone.
 * @param {int} [limbId] A Unique identifier for this armature. If omitted, a new one will be assigned.
 * @return {Layer[]} The new layers
 */
DuOCOLimb.prototype.toComp = function( doc, comp, parentLayer, limbId )
{
    comp = def(comp, DuAEProject.getActiveComp());
    if (!comp) return;

    parentLayer = def(parentLayer, null);
    limbId = def(limbId, new Date().getTime() );

    var layers = [];
    var boneIndex = 0;
    for (var i = 0, n = this.armature.length; i < n; i++)
    {
        layers = layers.concat( this.armature[i].toComp( doc, this, comp, parentLayer, limbId, boneIndex ) );
    }
    return layers;
}

/**
 * Creates a new chain of bones located on the vertices of the path.
 * @param {DuOCODoc} doc The doc containing the limb.
 * @param {string} name The name of the bones (will increment if needed)
 * @param {PropertyGroup|DuAEProperty} pathProp The path property (either an "ADBE Vector Shape - Group" or an "ADBE Mask Atom")
 * @returns {DuOCOBone} The root bone of the new chain
 */
DuOCOLimb.prototype.armatureFromPath = function( doc, name, pathProp )
{
    pathProp = new DuAEProperty(pathProp);
    var vertices = pathProp.verticesToComp( );

    var b = null;
    var root = null;
    var names = [];

    // Create for each vertex
    for(var i = 0, n = vertices.length; i < n; i++)
    {
        var vertex = vertices[i];
        var boneName = DuString.generateUnique(name, names);
        var bone = new DuOCOBone( boneName );
        names.push(boneName);
        var coord = doc.fromPixels( vertex );
        bone.x = coord[0];
        bone.y = coord[1];
        if (b != null)
        {
            bone.attached = true;
            b.children.push( bone );
            b = bone;
        }
        else
        {
            this.armature.push( bone );
            root = bone;
            b = bone;
        }
    }

    return root;
}

/**
 * Moves the armature of the limb to the vertices of the path.
 * @param {DuOCODoc} doc The doc containing the limb.
 * @param {PropertyGroup|DuAEProperty} pathProp The path property (either an "ADBE Vector Shape - Group" or an "ADBE Mask Atom")
 */
DuOCOLimb.prototype.moveArmatureToPath = function( doc, pathProp )
{
    if (this.armature.length == 0) return;

    pathProp = new DuAEProperty(pathProp);
    var vertices = pathProp.verticesToComp( );

    var b = null;

    // For each vertex
    for(var i = 0, n = vertices.length; i < n; i++)
    {
        var vertex = vertices[i];

        if (b == null) b = this.armature[0];
        else 
        {
            if (b.children.length == 0) return;
            b = b.children[0];
        }

        var coord = doc.fromPixels( vertex );
        b.x = coord[0];
        b.y = coord[1];
    }
}

/**
 * Moves the armature of the limb to the puppet pins.
 * @param {DuOCODoc} doc The doc containing the limb.
 * @param {Property[]|DuAEProperty[]} pins The puppet pins
 */
DuOCOLimb.prototype.moveArmatureToPuppetPins = function( doc, pins )
{
    if (this.armature.length == 0) return;

    var b = null;

    // Create for each pin
    for (var i = 0, n = pins.length; i < n; i++)
    {
        if (b == null) b = this.armature[0];
        else 
        {
            if (b.children.length == 0) return;
            b = b.children[0];
        }

        var pin = new DuAEProperty( pins[i] );
        var pinProp = pin.getProperty();

        if ( pinProp.matchName == "ADBE FreePin3 PosPin Atom" )
        {
            pinProp = pinProp.property( "ADBE FreePin3 PosPin Position" );
        }

        var pinPos = DuAELayer.getWorldPos( pin.layer, pinProp.value );
        if( pin.layer instanceof ShapeLayer ) pinPos = pinProp.value;
        pinPos = doc.fromPixels( pinPos );
        b.x = pinPos[0];
        b.y = pinPos[1];
    }
}

/**
 * Creates a new chain of bones located on the puppet pins.
 * @param {DuOCODoc} doc The doc containing the limb.
 * @param {string} name The name of the bones (will increment if needed)
 * @param {Property[]|DuAEProperty[]} pins The puppet pins
 * @returns {DuOCOBone} The root bone of the new chain
 */
DuOCOLimb.prototype.armatureFromPuppetPins = function( doc, name, pins )
{
    var b = null;
    var root = null;
    var names = [];

    // Create for each pin
    for (var i = 0, n = pins.length; i < n; i++)
    {
        var boneName = DuString.generateUnique(name, names);
        var bone = new DuOCOBone( boneName );
        names.push(boneName);

        var pin = new DuAEProperty( pins[i] );
        var pinProp = pin.getProperty();

        if ( pinProp.matchName == "ADBE FreePin3 PosPin Atom" )
        {
            pinProp = pinProp.property( "ADBE FreePin3 PosPin Position" );
        }

        var pinPos = DuAELayer.getWorldPos( pin.layer, pinProp.value );
        if( pin.layer instanceof ShapeLayer ) pinPos = pinProp.value;
        pinPos = doc.fromPixels( pinPos );
        bone.x = pinPos[0];
        bone.y = pinPos[1];

        if (b != null)
        {
            bone.attached = true;
            b.children.push( bone );
            b = bone;
        }
        else
        {
            this.armature.push( bone );
            root = bone;
            b = bone;
        }
    }

    return root;
}

/**
 * Moves the armature of the limb to the layers.
 * @param {DuOCODoc} doc The doc containing the limb.
 * @param {Layer[]|LayerCollection} layers The layers
 */
DuOCOLimb.prototype.moveArmatureToLayers = function( doc, layers )
{
    var b = null;

    var it = new DuList(layers);

    // Check if there are layers at the same location
    // To prevent moving structures if there are mulitple anchor points at the same place
    var moveLayers = true;
    var layer;
    while (layer = it.next()) {
        var pos = DuAELayer.getWorldPos( layer );
        pos = new DuList( pos );
        for (var i = it.current + 1, n = it.length(); i < n; i++)
        {
            var layer2 = it.at(i);
            var pos2 = DuAELayer.getWorldPos( layer2 );     
            if ( pos.equals( pos2, undefined, 0 ) ) return;
        }
    }

    // For each anchor point
    it.reinitIterator();
    while (layer = it.next()) {

        if (b == null) b = this.armature[0];
        else 
        {
            if (b.children.length == 0) return;
            b = b.children[0];
        }
        
        var pos = DuAELayer.getWorldPos( layer );
        pos = doc.fromPixels(pos);

        b.translateTo( pos[0], pos[1] );
    };
}

/**
 * Creates a new chain of bones located on the layer anchor points.
 * @param {DuOCODoc} doc The doc containing the limb.
 * @param {string} name The name of the bones (will increment if needed)
 * @param {Layer[]|LayerCollection} layers The layers
 * @returns {DuOCOBone} The root bone of the new chain
 */
DuOCOLimb.prototype.armatureFromLayers = function( doc, name, layers )
{
    var b = null;
    var root = null;
    var names = [];

    var it = new DuList(layers);

    // Check if there are layers at the same location
    // To prevent moving structures if there are mulitple anchor points at the same place
    var moveLayers = true;
    var layer;
    while (layer = it.next()) {
        var pos = DuAELayer.getWorldPos( layer );
        pos = new DuList( pos );
        for (var i = it.current + 1, n = it.length(); i < n; i++)
        {
            var layer2 = it.at(i);
            var pos2 = DuAELayer.getWorldPos( layer2 );     
            if ( pos.equals( pos2, undefined, 0 ) )
            {
                moveLayers = false;
                break;
            }
        }
        if ( !moveLayers ) break;
    }

    // Create for each anchor point
    var num = it.length();
    var boneLength = 100.0 / (num-1);
    var x = -50;
    it.reinitIterator();
    while (layer = it.next()) {
        var boneName = DuString.generateUnique(name, names);
        var bone = new DuOCOBone( boneName );
        names.push(boneName);
        
        if (moveLayers)
        {
            var pos = DuAELayer.getWorldPos( layer );
            pos = doc.fromPixels(pos);

            bone.x = pos[0];
            bone.y = pos[1];
        }
        else 
        {
            bone.x = x;
            bone.y = 100;
            x += boneLength;
        }

        if (b != null)
        {
            bone.attached = true;
            b.children.push( bone );
            b = bone;
        }
        else
        {
            this.armature.push( bone );
            root = bone;
            b = bone;
        }
    };

    return root;
}

/**
 * Creates the limbs and armatures in the comp
 * @param {DuOCODoc} doc The doc containing the bone.
 * @param {DuOCOLimb} limb The limb containing the bone.
 * @param {CompItem} [comp=DuAEProject.getActiveComp()] The composition to use.
 * @param {Layer} [parentLayer=null] The parent layer of the bone.
 * @param {int} [limbId] A Unique identifier for this armature. If omitted, a new one will be assigned.
 * @param {int} [boneIndex = 0] The index of the bone in the chain.
 * @return {Layer[]} The new layers
 */
DuOCOBone.prototype.toComp = function( doc, limb, comp, parentLayer, limbId, boneIndex )
{
    comp = def(comp, DuAEProject.getActiveComp());
    if (!comp) return;

    parentLayer = def(parentLayer, null);
    limbId = def(limbId, new Date().getTime() );
    boneIndex = def(boneIndex, 0);

    var layers = [];

    // Create the layer for this one
    var boneLayer = comp.layers.addShape();
    layers.push(boneLayer);

    // Tag & Attributes
    Duik.Layer.setAttributes( boneLayer, Duik.Layer.Type.BONE, this.name, limb.side, limb.location, doc.name );
    var tag = DuAETag.get( boneLayer );
    DuAETag.setValue( boneLayer, DuAETag.Key.DUIK_BONE_TYPE, this.type, tag );
    DuAETag.setValue( boneLayer, DuAETag.Key.DUIK_LIMB_TYPE, limb.type, tag );
    DuAETag.setValue( boneLayer, DuAETag.Key.DUIK_LIMB, limb.limb, tag );
    DuAETag.setValue( boneLayer, DuAETag.Key.DUIK_LIMB_ID, limbId, tag );
    DuAETag.setValue( boneLayer, DuAETag.Key.DUIK_ATTACHED_BONE, this.attached, tag );
    DuAETag.setValue( boneLayer, DuAETag.Key.DUIK_BONE_INDEX, boneIndex, tag );

    // Parent & position
    boneLayer.transform.position.setValue( doc.toPixels( [this.x, this.y] ) );
    boneLayer.transform.scale.expression = '[100,100];';
    boneLayer.parent = parentLayer;

    // Add the bone pseudo effect
    var peD = Duik.PseudoEffect.BONE_DATA;
    var dataEffect = peD.apply( boneLayer );
    var dataEffectInfo = new DuAEProperty(dataEffect);

    var pe = Duik.PseudoEffect.BONE;
    var effect = pe.apply( boneLayer );
    effect.name = DuScriptUI.String.BONE;
    var effectInfo = new DuAEProperty(effect);

    var peE = Duik.PseudoEffect.BONE_ENVELOP;
    var envelopEffect = peE.apply( boneLayer );
    envelopEffect.name = DuScriptUI.String.BONE_ENVELOP;
    var envelopEffectInfo = new DuAEProperty(envelopEffect);

    var peN = Duik.PseudoEffect.BONE_NOODLE;
    var noodleEffect = peN.apply( boneLayer );
    // Deactivate for tips
    if (this.type == DuOCO.Bone.TIP) noodleEffect.enabled = false;

    dataEffect = dataEffectInfo.getProperty();
    effect = effectInfo.getProperty();
    envelopEffect = envelopEffectInfo.getProperty();

    // The indices
    var dRootIndex = peD.props["Geometry"]["Root"].index;
    var dEndIndex = peD.props["Geometry"]["End"].index;
    var dWorldVecIndex = peD.props["Geometry"]["World Vector"].index;
    var dLengthIndex = peD.props["Geometry"]["Length"].index;
    var dOrientationIndex = peD.props["Geometry"]["Orientation"].index;
    var targetIndex = peD.props["Armature"]["Target"].index;
    var dChildIndex = peD.props["Armature"]["Child index"].index;
    var dParentIndex = peD.props["Armature"]["Parent index"].index;

    var sizeIndex = pe.props['Size'].index;
    var colorIndex = pe.props['Color'].index;
    var opacityIndex = pe.props['Opacity'].index;

    var eSizeIndex = peE.props['Size'].index;
    var eFillColorIndex = peE.props['Fill']['Color'].index;
    var eFillOpacityIndex = peE.props['Fill']['Opacity'].index;
    var eStrokeColorIndex = peE.props['Stroke']['Color'].index;
    var eStrokeOpacityIndex = peE.props['Stroke']['Opacity'].index;
    var eStrokeSizeIndex = peE.props['Stroke']['Size'].index;

    var nSizeIndex = peN.props["Size"].index;
    var nColorIndex = peN.props["Color"].index;
    var nShapeIndex = peN.props["Curve parameters"]["Shape"].index;
    var nRootSmoothnessIndex = peN.props["Curve parameters"]["Root smoothness"].index;
    var nRootCurveIndex = peN.props["Curve parameters"]["Root curve length"].index;
    var nEndSmoothnessIndex = peN.props["Curve parameters"]["End smoothness"].index;
    var nEndCurveIndex = peN.props["Curve parameters"]["End curve length"].index;


    // BONE DATA EXPRESSIONS
    dataEffect( dRootIndex ).expression =  [ DuAEExpression.Id.BONE_DATA,
        'function getLayerWorldPos(t, l) {',
        '	if (typeof t === \'undefined\') t = time;',
        '	if (typeof l === \'undefined\') l = thisLayer;',
        '	if (l.hasParent) return l.parent.toWorld(l.position, t);',
        '	return l.position.valueAtTime(t);',
        '}',
        '',
        'getLayerWorldPos();'
	].join('\n');

    dataEffect( dEndIndex ).expression = [ DuAEExpression.Id.BONE_DATA,
        'var fx = thisProperty.propertyGroup();',
        'var childIndex = fx(' + dChildIndex + ').value;',
        '',
        'var child = null;',
        'if (childIndex > 0 && childIndex <= thisComp.numLayers) child = thisComp.layer(childIndex);',
        '',
        'function getLayerWorldPos(t, l) {',
        '	if (typeof t === \'undefined\') t = time;',
        '	if (typeof l === \'undefined\') l = thisLayer;',
        '	if (l.hasParent) return l.parent.toWorld(l.position, t);',
        '	return l.position.valueAtTime(t);',
        '}',
        '',
        'if (child) getLayerWorldPos(time, child);',
        'else getLayerWorldPos();'
	].join('\n');

    dataEffect( dWorldVecIndex ).expression = [ DuAEExpression.Id.BONE_DATA,
        'var fx = thisProperty.propertyGroup();',
        'var r = fx(' + dRootIndex + ').value;',
        'var e = fx(' + dEndIndex + ').value;',
        'e-r;'
	].join('\n');

    dataEffect( dLengthIndex ).expression = [ DuAEExpression.Id.BONE_DATA,
        'var fx = thisProperty.propertyGroup();',
        'var v = fx(' + dWorldVecIndex + ');',
        'length(v);'
	].join('\n');

    dataEffect( dOrientationIndex ).expression = [ DuAEExpression.Id.BONE_DATA,
        'var fx = thisProperty.propertyGroup();',
        'var vec = fx(' + dWorldVecIndex + ').value;',
        '',
        '',
        'var angle = Math.atan2( vec[ 1 ], vec[ 0 ] );',
        'radiansToDegrees( angle );'
	].join('\n');

    dataEffect( dChildIndex ).expression = [ DuAEExpression.Id.BONE_DATA,
       'var childIndex = 0;',
        'var child = null;',
        'try {',
        '    var bfx = thisProperty.propertyGroup();',
        '    child = bfx( ' + targetIndex + ' );',
        '    childIndex = child.index;',
        '} catch ( e ) {}',
        '',
        'if ( childIndex != thisLayer.index ) {',
        '	function isBone( layer ) {',
        '		var ok = false;',
        '		try {',
        '			layer.content( "Bone" );',
        '			ok = true;',
        '		} catch ( e ) {',
        '			ok = false;',
        '		}',
        '		return ok;',
        '	}',
        '	if ( !child )',
        '		if ( index > 1 )',
        '			if ( thisComp.layer( index - 1 ).hasParent )',
        '				if ( thisComp.layer( index - 1 ).parent.index == index ) child = thisComp.layer( index - 1 );',
        '	if ( !isBone( child ) ) child = null;',
        '	if ( !child )',
        '		if ( index < thisComp.numLayers )',
        '			if ( thisComp.layer( index + 1 ).hasParent )',
        '				if ( thisComp.layer( index + 1 ).parent.index == index ) child = thisComp.layer( index + 1 );',
        '	if ( !isBone( child ) ) child = null;',
        '	if ( !child ) {',
        '		for ( var i = thisComp.numLayers; i > 0; i-- ) {',
        '			if ( thisComp.layer( i ).hasParent )',
        '				if ( thisComp.layer( i ).parent.index == thisLayer.index ) {',
        '					child = thisComp.layer( i );',
        '					if ( !isBone( child ) ) child = null;',
        '					if ( child ) break;',
        '				}',
        '		}',
        '	}',
        '}',
        '',
        'if (child) child.index;',
        'else 0;'
	].join('\n');

    dataEffect( dParentIndex ).expression = [ DuAEExpression.Id.BONE_DATA,
        'var prntIndex = 0;',
        DuAEExpression.Library.get(['checkDuikEffect']),
        '',
        'function isBone( layer ) {',
        '    var ok = false;',
        '    try {',
        '        layer.content( "Bone" );',
        '        ok = true;',
        '    } catch ( e ) {',
        '        ok = false;',
        '    }',
        '    return ok;',
        '}',
        '',
        'if (hasParent && isBone(parent)) {',
        '    for(var i = 1; i <= parent("Effects").numProperties; i++) {',
        '       var fx = parent.effect(i);',
        '       if (checkDuikEffect(fx, "Bone data")) {',
        '           var ci = fx(' + dChildIndex + ').value;',
        '           if (ci == index) prntIndex = parent.index;',
        '           break;',
        '       }',
        '    }',
        '}',
        '',
        'prntIndex;'
	].join('\n');

    // The auto-size
    effect( sizeIndex ).expression = [ DuAEExpression.Id.BONE,
        'var result = thisComp.width * .045;',
        'result *= value/100;',
        'result;'
    ].join('\n');

    // The envelop size
    envelopEffect( eSizeIndex ).setValue( comp.width * .025 );
    envelopEffect.enabled = false;

    // The noodle size
    noodleEffect( nSizeIndex ).setValue( comp.width * .005 );
    noodleEffect.enabled = false;

    // The content of the shape layer

    // -- BONE GROUP --
    var mainGroup = boneLayer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
    mainGroup.name = 'Bone';
    // Rotation
    mainGroup('ADBE Vector Transform Group')('ADBE Vector Rotation').expression = [ DuAEExpression.Id.BONE,
        'var fx = effect("' + dataEffect.name + '");',
        'var o = fx(' + dOrientationIndex + ');',
        '',
        DuAEExpression.Library.get(['dishineritRotation']),
        '',
        'var result = o - 2*rotation;',
        'result += dishineritRotation();',
        'result += 90;',
        'result;'
	].join('\n');
    // Opacity
    mainGroup('ADBE Vector Transform Group')('ADBE Vector Group Opacity').expression = [ DuAEExpression.Id.BONE,
        'var fx = effect("' + effect.name + '");',
        'var result = 0;',
        'if (fx.active) result = 100;',
        'result;'
	].join('\n');

    // Target Group
    var targetGroup = mainGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
    targetGroup.name = 'Target';
    var targetContent = targetGroup.property("ADBE Vectors Group");
    // Ellipse
    var shape = targetContent.addProperty("ADBE Vector Shape - Ellipse");
    shape("ADBE Vector Ellipse Size").setValue([4,4]);
    //fill
    var fill = targetContent.addProperty("ADBE Vector Graphic - Fill");
    fill("ADBE Vector Fill Color").setValue([ 0, 0, 0, 1.0]);

    // Display Group
    var displayGroup = mainGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
    displayGroup.name = 'Display';
    //display opacity
    displayGroup.transform.opacity.expression = [ DuAEExpression.Id.BONE,
            'var fx = effect("' + effect.name + '");',
            'var result = 0;',
            'if (fx.active) result = fx(' + opacityIndex + ').value;',
            'result;'
        ].join('\n');
    displayGroup.transform.scale.expression = [ DuAEExpression.Id.BONE,
        'var s = effect("' + effect.name + '")(' + sizeIndex + ');',
        '[s,100];',
	].join('\n');

    //Link Group 
    var linkGroup = displayGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
    linkGroup.name = 'Link';
    //anchor point
    linkGroup('ADBE Vector Transform Group')('ADBE Vector Anchor').setValue([ 0, 5]);
    //group scale
    linkGroup('ADBE Vector Transform Group')('ADBE Vector Scale').expression = [ DuAEExpression.Id.BONE,
        'var fx = effect("' + dataEffect.name + '");',
        'var dist = fx(' + dLengthIndex + ').value;',
        'var y = dist / 15 * 100;',
        'result = [ 100, y * 100 / thisLayer( "ADBE Root Vectors Group" )( "Bone" ).transform.scale[ 1 ] ];',
        'result;'
	].join('\n');
    var linkContent = linkGroup.property("ADBE Vectors Group");
    //star
    shape = linkContent.addProperty("ADBE Vector Shape - Star");
    shape("ADBE Vector Star Points").setValue( 3 );
    shape("ADBE Vector Star Outer Radius").setValue( 10 );
    shape("ADBE Vector Star Outer Roundess").setValue( 100 );
    shape("ADBE Vector Star Type").setValue( 2 );
    shape("ADBE Vector Star Outer Roundess").expression = [ DuAEExpression.Id.BONE,
        'var fx = effect( "' + dataEffect.name + '" );',
        'var dist = fx(' + dLengthIndex + ');',
        '',
        'var result = value;',
        '',
        'if ( dist < 20 ) dist = 20;',
        'var s = thisLayer( "ADBE Root Vectors Group" )( "Bone" ).transform.scale[ 0 ];',
        'result = value / ( dist / 30 ) * s / 80;',
        '',
        'result;'
	].join('\n');
    // circle
    var displayContent = displayGroup.property("ADBE Vectors Group")
    shape = displayContent.addProperty("ADBE Vector Shape - Ellipse");
    shape("ADBE Vector Ellipse Size").setValue([17,17]);
    shape("ADBE Vector Ellipse Size").expression = [ DuAEExpression.Id.BONE,
        'var s = effect("' + effect.name + '")(' + sizeIndex + ')/100*17;',
        '[17,s];'
    ].join('\n');
    //fill
    var fill = displayContent.addProperty("ADBE Vector Graphic - Fill");
    fill("ADBE Vector Fill Color").expression = [ DuAEExpression.Id.BONE,
	    'effect("' + effect.name +'")( ' + colorIndex + ').value;'
	].join('\n');

    // -- NOODLE GROUP --
    var noodleGroup = boneLayer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
    noodleGroup.name = 'Noodle';
    noodleGroup.transform.opacity.expression = [ DuAEExpression.Id.BONE_NOODLE,
        'var fx = effect("' + noodleEffect.name + '");',
        'if (fx.active) 100;',
        'else 0;'
	].join('\n');
    var noodlePath = noodleGroup.content.addProperty("ADBE Vector Shape - Group");
    noodlePath(2).expression = [ DuAEExpression.Id.BONE_NOODLE,
        'var bfx = effect("' + dataEffect.name + '");',
        'var worldRoot = bfx(' + dRootIndex + ').value;',
        'var worldEnd = bfx(' + dEndIndex + ').value;',
        'var vec = bfx(' + dWorldVecIndex + ').value;',
        'var childIndex = bfx(' + dChildIndex + ').value;',
        'var prntIndex = bfx(' + dParentIndex + ').value;',
        '',
        'var fx = effect("' + noodleEffect.name + '");',
        'var outSmoothness = fx(' + nEndSmoothnessIndex + ').value;',
        'var outCurve = fx(' + nEndCurveIndex + ').value;',
        'var inSmoothness = fx(' + nRootSmoothnessIndex + ').value;',
        'var inCurve = fx(' + nRootCurveIndex + ').value;',
        '',
        DuAEExpression.Library.get(['checkDuikEffect']),
        '',
        'if (fx.active) {',
        '	outSmoothness /= 100;',
        '	inSmoothness /= 100;',
        '	inCurve /= 100;',
        '	outCurve /= 100;',
        '',
        '	var child = null;',
        '	var prnt = null;',
        '',
        '	if (childIndex > 0 && childIndex <= thisComp.numLayers) child = thisComp.layer(childIndex);',
        '	if (prntIndex > 0 && prntIndex <= thisComp.numLayers) prnt = thisComp.layer(prntIndex);',
        '',
        '	var childVec = [0,0];',
        '	var prntVec = [0,0];',
        '',
        '	if (child) for(var i = 1; i <= child("Effects").numProperties; i++) {',
        '		var fx = child.effect(i);',
        '		if (checkDuikEffect(fx, "Bone data")) {',
        '			childVec = fx(\'World Vector\').value;',
        '			break;',
        '		}',
        '	}',
        '',
        '	if (prnt) for(var i = 1; i <= prnt("Effects").numProperties; i++) {',
        '		var fx = prnt.effect(i);',
        '		if (checkDuikEffect(fx, "Bone data")) {',
        '			prntVec = fx(\'World Vector\').value;',
        '			break;',
        '		}',
        '	}',
        '',
        '	var pts = [[0,0], fromWorld(worldEnd) ];',
        '',
        '	var iTs = [[0,0]];',
        '	if (childVec[0] != 0 && childVec[1] != 0) {',
        '		var iT = worldRoot + vec * (1-outSmoothness);',
        '		iT -= childVec * outSmoothness;',
        '		iT = fromWorld(iT);',
        '		iT -= fromWorld(worldEnd);',
        '		iT *= outCurve;',
        '		iTs.push( iT );',
        '	}',
        '	else iTs.push([0,0]);',
        '',
        '	var oTs = [];',
        '	if (prntVec[0] != 0 && prntVec[1] != 0) {',
        '		var oT = worldEnd + vec * (1-inSmoothness);',
        '		oT += prntVec * inSmoothness;',
        '		oT = fromWorld(oT);',
        '		oT *= inCurve;',
        '		oTs.push( oT );',
        '	}',
        '	else oTs.push([0,0]);',
        '	oTs.push([0,0]);',
        '',
        '	createPath(pts, iTs, oTs, false);',
        '}',
        'else value;'
	].join('\n');
    var stroke = noodleGroup.content.addProperty("ADBE Vector Graphic - Stroke");
    stroke('ADBE Vector Stroke Color').expression = [ DuAEExpression.Id.BONE_NOODLE,
        'var fx = effect("' + noodleEffect.name + '");',
        'var c = fx(' + nColorIndex + ').value;',
        'c;'
	].join('\n');
    stroke('ADBE Vector Stroke Width').expression = [ DuAEExpression.Id.BONE_NOODLE,
        'var bfx = effect("' + dataEffect.name + '");',
        'var childIndex = bfx(' + dChildIndex + ').value;',
        'var fx = effect("' + noodleEffect.name + '");',
        'var s = fx(' + nSizeIndex + ').value;',
        '',
        DuAEExpression.Library.get(['checkDuikEffect']),
        '',
        'var child = null;',
        'if (childIndex > 0 && childIndex <= thisComp.numLayers) child = thisComp.layer(childIndex);',
        '',
        'var childS = 0;',
        '',
        'if (child) for(var i = 1; i <= child("Effects").numProperties; i++) {',
        '	var cfx = child.effect(i);',
        '   if (checkDuikEffect(cfx, "Bone noodle")) {',
        '       childS = cfx(' + nSizeIndex + ').value;',
        '       break;',
        '   }',
        '}',
        '',
        'Math.max(s, childS);'
	].join('\n');
    stroke('ADBE Vector Stroke Line Cap').setValue(2);
    var taper = stroke('ADBE Vector Stroke Taper');
    if (taper) {
        taper('ADBE Vector Taper Start Length').expression = taper('ADBE Vector Taper End Length').expression = [ DuAEExpression.Id.BONE_NOODLE,
            'var fx = effect("' + noodleEffect.name + '");',
            'var s = fx(' + nShapeIndex + ').value;',
            's;'
        ].join('\n');
        // start width
        taper('ADBE Vector Taper Start Width').expression = [ DuAEExpression.Id.BONE_NOODLE,
            'var bfx = effect("' + dataEffect.name + '");',
            'var childIndex = bfx(' + dChildIndex + ').value;',
            'var fx = effect("' + noodleEffect.name + '");',
            'var s = fx(' + nSizeIndex + ').value;',
            '',
            DuAEExpression.Library.get(['checkDuikEffect']),
            '',
            'var child = null;',
            'if (childIndex > 0 && childIndex <= thisComp.numLayers) child = thisComp.layer(childIndex);',
            '',
            'var childS = 0;',
            '',
            'if (child) for(var i = 1; i <= child("Effects").numProperties; i++) {',
            '	var cfx = child.effect(i);',
            '   if (checkDuikEffect(cfx, "Bone noodle")) {',
            '       childS = cfx(' + nSizeIndex + ').value;',
            '       break;',
            '   }',
            '}',
            '',
            'var result = 100;',
            'if (childS > s) result = s / childS * 100;',
            '	',
            'result;'
        ].join('\n');
        taper('ADBE Vector Taper End Width').expression = [ DuAEExpression.Id.BONE_NOODLE,
            'var bfx = effect("' + dataEffect.name + '");',
            'var childIndex = bfx(' + dChildIndex + ').value;',
            'var fx = effect("' + noodleEffect.name + '");',
            'var s = fx(' + nSizeIndex + ').value;',
            '',
            DuAEExpression.Library.get(['checkDuikEffect']),
            '',
            'var child = null;',
            'if (childIndex > 0 && childIndex <= thisComp.numLayers) child = thisComp.layer(childIndex);',
            '',
            'var childS = 0;',
            '',
            'if (child) for(var i = 1; i <= child("Effects").numProperties; i++) {',
            '	var cfx = child.effect(i);',
            '   if (checkDuikEffect(cfx, "Bone noodle")) {',
            '       childS = cfx(' + nSizeIndex + ').value;',
            '       break;',
            '   }',
            '}',
            '',
            'var result = 100;',
            'if (childS < s) result = childS / s * 100',
            '	',
            'result;'
        ].join('\n');
        taper('ADBE Vector Taper Start Ease').setValue(33);
        taper('ADBE Vector Taper End Ease').setValue(33);
    }

    // -- ENVELOP GROUP --
    var envelopGroup = boneLayer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
    envelopGroup.name = 'Envelop';
    envelopGroup.transform.opacity.expression = [ DuAEExpression.Id.BONE_ENVELOP,
        'if (effect("' + envelopEffect.name + '").active) 100;',
        'else 0;'
    ].join('\n');
    envelopGroup.transform.rotation.expression = [ DuAEExpression.Id.BONE_ENVELOP,
        'var fx = effect("' + dataEffect.name + '");',
        'var o = fx(' + dOrientationIndex + ');',
        '',
        DuAEExpression.Library.get(['dishineritRotation']),
        '',
        'var result = o - 2*rotation;',
        'result += dishineritRotation();',
        'result += 90;',
        'result;'
	].join('\n');

    var rootGroup = envelopGroup('ADBE Vectors Group').addProperty('ADBE Vector Group');
    rootGroup.name = "root";
    rootGroup.transform.scale.expression = [ DuAEExpression.Id.BONE_ENVELOP,
        'var s = 0;',
        'if (hasParent) s = effect("' + envelopEffect.name +'")(' + eSizeIndex + ');',
        '[s, s];'
        ].join('\n');
    var rootCircle = rootGroup.content.addProperty("ADBE Vector Shape - Ellipse");
    rootCircle.name = "root";
    var rootMask = rootGroup.content.addProperty("ADBE Vector Shape - Rect");
    rootMask.name = "root_mask";
    rootMask.position.setValue([0,-50]);
    var rootMerge = rootGroup.content.addProperty('ADBE Vector Filter - Merge');
    rootMerge('ADBE Vector Merge Type').setValue( 3 );

    var endGroup = envelopGroup('ADBE Vectors Group').addProperty('ADBE Vector Group');
    endGroup.name = "end";
    endGroup.transform.scale.expression = [ DuAEExpression.Id.BONE_ENVELOP,
        'var bfx = effect("' + dataEffect.name + '");',
        'var childIndex = bfx(' + dChildIndex + ').value;',
        'var fx = effect("' + envelopEffect.name + '");',
        'var s = fx(' + eSizeIndex + ');',
        'var child = null;',
        'if (childIndex > 0 && childIndex <= thisComp.numLayers) child = thisComp.layer(childIndex);',
        'var result = [s,s];',
        'if ( child )',
        'if ( child.index != index ) {',
        '	try { result = child.content("Envelop").content("root").transform.scale }',
        '	catch (e) {}',
        '}',
        'result;'
	].join('\n');
    endGroup.transform.position.expression = [DuAEExpression.Id.BONE_ENVELOP,
        'var fx = effect("' + dataEffect.name + '");',
        'var l = fx(' + dLengthIndex + ');',
        '',
        '[0, -l ];'
        ].join('\n');
    var endCircle = endGroup.content.addProperty("ADBE Vector Shape - Ellipse");
    endCircle.name = "end";
    var endMask = endGroup.content.addProperty("ADBE Vector Shape - Rect");
    endMask.name = "end_mask";
    endMask.position.setValue( [0, 50] );
    var endMerge = endGroup.content.addProperty('ADBE Vector Filter - Merge');
    endMerge('ADBE Vector Merge Type').setValue( 3 );

    var shape = envelopGroup.content.addProperty('ADBE Vector Shape - Group');
    shape.name = "shape";
    shape('ADBE Vector Shape').expression = [ DuAEExpression.Id.BONE_ENVELOP,
        'var endPos = [0,0];',
        'var endSize = 0;',
        'var fx = effect("' + envelopEffect.name +'")',
        'if (fx.active) {',
        'try {',
        '	end_t = thisProperty.propertyGroup(2)("end").transform;',
        '	endPos = end_t.position.value;',
        '	endSize = end_t.scale.value[0];',
        '	endSize /= 2;',
        '}',
        'catch (e) {}',
        'var rootSize = fx(' + eSizeIndex + ').value / 2;',
        'var vertices = [',
        '	[endPos[0], endPos[1] - endSize/2],',
        '	[endSize, endPos[1]],',
        '	[rootSize, 0],',
        '	[0, rootSize/2],',
        '	[-rootSize, 0],',
        '	[-endSize, endPos[1] ]',
        '];',
        'var inT = [',
        '	[-endSize, 0],',
        '	[0,0],',
        '	[0,-rootSize],',
        '	[rootSize,0],',
        '	[0,0],',
        '	[0,endSize/3]',
        '];',
        'var outT = [',
        '	[endSize, 0],',
        '	[0,endSize/3],',
        '	[0,0],',
        '	[-rootSize,0],',
        '	[0,-rootSize],',
        '	[0,0]',
        '];',
        'createPath(vertices, inT, outT,true);',
        '} else { value; }'
	].join('\n');
    var shapeMerge = envelopGroup.content.addProperty('ADBE Vector Filter - Merge');
    shapeMerge('ADBE Vector Merge Type').setValue( 2 );

    stroke = envelopGroup.content.addProperty("ADBE Vector Graphic - Stroke");
    stroke('ADBE Vector Stroke Color').expression = [ DuAEExpression.Id.BONE_ENVELOP,
        'effect("' + envelopEffect.name +'")(' + eStrokeColorIndex + ').value;'
    ].join('\n');
    stroke('ADBE Vector Stroke Width').expression = [ DuAEExpression.Id.BONE_ENVELOP,
        'effect("' + envelopEffect.name +'")(' + eStrokeSizeIndex + ').value;'
    ].join('\n');
    stroke('ADBE Vector Stroke Opacity').expression = [ DuAEExpression.Id.BONE_ENVELOP,
        'effect("' + envelopEffect.name +'")(' + eStrokeOpacityIndex + ').value;'
    ].join('\n');

    fill = envelopGroup.content.addProperty("ADBE Vector Graphic - Fill");
    fill('ADBE Vector Fill Color').expression = [ DuAEExpression.Id.BONE_ENVELOP,
        'effect("' + envelopEffect.name +'")(' + eFillColorIndex + ').value;'
    ].join('\n');
    fill('ADBE Vector Fill Opacity').expression = [ DuAEExpression.Id.BONE_ENVELOP,
        'effect("' + envelopEffect.name +'")(' + eFillOpacityIndex + ').value;'
    ].join('\n');
        
    // If attached, set the target of the parent
    if (this.attached) parentLayer.effect( Duik.PseudoEffect.BONE_DATA.matchName )( targetIndex ).setValue( boneLayer.index );

    // And set the color
    if ( this.type == DuOCO.Bone.CLAVICLE ||
        this.type == DuOCO.Bone.HIPS
        )
        Duik.Bone.setColor( DuColor.Color.RAINBOX_RED, [boneLayer] );
    else if ( this.type == DuOCO.Bone.HUMERUS || 
        this.type == DuOCO.Bone.FEMUR ||
        this.type == DuOCO.Bone.SPINE ||
        this.type == DuOCO.Bone.TAIL_ROOT ||
        this.type == DuOCO.Bone.SNAKE_SPINE_ROOT || 
        this.type == DuOCO.Bone.FISH_SPINE_ROOT || 
        this.type == DuOCO.Bone.FIN ||
        this.type == DuOCO.Bone.HAIR_ROOT
        )
        Duik.Bone.setColor( DuColor.Color.ORANGE, [boneLayer] );
    else if ( this.type == DuOCO.Bone.TORSO)
        Duik.Bone.setColor( DuColor.Color.YELLOW_ORANGE, [boneLayer] );
    else if ( this.type == DuOCO.Bone.RADIUS ||
        this.type == DuOCO.Bone.TIBIA ||
        this.type == DuOCO.Bone.NECK ||
        this.type == DuOCO.Bone.TAIL_MID ||
        this.type == DuOCO.Bone.SNAKE_SPINE_MID ||
        this.type == DuOCO.Bone.FISH_SPINE_MID ||
        this.type == DuOCO.Bone.HAIR_MID
        )
        Duik.Bone.setColor( DuColor.Color.YELLOW, [boneLayer] );
    else if ( this.type == DuOCO.Bone.CARPUS ||
        this.type == DuOCO.Bone.TARSUS ||
        this.type == DuOCO.Bone.SKULL ||
        this.type == DuOCO.Bone.TAIL_END ||
        this.type == DuOCO.Bone.SNAKE_SPINE_END ||
        this.type == DuOCO.Bone.FISH_SPINE_END ||
        this.type == DuOCO.Bone.HAIR_END
        )
        Duik.Bone.setColor( DuColor.Color.LIGHT_BLUE, [boneLayer] );
    else if ( this.type == DuOCO.Bone.FINGER ||
        this.type == DuOCO.Bone.TIP ||
        this.type == DuOCO.Bone.SKULL_TIP ||
        this.type == DuOCO.Bone.TOE ||
        this.type == DuOCO.Bone.FEATHER || 
        this.type == DuOCO.Bone.FIN_FISHBONE
        )
        Duik.Bone.setColor( DuColor.Color.LIGHT_PURPLE, [boneLayer] );
    else if ( this.type == DuOCO.Bone.HEEL
        )
        Duik.Bone.setColor( DuColor.Color.GREEN, [boneLayer] );

    // Child bones
    for(var i = 0, n = this.children.length; i < n; i++)
    {
        boneIndex++;
        layers = layers.concat( this.children[i].toComp(doc, limb, comp, boneLayer, limbId, boneIndex) );
    }

    // Child limbs
    for(var i = 0, n = this.limbs.length; i < n; i++)
    {
        boneIndex++;
        layers = layers.concat( this.limbs[i].toComp(doc, comp, boneLayer, limbId, boneIndex) );
    }

    return layers;
}
