/**
 * Creates an OCO doc from the given composition.
 * @param {string} [name] The name of the character. If omitted, will use the comp name.
 * @param {CompItem} [comp=DuAEProject.getActiveComp()] The composition
 * @param {Boolean} [empty=false] Set to true to create an empty doc.
 * @param {Boolean} [selectedLayers=false] If empty is true, will use only the selected layers
 * @return {DoOCODoc} The new doc
 */
DuOCODoc.fromComp = function( name, comp , empty, selectedLayers )
{
    comp = def(comp, DuAEProject.getActiveComp());
    name = def( name, '');
    if (!comp) return new DuOCODoc( name );

    if (name == '')
    {
        var compStr = localize("$$$/AE/BEE/LStr/0005=composition");
        if (comp.name.toLowerCase().indexOf(compStr) == 0) name = DuScriptUI.String.CHARACTER;
        else if (comp.name.toLowerCase().indexOf('comp') == 0) name = DuScriptUI.String.CHARACTER;
        else name = comp.name;
    }

    empty = def(empty, false);
    selectedLayers = def( selectedLayers, false);
    
    var doc = new DuOCODoc( name );
    doc.resolution = [comp.width, comp.height];

    // Set the default params

    // world in the center, 20% above the bottom of the comp
    this.world = [comp.width/2, comp.height*0.2];
    // 50% of the comp height, divided by 185cm
    this.pixelsPerCm = comp.height*0.5/185;

    // TODO Get ground, character, etc

    return doc;
}

/**
 * Creates the limbs and armatures in the comp
 * @param {CompItem} [comp] The composition to use. If omitted, creates a new composition.
 * @param {float} [duration=60.0] The duration of the new comp, in seconds.
 * @param {frameRate} [float=24.0] The frame rate of the new comp.
 * @return {Layer[]} The new layers
 */
DuOCODoc.prototype.toComp = function( comp, duration, frameRate )
{
    duration = def(duration, 60);
    frameRate = def(frameRate, 24);

    if (typeof comp === 'undefined') comp = app.project.items.addComp( this.name, this.resolution[0], this.resolution[1], 1.0, duration, frameRate);

    var layers = [];
    // For each limb
    for(var i = 0, n = this.limbs.length; i < n; i++)
    {
        layers = layers.concat( this.limbs[i].toComp( this, comp ) );
    }
    return layers;
}

/**
 * Creates the limb and armatures in the comp
 * @param {DuOCODoc} doc The doc containing the limb.
 * @param {CompItem} [comp=DuAEProject.getActiveComp()] The composition to use.
 * @param {Layer} [parentLayer=null] The parent layer of the bone.
 * @param {int} [armatureId] A Unique identifier for this armature. If omitted, a new one will be assigned.
 * @return {Layer[]} The new layers
 */
DuOCOLimb.prototype.toComp = function( doc, comp, parentLayer, armatureId )
{
    comp = def(comp, DuAEProject.getActiveComp());
    if (!comp) return;

    parentLayer = def(parentLayer, null);
    armatureId = def(armatureId, new Date().getTime() );

    var layers = [];
    for (var i = 0, n = this.armature.length; i < n; i++)
    {
        layers = layers.concat( this.armature[i].toComp( doc, this, comp, parentLayer, armatureId ) );
    }
    return layers;
}

/**
 * Creates a new chain of bones located on the vertices of the path.
 * @param {DuOCODoc} doc The doc containing the limb.
 * @param {string} name The name of the bones (will increment if needed)
 * @param {PropertyGroup|DuAEProperty} pathProp The path property (either an "ADBE Vector Shape - Group" or an "ADBE Mask Atom")
 * @returns {DuOCOBone} The root bone of the new chain
 */
DuOCOLimb.prototype.armatureFromPath = function( doc, name, pathProp )
{
    pathProp = new DuAEProperty(pathProp);
    var vertices = pathProp.verticesToComp( );

    var b = null;
    var root = null;
    var names = [];

    // Create for each vertex
    for(var i = 0, n = vertices.length; i < n; i++)
    {
        var vertex = vertices[i];
        var boneName = DuString.generateUnique(name, names);
        var bone = new DuOCOBone( boneName );
        names.push(boneName);
        var coord = doc.fromPixels( vertex );
        bone.x = coord[0];
        bone.y = coord[1];
        if (b != null)
        {
            bone.attached = true;
            b.children.push( bone );
            b = bone;
        }
        else
        {
            this.armature.push( bone );
            root = bone;
            b = bone;
        }
    }

    return root;
}

/**
 * Moves the armature of the limb to the vertices of the path.
 * @param {DuOCODoc} doc The doc containing the limb.
 * @param {PropertyGroup|DuAEProperty} pathProp The path property (either an "ADBE Vector Shape - Group" or an "ADBE Mask Atom")
 */
DuOCOLimb.prototype.moveArmatureToPath = function( doc, pathProp )
{
    if (this.armature.length == 0) return;

    pathProp = new DuAEProperty(pathProp);
    var vertices = pathProp.verticesToComp( );

    var b = null;

    // For each vertex
    for(var i = 0, n = vertices.length; i < n; i++)
    {
        var vertex = vertices[i];

        if (b == null) b = this.armature[0];
        else 
        {
            if (b.children.length == 0) return;
            b = b.children[0];
        }

        var coord = doc.fromPixels( vertex );
        b.x = coord[0];
        b.y = coord[1];
    }
}

/**
 * Moves the armature of the limb to the puppet pins.
 * @param {DuOCODoc} doc The doc containing the limb.
 * @param {Property[]|DuAEProperty[]} pins The puppet pins
 */
DuOCOLimb.prototype.moveArmatureToPuppetPins = function( doc, pins )
{
    if (this.armature.length == 0) return;

    var b = null;

    // Create for each pin
    for (var i = 0, n = pins.length; i < n; i++)
    {
        if (b == null) b = this.armature[0];
        else 
        {
            if (b.children.length == 0) return;
            b = b.children[0];
        }

        var pin = new DuAEProperty( pins[i] );
        var pinProp = pin.getProperty();

        if ( pinProp.matchName == "ADBE FreePin3 PosPin Atom" )
        {
            pinProp = pinProp.property( "ADBE FreePin3 PosPin Position" );
        }

        var pinPos = DuAELayer.getWorldPos( pin.layer, pinProp.value );
        if( pin.layer instanceof ShapeLayer ) pinPos = pinProp.value;
        pinPos = doc.fromPixels( pinPos );
        b.x = pinPos[0];
        b.y = pinPos[1];
    }
}

/**
 * Creates a new chain of bones located on the puppet pins.
 * @param {DuOCODoc} doc The doc containing the limb.
 * @param {string} name The name of the bones (will increment if needed)
 * @param {Property[]|DuAEProperty[]} pins The puppet pins
 * @returns {DuOCOBone} The root bone of the new chain
 */
DuOCOLimb.prototype.armatureFromPuppetPins = function( doc, name, pins )
{
    var b = null;
    var root = null;
    var names = [];

    // Create for each pin
    for (var i = 0, n = pins.length; i < n; i++)
    {
        var boneName = DuString.generateUnique(name, names);
        var bone = new DuOCOBone( boneName );
        names.push(boneName);

        var pin = new DuAEProperty( pins[i] );
        var pinProp = pin.getProperty();

        if ( pinProp.matchName == "ADBE FreePin3 PosPin Atom" )
        {
            pinProp = pinProp.property( "ADBE FreePin3 PosPin Position" );
        }

        var pinPos = DuAELayer.getWorldPos( pin.layer, pinProp.value );
        if( pin.layer instanceof ShapeLayer ) pinPos = pinProp.value;
        pinPos = doc.fromPixels( pinPos );
        bone.x = pinPos[0];
        bone.y = pinPos[1];

        if (b != null)
        {
            bone.attached = true;
            b.children.push( bone );
            b = bone;
        }
        else
        {
            this.armature.push( bone );
            root = bone;
            b = bone;
        }
    }

    return root;
}

/**
 * Moves the armature of the limb to the layers.
 * @param {DuOCODoc} doc The doc containing the limb.
 * @param {Layer[]|LayerCollection} layers The layers
 */
DuOCOLimb.prototype.moveArmatureToLayers = function( doc, layers )
{
    var b = null;

    var it = new DuList(layers);

    // Check if there are layers at the same location
    // To prevent moving structures if there are mulitple anchor points at the same place
    var moveLayers = true;
    var layer;
    while (layer = it.next()) {
        var pos = DuAELayer.getWorldPos( layer );
        pos = new DuList( pos );
        for (var i = it.current + 1, n = it.length(); i < n; i++)
        {
            var layer2 = it.at(i);
            var pos2 = DuAELayer.getWorldPos( layer2 );     
            if ( pos.equals( pos2, undefined, 0 ) ) return;
        }
    }

    // For each anchor point
    it.reinitIterator();
    while (layer = it.next()) {

        if (b == null) b = this.armature[0];
        else 
        {
            if (b.children.length == 0) return;
            b = b.children[0];
        }
        
        var pos = DuAELayer.getWorldPos( layer );
        pos = doc.fromPixels(pos);

        b.x = pos[0];
        b.y = pos[1];
    };
}

/**
 * Creates a new chain of bones located on the layer anchor points.
 * @param {DuOCODoc} doc The doc containing the limb.
 * @param {string} name The name of the bones (will increment if needed)
 * @param {Layer[]|LayerCollection} layers The layers
 * @returns {DuOCOBone} The root bone of the new chain
 */
DuOCOLimb.prototype.armatureFromLayers = function( doc, name, layers )
{
    var b = null;
    var root = null;
    var names = [];

    var it = new DuList(layers);

    // Check if there are layers at the same location
    // To prevent moving structures if there are mulitple anchor points at the same place
    var moveLayers = true;
    var layer;
    while (layer = it.next()) {
        var pos = DuAELayer.getWorldPos( layer );
        pos = new DuList( pos );
        for (var i = it.current + 1, n = it.length(); i < n; i++)
        {
            var layer2 = it.at(i);
            var pos2 = DuAELayer.getWorldPos( layer2 );     
            if ( pos.equals( pos2, undefined, 0 ) )
            {
                moveLayers = false;
                break;
            }
        }
        if ( !moveLayers ) break;
    }

    // Create for each anchor point
    var num = it.length();
    var boneLength = 100.0 / (num-1);
    var x = -50;
    it.reinitIterator();
    while (layer = it.next()) {
        var boneName = DuString.generateUnique(name, names);
        var bone = new DuOCOBone( boneName );
        names.push(boneName);
        
        if (moveLayers)
        {
            var pos = DuAELayer.getWorldPos( layer );
            pos = doc.fromPixels(pos);

            bone.x = pos[0];
            bone.y = pos[1];
        }
        else 
        {
            bone.x = x;
            bone.y = 100;
            x += boneLength;
        }

        if (b != null)
        {
            bone.attached = true;
            b.children.push( bone );
            b = bone;
        }
        else
        {
            this.armature.push( bone );
            root = bone;
            b = bone;
        }
    };

    return root;
}

/**
 * Creates the limbs and armatures in the comp
 * @param {DuOCODoc} doc The doc containing the bone.
 * @param {DuOCOLimb} limb The limb containing the bone.
 * @param {CompItem} [comp=DuAEProject.getActiveComp()] The composition to use.
 * @param {Layer} [parentLayer=null] The parent layer of the bone.
 * @param {int} [armatureId] A Unique identifier for this armature. If omitted, a new one will be assigned.
 * @return {Layer[]} The new layers
 */
DuOCOBone.prototype.toComp = function( doc, limb, comp, parentLayer, armatureId )
{
    comp = def(comp, DuAEProject.getActiveComp());
    if (!comp) return;

    parentLayer = def(parentLayer, null);
    armatureId = def(armatureId, new Date().getTime() );

    var layers = [];

    // Create the layer for this one
    var boneLayer = comp.layers.addShape();
    layers.push(boneLayer);

    // Tag
    var tag = DuAETag.set( boneLayer );
    if (doc.name != '') DuAETag.addGroup( boneLayer, doc.name, tag );
    DuAETag.addGroup( boneLayer, tr( DuScriptUI.String.BONE ), tag );
    DuAETag.setValue( boneLayer, DuAETag.Key.DUIK_TYPE, Duik.Layer.Type.BONE, tag );
    DuAETag.setValue( boneLayer, DuAETag.Key.DUIK_BONE_TYPE, this.type, tag );
    DuAETag.setValue( boneLayer, DuAETag.Key.DUIK_LIMB_TYPE, limb.type, tag );
    DuAETag.setValue( boneLayer, DuAETag.Key.DUIK_LIMB, limb.limb, tag );
    DuAETag.setValue( boneLayer, DuAETag.Key.DUIK_ARMATURE_ID, armatureId, tag );
    DuAETag.setValue( boneLayer, DuAETag.Key.DUIK_ATTACHED_BONE, this.attached, tag );

    // Parent & position
    boneLayer.transform.position.setValue( doc.toPixels( [this.x, this.y] ) );
    boneLayer.transform.scale.expression = '[100,100];';
    boneLayer.parent = parentLayer;

    // Appearance
    boneLayer.label = 7;
    boneLayer.guideLayer = true;
    boneLayer.quality = LayerQuality.DRAFT;
    var layerName = 'B | ' + doc.name + ' | ' + this.name;
    boneLayer.name = layerName;

    // Side & location
    Duik.Bone.setSide( limb.side, [boneLayer] );
    Duik.Bone.setLocation( limb.location, [boneLayer] );

    // Add the bone pseudo effect
    var effect = Duik.PseudoEffect.BONE.apply( boneLayer );
    // The indices
    var sizeIndex = Duik.PseudoEffect.BONE.props['Display options']['Size'].index;
    var targetIndex = Duik.PseudoEffect.BONE.props['Display options']['Target'].index;
    var colorIndex = Duik.PseudoEffect.BONE.props['Display options']['Color'].index;
    var opacityIndex = Duik.PseudoEffect.BONE.props['Display options']['Opacity'].index;

    // The content of the shape layer
    // Bone group
    var mainGroup = boneLayer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
    mainGroup.name = 'Bone';
    //scale
    mainGroup('ADBE Vector Transform Group')('ADBE Vector Scale').expression = [ DuAEExpression.Id.BONE,
        'if(!active) value;',
        'else',
        '{',
        'var s = effect("' + effect.name + '")(' + sizeIndex + ');',
        '[s,s];',
        '}'
	].join('\n');
    //look-at
    mainGroup('ADBE Vector Transform Group')('ADBE Vector Rotation').expression = [ DuAEExpression.Id.BONE,
        'if ( active ) {',
        '    var child = null;',
        '    var childIndex = -1;',
        '    var fx = effect("' + effect.name + '");',
        '    try {',
        '        child = fx( ' + targetIndex + ' );',
        '        childIndex = child.index || fx( ' + sizeIndex + ' ).value == 0',
        '    } catch ( e ) {}',
        '    if ( childIndex == thisLayer.index ) value;',
        '    else {',
        '        var R = 45;',
        '',
        '        function isBone( layer ) {',
        '            var ok = false;',
        '            try {',
        '                layer.content( "Bone" );',
        '                ok = true;',
        '            } catch ( e ) {',
        '                ok = false;',
        '            }',
        '            return ok;',
        '        }',
        '        if ( !child )',
        '            if ( index > 1 )',
        '                if ( thisComp.layer( index - 1 ).hasParent )',
        '                    if ( thisComp.layer( index - 1 ).parent.index == index ) child = thisComp.layer( index - 1 );',
        '        if ( !isBone( child ) ) child = null;',
        '        if ( !child )',
        '            if ( index < thisComp.numLayers )',
        '                if ( thisComp.layer( index + 1 ).hasParent )',
        '                    if ( thisComp.layer( index + 1 ).parent.index == index ) child = thisComp.layer( index + 1 );',
        '        if ( !isBone( child ) ) child = null;',
        '        if ( !child ) {',
        '            for ( var i = thisComp.numLayers; i > 0; i-- ) {',
        '                if ( thisComp.layer( i ).hasParent )',
        '                    if ( thisComp.layer( i ).parent.index == thisLayer.index ) {',
        '                        child = thisComp.layer( i );',
        '                        if ( !isBone( child ) ) child = null;',
        '                        if ( child ) break;',
        '                    }',
        '            }',
        '        }',
        '        var result = value;',
        '        var layer = thisLayer;',
        '        while ( layer.hasParent ) {',
        '            layer = layer.parent;',
        '            result = result - layer.rotation;',
        '        }',
        '        if ( child )',
        '            if ( child.index != index ) {',
        '                C = child.toWorld( child.anchorPoint );',
        '                O = thisLayer.toWorld( thisLayer.anchorPoint );',
        '                var vec = O - C;',
        '                var angle = Math.atan2( vec[ 1 ], vec[ 0 ] );',
        '                var ik = radiansToDegrees( angle );',
        '                result += ( ik - 90 - rotation )',
        '            }',
        '        result;',
        '    }',
        '} else value;'
	].join('\n');

    //Target Group
    var targetGroup = mainGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
    targetGroup.name = 'Target';
    var targetContent = targetGroup.property("ADBE Vectors Group");
    //2nd ellipse
    var shape = targetContent.addProperty("ADBE Vector Shape - Ellipse");
    shape("ADBE Vector Ellipse Size").setValue([4,4]);
    //fill
    var fill = targetContent.addProperty("ADBE Vector Graphic - Fill");
    fill("ADBE Vector Fill Color").setValue([ 0, 0, 0, 1.0]);

    //Display Group
    var displayGroup = mainGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
    displayGroup.name = 'Display';
    //display opacity
    displayGroup('ADBE Vector Transform Group')('ADBE Vector Group Opacity').expression = [ DuAEExpression.Id.BONE,
            'effect("' + effect.name + '")(' + opacityIndex + ');'
        ].join('\n');
    //Link Group 
    var linkGroup = displayGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
    linkGroup.name = 'Link';
    //anchor point
    linkGroup('ADBE Vector Transform Group')('ADBE Vector Anchor').setValue([ 0, 5]);
    //group scale
    linkGroup('ADBE Vector Transform Group')('ADBE Vector Scale').expression = [ DuAEExpression.Id.BONE,
        'if ( active ) {',
        '    var child = null;',
        '    var childIndex = -1;',
        '    var fx = effect( "' + effect.name + '" );',
        '    try {',
        '        child = fx( ' + targetIndex + ' );',
        '        childIndex = child.index',
        '    } catch ( e ) {}',
        '    if ( childIndex == thisLayer.index || fx( ' + sizeIndex + ' ) == 0 )[ 0, 0 ];',
        '    else {',
        '        var X = 100;',
        '        var Y = 60;',
        '',
        '        function isBone( layer ) {',
        '            var ok = false;',
        '            try {',
        '                layer.content( "Bone" );',
        '                ok = true;',
        '            } catch ( e ) {',
        '                ok = false;',
        '            }',
        '            return ok;',
        '        }',
        '        if ( !child )',
        '            if ( index > 1 )',
        '                if ( thisComp.layer( index - 1 ).hasParent )',
        '                    if ( thisComp.layer( index - 1 ).parent.index == index ) child = thisComp.layer( index - 1 );',
        '        if ( !isBone( child ) ) child = null;',
        '        if ( !child )',
        '            if ( index < thisComp.numLayers )',
        '                if ( thisComp.layer( index + 1 ).hasParent )',
        '                    if ( thisComp.layer( index + 1 ).parent.index == index ) child = thisComp.layer( index + 1 );',
        '        if ( !isBone( child ) ) child = null;',
        '        if ( !child ) {',
        '            for ( var i = thisComp.numLayers; i > 0; i-- ) {',
        '                if ( thisComp.layer( i ).hasParent )',
        '                    if ( thisComp.layer( i ).parent.index == thisLayer.index ) {',
        '                        child = thisComp.layer( i );',
        '                        if ( !isBone( child ) ) child = null;',
        '                        if ( child ) break;',
        '                    }',
        '            }',
        '        }',
        '        if ( child ) {',
        '            var A = child.toWorld( child.anchorPoint );',
        '            var B = thisLayer.toWorld( thisLayer.anchorPoint );',
        '            var dist = length( A, B );',
        '            Y = dist / 15 * 100;',
        '        }',
        '        [ X, Y * 100 / thisLayer( "ADBE Root Vectors Group" )( "Bone" ).transform.scale[ 1 ] ];',
        '    }',
        '} else value;'
	].join('\n');
    var linkContent = linkGroup.property("ADBE Vectors Group");
    //star
    shape = linkContent.addProperty("ADBE Vector Shape - Star");
    shape("ADBE Vector Star Points").setValue( 3 );
    shape("ADBE Vector Star Outer Radius").setValue( 10 );
    shape("ADBE Vector Star Outer Roundess").setValue( 100 );
    shape("ADBE Vector Star Type").setValue( 2 );
    shape("ADBE Vector Star Outer Roundess").expression = [ DuAEExpression.Id.BONE,
        'if ( active ) {',
        '    var child = null;',
        '    var childIndex = -1;',
        '    var fx = effect( "' + effect.name + '" );',
        '    try {',
        '        child = fx( ' + targetIndex + ' );',
        '        childIndex = child.index',
        '    } catch ( e ) {}',
        '    if ( childIndex == thisLayer.index || fx( ' + sizeIndex + ' ) == 0 ) value;',
        '    else {',
        '        function isBone( layer ) {',
        '            var ok = false;',
        '            try {',
        '                layer.content( "Bone" );',
        '                ok = true;',
        '            } catch ( e ) {',
        '                ok = false;',
        '            }',
        '            return ok;',
        '        }',
        '        if ( !child )',
        '            if ( index > 1 )',
        '                if ( thisComp.layer( index - 1 ).hasParent )',
        '                    if ( thisComp.layer( index - 1 ).parent.index == index ) child = thisComp.layer( index - 1 );',
        '        if ( !isBone( child ) ) child = null;',
        '        if ( !child )',
        '            if ( index < thisComp.numLayers )',
        '                if ( thisComp.layer( index + 1 ).hasParent )',
        '                    if ( thisComp.layer( index + 1 ).parent.index == index ) child = thisComp.layer( index + 1 );',
        '        if ( !isBone( child ) ) child = null;',
        '        if ( !child ) {',
        '            for ( var i = thisComp.numLayers; i > 0; i-- ) {',
        '                if ( thisComp.layer( i ).hasParent )',
        '                    if ( thisComp.layer( i ).parent.index == thisLayer.index ) {',
        '                        child = thisComp.layer( i );',
        '                        if ( !isBone( child ) ) child = null;',
        '                        if ( child ) break;',
        '                    }',
        '            }',
        '        }',
        '        if ( child ) {',
        '            var A = child.toWorld( child.anchorPoint );',
        '            var B = thisLayer.toWorld( thisLayer.anchorPoint );',
        '            var dist = length( A, B );',
        '            if ( dist < 20 ) dist = 20;',
        '            var s = thisLayer( "ADBE Root Vectors Group" )( "Bone" ).transform.scale[ 0 ];',
        '            value / ( dist / 30 ) * s / 80;',
        '        } else value;',
        '    }',
        '}',
        'else value;'
    ].join('\n');
    // circle
    var displayContent = displayGroup.property("ADBE Vectors Group")
    shape = displayContent.addProperty("ADBE Vector Shape - Ellipse");
    shape("ADBE Vector Ellipse Size").setValue([20,20]);
    //fill
    var fill = displayContent.addProperty("ADBE Vector Graphic - Fill");
    fill("ADBE Vector Fill Color").expression = [ DuAEExpression.Id.BONE,
	    'effect("' + effect.name +'")( ' + colorIndex + ').value;'
	].join('\n');

    // If attached, set the target of the parent
    if (this.attached) parentLayer.effect( Duik.PseudoEffect.BONE.matchName )( targetIndex ).setValue( boneLayer.index );

    // And set the color
    if ( this.type == DuOCO.Bone.CLAVICLE ||
        this.type == DuOCO.Bone.HIPS
        )
        Duik.Bone.setColor( DuColor.Color.RAINBOX_RED, [boneLayer] );
    else if ( this.type == DuOCO.Bone.HUMERUS || 
        this.type == DuOCO.Bone.FEMUR ||
        this.type == DuOCO.Bone.SPINE ||
        this.type == DuOCO.Bone.TAIL_ROOT
        )
        Duik.Bone.setColor( DuColor.Color.ORANGE, [boneLayer] );
    else if ( this.type == DuOCO.Bone.RADIUS ||
        this.type == DuOCO.Bone.TIBIA ||
        this.type == DuOCO.Bone.NECK ||
        this.type == DuOCO.Bone.TAIL_MID
        )
        Duik.Bone.setColor( DuColor.Color.YELLOW, [boneLayer] );
    else if ( this.type == DuOCO.Bone.CARPUS ||
        this.type == DuOCO.Bone.TARSUS ||
        this.type == DuOCO.Bone.SKULL ||
        this.type == DuOCO.Bone.TAIL_END
        )
        Duik.Bone.setColor( DuColor.Color.LIGHT_BLUE, [boneLayer] );
    else if ( this.type == DuOCO.Bone.FINGER ||
        this.type == DuOCO.Bone.TIP ||
        this.type == DuOCO.Bone.TOE ||
        this.type == DuOCO.Bone.FEATHER
        )
        Duik.Bone.setColor( DuColor.Color.LIGHT_PURPLE, [boneLayer] );
    else if ( this.type == DuOCO.Bone.HEEL
        )
        Duik.Bone.setColor( DuColor.Color.GREEN, [boneLayer] );

    // Child bones
    for(var i = 0, n = this.children.length; i < n; i++)
    {
        layers = layers.concat( this.children[i].toComp(doc, limb, comp, boneLayer, armatureId) );
    }

    // Child limbs
    for(var i = 0, n = this.limbs.length; i < n; i++)
    {
        layers = layers.concat( this.limbs[i].toComp(doc, comp, boneLayer, armatureId) );
    }

    return layers;
}
