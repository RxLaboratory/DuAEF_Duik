/**
 * Creates an OCO doc from the given composition.
 * @param {string} [name] The name of the character. If omitted, will use the comp name.
 * @param {CompItem} [comp=DuAEProject.getActiveComp()] The composition
 * @param {Boolean} [empty=false] Set to true to create an empty doc.
 * @param {Boolean} [selectedLayers=false] If empty is true, will use only the selected layers
 * @return {DoOCODoc} The new doc
 */
DuOCODoc.fromComp = function( name, comp , empty, selectedLayers )
{
    comp = def(comp, DuAEProject.getActiveComp());
    name = def( name, '');
    if (!comp) return new DuOCODoc( name );

    if (name == '')
    {
        var compStr = localize("$$$/AE/BEE/LStr/0005=composition");
        if (comp.name.toLowerCase().indexOf(compStr) == 0) name = DuScriptUI.String.CHARACTER;
        else if (comp.name.toLowerCase().indexOf('comp') == 0) name = DuScriptUI.String.CHARACTER;
        else name = comp.name;
    }

    empty = def(empty, false);
    selectedLayers = def( selectedLayers, false);
    
    var doc = new DuOCODoc( name );
    doc.resolution = [comp.width, comp.height];

    // Set the default params

    // world in the center, 20% above the bottom of the comp
    doc.world = [comp.width/2, comp.height*0.2];
    // 50% of the comp height, divided by 185cm
    doc.pixelsPerCm = comp.height*0.5/185;

    // TODO Get ground, character, etc

    return doc;
}

/**
 * Creates the limbs and armatures in the comp
 * @param {CompItem} [comp] The composition to use. If omitted, creates a new composition.
 * @param {float} [duration=60.0] The duration of the new comp, in seconds.
 * @param {frameRate} [float=24.0] The frame rate of the new comp.
 * @return {Layer[]} The new layers
 */
DuOCODoc.prototype.toComp = function( comp, duration, frameRate )
{
    duration = def(duration, 60);
    frameRate = def(frameRate, 24);

    if (typeof comp === 'undefined') comp = app.project.items.addComp( this.name, this.resolution[0], this.resolution[1], 1.0, duration, frameRate);

    var layers = [];
    // For each limb
    for(var i = 0, n = this.limbs.length; i < n; i++)
    {
        layers = layers.concat( this.limbs[i].toComp( this, comp ) );
    }
    return layers;
}

/**
 * Creates the limb and armatures in the comp
 * @param {DuOCODoc} doc The doc containing the limb.
 * @param {CompItem} [comp=DuAEProject.getActiveComp()] The composition to use.
 * @param {Layer} [parentLayer=null] The parent layer of the bone.
 * @param {int} [limbId] A Unique identifier for this armature. If omitted, a new one will be assigned.
 * @return {Layer[]} The new layers
 */
DuOCOLimb.prototype.toComp = function( doc, comp, parentLayer, limbId )
{
    comp = def(comp, DuAEProject.getActiveComp());
    if (!comp) return;

    parentLayer = def(parentLayer, null);
    limbId = def(limbId, new Date().getTime() );

    var layers = [];
    var boneIndex = 0;
    for (var i = 0, n = this.armature.length; i < n; i++)
    {
        layers = layers.concat( this.armature[i].toComp( doc, this, comp, parentLayer, limbId, boneIndex ) );
    }
    return layers;
}

/**
 * Creates a new chain of bones located on the vertices of the path.
 * @param {DuOCODoc} doc The doc containing the limb.
 * @param {string} name The name of the bones (will increment if needed)
 * @param {PropertyGroup|DuAEProperty} pathProp The path property (either an "ADBE Vector Shape - Group" or an "ADBE Mask Atom")
 * @returns {DuOCOBone} The root bone of the new chain
 */
DuOCOLimb.prototype.armatureFromPath = function( doc, name, pathProp )
{
    pathProp = new DuAEProperty(pathProp);
    var vertices = pathProp.verticesToComp( );

    var b = null;
    var root = null;
    var names = [];

    // Create for each vertex
    for(var i = 0, n = vertices.length; i < n; i++)
    {
        var vertex = vertices[i];
        var boneName = DuString.generateUnique(name, names);
        var bone = new DuOCOBone( boneName );
        names.push(boneName);
        var coord = doc.fromPixels( vertex );
        bone.x = coord[0];
        bone.y = coord[1];
        if (b != null)
        {
            bone.attached = true;
            b.children.push( bone );
            b = bone;
        }
        else
        {
            this.armature.push( bone );
            root = bone;
            b = bone;
        }
    }

    return root;
}

/**
 * Moves the armature of the limb to the vertices of the path.
 * @param {DuOCODoc} doc The doc containing the limb.
 * @param {PropertyGroup|DuAEProperty} pathProp The path property (either an "ADBE Vector Shape - Group" or an "ADBE Mask Atom")
 */
DuOCOLimb.prototype.moveArmatureToPath = function( doc, pathProp )
{
    if (this.armature.length == 0) return;

    pathProp = new DuAEProperty(pathProp);
    var vertices = pathProp.verticesToComp( );

    var b = null;

    // For each vertex
    for(var i = 0, n = vertices.length; i < n; i++)
    {
        var vertex = vertices[i];

        if (b == null) b = this.armature[0];
        else 
        {
            if (b.children.length == 0) return;
            b = b.children[0];
        }

        var coord = doc.fromPixels( vertex );
        b.x = coord[0];
        b.y = coord[1];
    }
}

/**
 * Moves the armature of the limb to the puppet pins.
 * @param {DuOCODoc} doc The doc containing the limb.
 * @param {Property[]|DuAEProperty[]} pins The puppet pins
 */
DuOCOLimb.prototype.moveArmatureToPuppetPins = function( doc, pins )
{
    if (this.armature.length == 0) return;

    var b = null;

    // Create for each pin
    for (var i = 0, n = pins.length; i < n; i++)
    {
        if (b == null) b = this.armature[0];
        else 
        {
            if (b.children.length == 0) return;
            b = b.children[0];
        }

        var pin = new DuAEProperty( pins[i] );
        var pinProp = pin.getProperty();

        if ( pinProp.matchName == "ADBE FreePin3 PosPin Atom" )
        {
            pinProp = pinProp.property( "ADBE FreePin3 PosPin Position" );
        }

        var pinPos = DuAELayer.getWorldPos( pin.layer, pinProp.value );
        if( pin.layer instanceof ShapeLayer ) pinPos = pinProp.value;
        pinPos = doc.fromPixels( pinPos );
        b.x = pinPos[0];
        b.y = pinPos[1];
    }
}

/**
 * Creates a new chain of bones located on the puppet pins.
 * @param {DuOCODoc} doc The doc containing the limb.
 * @param {string} name The name of the bones (will increment if needed)
 * @param {Property[]|DuAEProperty[]} pins The puppet pins
 * @returns {DuOCOBone} The root bone of the new chain
 */
DuOCOLimb.prototype.armatureFromPuppetPins = function( doc, name, pins )
{
    var b = null;
    var root = null;
    var names = [];

    // Create for each pin
    for (var i = 0, n = pins.length; i < n; i++)
    {
        var boneName = DuString.generateUnique(name, names);
        var bone = new DuOCOBone( boneName );
        names.push(boneName);

        var pin = new DuAEProperty( pins[i] );
        var pinProp = pin.getProperty();

        if ( pinProp.matchName == "ADBE FreePin3 PosPin Atom" )
        {
            pinProp = pinProp.property( "ADBE FreePin3 PosPin Position" );
        }

        var pinPos = DuAELayer.getWorldPos( pin.layer, pinProp.value );
        if( pin.layer instanceof ShapeLayer ) pinPos = pinProp.value;
        pinPos = doc.fromPixels( pinPos );
        bone.x = pinPos[0];
        bone.y = pinPos[1];

        if (b != null)
        {
            bone.attached = true;
            b.children.push( bone );
            b = bone;
        }
        else
        {
            this.armature.push( bone );
            root = bone;
            b = bone;
        }
    }

    return root;
}

/**
 * Moves the armature of the limb to the layers.
 * @param {DuOCODoc} doc The doc containing the limb.
 * @param {Layer[]|LayerCollection} layers The layers
 */
DuOCOLimb.prototype.moveArmatureToLayers = function( doc, layers )
{
    var b = null;

    var it = new DuList(layers);

    // Check if there are layers at the same location
    // To prevent moving structures if there are mulitple anchor points at the same place
    var moveLayers = true;
    var layer;
    while (layer = it.next()) {
        var pos = DuAELayer.getWorldPos( layer );
        pos = new DuList( pos );
        for (var i = it.current + 1, n = it.length(); i < n; i++)
        {
            var layer2 = it.at(i);
            var pos2 = DuAELayer.getWorldPos( layer2 );     
            if ( pos.equals( pos2, undefined, 0 ) ) return;
        }
    }

    // For each anchor point
    it.reinitIterator();
    while (layer = it.next()) {

        if (b == null) b = this.armature[0];
        else 
        {
            if (b.children.length == 0) return;
            b = b.children[0];
        }
        
        var pos = DuAELayer.getWorldPos( layer );
        pos = doc.fromPixels(pos);

        b.x = pos[0];
        b.y = pos[1];
    };
}

/**
 * Creates a new chain of bones located on the layer anchor points.
 * @param {DuOCODoc} doc The doc containing the limb.
 * @param {string} name The name of the bones (will increment if needed)
 * @param {Layer[]|LayerCollection} layers The layers
 * @returns {DuOCOBone} The root bone of the new chain
 */
DuOCOLimb.prototype.armatureFromLayers = function( doc, name, layers )
{
    var b = null;
    var root = null;
    var names = [];

    var it = new DuList(layers);

    // Check if there are layers at the same location
    // To prevent moving structures if there are mulitple anchor points at the same place
    var moveLayers = true;
    var layer;
    while (layer = it.next()) {
        var pos = DuAELayer.getWorldPos( layer );
        pos = new DuList( pos );
        for (var i = it.current + 1, n = it.length(); i < n; i++)
        {
            var layer2 = it.at(i);
            var pos2 = DuAELayer.getWorldPos( layer2 );     
            if ( pos.equals( pos2, undefined, 0 ) )
            {
                moveLayers = false;
                break;
            }
        }
        if ( !moveLayers ) break;
    }

    // Create for each anchor point
    var num = it.length();
    var boneLength = 100.0 / (num-1);
    var x = -50;
    it.reinitIterator();
    while (layer = it.next()) {
        var boneName = DuString.generateUnique(name, names);
        var bone = new DuOCOBone( boneName );
        names.push(boneName);
        
        if (moveLayers)
        {
            var pos = DuAELayer.getWorldPos( layer );
            pos = doc.fromPixels(pos);

            bone.x = pos[0];
            bone.y = pos[1];
        }
        else 
        {
            bone.x = x;
            bone.y = 100;
            x += boneLength;
        }

        if (b != null)
        {
            bone.attached = true;
            b.children.push( bone );
            b = bone;
        }
        else
        {
            this.armature.push( bone );
            root = bone;
            b = bone;
        }
    };

    return root;
}

/**
 * Creates the limbs and armatures in the comp
 * @param {DuOCODoc} doc The doc containing the bone.
 * @param {DuOCOLimb} limb The limb containing the bone.
 * @param {CompItem} [comp=DuAEProject.getActiveComp()] The composition to use.
 * @param {Layer} [parentLayer=null] The parent layer of the bone.
 * @param {int} [limbId] A Unique identifier for this armature. If omitted, a new one will be assigned.
 * @param {int} [boneIndex = 0] The index of the bone in the chain.
 * @return {Layer[]} The new layers
 */
DuOCOBone.prototype.toComp = function( doc, limb, comp, parentLayer, limbId, boneIndex )
{
    comp = def(comp, DuAEProject.getActiveComp());
    if (!comp) return;

    parentLayer = def(parentLayer, null);
    limbId = def(limbId, new Date().getTime() );
    boneIndex = def(boneIndex, 0);

    var layers = [];

    // Create the layer for this one
    var boneLayer = comp.layers.addShape();
    layers.push(boneLayer);

    // Tag & Attributes
    Duik.Layer.setAttributes( boneLayer, Duik.Layer.Type.BONE, this.name, limb.side, limb.location, doc.name );
    var tag = DuAETag.get( boneLayer );
    DuAETag.setValue( boneLayer, DuAETag.Key.DUIK_BONE_TYPE, this.type, tag );
    DuAETag.setValue( boneLayer, DuAETag.Key.DUIK_LIMB_TYPE, limb.type, tag );
    DuAETag.setValue( boneLayer, DuAETag.Key.DUIK_LIMB, limb.limb, tag );
    DuAETag.setValue( boneLayer, DuAETag.Key.DUIK_LIMB_ID, limbId, tag );
    DuAETag.setValue( boneLayer, DuAETag.Key.DUIK_ATTACHED_BONE, this.attached, tag );
    DuAETag.setValue( boneLayer, DuAETag.Key.DUIK_BONE_INDEX, boneIndex, tag );

    // Parent & position
    boneLayer.transform.position.setValue( doc.toPixels( [this.x, this.y] ) );
    boneLayer.transform.scale.expression = '[100,100];';
    boneLayer.parent = parentLayer;

    // Add the bone pseudo effect
    var pe = Duik.PseudoEffect.BONE;
    var effect = pe.apply( boneLayer );
    effect.name = DuScriptUI.String.BONE;
    var effectInfo = new DuAEProperty(effect);
    var peE = Duik.PseudoEffect.BONE_ENVELOP;
    var envelopEffect = peE.apply( boneLayer );
    envelopEffect.name = DuScriptUI.String.BONE_ENVELOP;
    effect = effectInfo.getProperty();
    // The indices
    var sizeIndex = pe.props['Size'].index;
    var targetIndex = pe.props['Target'].index;
    var colorIndex = pe.props['Color'].index;
    var opacityIndex = pe.props['Opacity'].index;

    var eSizeIndex = peE.props['Size'].index;
    var eFillColorIndex = peE.props['Fill']['Color'].index;
    var eFillOpacityIndex = peE.props['Fill']['Opacity'].index;
    var eStrokeColorIndex = peE.props['Stroke']['Color'].index;
    var eStrokeOpacityIndex = peE.props['Stroke']['Opacity'].index;
    var eStrokeSizeIndex = peE.props['Stroke']['Size'].index;

    // The auto-size
    effect( sizeIndex ).expression = [ DuAEExpression.Id.BONE,
        'var result = thisComp.width * .045;',
        'result *= value/100;',
        'result;'
        ].join('\n');

    // The envelop size
    envelopEffect( eSizeIndex ).setValue( comp.width * .025 );
    envelopEffect.enabled = false;

    // The content of the shape layer
    // Bone group
    var mainGroup = boneLayer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
    mainGroup.name = 'Bone';
    //look-at
    mainGroup('ADBE Vector Transform Group')('ADBE Vector Rotation').expression = [ DuAEExpression.Id.BONE,
        '    var child = null;',
        '    var childIndex = -1;',
        '   var result = value;',
        '    try {',
        '       var fx = effect("' + effect.name + '");',
        '        child = fx( ' + targetIndex + ' );',
        '        childIndex = child.index;',
        '    } catch ( e ) {}',
        '    if ( childIndex != thisLayer.index ) {',
        '        function isBone( layer ) {',
        '            var ok = false;',
        '            try {',
        '                layer.content( "Bone" );',
        '                ok = true;',
        '            } catch ( e ) {',
        '                ok = false;',
        '            }',
        '            return ok;',
        '        }',
        '        if ( !child )',
        '            if ( index > 1 )',
        '                if ( thisComp.layer( index - 1 ).hasParent )',
        '                    if ( thisComp.layer( index - 1 ).parent.index == index ) child = thisComp.layer( index - 1 );',
        '        if ( !isBone( child ) ) child = null;',
        '        if ( !child )',
        '            if ( index < thisComp.numLayers )',
        '                if ( thisComp.layer( index + 1 ).hasParent )',
        '                    if ( thisComp.layer( index + 1 ).parent.index == index ) child = thisComp.layer( index + 1 );',
        '        if ( !isBone( child ) ) child = null;',
        '        if ( !child ) {',
        '            for ( var i = thisComp.numLayers; i > 0; i-- ) {',
        '                if ( thisComp.layer( i ).hasParent )',
        '                    if ( thisComp.layer( i ).parent.index == thisLayer.index ) {',
        '                        child = thisComp.layer( i );',
        '                        if ( !isBone( child ) ) child = null;',
        '                        if ( child ) break;',
        '                    }',
        '            }',
        '        }',
        '        var result = value;',
        '        var layer = thisLayer;',
        '        while ( layer.hasParent ) {',
        '            layer = layer.parent;',
        '            result = result - layer.rotation;',
        '        }',
        '        if ( child )',
        '            if ( child.index != index ) {',
        '                C = child.toWorld( child.anchorPoint );',
        '                O = thisLayer.toWorld( thisLayer.anchorPoint );',
        '                var vec = O - C;',
        '                var angle = Math.atan2( vec[ 1 ], vec[ 0 ] );',
        '                var ik = radiansToDegrees( angle );',
        '                result += ( ik - 90 - rotation )',
        '            }',
        '       }',
        'result;'
	].join('\n');

    //Target Group
    var targetGroup = mainGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
    targetGroup.name = 'Target';
    targetGroup.transform.opacity.expression = [ DuAEExpression.Id.BONE,
            'var fx = effect("' + effect.name + '");',
            'var result = 0;',
            'if (fx.active) result = 100;',
            'result;'
        ].join('\n');
    var targetContent = targetGroup.property("ADBE Vectors Group");
    //2nd ellipse
    var shape = targetContent.addProperty("ADBE Vector Shape - Ellipse");
    shape("ADBE Vector Ellipse Size").setValue([4,4]);
    //fill
    var fill = targetContent.addProperty("ADBE Vector Graphic - Fill");
    fill("ADBE Vector Fill Color").setValue([ 0, 0, 0, 1.0]);

    //Display Group
    var displayGroup = mainGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
    displayGroup.name = 'Display';
    //display opacity
    displayGroup.transform.opacity.expression = [ DuAEExpression.Id.BONE,
            'var fx = effect("' + effect.name + '");',
            'var result = 0;',
            'if (fx.active) result = fx(' + opacityIndex + ').value;',
            'result;'
        ].join('\n');
    displayGroup.transform.scale.expression = [ DuAEExpression.Id.BONE,
        'var s = effect("' + effect.name + '")(' + sizeIndex + ');',
        '[s,100];',
	].join('\n');
    //Link Group 
    var linkGroup = displayGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
    linkGroup.name = 'Link';
    //anchor point
    linkGroup('ADBE Vector Transform Group')('ADBE Vector Anchor').setValue([ 0, 5]);
    //group scale
    linkGroup('ADBE Vector Transform Group')('ADBE Vector Scale').expression = [ DuAEExpression.Id.BONE,
        '    var child = null;',
        '    var childIndex = -1;',
        '    var result = [ 0, 0 ];',
        '    var fx = effect( "' + effect.name + '" );',
        '    try {',
        '       child = fx( ' + targetIndex + ' );',
        '       childIndex = child.index',
        '    } catch ( e ) {}',
        '    if ( childIndex != thisLayer.index || fx.active ) {',
        '        var X = 100;',
        '        var Y = 60;',
        '',
        '        function isBone( layer ) {',
        '            var ok = false;',
        '            try {',
        '                layer.content( "Bone" );',
        '                ok = true;',
        '            } catch ( e ) {',
        '                ok = false;',
        '            }',
        '            return ok;',
        '        }',
        '        if ( !child )',
        '            if ( index > 1 )',
        '                if ( thisComp.layer( index - 1 ).hasParent )',
        '                    if ( thisComp.layer( index - 1 ).parent.index == index ) child = thisComp.layer( index - 1 );',
        '        if ( !isBone( child ) ) child = null;',
        '        if ( !child )',
        '            if ( index < thisComp.numLayers )',
        '                if ( thisComp.layer( index + 1 ).hasParent )',
        '                    if ( thisComp.layer( index + 1 ).parent.index == index ) child = thisComp.layer( index + 1 );',
        '        if ( !isBone( child ) ) child = null;',
        '        if ( !child ) {',
        '            for ( var i = thisComp.numLayers; i > 0; i-- ) {',
        '                if ( thisComp.layer( i ).hasParent )',
        '                    if ( thisComp.layer( i ).parent.index == thisLayer.index ) {',
        '                        child = thisComp.layer( i );',
        '                        if ( !isBone( child ) ) child = null;',
        '                        if ( child ) break;',
        '                    }',
        '            }',
        '        }',
        '        if ( child ) {',
        '            var A = child.toWorld( child.anchorPoint );',
        '            var B = thisLayer.toWorld( thisLayer.anchorPoint );',
        '            var dist = length( A, B );',
        '            Y = dist / 15 * 100;',
        '        }',
        '        result = [ X, Y * 100 / thisLayer( "ADBE Root Vectors Group" )( "Bone" ).transform.scale[ 1 ] ];',
        '    }',
        'result;'
	].join('\n');
    var linkContent = linkGroup.property("ADBE Vectors Group");
    //star
    shape = linkContent.addProperty("ADBE Vector Shape - Star");
    shape("ADBE Vector Star Points").setValue( 3 );
    shape("ADBE Vector Star Outer Radius").setValue( 10 );
    shape("ADBE Vector Star Outer Roundess").setValue( 100 );
    shape("ADBE Vector Star Type").setValue( 2 );
    shape("ADBE Vector Star Outer Roundess").expression = [ DuAEExpression.Id.BONE,
        '    var child = null;',
        '    var childIndex = -1;',
        '    var result = value;',
        '    var fx = effect( "' + effect.name + '" );',
        '    try {',
        '        child = fx( ' + targetIndex + ' );',
        '        childIndex = child.index',
        '    } catch ( e ) {}',
        '    if ( childIndex != thisLayer.index || fx.active ) {',
        '        function isBone( layer ) {',
        '            var ok = false;',
        '            try {',
        '                layer.content( "Bone" );',
        '                ok = true;',
        '            } catch ( e ) {',
        '                ok = false;',
        '            }',
        '            return ok;',
        '        }',
        '        if ( !child )',
        '            if ( index > 1 )',
        '                if ( thisComp.layer( index - 1 ).hasParent )',
        '                    if ( thisComp.layer( index - 1 ).parent.index == index ) child = thisComp.layer( index - 1 );',
        '        if ( !isBone( child ) ) child = null;',
        '        if ( !child )',
        '            if ( index < thisComp.numLayers )',
        '                if ( thisComp.layer( index + 1 ).hasParent )',
        '                    if ( thisComp.layer( index + 1 ).parent.index == index ) child = thisComp.layer( index + 1 );',
        '        if ( !isBone( child ) ) child = null;',
        '        if ( !child ) {',
        '            for ( var i = thisComp.numLayers; i > 0; i-- ) {',
        '                if ( thisComp.layer( i ).hasParent )',
        '                    if ( thisComp.layer( i ).parent.index == thisLayer.index ) {',
        '                        child = thisComp.layer( i );',
        '                        if ( !isBone( child ) ) child = null;',
        '                        if ( child ) break;',
        '                    }',
        '            }',
        '        }',
        '        if ( child ) {',
        '            var A = child.toWorld( child.anchorPoint );',
        '            var B = thisLayer.toWorld( thisLayer.anchorPoint );',
        '            var dist = length( A, B );',
        '            if ( dist < 20 ) dist = 20;',
        '            var s = thisLayer( "ADBE Root Vectors Group" )( "Bone" ).transform.scale[ 0 ];',
        '            result = value / ( dist / 30 ) * s / 80;',
        '        } else result = value;',
        '    }',
        'result;'
    ].join('\n');
    // circle
    var displayContent = displayGroup.property("ADBE Vectors Group")
    shape = displayContent.addProperty("ADBE Vector Shape - Ellipse");
    shape("ADBE Vector Ellipse Size").setValue([17,17]);
    shape("ADBE Vector Ellipse Size").expression = [ DuAEExpression.Id.BONE,
        'var s = effect("' + effect.name + '")(' + sizeIndex + ')/100*17;',
        '[17,s];'
    ].join('\n');
    //fill
    var fill = displayContent.addProperty("ADBE Vector Graphic - Fill");
    fill("ADBE Vector Fill Color").expression = [ DuAEExpression.Id.BONE,
	    'effect("' + effect.name +'")( ' + colorIndex + ').value;'
	].join('\n');

    //Envelop Group
    // display evenvelop checkbox
    var envelopGroup = mainGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
    envelopGroup.name = 'Envelop';
    envelopGroup.transform.opacity.expression = [ DuAEExpression.Id.BONE_ENVELOP,
        'if (effect("' + envelopEffect.name + '").active) 100;',
        'else 0;'
    ].join('\n');

    var rootGroup = envelopGroup('ADBE Vectors Group').addProperty('ADBE Vector Group');
    rootGroup.name = "root";
    rootGroup.transform.scale.expression = [ DuAEExpression.Id.BONE_ENVELOP,
        'var s = 0;',
        'if (hasParent) s = effect("' + envelopEffect.name +'")(' + eSizeIndex + ');',
        '[s, s];'
        ].join('\n');
    var rootCircle = rootGroup.content.addProperty("ADBE Vector Shape - Ellipse");
    rootCircle.name = "root";
    var rootMask = rootGroup.content.addProperty("ADBE Vector Shape - Rect");
    rootMask.name = "root_mask";
    rootMask.position.setValue([0,-50]);
    var rootMerge = rootGroup.content.addProperty('ADBE Vector Filter - Merge');
    rootMerge('ADBE Vector Merge Type').setValue( 3 );

    var endGroup = envelopGroup('ADBE Vectors Group').addProperty('ADBE Vector Group');
    endGroup.name = "end";
    endGroup.transform.scale.expression = [ DuAEExpression.Id.BONE_ENVELOP,
        'var child = null;',
        'var childIndex = -1;',
        'var fx = effect("' + envelopEffect.name + '");',
        'var s = fx(' + eSizeIndex + ');',
        'var result = [s,s];',
        'try {',
        '    var bfx = effect(' + effect.name + ');',
        '    child = bfx( ' + targetIndex + ' );',
        '    childIndex = child.index;',
        '} catch ( e ) {}',
        'if ( childIndex != thisLayer.index && fx.active ) {',
        '	function isBone( layer ) {',
        '		var ok = false;',
        '		try {',
        '			layer.content( "Bone" );',
        '			ok = true;',
        '		} catch ( e ) {',
        '			ok = false;',
        '		}',
        '		return ok;',
        '	}',
        '	if ( !child )',
        '		if ( index > 1 )',
        '			if ( thisComp.layer( index - 1 ).hasParent )',
        '				if ( thisComp.layer( index - 1 ).parent.index == index ) child = thisComp.layer( index - 1 );',
        '	if ( !isBone( child ) ) child = null;',
        '	if ( !child )',
        '		if ( index < thisComp.numLayers )',
        '			if ( thisComp.layer( index + 1 ).hasParent )',
        '				if ( thisComp.layer( index + 1 ).parent.index == index ) child = thisComp.layer( index + 1 );',
        '	if ( !isBone( child ) ) child = null;',
        '	if ( !child ) {',
        '		for ( var i = thisComp.numLayers; i > 0; i-- ) {',
        '			if ( thisComp.layer( i ).hasParent )',
        '				if ( thisComp.layer( i ).parent.index == thisLayer.index ) {',
        '					child = thisComp.layer( i );',
        '					if ( !isBone( child ) ) child = null;',
        '					if ( child ) break;',
        '				}',
        '		}',
        '	}',
        '	if ( child )',
        '	if ( child.index != index ) {',
        '		try { result = child.content("Bone").content("Envelop").content("root").transform.scale }',
        '		catch (e) {}',
        '	}',
        '}',
        'result;',
        ''
    ].join('\n');
    endGroup.transform.position.expression = [DuAEExpression.Id.BONE_ENVELOP,
        'var child = null;',
        'var childIndex = -1;',
        'var fx = effect("' + envelopEffect.name + '");',
        'var result = [0,0];',
        'try {',
        '    var bfx = effect(' + effect.name + ');',
        '    child = bfx( ' + targetIndex + ' );',
        '    childIndex = child.index;',
        '} catch ( e ) {}',
        'if ( childIndex != thisLayer.index && fx.active ) {',
        '	function isBone( layer ) {',
        '		var ok = false;',
        '		try {',
        '			layer.content( "Bone" );',
        '			ok = true;',
        '		} catch ( e ) {',
        '			ok = false;',
        '		}',
        '		return ok;',
        '	}',
        '	if ( !child )',
        '		if ( index > 1 )',
        '			if ( thisComp.layer( index - 1 ).hasParent )',
        '				if ( thisComp.layer( index - 1 ).parent.index == index ) child = thisComp.layer( index - 1 );',
        '	if ( !isBone( child ) ) child = null;',
        '	if ( !child )',
        '		if ( index < thisComp.numLayers )',
        '			if ( thisComp.layer( index + 1 ).hasParent )',
        '				if ( thisComp.layer( index + 1 ).parent.index == index ) child = thisComp.layer( index + 1 );',
        '	if ( !isBone( child ) ) child = null;',
        '	if ( !child ) {',
        '		for ( var i = thisComp.numLayers; i > 0; i-- ) {',
        '			if ( thisComp.layer( i ).hasParent )',
        '				if ( thisComp.layer( i ).parent.index == thisLayer.index ) {',
        '					child = thisComp.layer( i );',
        '					if ( !isBone( child ) ) child = null;',
        '					if ( child ) break;',
        '				}',
        '		}',
        '	}',
        '	var result = value;',
        '	if(child) if (childIndex != index) result = [0, -length( [0,0], child.position ) ];',
        '}',
        'result;'
	].join('\n');
    var endCircle = endGroup.content.addProperty("ADBE Vector Shape - Ellipse");
    endCircle.name = "end";
    var endMask = endGroup.content.addProperty("ADBE Vector Shape - Rect");
    endMask.name = "end_mask";
    endMask.position.setValue( [0, 50] );
    var endMerge = endGroup.content.addProperty('ADBE Vector Filter - Merge');
    endMerge('ADBE Vector Merge Type').setValue( 3 );

    var shape = envelopGroup.content.addProperty('ADBE Vector Shape - Group');
    shape.name = "shape";
    shape('ADBE Vector Shape').expression = [ DuAEExpression.Id.BONE_ENVELOP,
        'var endPos = [0,0];',
        'var endSize = 0;',
        'var fx = effect("' + envelopEffect.name +'")',
        'if (fx.active) {',
        'try {',
        '	end_t = thisProperty.propertyGroup(2)("end").transform;',
        '	endPos = end_t.position.value;',
        '	endSize = end_t.scale.value[0];',
        '	endSize /= 2;',
        '}',
        'catch (e) {}',
        'var rootSize = fx(' + eSizeIndex + ').value / 2;',
        'var vertices = [',
        '	[endPos[0], endPos[1] - endSize/2],',
        '	[endSize, endPos[1]],',
        '	[rootSize, 0],',
        '	[0, rootSize/2],',
        '	[-rootSize, 0],',
        '	[-endSize, endPos[1] ]',
        '];',
        'var inT = [',
        '	[-endSize, 0],',
        '	[0,0],',
        '	[0,-rootSize],',
        '	[rootSize,0],',
        '	[0,0],',
        '	[0,endSize/3]',
        '];',
        'var outT = [',
        '	[endSize, 0],',
        '	[0,endSize/3],',
        '	[0,0],',
        '	[-rootSize,0],',
        '	[0,-rootSize],',
        '	[0,0]',
        '];',
        'createPath(vertices, inT, outT,true);',
        '} else { value; }'
	].join('\n');
    var shapeMerge = envelopGroup.content.addProperty('ADBE Vector Filter - Merge');
    shapeMerge('ADBE Vector Merge Type').setValue( 2 );

    var stroke = envelopGroup.content.addProperty("ADBE Vector Graphic - Stroke");
    stroke('ADBE Vector Stroke Color').expression = [ DuAEExpression.Id.BONE_ENVELOP,
        'effect("' + envelopEffect.name +'")(' + eStrokeColorIndex + ').value;'
    ].join('\n');
    stroke('ADBE Vector Stroke Width').expression = [ DuAEExpression.Id.BONE_ENVELOP,
        'effect("' + envelopEffect.name +'")(' + eStrokeSizeIndex + ').value;'
    ].join('\n');
    stroke('ADBE Vector Stroke Opacity').expression = [ DuAEExpression.Id.BONE_ENVELOP,
        'effect("' + envelopEffect.name +'")(' + eStrokeOpacityIndex + ').value;'
    ].join('\n');

    fill = envelopGroup.content.addProperty("ADBE Vector Graphic - Fill");
    fill('ADBE Vector Fill Color').expression = [ DuAEExpression.Id.BONE_ENVELOP,
        'effect("' + envelopEffect.name +'")(' + eFillColorIndex + ').value;'
    ].join('\n');
    fill('ADBE Vector Fill Opacity').expression = [ DuAEExpression.Id.BONE_ENVELOP,
        'effect("' + envelopEffect.name +'")(' + eFillOpacityIndex + ').value;'
    ].join('\n');
        
    // If attached, set the target of the parent
    if (this.attached) parentLayer.effect( Duik.PseudoEffect.BONE.matchName )( targetIndex ).setValue( boneLayer.index );

    // And set the color
    if ( this.type == DuOCO.Bone.CLAVICLE ||
        this.type == DuOCO.Bone.HIPS
        )
        Duik.Bone.setColor( DuColor.Color.RAINBOX_RED, [boneLayer] );
    else if ( this.type == DuOCO.Bone.HUMERUS || 
        this.type == DuOCO.Bone.FEMUR ||
        this.type == DuOCO.Bone.SPINE ||
        this.type == DuOCO.Bone.TAIL_ROOT ||
        this.type == DuOCO.Bone.SNAKE_SPINE_ROOT || 
        this.type == DuOCO.Bone.FISH_SPINE_ROOT || 
        this.type == DuOCO.Bone.FIN ||
        this.type == DuOCO.Bone.HAIR_ROOT
        )
        Duik.Bone.setColor( DuColor.Color.ORANGE, [boneLayer] );
    else if ( this.type == DuOCO.Bone.TORSO)
        Duik.Bone.setColor( DuColor.Color.YELLOW_ORANGE, [boneLayer] );
    else if ( this.type == DuOCO.Bone.RADIUS ||
        this.type == DuOCO.Bone.TIBIA ||
        this.type == DuOCO.Bone.NECK ||
        this.type == DuOCO.Bone.TAIL_MID ||
        this.type == DuOCO.Bone.SNAKE_SPINE_MID ||
        this.type == DuOCO.Bone.FISH_SPINE_MID ||
        this.type == DuOCO.Bone.HAIR_MID
        )
        Duik.Bone.setColor( DuColor.Color.YELLOW, [boneLayer] );
    else if ( this.type == DuOCO.Bone.CARPUS ||
        this.type == DuOCO.Bone.TARSUS ||
        this.type == DuOCO.Bone.SKULL ||
        this.type == DuOCO.Bone.TAIL_END ||
        this.type == DuOCO.Bone.SNAKE_SPINE_END ||
        this.type == DuOCO.Bone.FISH_SPINE_END ||
        this.type == DuOCO.Bone.HAIR_END
        )
        Duik.Bone.setColor( DuColor.Color.LIGHT_BLUE, [boneLayer] );
    else if ( this.type == DuOCO.Bone.FINGER ||
        this.type == DuOCO.Bone.TIP ||
        this.type == DuOCO.Bone.SKULL_TIP ||
        this.type == DuOCO.Bone.TOE ||
        this.type == DuOCO.Bone.FEATHER || 
        this.type == DuOCO.Bone.FIN_FISHBONE
        )
        Duik.Bone.setColor( DuColor.Color.LIGHT_PURPLE, [boneLayer] );
    else if ( this.type == DuOCO.Bone.HEEL
        )
        Duik.Bone.setColor( DuColor.Color.GREEN, [boneLayer] );

    // Child bones
    for(var i = 0, n = this.children.length; i < n; i++)
    {
        boneIndex++;
        layers = layers.concat( this.children[i].toComp(doc, limb, comp, boneLayer, limbId, boneIndex) );
    }

    // Child limbs
    for(var i = 0, n = this.limbs.length; i < n; i++)
    {
        boneIndex++;
        layers = layers.concat( this.limbs[i].toComp(doc, comp, boneLayer, limbId, boneIndex) );
    }

    return layers;
}
